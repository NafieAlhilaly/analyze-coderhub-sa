{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function calcAutorange(gd) {\n  var fullLayout = gd._fullLayout;\n  var shapeList = Lib.filterVisible(fullLayout.shapes);\n  if (!shapeList.length || !gd._fullData.length) return;\n\n  for (var i = 0; i < shapeList.length; i++) {\n    var shape = shapeList[i];\n    shape._extremes = {};\n    var ax;\n    var bounds;\n    var xRefType = Axes.getRefType(shape.xref);\n    var yRefType = Axes.getRefType(shape.yref); // paper and axis domain referenced shapes don't affect autorange\n\n    if (shape.xref !== 'paper' && xRefType !== 'domain') {\n      var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n      var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n      ax = Axes.getFromId(gd, shape.xref);\n      bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n      }\n    }\n\n    if (shape.yref !== 'paper' && yRefType !== 'domain') {\n      var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n      var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n      ax = Axes.getFromId(gd, shape.yref);\n      bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n\n      if (bounds) {\n        shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n      }\n    }\n  }\n};\n\nfunction calcXPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n  return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n  var ppad = lineWidth / 2;\n  var axisDirectionReverted = isYAxis;\n\n  if (sizeMode === 'pixel') {\n    var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];\n    var maxValue = Lib.aggNums(Math.max, null, coords);\n    var minValue = Lib.aggNums(Math.min, null, coords);\n    var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n    var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n    return {\n      ppad: ppad,\n      ppadplus: axisDirectionReverted ? beforePad : afterPad,\n      ppadminus: axisDirectionReverted ? afterPad : beforePad\n    };\n  } else {\n    return {\n      ppad: ppad\n    };\n  }\n}\n\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n  var convertVal = ax.type === 'category' || ax.type === 'multicategory' ? ax.r2c : ax.d2c;\n  if (v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n  if (!path) return;\n  var min = Infinity;\n  var max = -Infinity;\n  var segments = path.match(constants.segmentRE);\n  var i;\n  var segment;\n  var drawnParam;\n  var params;\n  var val;\n  if (ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n  for (i = 0; i < segments.length; i++) {\n    segment = segments[i];\n    drawnParam = paramsToUse[segment.charAt(0)].drawn;\n    if (drawnParam === undefined) continue;\n    params = segments[i].substr(1).match(constants.paramRE);\n    if (!params || params.length < drawnParam) continue;\n    val = convertVal(params[drawnParam]);\n    if (val < min) min = val;\n    if (val > max) max = val;\n  }\n\n  if (max >= min) return [min, max];\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/shapes/calc_autorange.js"],"names":["Lib","require","Axes","constants","helpers","module","exports","calcAutorange","gd","fullLayout","_fullLayout","shapeList","filterVisible","shapes","length","_fullData","i","shape","_extremes","ax","bounds","xRefType","getRefType","xref","yRefType","yref","vx0","xsizemode","xanchor","x0","vx1","x1","getFromId","shapeBounds","path","paramIsX","_id","findExtremes","calcXPaddingOptions","vy0","ysizemode","yanchor","y0","vy1","y1","paramIsY","calcYPaddingOptions","calcPaddingOptions","line","width","lineWidth","sizeMode","v0","v1","isYAxis","ppad","axisDirectionReverted","coords","extractPathCoords","maxValue","aggNums","Math","max","minValue","min","beforePad","abs","afterPad","ppadplus","ppadminus","paramsToUse","convertVal","type","r2c","d2c","undefined","Infinity","segments","match","segmentRE","segment","drawnParam","params","val","decodeDate","charAt","drawn","substr","paramRE"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\nmodule.exports = function calcAutorange(gd) {\n    var fullLayout = gd._fullLayout;\n    var shapeList = Lib.filterVisible(fullLayout.shapes);\n\n    if(!shapeList.length || !gd._fullData.length) return;\n\n    for(var i = 0; i < shapeList.length; i++) {\n        var shape = shapeList[i];\n        shape._extremes = {};\n\n        var ax; var bounds;\n        var xRefType = Axes.getRefType(shape.xref);\n        var yRefType = Axes.getRefType(shape.yref);\n\n        // paper and axis domain referenced shapes don't affect autorange\n        if(shape.xref !== 'paper' && xRefType !== 'domain') {\n            var vx0 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x0;\n            var vx1 = shape.xsizemode === 'pixel' ? shape.xanchor : shape.x1;\n            ax = Axes.getFromId(gd, shape.xref);\n\n            bounds = shapeBounds(ax, vx0, vx1, shape.path, constants.paramIsX);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));\n            }\n        }\n\n        if(shape.yref !== 'paper' && yRefType !== 'domain') {\n            var vy0 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y0;\n            var vy1 = shape.ysizemode === 'pixel' ? shape.yanchor : shape.y1;\n            ax = Axes.getFromId(gd, shape.yref);\n\n            bounds = shapeBounds(ax, vy0, vy1, shape.path, constants.paramIsY);\n            if(bounds) {\n                shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));\n            }\n        }\n    }\n};\n\nfunction calcXPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);\n}\n\nfunction calcYPaddingOptions(shape) {\n    return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);\n}\n\nfunction calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {\n    var ppad = lineWidth / 2;\n    var axisDirectionReverted = isYAxis;\n\n    if(sizeMode === 'pixel') {\n        var coords = path ?\n            helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) :\n            [v0, v1];\n        var maxValue = Lib.aggNums(Math.max, null, coords);\n        var minValue = Lib.aggNums(Math.min, null, coords);\n        var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;\n        var afterPad = maxValue > 0 ? maxValue + ppad : ppad;\n\n        return {\n            ppad: ppad,\n            ppadplus: axisDirectionReverted ? beforePad : afterPad,\n            ppadminus: axisDirectionReverted ? afterPad : beforePad\n        };\n    } else {\n        return {ppad: ppad};\n    }\n}\n\nfunction shapeBounds(ax, v0, v1, path, paramsToUse) {\n    var convertVal = (ax.type === 'category' || ax.type === 'multicategory') ? ax.r2c : ax.d2c;\n\n    if(v0 !== undefined) return [convertVal(v0), convertVal(v1)];\n    if(!path) return;\n\n    var min = Infinity;\n    var max = -Infinity;\n    var segments = path.match(constants.segmentRE);\n    var i;\n    var segment;\n    var drawnParam;\n    var params;\n    var val;\n\n    if(ax.type === 'date') convertVal = helpers.decodeDate(convertVal);\n\n    for(i = 0; i < segments.length; i++) {\n        segment = segments[i];\n        drawnParam = paramsToUse[segment.charAt(0)].drawn;\n        if(drawnParam === undefined) continue;\n\n        params = segments[i].substr(1).match(constants.paramRE);\n        if(!params || params.length < drawnParam) continue;\n\n        val = convertVal(params[drawnParam]);\n        if(val < min) min = val;\n        if(val > max) max = val;\n    }\n    if(max >= min) return [min, max];\n}\n"]},"metadata":{},"sourceType":"script"}