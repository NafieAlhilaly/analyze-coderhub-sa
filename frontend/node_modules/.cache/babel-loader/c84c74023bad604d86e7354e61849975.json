{"ast":null,"code":"'use strict';\n\nvar tarjan = require('strongly-connected-components');\n\nvar Lib = require('../../lib');\n\nvar wrap = require('../../lib/gup').wrap;\n\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar isIndex = Lib.isIndex;\n\nvar Colorscale = require('../../components/colorscale');\n\nfunction convertToD3Sankey(trace) {\n  var nodeSpec = trace.node;\n  var linkSpec = trace.link;\n  var links = [];\n  var hasLinkColorArray = isArrayOrTypedArray(linkSpec.color);\n  var hasLinkCustomdataArray = isArrayOrTypedArray(linkSpec.customdata);\n  var linkedNodes = {};\n  var components = {};\n  var componentCount = linkSpec.colorscales.length;\n  var i;\n\n  for (i = 0; i < componentCount; i++) {\n    var cscale = linkSpec.colorscales[i];\n    var specs = Colorscale.extractScale(cscale, {\n      cLetter: 'c'\n    });\n    var scale = Colorscale.makeColorScaleFunc(specs);\n    components[cscale.label] = scale;\n  }\n\n  var maxNodeId = 0;\n\n  for (i = 0; i < linkSpec.value.length; i++) {\n    if (linkSpec.source[i] > maxNodeId) maxNodeId = linkSpec.source[i];\n    if (linkSpec.target[i] > maxNodeId) maxNodeId = linkSpec.target[i];\n  }\n\n  var nodeCount = maxNodeId + 1;\n  trace.node._count = nodeCount; // Group nodes\n\n  var j;\n  var groups = trace.node.groups;\n  var groupLookup = {};\n\n  for (i = 0; i < groups.length; i++) {\n    var group = groups[i]; // Build a lookup table to quickly find in which group a node is\n\n    for (j = 0; j < group.length; j++) {\n      var nodeIndex = group[j];\n      var groupIndex = nodeCount + i;\n\n      if (groupLookup.hasOwnProperty(nodeIndex)) {\n        Lib.warn('Node ' + nodeIndex + ' is already part of a group.');\n      } else {\n        groupLookup[nodeIndex] = groupIndex;\n      }\n    }\n  } // Process links\n\n\n  var groupedLinks = {\n    source: [],\n    target: []\n  };\n\n  for (i = 0; i < linkSpec.value.length; i++) {\n    var val = linkSpec.value[i]; // remove negative values, but keep zeros with special treatment\n\n    var source = linkSpec.source[i];\n    var target = linkSpec.target[i];\n\n    if (!(val > 0 && isIndex(source, nodeCount) && isIndex(target, nodeCount))) {\n      continue;\n    } // Remove links that are within the same group\n\n\n    if (groupLookup.hasOwnProperty(source) && groupLookup.hasOwnProperty(target) && groupLookup[source] === groupLookup[target]) {\n      continue;\n    } // if link targets a node in the group, relink target to that group\n\n\n    if (groupLookup.hasOwnProperty(target)) {\n      target = groupLookup[target];\n    } // if link originates from a node in a group, relink source to that group\n\n\n    if (groupLookup.hasOwnProperty(source)) {\n      source = groupLookup[source];\n    }\n\n    source = +source;\n    target = +target;\n    linkedNodes[source] = linkedNodes[target] = true;\n    var label = '';\n    if (linkSpec.label && linkSpec.label[i]) label = linkSpec.label[i];\n    var concentrationscale = null;\n    if (label && components.hasOwnProperty(label)) concentrationscale = components[label];\n    links.push({\n      pointNumber: i,\n      label: label,\n      color: hasLinkColorArray ? linkSpec.color[i] : linkSpec.color,\n      customdata: hasLinkCustomdataArray ? linkSpec.customdata[i] : linkSpec.customdata,\n      concentrationscale: concentrationscale,\n      source: source,\n      target: target,\n      value: +val\n    });\n    groupedLinks.source.push(source);\n    groupedLinks.target.push(target);\n  } // Process nodes\n\n\n  var totalCount = nodeCount + groups.length;\n  var hasNodeColorArray = isArrayOrTypedArray(nodeSpec.color);\n  var hasNodeCustomdataArray = isArrayOrTypedArray(nodeSpec.customdata);\n  var nodes = [];\n\n  for (i = 0; i < totalCount; i++) {\n    if (!linkedNodes[i]) continue;\n    var l = nodeSpec.label[i];\n    nodes.push({\n      group: i > nodeCount - 1,\n      childrenNodes: [],\n      pointNumber: i,\n      label: l,\n      color: hasNodeColorArray ? nodeSpec.color[i] : nodeSpec.color,\n      customdata: hasNodeCustomdataArray ? nodeSpec.customdata[i] : nodeSpec.customdata\n    });\n  } // Check if we have circularity on the resulting graph\n\n\n  var circular = false;\n\n  if (circularityPresent(totalCount, groupedLinks.source, groupedLinks.target)) {\n    circular = true;\n  }\n\n  return {\n    circular: circular,\n    links: links,\n    nodes: nodes,\n    // Data structure for groups\n    groups: groups,\n    groupLookup: groupLookup\n  };\n}\n\nfunction circularityPresent(nodeLen, sources, targets) {\n  var nodes = Lib.init2dArray(nodeLen, 0);\n\n  for (var i = 0; i < Math.min(sources.length, targets.length); i++) {\n    if (Lib.isIndex(sources[i], nodeLen) && Lib.isIndex(targets[i], nodeLen)) {\n      if (sources[i] === targets[i]) {\n        return true; // self-link which is also a scc of one\n      }\n\n      nodes[sources[i]].push(targets[i]);\n    }\n  }\n\n  var scc = tarjan(nodes); // TarjÃ¡n's strongly connected components algorithm coded by Mikola Lysenko\n  // returns at least one non-singular component if there's circularity in the graph\n\n  return scc.components.some(function (c) {\n    return c.length > 1;\n  });\n}\n\nmodule.exports = function calc(gd, trace) {\n  var result = convertToD3Sankey(trace);\n  return wrap({\n    circular: result.circular,\n    _nodes: result.nodes,\n    _links: result.links,\n    // Data structure for grouping\n    _groups: result.groups,\n    _groupLookup: result.groupLookup\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/sankey/calc.js"],"names":["tarjan","require","Lib","wrap","isArrayOrTypedArray","isIndex","Colorscale","convertToD3Sankey","trace","nodeSpec","node","linkSpec","link","links","hasLinkColorArray","color","hasLinkCustomdataArray","customdata","linkedNodes","components","componentCount","colorscales","length","i","cscale","specs","extractScale","cLetter","scale","makeColorScaleFunc","label","maxNodeId","value","source","target","nodeCount","_count","j","groups","groupLookup","group","nodeIndex","groupIndex","hasOwnProperty","warn","groupedLinks","val","concentrationscale","push","pointNumber","totalCount","hasNodeColorArray","hasNodeCustomdataArray","nodes","l","childrenNodes","circular","circularityPresent","nodeLen","sources","targets","init2dArray","Math","min","scc","some","c","module","exports","calc","gd","result","_nodes","_links","_groups","_groupLookup"],"mappings":"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","sourcesContent":["'use strict';\n\nvar tarjan = require('strongly-connected-components');\nvar Lib = require('../../lib');\nvar wrap = require('../../lib/gup').wrap;\n\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar isIndex = Lib.isIndex;\nvar Colorscale = require('../../components/colorscale');\n\nfunction convertToD3Sankey(trace) {\n    var nodeSpec = trace.node;\n    var linkSpec = trace.link;\n\n    var links = [];\n    var hasLinkColorArray = isArrayOrTypedArray(linkSpec.color);\n    var hasLinkCustomdataArray = isArrayOrTypedArray(linkSpec.customdata);\n    var linkedNodes = {};\n\n    var components = {};\n    var componentCount = linkSpec.colorscales.length;\n    var i;\n    for(i = 0; i < componentCount; i++) {\n        var cscale = linkSpec.colorscales[i];\n        var specs = Colorscale.extractScale(cscale, {cLetter: 'c'});\n        var scale = Colorscale.makeColorScaleFunc(specs);\n        components[cscale.label] = scale;\n    }\n\n    var maxNodeId = 0;\n    for(i = 0; i < linkSpec.value.length; i++) {\n        if(linkSpec.source[i] > maxNodeId) maxNodeId = linkSpec.source[i];\n        if(linkSpec.target[i] > maxNodeId) maxNodeId = linkSpec.target[i];\n    }\n    var nodeCount = maxNodeId + 1;\n    trace.node._count = nodeCount;\n\n    // Group nodes\n    var j;\n    var groups = trace.node.groups;\n    var groupLookup = {};\n    for(i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        // Build a lookup table to quickly find in which group a node is\n        for(j = 0; j < group.length; j++) {\n            var nodeIndex = group[j];\n            var groupIndex = nodeCount + i;\n            if(groupLookup.hasOwnProperty(nodeIndex)) {\n                Lib.warn('Node ' + nodeIndex + ' is already part of a group.');\n            } else {\n                groupLookup[nodeIndex] = groupIndex;\n            }\n        }\n    }\n\n    // Process links\n    var groupedLinks = {\n        source: [],\n        target: []\n    };\n    for(i = 0; i < linkSpec.value.length; i++) {\n        var val = linkSpec.value[i];\n        // remove negative values, but keep zeros with special treatment\n        var source = linkSpec.source[i];\n        var target = linkSpec.target[i];\n        if(!(val > 0 && isIndex(source, nodeCount) && isIndex(target, nodeCount))) {\n            continue;\n        }\n\n        // Remove links that are within the same group\n        if(groupLookup.hasOwnProperty(source) && groupLookup.hasOwnProperty(target) && groupLookup[source] === groupLookup[target]) {\n            continue;\n        }\n\n        // if link targets a node in the group, relink target to that group\n        if(groupLookup.hasOwnProperty(target)) {\n            target = groupLookup[target];\n        }\n\n        // if link originates from a node in a group, relink source to that group\n        if(groupLookup.hasOwnProperty(source)) {\n            source = groupLookup[source];\n        }\n\n        source = +source;\n        target = +target;\n        linkedNodes[source] = linkedNodes[target] = true;\n\n        var label = '';\n        if(linkSpec.label && linkSpec.label[i]) label = linkSpec.label[i];\n\n        var concentrationscale = null;\n        if(label && components.hasOwnProperty(label)) concentrationscale = components[label];\n\n        links.push({\n            pointNumber: i,\n            label: label,\n            color: hasLinkColorArray ? linkSpec.color[i] : linkSpec.color,\n            customdata: hasLinkCustomdataArray ? linkSpec.customdata[i] : linkSpec.customdata,\n            concentrationscale: concentrationscale,\n            source: source,\n            target: target,\n            value: +val\n        });\n\n        groupedLinks.source.push(source);\n        groupedLinks.target.push(target);\n    }\n\n    // Process nodes\n    var totalCount = nodeCount + groups.length;\n    var hasNodeColorArray = isArrayOrTypedArray(nodeSpec.color);\n    var hasNodeCustomdataArray = isArrayOrTypedArray(nodeSpec.customdata);\n    var nodes = [];\n    for(i = 0; i < totalCount; i++) {\n        if(!linkedNodes[i]) continue;\n        var l = nodeSpec.label[i];\n\n        nodes.push({\n            group: (i > nodeCount - 1),\n            childrenNodes: [],\n            pointNumber: i,\n            label: l,\n            color: hasNodeColorArray ? nodeSpec.color[i] : nodeSpec.color,\n            customdata: hasNodeCustomdataArray ? nodeSpec.customdata[i] : nodeSpec.customdata\n        });\n    }\n\n    // Check if we have circularity on the resulting graph\n    var circular = false;\n    if(circularityPresent(totalCount, groupedLinks.source, groupedLinks.target)) {\n        circular = true;\n    }\n\n    return {\n        circular: circular,\n        links: links,\n        nodes: nodes,\n\n        // Data structure for groups\n        groups: groups,\n        groupLookup: groupLookup\n    };\n}\n\nfunction circularityPresent(nodeLen, sources, targets) {\n    var nodes = Lib.init2dArray(nodeLen, 0);\n\n    for(var i = 0; i < Math.min(sources.length, targets.length); i++) {\n        if(Lib.isIndex(sources[i], nodeLen) && Lib.isIndex(targets[i], nodeLen)) {\n            if(sources[i] === targets[i]) {\n                return true; // self-link which is also a scc of one\n            }\n            nodes[sources[i]].push(targets[i]);\n        }\n    }\n\n    var scc = tarjan(nodes);\n\n    // TarjÃ¡n's strongly connected components algorithm coded by Mikola Lysenko\n    // returns at least one non-singular component if there's circularity in the graph\n    return scc.components.some(function(c) {\n        return c.length > 1;\n    });\n}\n\nmodule.exports = function calc(gd, trace) {\n    var result = convertToD3Sankey(trace);\n\n    return wrap({\n        circular: result.circular,\n        _nodes: result.nodes,\n        _links: result.links,\n\n        // Data structure for grouping\n        _groups: result.groups,\n        _groupLookup: result.groupLookup,\n    });\n};\n"]},"metadata":{},"sourceType":"script"}