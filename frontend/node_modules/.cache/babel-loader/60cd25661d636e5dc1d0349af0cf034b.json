{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Titles = require('../../components/titles');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\n\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\n\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\nvar ZERO_PATH = {\n  K: 'zeroline'\n};\nvar GRID_PATH = {\n  K: 'gridline',\n  L: 'path'\n};\nvar TICK_PATH = {\n  K: 'tick',\n  L: 'path'\n};\nvar TICK_TEXT = {\n  K: 'tick',\n  L: 'text'\n};\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\nvar TEXTPAD = 3;\nvar axes = module.exports = {};\naxes.setConvert = require('./set_convert');\n\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\n\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked; // tight coupling to chart studio\n\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\n\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\nvar epsilon = 0.0001;\n\nfunction expandRange(range) {\n  var delta = (range[1] - range[0]) * epsilon;\n  return [range[0] - delta, range[1] + delta];\n}\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\n\n\naxes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {\n  var axLetter = attr.charAt(attr.length - 1);\n  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n  var refAttr = attr + 'ref';\n  var attrDef = {};\n  if (!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n  if (!extraOption) extraOption = dflt;\n  axlist = axlist.concat(axlist.map(function (x) {\n    return x + ' domain';\n  })); // data-ref annotations are not supported in gl2d yet\n\n  attrDef[refAttr] = {\n    valType: 'enumerated',\n    values: axlist.concat(extraOption ? typeof extraOption === 'string' ? [extraOption] : extraOption : []),\n    dflt: dflt\n  }; // xref, yref\n\n  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\n\n\naxes.getRefType = function (ar) {\n  if (ar === undefined) {\n    return ar;\n  }\n\n  if (ar === 'paper') {\n    return 'paper';\n  }\n\n  if (ar === 'pixel') {\n    return 'pixel';\n  }\n\n  if (/( domain)$/.test(ar)) {\n    return 'domain';\n  } else {\n    return 'range';\n  }\n};\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\n\n\naxes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {\n  var cleanPos, pos;\n  var axRefType = axes.getRefType(axRef);\n\n  if (axRefType !== 'range') {\n    cleanPos = Lib.ensureNumber;\n    pos = coerce(attr, dflt);\n  } else {\n    var ax = axes.getFromId(gd, axRef);\n    dflt = ax.fraction2r(dflt);\n    pos = coerce(attr, dflt);\n    cleanPos = ax.cleanPos;\n  }\n\n  containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function (pos, gd, axRef) {\n  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;\n  return cleanPos(pos);\n};\n\naxes.redrawComponents = function (gd, axIds) {\n  axIds = axIds ? axIds : axes.listIds(gd);\n  var fullLayout = gd._fullLayout;\n\n  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n    var method = Registry.getComponentMethod(moduleName, methodName);\n    var stash = {};\n\n    for (var i = 0; i < axIds.length; i++) {\n      var ax = fullLayout[axes.id2name(axIds[i])];\n      var indices = ax[stashName];\n\n      for (var j = 0; j < indices.length; j++) {\n        var ind = indices[j];\n\n        if (!stash[ind]) {\n          method(gd, ind);\n          stash[ind] = 1; // once is enough for images (which doesn't use the `i` arg anyway)\n\n          if (shortCircuit) return;\n        }\n      }\n    }\n  } // annotations and shapes 'draw' method is slow,\n  // use the finer-grained 'drawOne' method instead\n\n\n  _redrawOneComp('annotations', 'drawOne', '_annIndices');\n\n  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n\n  _redrawOneComp('images', 'draw', '_imgIndices', true);\n};\n\nvar getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {\n  var ax; // If target points to an axis, use the type we already have for that\n  // axis to find the data type. Otherwise use the values to autotype.\n\n  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray; // In the case of an array target, make a mock data array\n  // and call supplyDefaults to the data type and\n  // setup the data-to-calc method.\n\n  if (Array.isArray(d2cTarget)) {\n    ax = {\n      type: autoType(targetArray, undefined, {\n        autotypenumbers: gd._fullLayout.autotypenumbers\n      }),\n      _categories: []\n    };\n    axes.setConvert(ax); // build up ax._categories (usually done during ax.makeCalcdata()\n\n    if (ax.type === 'category') {\n      for (var i = 0; i < targetArray.length; i++) {\n        ax.d2c(targetArray[i]);\n      }\n    } // TODO what to do for transforms?\n\n  } else {\n    ax = axes.getFromTrace(gd, trace, d2cTarget);\n  } // if 'target' has corresponding axis\n  // -> use setConvert method\n\n\n  if (ax) return {\n    d2c: ax.d2c,\n    c2d: ax.c2d\n  }; // special case for 'ids'\n  // -> cast to String\n\n  if (d2cTarget === 'ids') return {\n    d2c: toString,\n    c2d: toString\n  }; // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n  // -> cast to Number\n\n  return {\n    d2c: toNum,\n    c2d: toNum\n  };\n};\n\nfunction toNum(v) {\n  return +v;\n}\n\nfunction toString(v) {\n  return String(v);\n}\n\naxes.getDataToCoordFunc = function (gd, trace, target, targetArray) {\n  return getDataConversions(gd, trace, target, targetArray).d2c;\n}; // get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\n\n\naxes.counterLetter = function (id) {\n  var axLetter = id.charAt(0);\n  if (axLetter === 'x') return 'y';\n  if (axLetter === 'y') return 'x';\n}; // incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\n\n\naxes.minDtick = function (ax, newDiff, newFirst, allow) {\n  // doesn't make sense to do forced min dTick on log or category axes,\n  // and the plot itself may decide to cancel (ie non-grouped bars)\n  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n    ax._minDtick = 0;\n  } else if (ax._minDtick === undefined) {\n    // undefined means there's nothing there yet\n    ax._minDtick = newDiff;\n    ax._forceTick0 = newFirst;\n  } else if (ax._minDtick) {\n    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && // existing minDtick is an integer multiple of newDiff\n    // (within rounding err)\n    // and forceTick0 can be shifted to newFirst\n    ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {\n      ax._minDtick = newDiff;\n      ax._forceTick0 = newFirst;\n    } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || // if the converse is true (newDiff is a multiple of minDtick and\n    // newFirst can be shifted to forceTick0) then do nothing - same\n    // forcing stands. Otherwise, cancel forced minimum\n    ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {\n      ax._minDtick = 0;\n    }\n  }\n}; // save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\n\n\naxes.saveRangeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._rangeInitial === undefined;\n    var hasChanged = isNew || !(ax.range[0] === ax._rangeInitial[0] && ax.range[1] === ax._rangeInitial[1]);\n\n    if (isNew && ax.autorange === false || overwrite && hasChanged) {\n      ax._rangeInitial = ax.range.slice();\n      hasOneAxisChanged = true;\n    }\n  }\n\n  return hasOneAxisChanged;\n}; // save a copy of the initial spike visibility\n\n\naxes.saveShowSpikeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  var allSpikesEnabled = 'on';\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._showSpikeInitial === undefined;\n    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n    if (isNew || overwrite && hasChanged) {\n      ax._showSpikeInitial = ax.showspikes;\n      hasOneAxisChanged = true;\n    }\n\n    if (allSpikesEnabled === 'on' && !ax.showspikes) {\n      allSpikesEnabled = 'off';\n    }\n  }\n\n  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  return hasOneAxisChanged;\n};\n\naxes.autoBin = function (data, ax, nbins, is2d, calendar, size) {\n  var dataMin = Lib.aggNums(Math.min, null, data);\n  var dataMax = Lib.aggNums(Math.max, null, data);\n\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    return {\n      start: dataMin - 0.5,\n      end: dataMax + 0.5,\n      size: Math.max(1, Math.round(size) || 1),\n      _dataSpan: dataMax - dataMin\n    };\n  }\n\n  if (!calendar) calendar = ax.calendar; // piggyback off tick code to make \"nice\" bin sizes and edges\n\n  var dummyAx;\n\n  if (ax.type === 'log') {\n    dummyAx = {\n      type: 'linear',\n      range: [dataMin, dataMax]\n    };\n  } else {\n    dummyAx = {\n      type: ax.type,\n      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n      calendar: calendar\n    };\n  }\n\n  axes.setConvert(dummyAx);\n  size = size && cleanTicks.dtick(size, dummyAx.type);\n\n  if (size) {\n    dummyAx.dtick = size;\n    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n  } else {\n    var size0;\n    if (nbins) size0 = (dataMax - dataMin) / nbins;else {\n      // totally auto: scale off std deviation so the highest bin is\n      // somewhat taller than the total number of bins, but don't let\n      // the size get smaller than the 'nice' rounded down minimum\n      // difference between values\n      var distinctData = Lib.distinctVals(data);\n      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));\n      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4)); // fallback if ax.d2c output BADNUMs\n      // e.g. when user try to plot categorical bins\n      // on a layout.xaxis.type: 'linear'\n\n      if (!isNumeric(size0)) size0 = 1;\n    }\n    axes.autoTicks(dummyAx, size0);\n  }\n\n  var finalSize = dummyAx.dtick;\n  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n  var binEnd, bincount; // check for too many data points right at the edges of bins\n  // (>50% within 1% of bin edges) or all data points integral\n  // and offset the bins accordingly\n\n  if (typeof finalSize === 'number') {\n    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n    binEnd = binStart + bincount * finalSize;\n  } else {\n    // month ticks - should be the only nonlinear kind we have at this point.\n    // dtick (as supplied by axes.autoTick) only has nonlinear values on\n    // date and log axes, but even if you display a histogram on a log axis\n    // we bin it on a linear axis (which one could argue against, but that's\n    // a separate issue)\n    if (dummyAx.dtick.charAt(0) === 'M') {\n      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n    } // calculate the endpoint for nonlinear ticks - you have to\n    // just increment until you're done\n\n\n    binEnd = binStart;\n    bincount = 0;\n\n    while (binEnd <= dataMax) {\n      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n      bincount++;\n    }\n  }\n\n  return {\n    start: ax.c2r(binStart, 0, calendar),\n    end: ax.c2r(binEnd, 0, calendar),\n    size: finalSize,\n    _dataSpan: dataMax - dataMin\n  };\n};\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n  var edgecount = 0;\n  var midcount = 0;\n  var intcount = 0;\n  var blankCount = 0;\n\n  function nearEdge(v) {\n    // is a value within 1% of a bin edge?\n    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n  }\n\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;\n    if (nearEdge(data[i])) edgecount++;\n    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;\n  }\n\n  var dataCount = data.length - blankCount;\n\n  if (intcount === dataCount && ax.type !== 'date') {\n    if (ax.dtick < 1) {\n      // all integers: if bin size is <1, it's because\n      // that was specifically requested (large nbins)\n      // so respect that... but center the bins containing\n      // integers on those integers\n      binStart = dataMin - 0.5 * ax.dtick;\n    } else {\n      // otherwise start half an integer down regardless of\n      // the bin size, just enough to clear up endpoint\n      // ambiguity about which integers are in which bins.\n      binStart -= 0.5;\n      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;\n    }\n  } else if (midcount < dataCount * 0.1) {\n    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {\n      // lots of points at the edge, not many in the middle\n      // shift half a bin\n      var binshift = ax.dtick / 2;\n      binStart += binStart + binshift < dataMin ? binshift : -binshift;\n    }\n  }\n\n  return binStart;\n}\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n  var stats = Lib.findExactDates(data, calendar); // number of data points that needs to be an exact value\n  // to shift that increment to (near) the bin center\n\n  var threshold = 0.8;\n\n  if (stats.exactDays > threshold) {\n    var numMonths = Number(dtick.substr(1));\n\n    if (stats.exactYears > threshold && numMonths % 12 === 0) {\n      // The exact middle of a non-leap-year is 1.5 days into July\n      // so if we start the bins here, all but leap years will\n      // get hover-labeled as exact years.\n      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n    } else if (stats.exactMonths > threshold) {\n      // Months are not as clean, but if we shift half the *longest*\n      // month (31/2 days) then 31-day months will get labeled exactly\n      // and shorter months will get labeled with the correct month\n      // but shifted 12-36 hours into it.\n      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n    } else {\n      // Shifting half a day is exact, but since these are month bins it\n      // will always give a somewhat odd-looking label, until we do something\n      // smarter like showing the bin boundaries (or the bounds of the actual\n      // data in each bin)\n      binStart -= HALFDAY;\n    }\n\n    var nextBinStart = axes.tickIncrement(binStart, dtick);\n    if (nextBinStart <= dataMin) return nextBinStart;\n  }\n\n  return binStart;\n} // ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n// ensure we have tick0, dtick, and tick rounding calculated\n\n\naxes.prepTicks = function (ax, opts) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n  ax._dtickInit = ax.dtick;\n  ax._tick0Init = ax.tick0; // calculate max number of (auto) ticks to display based on plot size\n\n  if (ax.tickmode === 'auto' || !ax.dtick) {\n    var nt = ax.nticks;\n    var minPx;\n\n    if (!nt) {\n      if (ax.type === 'category' || ax.type === 'multicategory') {\n        minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n        nt = ax._length / minPx;\n      } else {\n        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n      } // radial axes span half their domain,\n      // multiply nticks value by two to get correct number of auto ticks.\n\n\n      if (ax._name === 'radialaxis') nt *= 2;\n    } // add a couple of extra digits for filling in ticks when we\n    // have explicit tickvals without tick text\n\n\n    if (ax.tickmode === 'array') nt *= 100;\n    ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n    axes.autoTicks(ax, ax._roughDTick); // check for a forced minimum dtick\n\n    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n      ax.dtick = ax._minDtick;\n      ax.tick0 = ax.l2r(ax._forceTick0);\n    }\n  }\n\n  if (ax.ticklabelmode === 'period') {\n    adjustPeriodDelta(ax);\n  } // check for missing tick0\n\n\n  if (!ax.tick0) {\n    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;\n  } // ensure we don't try to make ticks below our minimum precision\n  // see https://github.com/plotly/plotly.js/issues/2892\n\n\n  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1; // now figure out rounding of tick values\n\n  autoTickRound(ax);\n};\n\nfunction nMonths(dtick) {\n  return +dtick.substring(1);\n}\n\nfunction adjustPeriodDelta(ax) {\n  // adjusts ax.dtick and sets ax._definedDelta\n  var definedDelta;\n\n  function mDate() {\n    return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== 'M');\n  }\n\n  var isMDate = mDate();\n  var tickformat = axes.getTickFormat(ax);\n\n  if (tickformat) {\n    var noDtick = ax._dtickInit !== ax.dtick;\n\n    if (!/%[fLQsSMX]/.test(tickformat) // %f: microseconds as a decimal number [000000, 999999]\n    // %L: milliseconds as a decimal number [000, 999]\n    // %Q: milliseconds since UNIX epoch\n    // %s: seconds since UNIX epoch\n    // %S: second as a decimal number [00,61]\n    // %M: minute as a decimal number [00,59]\n    // %X: the locale’s time, such as %-I:%M:%S %p\n    ) {\n      if (/%[HI]/.test(tickformat) // %H: hour (24-hour clock) as a decimal number [00,23]\n      // %I: hour (12-hour clock) as a decimal number [01,12]\n      ) {\n        definedDelta = ONEHOUR;\n        if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n      } else if (/%p/.test(tickformat) // %p: either AM or PM\n      ) {\n        definedDelta = HALFDAY;\n        if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n      } else if (/%[Aadejuwx]/.test(tickformat) // %A: full weekday name\n      // %a: abbreviated weekday name\n      // %d: zero-padded day of the month as a decimal number [01,31]\n      // %e: space-padded day of the month as a decimal number [ 1,31]\n      // %j: day of the year as a decimal number [001,366]\n      // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n      // %w: Sunday-based weekday as a decimal number [0,6]\n      // %x: the locale’s date, such as %-m/%-d/%Y\n      ) {\n        definedDelta = ONEDAY;\n        if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n      } else if (/%[UVW]/.test(tickformat) // %U: Sunday-based week of the year as a decimal number [00,53]\n      // %V: ISO 8601 week of the year as a decimal number [01, 53]\n      // %W: Monday-based week of the year as a decimal number [00,53]\n      ) {\n        definedDelta = ONEWEEK;\n        if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n      } else if (/%[Bbm]/.test(tickformat) // %B: full month name\n      // %b: abbreviated month name\n      // %m: month as a decimal number [01,12]\n      ) {\n        definedDelta = ONEAVGMONTH;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = 'M1';\n      } else if (/%[q]/.test(tickformat) // %q: quarter of the year as a decimal number [1,4]\n      ) {\n        definedDelta = ONEAVGQUARTER;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = 'M3';\n      } else if (/%[Yy]/.test(tickformat) // %Y: year with century as a decimal number, such as 1999\n      // %y: year without century as a decimal number [00,99]\n      ) {\n        definedDelta = ONEAVGYEAR;\n        if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = 'M12';\n      }\n    }\n  }\n\n  isMDate = mDate();\n\n  if (isMDate && ax.tick0 === ax._dowTick0) {\n    // discard Sunday/Monday tweaks\n    ax.tick0 = ax._rawTick0;\n  }\n\n  ax._definedDelta = definedDelta;\n}\n\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n  for (var i = 0; i < tickVals.length; i++) {\n    var v = tickVals[i].value;\n    var a = i;\n    var b = i + 1;\n\n    if (i < tickVals.length - 1) {\n      a = i;\n      b = i + 1;\n    } else if (i > 0) {\n      a = i - 1;\n      b = i;\n    } else {\n      a = i;\n      b = i;\n    }\n\n    var A = tickVals[a].value;\n    var B = tickVals[b].value;\n    var actualDelta = Math.abs(B - A);\n    var delta = definedDelta || actualDelta;\n    var periodLength = 0;\n\n    if (delta >= ONEMINYEAR) {\n      if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGYEAR;\n      }\n    } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n      if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGQUARTER;\n      }\n    } else if (delta >= ONEMINMONTH) {\n      if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGMONTH;\n      }\n    } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {\n      periodLength = ONEWEEK;\n    } else if (delta >= ONEDAY) {\n      periodLength = ONEDAY;\n    } else if (definedDelta === HALFDAY && delta >= HALFDAY) {\n      periodLength = HALFDAY;\n    } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {\n      periodLength = ONEHOUR;\n    }\n\n    var inBetween;\n\n    if (periodLength >= actualDelta) {\n      // ensure new label positions remain between ticks\n      periodLength = actualDelta;\n      inBetween = true;\n    }\n\n    var endPeriod = v + periodLength;\n\n    if (ax.rangebreaks && periodLength > 0) {\n      var nAll = 84; // highly divisible 7 * 12\n\n      var n = 0;\n\n      for (var c = 0; c < nAll; c++) {\n        var r = (c + 0.5) / nAll;\n        if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n      }\n\n      periodLength *= n / nAll;\n\n      if (!periodLength) {\n        tickVals[i].drop = true;\n      }\n\n      if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n    }\n\n    if (periodLength > 0 || // not instant\n    i === 0 // taking care first tick added\n    ) {\n      tickVals[i].periodX = v + periodLength / 2;\n    }\n  }\n} // calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\n\n\naxes.calcTicks = function calcTicks(ax, opts) {\n  axes.prepTicks(ax, opts);\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts); // now that we've figured out the auto values for formatting\n  // in case we're missing some ticktext, we can break out for array ticks\n\n  if (ax.tickmode === 'array') return arrayTicks(ax); // add a tiny bit so we get ticks which may have rounded out\n\n  var exRng = expandRange(rng);\n  var startTick = exRng[0];\n  var endTick = exRng[1]; // check for reversed axis\n\n  var axrev = rng[1] < rng[0];\n  var minRange = Math.min(rng[0], rng[1]);\n  var maxRange = Math.max(rng[0], rng[1]);\n  var isDLog = ax.type === 'log' && !(isNumeric(ax.dtick) || ax.dtick.charAt(0) === 'L');\n  var isPeriod = ax.ticklabelmode === 'period'; // find the first tick\n\n  ax._tmin = axes.tickFirst(ax, opts); // No visible ticks? Quit.\n  // I've only seen this on category axes with all categories off the edge.\n\n  if (ax._tmin < startTick !== axrev) return []; // return the full set of tick vals\n\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);\n  }\n\n  var x = ax._tmin;\n\n  if (ax.rangebreaks && ax._tick0Init !== ax.tick0) {\n    // adjust tick0\n    x = moveOutsideBreak(x, ax);\n\n    if (!axrev) {\n      x = axes.tickIncrement(x, ax.dtick, !axrev, ax.calendar);\n    }\n  }\n\n  if (isPeriod) {\n    // add one item to label period before tick0\n    x = axes.tickIncrement(x, ax.dtick, !axrev, ax.calendar);\n  }\n\n  var maxTicks = Math.max(1000, ax._length || 0);\n  var tickVals = [];\n  var xPrevious = null;\n\n  for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)) {\n    if (ax.rangebreaks) {\n      if (!axrev) {\n        if (x < startTick) continue;\n        if (ax.maskBreaks(x) === BADNUM && moveOutsideBreak(x, ax) >= maxRange) break;\n      }\n    } // prevent infinite loops - no more than one tick per pixel,\n    // and make sure each value is different from the previous\n\n\n    if (tickVals.length > maxTicks || x === xPrevious) break;\n    xPrevious = x;\n    var minor = false;\n\n    if (isDLog && x !== (x | 0)) {\n      minor = true;\n    }\n\n    tickVals.push({\n      minor: minor,\n      value: x\n    });\n  }\n\n  if (isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);\n  var i;\n\n  if (ax.rangebreaks) {\n    var flip = ax._id.charAt(0) === 'y';\n    var fontSize = 1; // one pixel minimum\n\n    if (ax.tickmode === 'auto') {\n      fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    }\n\n    var prevL = NaN;\n\n    for (i = tickVals.length - 1; i > -1; i--) {\n      if (tickVals[i].drop) {\n        tickVals.splice(i, 1);\n        continue;\n      }\n\n      tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax); // avoid overlaps\n\n      var l = ax.c2p(tickVals[i].value);\n\n      if (flip ? prevL > l - fontSize : prevL < l + fontSize) {\n        // ensure one pixel minimum\n        tickVals.splice(axrev ? i + 1 : i, 1);\n      } else {\n        prevL = l;\n      }\n    }\n  } // If same angle over a full circle, the last tick vals is a duplicate.\n  // TODO must do something similar for angular date axes.\n\n\n  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n    tickVals.pop();\n  } // save the last tick as well as first, so we can\n  // show the exponent only on the last one\n\n\n  ax._tmax = (tickVals[tickVals.length - 1] || {}).value; // for showing the rest of a date when the main tick label is only the\n  // latter part: ax._prevDateHead holds what we showed most recently.\n  // Start with it cleared and mark that we're in calcTicks (ie calculating a\n  // whole string of these so we should care what the previous date head was!)\n\n  ax._prevDateHead = '';\n  ax._inCalcTicks = true;\n  var ticksOut = [];\n  var t, p;\n\n  for (i = 0; i < tickVals.length; i++) {\n    var _minor = tickVals[i].minor;\n    var _value = tickVals[i].value;\n    t = axes.tickText(ax, _value, false, // hover\n    _minor // noSuffixPrefix\n    );\n    p = tickVals[i].periodX;\n\n    if (p !== undefined) {\n      t.periodX = p;\n\n      if (p > maxRange || p < minRange) {\n        // hide label if outside the range\n        if (p > maxRange) t.periodX = maxRange;\n        if (p < minRange) t.periodX = minRange;\n        t.text = ' '; // don't use an empty string here which can confuse automargin (issue 5132)\n\n        ax._prevDateHead = '';\n      }\n    }\n\n    ticksOut.push(t);\n  }\n\n  ax._inCalcTicks = false;\n  return ticksOut;\n};\n\nfunction arrayTicks(ax) {\n  var vals = ax.tickvals;\n  var text = ax.ticktext;\n  var ticksOut = new Array(vals.length);\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  var exRng = expandRange(rng);\n  var tickMin = Math.min(exRng[0], exRng[1]);\n  var tickMax = Math.max(exRng[0], exRng[1]);\n  var j = 0; // without a text array, just format the given values as any other ticks\n  // except with more precision to the numbers\n\n  if (!Array.isArray(text)) text = []; // make sure showing ticks doesn't accidentally add new categories\n  // TODO multicategory, if we allow ticktext / tickvals\n\n  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l; // array ticks on log axes always show the full number\n  // (if no explicit ticktext overrides it)\n\n  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n  }\n\n  for (var i = 0; i < vals.length; i++) {\n    var vali = tickVal2l(vals[i]);\n\n    if (vali > tickMin && vali < tickMax) {\n      if (text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));\n      j++;\n    }\n  }\n\n  if (j < vals.length) ticksOut.splice(j, vals.length - j);\n\n  if (ax.rangebreaks) {\n    // remove ticks falling inside rangebreaks\n    ticksOut = ticksOut.filter(function (d) {\n      return ax.maskBreaks(d.x) !== BADNUM;\n    });\n  }\n\n  return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30]; // 2&3 day ticks are weird, but need something btwn 1&7\n\nvar roundDays = [1, 2, 3, 7, 14]; // approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\n\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1]; // N.B. `thetaunit; 'radians' angular axes must be converted to degrees\n\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n  return base * Lib.roundUp(roughDTick / base, roundingSet);\n} // autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\n\n\naxes.autoTicks = function (ax, roughDTick) {\n  var base;\n\n  function getBase(v) {\n    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n  }\n\n  if (ax.type === 'date') {\n    ax.tick0 = Lib.dateTick0(ax.calendar, 0); // the criteria below are all based on the rough spacing we calculate\n    // being > half of the final unit - so precalculate twice the rough val\n\n    var roughX2 = 2 * roughDTick;\n\n    if (roughX2 > ONEAVGYEAR) {\n      roughDTick /= ONEAVGYEAR;\n      base = getBase(10);\n      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);\n    } else if (roughX2 > ONEAVGMONTH) {\n      roughDTick /= ONEAVGMONTH;\n      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n    } else if (roughX2 > ONEDAY) {\n      ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays); // get week ticks on sunday\n      // this will also move the base tick off 2000-01-01 if dtick is\n      // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n\n      var tickformat = axes.getTickFormat(ax);\n      var isPeriod = ax.ticklabelmode === 'period';\n      if (isPeriod) ax._rawTick0 = ax.tick0;\n\n      if (/%[uVW]/.test(tickformat)) {\n        ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n      } else {\n        ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n      }\n\n      if (isPeriod) ax._dowTick0 = ax.tick0;\n    } else if (roughX2 > ONEHOUR) {\n      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n    } else if (roughX2 > ONEMIN) {\n      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n    } else if (roughX2 > ONESEC) {\n      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n    } else {\n      // milliseconds\n      base = getBase(10);\n      ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n  } else if (ax.type === 'log') {\n    ax.tick0 = 0;\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n    if (roughDTick > 0.7) {\n      // only show powers of 10\n      ax.dtick = Math.ceil(roughDTick);\n    } else if (Math.abs(rng[1] - rng[0]) < 1) {\n      // span is less than one power of 10\n      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick); // ticks on a linear scale, labeled fully\n\n      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;\n      base = getBase(10);\n      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n    } else {\n      // include intermediates between powers of 10,\n      // labeled with small digits\n      // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';\n    }\n  } else if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax.tick0 = 0;\n    ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n  } else if (isAngular(ax)) {\n    ax.tick0 = 0;\n    base = 1;\n    ax.dtick = roundDTick(roughDTick, base, roundAngles);\n  } else {\n    // auto ticks always start at 0\n    ax.tick0 = 0;\n    base = getBase(10);\n    ax.dtick = roundDTick(roughDTick, base, roundBase10);\n  } // prevent infinite loops\n\n\n  if (ax.dtick === 0) ax.dtick = 1; // TODO: this is from log axis histograms with autorange off\n\n  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n    var olddtick = ax.dtick;\n    ax.dtick = 1;\n    throw 'ax.dtick error: ' + String(olddtick);\n  }\n}; // after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\n\n\nfunction autoTickRound(ax) {\n  var dtick = ax.dtick;\n  ax._tickexponent = 0;\n\n  if (!isNumeric(dtick) && typeof dtick !== 'string') {\n    dtick = 1;\n  }\n\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax._tickround = null;\n  }\n\n  if (ax.type === 'date') {\n    // If tick0 is unusual, give tickround a bit more information\n    // not necessarily *all* the information in tick0 though, if it's really odd\n    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n    var tick0ms = ax.r2l(ax.tick0);\n    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n    var tick0len = tick0str.length;\n\n    if (String(dtick).charAt(0) === 'M') {\n      // any tick0 more specific than a year: alway show the full date\n      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd'; // show the month unless ticks are full multiples of a year\n      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';\n    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {\n      // tickround is a number of digits of fractional seconds\n      // of any two adjacent ticks, at least one will have the maximum fractional digits\n      // of all possible ticks - so take the max. length of tick0 and the next one\n      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n      ax._tickround = Math.max(tick0len, tick1len) - 20; // We shouldn't get here... but in case there's a situation I'm\n      // not thinking of where tick0str and tick1str are identical or\n      // something, fall back on maximum precision\n\n      if (ax._tickround < 0) ax._tickround = 4;\n    }\n  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {\n    // linear or log (except D1, D2)\n    var rng = ax.range.map(ax.r2d || Number);\n    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1)); // 2 digits past largest digit of dtick\n\n    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n    var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n\n    if (Math.abs(rangeexp) > minexponent) {\n      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n      } else ax._tickexponent = rangeexp;\n    }\n  } else {\n    // D1 or D2 (log)\n    ax._tickround = null;\n  }\n} // months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\n\n\naxes.tickIncrement = function (x, dtick, axrev, calendar) {\n  var axSign = axrev ? -1 : 1; // includes linear, all dates smaller than month, and pure 10^n in log\n\n  if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick); // everything else is a string, one character plus a number\n\n  var tType = dtick.charAt(0);\n  var dtSigned = axSign * Number(dtick.substr(1)); // Dates: months (or years - see Lib.incrementMonth)\n\n  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar); // Log scales: Linear, Digits\n\n  if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10; // log10 of 2,5,10, or all digits (logs just have to be\n  // close enough to round)\n\n  if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var x2 = x + axSign * 0.01;\n    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  }\n\n  throw 'unrecognized dtick ' + String(dtick);\n}; // calculate the first tick on an axis\n\n\naxes.tickFirst = function (ax, opts) {\n  var r2l = ax.r2l || Number;\n  var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var sRound = axrev ? Math.floor : Math.ceil; // add a tiny extra bit to make sure we get ticks\n  // that may have been rounded out\n\n  var r0 = expandRange(rng)[0];\n  var dtick = ax.dtick;\n  var tick0 = r2l(ax.tick0);\n\n  if (isNumeric(dtick)) {\n    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0; // make sure no ticks outside the category list\n\n    if (ax.type === 'category' || ax.type === 'multicategory') {\n      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n    }\n\n    return tmin;\n  }\n\n  var tType = dtick.charAt(0);\n  var dtNum = Number(dtick.substr(1)); // Dates: months (or years)\n\n  if (tType === 'M') {\n    var cnt = 0;\n    var t0 = tick0;\n    var t1, mult, newDTick; // This algorithm should work for *any* nonlinear (but close to linear!)\n    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n\n    while (cnt < 10) {\n      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n\n      if ((t1 - r0) * (t0 - r0) <= 0) {\n        // t1 and t0 are on opposite sides of r0! we've succeeded!\n        if (axrev) return Math.min(t0, t1);\n        return Math.max(t0, t1);\n      }\n\n      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);\n      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;\n      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n      cnt++;\n    }\n\n    Lib.error('tickFirst did not converge', ax);\n    return t0;\n  } else if (tType === 'L') {\n    // Log scales: Linear, Digits\n    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n  } else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n}; // draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\n\n\naxes.tickText = function (ax, x, hover, noSuffixPrefix) {\n  var out = tickTextObj(ax, x);\n  var arrayMode = ax.tickmode === 'array';\n  var extraPrecision = hover || arrayMode;\n  var axType = ax.type; // TODO multicategory, if we allow ticktext / tickvals\n\n  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n  var i;\n\n  if (arrayMode && Array.isArray(ax.ticktext)) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n\n    for (i = 0; i < ax.ticktext.length; i++) {\n      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n    }\n\n    if (i < ax.ticktext.length) {\n      out.text = String(ax.ticktext[i]);\n      return out;\n    }\n  }\n\n  function isHidden(showAttr) {\n    if (showAttr === undefined) return true;\n    if (hover) return showAttr === 'none';\n    var firstOrLast = {\n      first: ax._tmin,\n      last: ax._tmax\n    }[showAttr];\n    return showAttr !== 'all' && x !== firstOrLast;\n  }\n\n  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp); // add prefix and suffix\n\n  if (!noSuffixPrefix) {\n    if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n  } // Setup ticks and grid lines boundaries\n  // at 1/2 a 'category' to the left/bottom\n\n\n  if (ax.tickson === 'boundaries' || ax.showdividers) {\n    var inbounds = function (v) {\n      var p = ax.l2p(v);\n      return p >= 0 && p <= ax._length ? v : null;\n    };\n\n    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n  }\n\n  return out;\n};\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\n\n\naxes.hoverLabelText = function (ax, values, hoverformat) {\n  if (hoverformat) ax = Lib.extendFlat({}, ax, {\n    hoverformat: hoverformat\n  });\n  var val = Array.isArray(values) ? values[0] : values;\n  var val2 = Array.isArray(values) ? values[1] : undefined;\n\n  if (val2 !== undefined && val2 !== val) {\n    return axes.hoverLabelText(ax, val, hoverformat) + ' - ' + axes.hoverLabelText(ax, val2, hoverformat);\n  }\n\n  var logOffScale = ax.type === 'log' && val <= 0;\n  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n  if (logOffScale) {\n    return val === 0 ? '0' : MINUS_SIGN + tx;\n  } // TODO: should we do something special if the axis calendar and\n  // the data calendar are different? Somehow display both dates with\n  // their system names? Right now it will just display in the axis calendar\n  // but users could add the other one as text.\n\n\n  return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n  var tf = ax.tickfont || {};\n  return {\n    x: x,\n    dx: 0,\n    dy: 0,\n    text: text || '',\n    fontSize: tf.size,\n    font: tf.family,\n    fontColor: tf.color\n  };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n  var tr = ax._tickround;\n  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);\n\n  if (extraPrecision) {\n    // second or sub-second precision: extra always shows max digits.\n    // for other fields, extra precision just adds one field.\n    if (isNumeric(tr)) tr = 4;else tr = {\n      y: 'm',\n      m: 'd',\n      d: 'M',\n      M: 'S',\n      S: 4\n    }[tr];\n  }\n\n  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n  var headStr;\n  var splitIndex = dateStr.indexOf('\\n');\n\n  if (splitIndex !== -1) {\n    headStr = dateStr.substr(splitIndex + 1);\n    dateStr = dateStr.substr(0, splitIndex);\n  }\n\n  if (extraPrecision) {\n    // if extraPrecision led to trailing zeros, strip them off\n    // actually, this can lead to removing even more zeros than\n    // in the original rounding, but that's fine because in these\n    // contexts uniformity is not so important (if there's even\n    // anything to be uniform with!)\n    // can we remove the whole time part?\n    if (dateStr === '00:00:00' || dateStr === '00:00') {\n      dateStr = headStr;\n      headStr = '';\n    } else if (dateStr.length === 8) {\n      // strip off seconds if they're zero (zero fractional seconds\n      // are already omitted)\n      // but we never remove minutes and leave just hours\n      dateStr = dateStr.replace(/:00$/, '');\n    }\n  }\n\n  if (headStr) {\n    if (hover) {\n      // hover puts it all on one line, so headPart works best up front\n      // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n    } else {\n      if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {\n        ax._prevDateHead = headStr;\n        dateStr += '<br>' + headStr;\n      } else {\n        var isInside = insideTicklabelposition(ax);\n        var side = ax._realSide || ax.side; // polar mocks the side of the radial axis\n\n        if (!isInside && side === 'top' || isInside && side === 'bottom') {\n          dateStr += '<br> ';\n        }\n      }\n    }\n  }\n\n  out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n  var dtick = ax.dtick;\n  var x = out.x;\n  var tickformat = ax.tickformat;\n  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  }\n\n  if (extraPrecision && dtChar0 !== 'L') {\n    dtick = 'L3';\n    dtChar0 = 'L';\n  }\n\n  if (tickformat || dtChar0 === 'L') {\n    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {\n    var p = Math.round(x);\n    var absP = Math.abs(p);\n    var exponentFormat = ax.exponentformat;\n\n    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {\n      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n      out.fontSize *= 1.25;\n    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n    } else {\n      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n\n      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {\n        out.dy -= out.fontSize / 6;\n      }\n    }\n  } else if (dtChar0 === 'D') {\n    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n    out.fontSize *= 0.75;\n  } else throw 'unrecognized dtick ' + String(dtick); // if 9's are printed on log scale, move the 10's away a bit\n\n\n  if (ax.dtick === 'D1') {\n    var firstChar = String(out.text).charAt(0);\n\n    if (firstChar === '0' || firstChar === '1') {\n      if (ax._id.charAt(0) === 'y') {\n        out.dx -= out.fontSize / 4;\n      } else {\n        out.dy += out.fontSize / 2;\n        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);\n      }\n    }\n  }\n}\n\nfunction formatCategory(ax, out) {\n  var tt = ax._categories[Math.round(out.x)];\n\n  if (tt === undefined) tt = '';\n  out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n  var v = Math.round(out.x);\n  var cats = ax._categories[v] || [];\n  var tt = cats[1] === undefined ? '' : String(cats[1]);\n  var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n  if (hover) {\n    // TODO is this what we want?\n    out.text = tt2 + ' - ' + tt;\n  } else {\n    // setup for secondary labels\n    out.text = tt;\n    out.text2 = tt2;\n  }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    hideexp = 'hide';\n  }\n\n  out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n  if (ax.thetaunit === 'radians' && !hover) {\n    var num = out.x / 180;\n\n    if (num === 0) {\n      out.text = '0';\n    } else {\n      var frac = num2frac(num);\n\n      if (frac[1] >= 100) {\n        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n      } else {\n        var isNeg = out.x < 0;\n\n        if (frac[1] === 1) {\n          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';\n        } else {\n          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');\n        }\n\n        if (isNeg) out.text = MINUS_SIGN + out.text;\n      }\n    }\n  } else {\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n  }\n} // inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\n\n\nfunction num2frac(num) {\n  function almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n  }\n\n  function findGCD(a, b) {\n    return almostEq(b, 0) ? a : findGCD(b, a % b);\n  }\n\n  function findPrecision(n) {\n    var e = 1;\n\n    while (!almostEq(Math.round(n * e) / e, n)) {\n      e *= 10;\n    }\n\n    return e;\n  }\n\n  var precision = findPrecision(num);\n  var number = num * precision;\n  var gcd = Math.abs(findGCD(number, precision));\n  return [// numerator\n  Math.round(number / gcd), // denominator\n  Math.round(precision / gcd)];\n} // format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\n\n\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n  return exponentFormat === 'SI' || exponentFormat === 'B';\n} // are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\n\n\nfunction beyondSI(exponent) {\n  return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n  var isNeg = v < 0; // max number of digits past decimal point to show\n\n  var tickRound = ax._tickround;\n  var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n  var exponent = ax._tickexponent;\n  var tickformat = axes.getTickFormat(ax);\n  var separatethousands = ax.separatethousands; // special case for hover: set exponent just for this value, and\n  // add a couple more digits of precision over tick labels\n\n  if (hover) {\n    // make a dummy axis obj to get the auto rounding and exponent\n    var ah = {\n      exponentformat: exponentFormat,\n      minexponent: ax.minexponent,\n      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,\n      // if not showing any exponents, don't change the exponent\n      // from what we calculate\n      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n    };\n    autoTickRound(ah);\n    tickRound = (Number(ah._tickround) || 0) + 4;\n    exponent = ah._tickexponent;\n    if (ax.hoverformat) tickformat = ax.hoverformat;\n  }\n\n  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN); // 'epsilon' - rounding increment\n\n  var e = Math.pow(10, -tickRound) / 2; // exponentFormat codes:\n  // 'e' (1.2e+6, default)\n  // 'E' (1.2E+6)\n  // 'SI' (1.2M)\n  // 'B' (same as SI except 10^9=B not G)\n  // 'none' (1200000)\n  // 'power' (1.2x10^6)\n  // 'hide' (1.2, use 3rd argument=='hide' to eg\n  //      only show exponent on last tick)\n\n  if (exponentFormat === 'none') exponent = 0; // take the sign out, put it back manually at the end\n  // - makes cases easier\n\n  v = Math.abs(v);\n\n  if (v < e) {\n    // 0 is just 0, but may get exponent if it's the last tick\n    v = '0';\n    isNeg = false;\n  } else {\n    v += e; // take out a common exponent, if any\n\n    if (exponent) {\n      v *= Math.pow(10, -exponent);\n      tickRound += exponent;\n    } // round the mantissa\n\n\n    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {\n      v = String(Math.round(v));\n      v = v.substr(0, v.length + tickRound);\n\n      for (var i = tickRound; i < 0; i++) v += '0';\n    } else {\n      v = String(v);\n      var dp = v.indexOf('.') + 1;\n      if (dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n    } // insert appropriate decimal point and thousands separator\n\n    v = Lib.numSeparate(v, ax._separators, separatethousands);\n  } // add exponent\n\n\n  if (exponent && exponentFormat !== 'hide') {\n    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n    var signedExponent;\n    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);\n\n    if (exponentFormat === 'e' || exponentFormat === 'E') {\n      v += exponentFormat + signedExponent;\n    } else if (exponentFormat === 'power') {\n      v += '×10<sup>' + signedExponent + '</sup>';\n    } else if (exponentFormat === 'B' && exponent === 9) {\n      v += 'B';\n    } else if (isSIFormat(exponentFormat)) {\n      v += SIPREFIXES[exponent / 3 + 5];\n    }\n  } // put sign back in and return\n  // replace standard minus character (which is technically a hyphen)\n  // with a true minus sign\n\n\n  if (isNeg) return MINUS_SIGN + v;\n  return v;\n}\n\naxes.getTickFormat = function (ax) {\n  var i;\n\n  function convertToMs(dtick) {\n    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n  }\n\n  function compareLogTicks(left, right) {\n    var priority = ['L', 'D'];\n\n    if (typeof left === typeof right) {\n      if (typeof left === 'number') {\n        return left - right;\n      } else {\n        var leftPriority = priority.indexOf(left.charAt(0));\n        var rightPriority = priority.indexOf(right.charAt(0));\n\n        if (leftPriority === rightPriority) {\n          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n        } else {\n          return leftPriority - rightPriority;\n        }\n      }\n    } else {\n      return typeof left === 'number' ? 1 : -1;\n    }\n  }\n\n  function isProperStop(dtick, range, convert) {\n    var convertFn = convert || function (x) {\n      return x;\n    };\n\n    var leftDtick = range[0];\n    var rightDtick = range[1];\n    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));\n  }\n\n  function isProperLogStop(dtick, range) {\n    var isLeftDtickNull = range[0] === null;\n    var isRightDtickNull = range[1] === null;\n    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n  }\n\n  var tickstop, stopi;\n\n  if (ax.tickformatstops && ax.tickformatstops.length > 0) {\n    switch (ax.type) {\n      case 'date':\n      case 'linear':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n\n            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n\n          break;\n        }\n\n      case 'log':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n\n            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n\n          break;\n        }\n\n      default:\n    }\n  }\n\n  return tickstop ? tickstop.value : ax.tickformat;\n}; // getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\n\n\naxes.getSubplots = function (gd, ax) {\n  var subplotObj = gd._fullLayout._subplots;\n  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n  out.sort(function (a, b) {\n    var aParts = a.substr(1).split('y');\n    var bParts = b.substr(1).split('y');\n    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n    return +aParts[0] - +bParts[0];\n  });\n  return out;\n}; // find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\n\n\naxes.findSubplotsWithAxis = function (subplots, ax) {\n  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');\n  var subplotsWithAx = [];\n\n  for (var i = 0; i < subplots.length; i++) {\n    var sp = subplots[i];\n    if (axMatch.test(sp)) subplotsWithAx.push(sp);\n  }\n\n  return subplotsWithAx;\n}; // makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\n\n\naxes.makeClipPaths = function (gd) {\n  var fullLayout = gd._fullLayout; // for more info: https://github.com/plotly/plotly.js/issues/2595\n\n  if (fullLayout._hasOnlyLargeSploms) return;\n  var fullWidth = {\n    _offset: 0,\n    _length: fullLayout.width,\n    _id: ''\n  };\n  var fullHeight = {\n    _offset: 0,\n    _length: fullLayout.height,\n    _id: ''\n  };\n  var xaList = axes.list(gd, 'x', true);\n  var yaList = axes.list(gd, 'y', true);\n  var clipList = [];\n  var i, j;\n\n  for (i = 0; i < xaList.length; i++) {\n    clipList.push({\n      x: xaList[i],\n      y: fullHeight\n    });\n\n    for (j = 0; j < yaList.length; j++) {\n      if (i === 0) clipList.push({\n        x: fullWidth,\n        y: yaList[j]\n      });\n      clipList.push({\n        x: xaList[i],\n        y: yaList[j]\n      });\n    }\n  } // selectors don't work right with camelCase tags,\n  // have to use class instead\n  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n\n\n  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {\n    return d.x._id + d.y._id;\n  });\n\n  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {\n    return 'clip' + fullLayout._uid + d.x._id + d.y._id;\n  }).append('rect');\n  axClips.exit().remove();\n  axClips.each(function (d) {\n    d3.select(this).select('rect').attr({\n      x: d.x._offset || 0,\n      y: d.y._offset || 0,\n      width: d.x._length || 1,\n      height: d.y._length || 1\n    });\n  });\n};\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\n\n\naxes.draw = function (gd, arg, opts) {\n  var fullLayout = gd._fullLayout;\n\n  if (arg === 'redraw') {\n    fullLayout._paper.selectAll('g.subplot').each(function (d) {\n      var id = d[0];\n      var plotinfo = fullLayout._plots[id];\n\n      if (plotinfo) {\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n        if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n        if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n        fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n\n        fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n      }\n    });\n  }\n\n  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;\n  return Lib.syncOrAsync(axList.map(function (axId) {\n    return function () {\n      if (!axId) return;\n      var ax = axes.getFromId(gd, axId);\n      var axDone = axes.drawOne(gd, ax, opts);\n      ax._r = ax.range.slice();\n      ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n      return axDone;\n    };\n  }));\n};\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\n\n\naxes.drawOne = function (gd, ax, opts) {\n  opts = opts || {};\n  var i, sp, plotinfo;\n  ax.setScale();\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var counterLetter = axes.counterLetter(axId);\n  var mainPlotinfo = fullLayout._plots[ax._mainSubplot]; // this happens when updating matched group with 'missing' axes\n\n  if (!mainPlotinfo) return;\n  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n  var mainLinePosition = ax._mainLinePosition;\n  var mainMirrorPosition = ax._mainMirrorPosition;\n  var vals = ax._vals = axes.calcTicks(ax); // Add a couple of axis properties that should cause us to recreate\n  // elements. Used in d3 data function.\n\n  var axInfo = [ax.mirror, mainLinePosition, mainMirrorPosition].join('_');\n\n  for (i = 0; i < vals.length; i++) {\n    vals[i].axInfo = axInfo;\n  } // stash selections to avoid DOM queries e.g.\n  // - stash tickLabels selection, so that drawTitle can use it to scoot title\n\n\n  ax._selections = {}; // stash tick angle (including the computed 'auto' values) per tick-label class\n  // linkup 'previous' tick angles on redraws\n\n  if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n  ax._tickAngles = {}; // measure [in px] between axis position and outward-most part of bounding box\n  // (touching either the tick label or ticks)\n  // depth can be expansive to compute, so we only do so when required\n\n  ax._depth = null; // calcLabelLevelBbox can be expensive,\n  // so make sure to not call it twice during the same Axes.drawOne call\n  // by stashing label-level bounding boxes per tick-label class\n\n  var llbboxes = {};\n\n  function getLabelLevelBbox(suffix) {\n    var cls = axId + (suffix || 'tick');\n    if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls);\n    return llbboxes[cls];\n  }\n\n  if (!ax.visible) return;\n  var transTickFn = axes.makeTransTickFn(ax);\n  var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n  var tickVals; // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n  // The key case here is removing zero lines when the axis bound is zero\n\n  var valsClipped;\n  var insideTicks = ax.ticks === 'inside';\n  var outsideTicks = ax.ticks === 'outside';\n\n  if (ax.tickson === 'boundaries') {\n    var boundaryVals = getBoundaryVals(ax, vals);\n    valsClipped = axes.clipEnds(ax, boundaryVals);\n    tickVals = insideTicks ? valsClipped : boundaryVals;\n  } else {\n    valsClipped = axes.clipEnds(ax, vals);\n    tickVals = insideTicks && ax.ticklabelmode !== 'period' ? valsClipped : vals;\n  }\n\n  var gridVals = ax._gridVals = valsClipped;\n  var dividerVals = getDividerVals(ax, vals);\n\n  if (!fullLayout._hasOnlyLargeSploms) {\n    var subplotsWithAx = ax._subplotsWith; // keep track of which subplots (by main counter axis) we've already\n    // drawn grids for, so we don't overdraw overlaying subplots\n\n    var finishedGrids = {};\n\n    for (i = 0; i < subplotsWithAx.length; i++) {\n      sp = subplotsWithAx[i];\n      plotinfo = fullLayout._plots[sp];\n      var counterAxis = plotinfo[counterLetter + 'axis'];\n      var mainCounterID = counterAxis._mainAxis._id;\n      if (finishedGrids[mainCounterID]) continue;\n      finishedGrids[mainCounterID] = 1;\n      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;\n      axes.drawGrid(gd, ax, {\n        vals: gridVals,\n        counterAxis: counterAxis,\n        layer: plotinfo.gridlayer.select('.' + axId),\n        path: gridPath,\n        transFn: transTickFn\n      });\n      axes.drawZeroLine(gd, ax, {\n        counterAxis: counterAxis,\n        layer: plotinfo.zerolinelayer,\n        path: gridPath,\n        transFn: transTickFn\n      });\n    }\n  }\n\n  var tickSigns = axes.getTickSigns(ax);\n  var tickSubplots = [];\n\n  if (ax.ticks) {\n    var mainTickPath = axes.makeTickPath(ax, mainLinePosition, tickSigns[2]);\n    var mirrorTickPath;\n    var fullTickPath;\n\n    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n      mirrorTickPath = axes.makeTickPath(ax, mainMirrorPosition, tickSigns[3]);\n      fullTickPath = mainTickPath + mirrorTickPath;\n    } else {\n      mirrorTickPath = '';\n      fullTickPath = mainTickPath;\n    }\n\n    var tickPath;\n\n    if (ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n      var dividerLookup = {};\n\n      for (i = 0; i < dividerVals.length; i++) {\n        dividerLookup[dividerVals[i].x] = 1;\n      }\n\n      tickPath = function (d) {\n        return dividerLookup[d.x] ? mirrorTickPath : fullTickPath;\n      };\n    } else {\n      tickPath = fullTickPath;\n    }\n\n    axes.drawTicks(gd, ax, {\n      vals: tickVals,\n      layer: mainAxLayer,\n      path: tickPath,\n      transFn: transTickFn\n    });\n\n    if (ax.mirror === 'allticks') {\n      tickSubplots = Object.keys(ax._linepositions || {});\n    }\n  }\n\n  for (i = 0; i < tickSubplots.length; i++) {\n    sp = tickSubplots[i];\n    plotinfo = fullLayout._plots[sp]; // [bottom or left, top or right], free and main are handled above\n\n    var linepositions = ax._linepositions[sp] || [];\n    var spTickPath = axes.makeTickPath(ax, linepositions[0], tickSigns[0]) + axes.makeTickPath(ax, linepositions[1], tickSigns[1]);\n    axes.drawTicks(gd, ax, {\n      vals: tickVals,\n      layer: plotinfo[axLetter + 'axislayer'],\n      path: spTickPath,\n      transFn: transTickFn\n    });\n  }\n\n  var seq = []; // tick labels - for now just the main labels.\n  // TODO: mirror labels, esp for subplots\n\n  seq.push(function () {\n    return axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: mainAxLayer,\n      plotinfo: plotinfo,\n      transFn: transTickLabelFn,\n      labelFns: axes.makeLabelFns(ax, mainLinePosition)\n    });\n  });\n\n  if (ax.type === 'multicategory') {\n    var pad = {\n      x: 2,\n      y: 10\n    }[axLetter];\n    seq.push(function () {\n      var bboxKey = {\n        x: 'height',\n        y: 'width'\n      }[axLetter];\n      var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n      return axes.drawLabels(gd, ax, {\n        vals: getSecondaryLabelVals(ax, vals),\n        layer: mainAxLayer,\n        cls: axId + 'tick2',\n        repositionOnUpdate: true,\n        secondary: true,\n        transFn: transTickFn,\n        labelFns: axes.makeLabelFns(ax, mainLinePosition + standoff * tickSigns[4])\n      });\n    });\n    seq.push(function () {\n      ax._depth = tickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePosition);\n      return drawDividers(gd, ax, {\n        vals: dividerVals,\n        layer: mainAxLayer,\n        path: axes.makeTickPath(ax, mainLinePosition, tickSigns[4], ax._depth),\n        transFn: transTickFn\n      });\n    });\n  } else if (ax.title.hasOwnProperty('standoff')) {\n    seq.push(function () {\n      ax._depth = tickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePosition);\n    });\n  }\n\n  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n  seq.push(function () {\n    var s = ax.side.charAt(0);\n    var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n    var pos = axes.getPxPosition(gd, ax);\n    var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n    var llbbox;\n    var push;\n    var mirrorPush;\n    var rangeSliderPush;\n\n    if (ax.automargin || hasRangeSlider) {\n      if (ax.type === 'multicategory') {\n        llbbox = getLabelLevelBbox('tick2');\n      } else {\n        llbbox = getLabelLevelBbox();\n\n        if (axLetter === 'x' && s === 'b') {\n          ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n        }\n      }\n    }\n\n    if (ax.automargin) {\n      push = {\n        x: 0,\n        y: 0,\n        r: 0,\n        l: 0,\n        t: 0,\n        b: 0\n      };\n      var domainIndices = [0, 1];\n\n      if (axLetter === 'x') {\n        if (s === 'b') {\n          push[s] = ax._depth;\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n\n        if (llbbox.width > 0) {\n          var rExtra = llbbox.right - (ax._offset + ax._length);\n\n          if (rExtra > 0) {\n            push.xr = 1;\n            push.r = rExtra;\n          }\n\n          var lExtra = ax._offset - llbbox.left;\n\n          if (lExtra > 0) {\n            push.xl = 0;\n            push.l = lExtra;\n          }\n        }\n      } else {\n        if (s === 'l') {\n          push[s] = ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n\n        if (llbbox.height > 0) {\n          var bExtra = llbbox.bottom - (ax._offset + ax._length);\n\n          if (bExtra > 0) {\n            push.yb = 0;\n            push.b = bExtra;\n          }\n\n          var tExtra = ax._offset - llbbox.top;\n\n          if (tExtra > 0) {\n            push.yt = 1;\n            push.t = tExtra;\n          }\n        }\n      }\n\n      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[domainIndices[0]];\n\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n      }\n\n      if (ax.mirror && ax.anchor !== 'free') {\n        mirrorPush = {\n          x: 0,\n          y: 0,\n          r: 0,\n          l: 0,\n          t: 0,\n          b: 0\n        };\n        mirrorPush[sMirror] = ax.linewidth;\n        if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n\n        if (ax.mirror === true || ax.mirror === 'ticks') {\n          mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n        } else if (ax.mirror === 'all' || ax.mirror === 'allticks') {\n          mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n        }\n      }\n    }\n\n    if (hasRangeSlider) {\n      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n    }\n\n    Plots.autoMargin(gd, axAutoMarginID(ax), push);\n    Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n  });\n\n  if (!opts.skipTitle && !(hasRangeSlider && ax.side === 'bottom')) {\n    seq.push(function () {\n      return drawTitle(gd, ax);\n    });\n  }\n\n  return Lib.syncOrAsync(seq);\n};\n\nfunction getBoundaryVals(ax, vals) {\n  var out = [];\n  var i; // boundaryVals are never used for labels;\n  // no need to worry about the other tickTextObj keys\n\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n\n  if (vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      _push(vals[i], 0);\n    }\n\n    _push(vals[i - 1], 1);\n  }\n\n  return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n  var out = [];\n  var lookup = {};\n\n  for (var i = 0; i < vals.length; i++) {\n    var d = vals[i];\n\n    if (lookup[d.text2]) {\n      lookup[d.text2].push(d.x);\n    } else {\n      lookup[d.text2] = [d.x];\n    }\n  }\n\n  for (var k in lookup) {\n    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n  }\n\n  return out;\n}\n\nfunction getDividerVals(ax, vals) {\n  var out = [];\n  var i, current;\n  var reversed = vals.length && vals[vals.length - 1].x < vals[0].x; // never used for labels;\n  // no need to worry about the other tickTextObj keys\n\n  var _push = function (d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n\n  if (ax.showdividers && vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      var d = vals[i];\n\n      if (d.text2 !== current) {\n        _push(d, reversed ? 1 : 0);\n      }\n\n      current = d.text2;\n    }\n\n    _push(vals[i - 1], reversed ? 0 : 1);\n  }\n\n  return out;\n}\n\nfunction calcLabelLevelBbox(ax, cls) {\n  var top, bottom;\n  var left, right;\n\n  if (ax._selections[cls].size()) {\n    top = Infinity;\n    bottom = -Infinity;\n    left = Infinity;\n    right = -Infinity;\n\n    ax._selections[cls].each(function () {\n      var thisLabel = selectTickLabel(this); // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n      // retrieve a bbox computed with transform info\n      //\n      // To improve perf, it would be nice to use `thisLabel.node()`\n      // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n      // together with the makeLabelFns outputs and `tickangle`\n      // to compute one bbox per (tick value x tick style)\n\n      var bb = Drawing.bBox(thisLabel.node().parentNode);\n      top = Math.min(top, bb.top);\n      bottom = Math.max(bottom, bb.bottom);\n      left = Math.min(left, bb.left);\n      right = Math.max(right, bb.right);\n    });\n  } else {\n    top = 0;\n    bottom = 0;\n    left = 0;\n    right = 0;\n  }\n\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    height: bottom - top,\n    width: right - left\n  };\n}\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\n\n\naxes.getTickSigns = function (ax) {\n  var axLetter = ax._id.charAt(0);\n\n  var sideOpposite = {\n    x: 'top',\n    y: 'right'\n  }[axLetter];\n  var main = ax.side === sideOpposite ? 1 : -1;\n  var out = [-1, 1, main, -main]; // then we flip if outside XOR y axis\n\n  if (ax.ticks !== 'inside' === (axLetter === 'x')) {\n    out = out.map(function (v) {\n      return -v;\n    });\n  } // independent of `ticks`; do not flip this one\n\n\n  if (ax.side) {\n    out.push({\n      l: -1,\n      t: -1,\n      r: 1,\n      b: 1\n    }[ax.side.charAt(0)]);\n  }\n\n  return out;\n};\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\n\n\naxes.makeTransTickFn = function (ax) {\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(ax._offset + ax.l2p(d.x), 0);\n  } : function (d) {\n    return strTranslate(0, ax._offset + ax.l2p(d.x));\n  };\n};\n\naxes.makeTransTickLabelFn = function (ax) {\n  var uv = getTickLabelUV(ax);\n  var u = uv[0];\n  var v = uv[1];\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(u + ax._offset + ax.l2p(getPosX(d)), v);\n  } : function (d) {\n    return strTranslate(v, u + ax._offset + ax.l2p(getPosX(d)));\n  };\n};\n\nfunction getPosX(d) {\n  return d.periodX !== undefined ? d.periodX : d.x;\n} // u is a shift along the axis,\n// v is a shift perpendicular to the axis\n\n\nfunction getTickLabelUV(ax) {\n  var ticklabelposition = ax.ticklabelposition || '';\n\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isInside = has('inside');\n  var isAligned = isBottom || isLeft || isTop || isRight; // early return\n\n  if (!isAligned && !isInside) return [0, 0];\n  var side = ax.side;\n  var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n  var v = TEXTPAD;\n  var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n\n  if (isBottom || isTop) {\n    u += fontSize * CAP_SHIFT;\n    v += (ax.linewidth || 0) / 2;\n  }\n\n  if (isLeft || isRight) {\n    u += (ax.linewidth || 0) / 2;\n    v += TEXTPAD;\n  }\n\n  if (isInside && side === 'top') {\n    v -= fontSize * (1 - CAP_SHIFT);\n  }\n\n  if (isLeft || isTop) u = -u;\n  if (side === 'bottom' || side === 'right') v = -v;\n  return [isAligned ? u : 0, isInside ? v : 0];\n}\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {number (optional)} len tick length\n * @return {string}\n */\n\n\naxes.makeTickPath = function (ax, shift, sgn, len) {\n  len = len !== undefined ? len : ax.ticklen;\n\n  var axLetter = ax._id.charAt(0);\n\n  var pad = (ax.linewidth || 1) / 2;\n  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;\n};\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\n\n\naxes.makeLabelFns = function (ax, shift, angle) {\n  var ticklabelposition = ax.ticklabelposition || '';\n\n  var has = function (str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n  var insideTickLabels = has('inside');\n  var labelsOverTicks = ticklabelposition === 'inside' && ax.ticks === 'inside' || !insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries';\n  var labelStandoff = 0;\n  var labelShift = 0;\n  var tickLen = labelsOverTicks ? ax.ticklen : 0;\n\n  if (insideTickLabels) {\n    tickLen *= -1;\n  } else if (isAligned) {\n    tickLen = 0;\n  }\n\n  if (labelsOverTicks) {\n    labelStandoff += tickLen;\n\n    if (angle) {\n      var rad = Lib.deg2rad(angle);\n      labelStandoff = tickLen * Math.cos(rad) + 1;\n      labelShift = tickLen * Math.sin(rad);\n    }\n  }\n\n  if (ax.showticklabels && (labelsOverTicks || ax.showline)) {\n    labelStandoff += 0.2 * ax.tickfont.size;\n  }\n\n  labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n  var out = {\n    labelStandoff: labelStandoff,\n    labelShift: labelShift\n  };\n  var x0, y0, ff, flipIt;\n  var xQ = 0;\n  var side = ax.side;\n\n  var axLetter = ax._id.charAt(0);\n\n  var tickangle = ax.tickangle;\n  var endSide;\n\n  if (axLetter === 'x') {\n    endSide = !insideTickLabels && side === 'bottom' || insideTickLabels && side === 'top';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelShift * flipIt;\n    y0 = shift + labelStandoff * flipIt;\n    ff = endSide ? 1 : -0.2;\n\n    if (Math.abs(tickangle) === 90) {\n      if (insideTickLabels) {\n        ff += MID_SHIFT;\n      } else {\n        if (tickangle === -90 && side === 'bottom') {\n          ff = CAP_SHIFT;\n        } else if (tickangle === 90 && side === 'top') {\n          ff = MID_SHIFT;\n        } else {\n          ff = 0.5;\n        }\n      }\n\n      xQ = MID_SHIFT / 2 * (tickangle / 90);\n    }\n\n    out.xFn = function (d) {\n      return d.dx + x0 + xQ * d.fontSize;\n    };\n\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * ff;\n    };\n\n    out.anchorFn = function (d, a) {\n      if (isAligned) {\n        if (isLeft) return 'end';\n        if (isRight) return 'start';\n      }\n\n      if (!isNumeric(a) || a === 0 || a === 180) {\n        return 'middle';\n      }\n\n      return a * flipIt < 0 !== insideTickLabels ? 'end' : 'start';\n    };\n\n    out.heightFn = function (d, a, h) {\n      return a < -60 || a > 60 ? -0.5 * h : ax.side === 'top' !== insideTickLabels ? -h : 0;\n    };\n  } else if (axLetter === 'y') {\n    endSide = !insideTickLabels && side === 'left' || insideTickLabels && side === 'right';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelStandoff;\n    y0 = labelShift * flipIt;\n    ff = 0;\n\n    if (!insideTickLabels && Math.abs(tickangle) === 90) {\n      if (tickangle === -90 && side === 'left' || tickangle === 90 && side === 'right') {\n        ff = CAP_SHIFT;\n      } else {\n        ff = 0.5;\n      }\n    }\n\n    if (insideTickLabels) {\n      var ang = isNumeric(tickangle) ? +tickangle : 0;\n\n      if (ang !== 0) {\n        var rA = Lib.deg2rad(ang);\n        xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n        ff = 0;\n      }\n    }\n\n    out.xFn = function (d) {\n      return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;\n    };\n\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * MID_SHIFT;\n    };\n\n    out.anchorFn = function (d, a) {\n      if (isNumeric(a) && Math.abs(a) === 90) {\n        return 'middle';\n      }\n\n      return endSide ? 'end' : 'start';\n    };\n\n    out.heightFn = function (d, a, h) {\n      if (ax.side === 'right') a *= -1;\n      return a < -30 ? -h : a < 30 ? -0.5 * h : 0;\n    };\n  }\n\n  return out;\n};\n\nfunction tickDataFn(d) {\n  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawTicks = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'tick';\n  var vals = opts.vals;\n\n  if (ax.ticklabelmode === 'period') {\n    // drop very first tick that we added to handle period\n    vals = vals.slice();\n    vals.shift();\n  }\n\n  var ticks = opts.layer.selectAll('path.' + cls).data(ax.ticks ? vals : [], tickDataFn);\n  ticks.exit().remove();\n  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).call(Color.stroke, ax.tickcolor).style('stroke-width', Drawing.crispRound(gd, ax.tickwidth, 1) + 'px').attr('d', opts.path).style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n  ticks.attr('transform', opts.transFn);\n};\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawGrid = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'grid';\n  var vals = opts.vals;\n  var counterAx = opts.counterAxis;\n\n  if (ax.showgrid === false) {\n    vals = [];\n  } else if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n    var isArrayMode = ax.tickmode === 'array';\n\n    for (var i = 0; i < vals.length; i++) {\n      var xi = vals[i].x;\n\n      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {\n        vals = vals.slice(0, i).concat(vals.slice(i + 1)); // In array mode you can in principle have multiple\n        // ticks at 0, so test them all. Otherwise once we found\n        // one we can stop.\n\n        if (isArrayMode) i--;else break;\n      }\n    }\n  }\n\n  var grid = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  grid.exit().remove();\n  grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);\n  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n  grid.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.gridcolor || '#ddd').style('stroke-width', ax._gw + 'px').style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [GRID_PATH]);\n  if (typeof opts.path === 'function') grid.attr('d', opts.path);\n};\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawZeroLine = function (gd, ax, opts) {\n  opts = opts || opts;\n  var cls = ax._id + 'zl';\n  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{\n    x: 0,\n    id: ax._id\n  }] : []);\n  zl.exit().remove();\n  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {\n    // use the fact that only one element can enter to trigger a sort.\n    // If several zerolines enter at the same time we will sort once per,\n    // but generally this should be a minimal overhead.\n    opts.layer.selectAll('path').sort(function (da, db) {\n      return idSort(da.id, db.id);\n    });\n  });\n  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px').style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\n\n\naxes.drawLabels = function (gd, ax, opts) {\n  opts = opts || {};\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var cls = opts.cls || axId + 'tick';\n  var vals = opts.vals;\n  var labelFns = opts.labelFns;\n  var tickAngle = opts.secondary ? 0 : ax.tickangle;\n  var prevAngle = (ax._prevTickAngles || {})[cls];\n  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);\n  var labelsReady = [];\n  tickLabels.enter().append('g').classed(cls, 1).append('text') // only so tex has predictable alignment that we can\n  // alter later\n  .attr('text-anchor', 'middle').each(function (d) {\n    var thisLabel = d3.select(this);\n    var newPromise = gd._promises.length;\n    thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, d.font, d.fontSize, d.fontColor).text(d.text).call(svgTextUtils.convertToTspans, gd);\n\n    if (gd._promises[newPromise]) {\n      // if we have an async label, we'll deal with that\n      // all here so take it out of gd._promises and\n      // instead position the label and promise this in\n      // labelsReady\n      labelsReady.push(gd._promises.pop().then(function () {\n        positionLabels(thisLabel, tickAngle);\n      }));\n    } else {\n      // sync label: just position it now.\n      positionLabels(thisLabel, tickAngle);\n    }\n  });\n  hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n  tickLabels.exit().remove();\n\n  if (opts.repositionOnUpdate) {\n    tickLabels.each(function (d) {\n      d3.select(this).select('text').call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n    });\n  }\n\n  function positionLabels(s, angle) {\n    s.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      var anchor = labelFns.anchorFn(d, angle);\n      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelFns.xFn(d) + ',' + (labelFns.yFn(d) - d.fontSize / 2) + ')' : ''); // how much to shift a multi-line label to center it vertically.\n\n      var nLines = svgTextUtils.lineCount(thisLabel);\n      var lineHeight = LINE_SPACING * d.fontSize;\n      var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n\n      if (anchorHeight) {\n        transform += strTranslate(0, anchorHeight);\n      }\n\n      if (mathjaxGroup.empty()) {\n        var thisText = thisLabel.select('text');\n        thisText.attr({\n          transform: transform,\n          'text-anchor': anchor\n        });\n        thisText.style('opacity', 1); // visible\n\n        if (ax._adjustTickLabelsOverflow) {\n          ax._adjustTickLabelsOverflow();\n        }\n      } else {\n        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n        var mjShift = mjWidth * {\n          end: -0.5,\n          start: 0.5\n        }[anchor];\n        mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n      }\n    });\n  }\n\n  ax._adjustTickLabelsOverflow = function () {\n    var ticklabeloverflow = ax.ticklabeloverflow;\n    if (!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n    var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n    var isX = ax._id.charAt(0) === 'x'; // div positions\n\n    var p0 = 0;\n    var p1 = isX ? gd._fullLayout.width : gd._fullLayout.height;\n\n    if (ticklabeloverflow.indexOf('domain') !== -1) {\n      // domain positions\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      p0 = ax.l2p(rl[0]) + ax._offset;\n      p1 = ax.l2p(rl[1]) + ax._offset;\n    }\n\n    var min = Math.min(p0, p1);\n    var max = Math.max(p0, p1);\n    var side = ax.side;\n    var visibleLabelMin = Infinity;\n    var visibleLabelMax = -Infinity;\n    tickLabels.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n\n      if (mathjaxGroup.empty()) {\n        var bb = Drawing.bBox(thisLabel.node());\n        var adjust = 0;\n\n        if (isX) {\n          if (bb.right > max) adjust = 1;else if (bb.left < min) adjust = 1;\n        } else {\n          if (bb.bottom > max) adjust = 1;else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n        }\n\n        var t = thisLabel.select('text');\n\n        if (adjust) {\n          if (hideOverflow) t.style('opacity', 0); // hidden\n        } else {\n          t.style('opacity', 1); // visible\n\n          if (side === 'bottom' || side === 'right') {\n            visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n          } else {\n            visibleLabelMin = -Infinity;\n          }\n\n          if (side === 'top' || side === 'left') {\n            visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n          } else {\n            visibleLabelMax = Infinity;\n          }\n        }\n      } // TODO: hide mathjax?\n\n    });\n\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n\n      if (anchorAx) {\n        anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n        anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n      }\n    }\n  };\n\n  ax._hideCounterAxisInsideTickLabels = function (partialOpts) {\n    var isX = ax._id.charAt(0) === 'x';\n    var anchoredAxes = [];\n\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n    }\n\n    anchoredAxes.forEach(function (anchorAx, idx) {\n      if (anchorAx && insideTicklabelposition(anchorAx)) {\n        (partialOpts || [ZERO_PATH, GRID_PATH, TICK_PATH, TICK_TEXT]).forEach(function (e) {\n          var isPeriodLabel = e.K === 'tick' && e.L === 'text' && ax.ticklabelmode === 'period';\n          var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n          var sel;\n          if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n          sel.each(function () {\n            var w = d3.select(this);\n            if (e.L) w = w.selectAll(e.L);\n            w.each(function (d) {\n              var q = ax.l2p(isPeriodLabel ? getPosX(d) : d.x) + ax._offset;\n\n              var t = d3.select(this);\n\n              if (q < ax['_visibleLabelMax_' + anchorAx._id] && q > ax['_visibleLabelMin_' + anchorAx._id]) {\n                t.style('display', 'none'); // hidden\n              } else if (e.K === 'tick' && !idx) {\n                t.style('display', null); // visible\n              }\n            });\n          });\n        });\n      }\n    });\n  }; // make sure all labels are correctly positioned at their base angle\n  // the positionLabels call above is only for newly drawn labels.\n  // do this without waiting, using the last calculated angle to\n  // minimize flicker, then do it again when we know all labels are\n  // there, putting back the prescribed angle to check for overlaps.\n\n\n  positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);\n\n  function allLabelsReady() {\n    return labelsReady.length && Promise.all(labelsReady);\n  }\n\n  var autoangle = null;\n\n  function fixLabelOverlaps() {\n    positionLabels(tickLabels, tickAngle); // check for auto-angling if x labels overlap\n    // don't auto-angle at all for log axes with\n    // base and digit format\n\n    if (vals.length && axLetter === 'x' && !isNumeric(tickAngle) && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n      autoangle = 0;\n      var maxFontSize = 0;\n      var lbbArray = [];\n      var i;\n      tickLabels.each(function (d) {\n        maxFontSize = Math.max(maxFontSize, d.fontSize);\n        var x = ax.l2p(d.x);\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        lbbArray.push({\n          // ignore about y, just deal with x overlaps\n          top: 0,\n          bottom: 10,\n          height: 10,\n          left: x - bb.width / 2,\n          // impose a 2px gap\n          right: x + bb.width / 2 + 2,\n          width: bb.width + 2\n        });\n      });\n\n      if ((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n        var gap = 2;\n        if (ax.ticks) gap += ax.tickwidth / 2; // TODO should secondary labels also fall into this fix-overlap regime?\n\n        for (i = 0; i < lbbArray.length; i++) {\n          var xbnd = vals[i].xbnd;\n          var lbb = lbbArray[i];\n\n          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {\n            autoangle = 90;\n            break;\n          }\n        }\n      } else {\n        var vLen = vals.length;\n        var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n        var ticklabelposition = ax.ticklabelposition || '';\n\n        var has = function (str) {\n          return ticklabelposition.indexOf(str) !== -1;\n        };\n\n        var isTop = has('top');\n        var isLeft = has('left');\n        var isRight = has('right');\n        var isBottom = has('bottom');\n        var isAligned = isBottom || isLeft || isTop || isRight;\n        var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;\n        var rotate90 = tickSpacing < maxFontSize * 2.5 || ax.type === 'multicategory'; // any overlap at all - set 30 degrees or 90 degrees\n\n        for (i = 0; i < lbbArray.length - 1; i++) {\n          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n            autoangle = rotate90 ? 90 : 30;\n            break;\n          }\n        }\n      }\n\n      if (autoangle) {\n        positionLabels(tickLabels, autoangle);\n      }\n    }\n  }\n\n  if (ax._selections) {\n    ax._selections[cls] = tickLabels;\n  }\n\n  var seq = [allLabelsReady]; // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n  // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n  // as this can lead to infinite redraw loops!\n\n  if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n    autoangle = 90;\n    seq.push(function () {\n      positionLabels(tickLabels, prevAngle);\n    });\n  } else {\n    seq.push(fixLabelOverlaps);\n  } // save current tick angle for future redraws\n\n\n  if (ax._tickAngles) {\n    seq.push(function () {\n      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;\n    });\n  }\n\n  var anchorAx = ax._anchorAxis;\n\n  if (anchorAx && anchorAx.autorange && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {\n    if (!fullLayout._insideTickLabelsAutorange) {\n      fullLayout._insideTickLabelsAutorange = {};\n    }\n\n    fullLayout._insideTickLabelsAutorange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n    seq.push(function computeFinalTickLabelBoundingBoxes() {\n      tickLabels.each(function (d, i) {\n        var thisLabel = selectTickLabel(this);\n        var mathjaxGroup = thisLabel.select('.text-math-group');\n\n        if (mathjaxGroup.empty()) {\n          ax._vals[i].bb = Drawing.bBox(thisLabel.node());\n        }\n      });\n    });\n  }\n\n  var done = Lib.syncOrAsync(seq);\n  if (done && done.then) gd._promises.push(done);\n  return done;\n};\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\n\n\nfunction drawDividers(gd, ax, opts) {\n  var cls = ax._id + 'divider';\n  var vals = opts.vals;\n  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  dividers.exit().remove();\n  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n  dividers.attr('transform', opts.transFn).attr('d', opts.path);\n}\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\n\n\naxes.getPxPosition = function (gd, ax) {\n  var gs = gd._fullLayout._size;\n\n  var axLetter = ax._id.charAt(0);\n\n  var side = ax.side;\n  var anchorAxis;\n\n  if (ax.anchor !== 'free') {\n    anchorAxis = ax._anchorAxis;\n  } else if (axLetter === 'x') {\n    anchorAxis = {\n      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n      _length: 0\n    };\n  } else if (axLetter === 'y') {\n    anchorAxis = {\n      _offset: gs.l + (ax.position || 0) * gs.w,\n      _length: 0\n    };\n  }\n\n  if (side === 'top' || side === 'left') {\n    return anchorAxis._offset;\n  } else if (side === 'bottom' || side === 'right') {\n    return anchorAxis._offset + anchorAxis._length;\n  }\n};\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\n\n\nfunction approxTitleDepth(ax) {\n  var fontSize = ax.title.font.size;\n  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n\n  if (ax.title.hasOwnProperty('standoff')) {\n    return extraLines ? fontSize * (CAP_SHIFT + extraLines * LINE_SPACING) : fontSize * CAP_SHIFT;\n  } else {\n    return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;\n  }\n}\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\n\n\nfunction drawTitle(gd, ax) {\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var fontSize = ax.title.font.size;\n  var titleStandoff;\n\n  if (ax.title.hasOwnProperty('standoff')) {\n    titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);\n  } else {\n    var isInside = insideTicklabelposition(ax);\n\n    if (ax.type === 'multicategory') {\n      titleStandoff = ax._depth;\n    } else {\n      var offsetBase = 1.5 * fontSize;\n\n      if (isInside) {\n        offsetBase = 0.5 * fontSize;\n\n        if (ax.ticks === 'outside') {\n          offsetBase += ax.ticklen;\n        }\n      }\n\n      titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n    }\n\n    if (!isInside) {\n      if (axLetter === 'x') {\n        titleStandoff += ax.side === 'top' ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);\n      } else {\n        titleStandoff += ax.side === 'right' ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);\n      }\n    }\n  }\n\n  var pos = axes.getPxPosition(gd, ax);\n  var transform, x, y;\n\n  if (axLetter === 'x') {\n    x = ax._offset + ax._length / 2;\n    y = ax.side === 'top' ? pos - titleStandoff : pos + titleStandoff;\n  } else {\n    y = ax._offset + ax._length / 2;\n    x = ax.side === 'right' ? pos + titleStandoff : pos - titleStandoff;\n    transform = {\n      rotate: '-90',\n      offset: 0\n    };\n  }\n\n  var avoid;\n\n  if (ax.type !== 'multicategory') {\n    var tickLabels = ax._selections[ax._id + 'tick'];\n    avoid = {\n      selection: tickLabels,\n      side: ax.side\n    };\n\n    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n      var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n      avoid.offsetLeft = translation.x;\n      avoid.offsetTop = translation.y;\n    }\n\n    if (ax.title.hasOwnProperty('standoff')) {\n      avoid.pad = 0;\n    }\n  }\n\n  return Titles.draw(gd, axId + 'title', {\n    propContainer: ax,\n    propName: ax._name + '.title.text',\n    placeholder: fullLayout._dfltTitle[axLetter],\n    avoid: avoid,\n    transform: transform,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    }\n  });\n}\n\naxes.shouldShowZeroLine = function (gd, ax, counterAxis) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));\n};\n\naxes.clipEnds = function (ax, vals) {\n  return vals.filter(function (d) {\n    return clipEnds(ax, d.x);\n  });\n};\n\nfunction clipEnds(ax, l) {\n  var p = ax.l2p(l);\n  return p > 1 && p < ax._length - 1;\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n  var mainCounterAxis = counterAxis._mainAxis;\n  if (!mainCounterAxis) return;\n  var fullLayout = gd._fullLayout;\n\n  var axLetter = ax._id.charAt(0);\n\n  var counterLetter = axes.counterLetter(ax._id);\n  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);\n\n  function lineNearZero(ax2) {\n    if (!ax2.showline || !ax2.linewidth) return false;\n    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n    function closeEnough(pos2) {\n      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n    }\n\n    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n      return true;\n    }\n\n    var linePositions = ax2._linepositions || {};\n\n    for (var k in linePositions) {\n      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n        return true;\n      }\n    }\n  }\n\n  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n\n  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n    return lineNearZero(counterAxis, zeroPosition);\n  }\n\n  var counterLetterAxes = axes.list(gd, counterLetter);\n\n  for (var i = 0; i < counterLetterAxes.length; i++) {\n    var counterAxis2 = counterLetterAxes[i];\n\n    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {\n      return true;\n    }\n  }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n  var fullData = gd._fullData;\n  var subplot = ax._mainSubplot;\n\n  var axLetter = ax._id.charAt(0);\n\n  for (var i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n\n    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {\n      if (Registry.traceIs(trace, 'bar-like') && trace.orientation === {\n        x: 'h',\n        y: 'v'\n      }[axLetter]) return true;\n      if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;\n    }\n  }\n\n  return false;\n}\n\nfunction selectTickLabel(gTick) {\n  var s = d3.select(gTick);\n  var mj = s.select('.text-math-group');\n  return mj.empty() ? s.select('text') : mj;\n}\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\n\n\naxes.allowAutoMargin = function (gd) {\n  var axList = axes.list(gd, '', true);\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n\n    if (ax.automargin) {\n      Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n\n      if (ax.mirror) {\n        Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n      }\n    }\n\n    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n    }\n  }\n};\n\nfunction axAutoMarginID(ax) {\n  return ax._id + '.automargin';\n}\n\nfunction axMirrorAutoMarginID(ax) {\n  return axAutoMarginID(ax) + '.mirror';\n}\n\nfunction rangeSliderAutoMarginID(ax) {\n  return ax._id + '.rangeslider';\n} // swap all the presentation attributes of the axes showing these traces\n\n\naxes.swap = function (gd, traces) {\n  var axGroups = makeAxisGroups(gd, traces);\n\n  for (var i = 0; i < axGroups.length; i++) {\n    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n  }\n};\n\nfunction makeAxisGroups(gd, traces) {\n  var groups = [];\n  var i, j;\n\n  for (i = 0; i < traces.length; i++) {\n    var groupsi = [];\n    var xi = gd._fullData[traces[i]].xaxis;\n    var yi = gd._fullData[traces[i]].yaxis;\n    if (!xi || !yi) continue; // not a 2D cartesian trace?\n\n    for (j = 0; j < groups.length; j++) {\n      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n        groupsi.push(j);\n      }\n    }\n\n    if (!groupsi.length) {\n      groups.push({\n        x: [xi],\n        y: [yi]\n      });\n      continue;\n    }\n\n    var group0 = groups[groupsi[0]];\n    var groupj;\n\n    if (groupsi.length > 1) {\n      for (j = 1; j < groupsi.length; j++) {\n        groupj = groups[groupsi[j]];\n        mergeAxisGroups(group0.x, groupj.x);\n        mergeAxisGroups(group0.y, groupj.y);\n      }\n    }\n\n    mergeAxisGroups(group0.x, [xi]);\n    mergeAxisGroups(group0.y, [yi]);\n  }\n\n  return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n  for (var i = 0; i < fromSet.length; i++) {\n    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n  }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n  var xFullAxes = [];\n  var yFullAxes = [];\n  var layout = gd.layout;\n  var i, j;\n\n  for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n\n  for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n  var allAxKeys = Object.keys(axAttrs);\n  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];\n  var numericTypes = ['linear', 'log'];\n\n  for (i = 0; i < allAxKeys.length; i++) {\n    var keyi = allAxKeys[i];\n    var xVal = xFullAxes[0][keyi];\n    var yVal = yFullAxes[0][keyi];\n    var allEqual = true;\n    var coerceLinearX = false;\n    var coerceLinearY = false;\n\n    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {\n      continue;\n    }\n\n    for (j = 1; j < xFullAxes.length && allEqual; j++) {\n      var xVali = xFullAxes[j][keyi];\n\n      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearX = true;\n      } else if (xVali !== xVal) allEqual = false;\n    }\n\n    for (j = 1; j < yFullAxes.length && allEqual; j++) {\n      var yVali = yFullAxes[j][keyi];\n\n      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearY = true;\n      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;\n    }\n\n    if (allEqual) {\n      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n    }\n  } // now swap x&y for any annotations anchored to these x & y\n\n\n  for (i = 0; i < gd._fullLayout.annotations.length; i++) {\n    var ann = gd._fullLayout.annotations[i];\n\n    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {\n      Lib.swapAttrs(layout.annotations[i], ['?']);\n    }\n  }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n  // in case the value is the default for either axis,\n  // look at the first axis in each list and see if\n  // this key's value is undefined\n  var np = Lib.nestedProperty;\n  var xVal = np(layout[xFullAxes[0]._name], key).get();\n  var yVal = np(layout[yFullAxes[0]._name], key).get();\n  var i;\n\n  if (key === 'title') {\n    // special handling of placeholder titles\n    if (xVal && xVal.text === dfltTitle.x) {\n      xVal.text = dfltTitle.y;\n    }\n\n    if (yVal && yVal.text === dfltTitle.y) {\n      yVal.text = dfltTitle.x;\n    }\n  }\n\n  for (i = 0; i < xFullAxes.length; i++) {\n    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n  }\n\n  for (i = 0; i < yFullAxes.length; i++) {\n    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n  }\n}\n\nfunction isAngular(ax) {\n  return ax._id === 'angularaxis';\n}\n\nfunction moveOutsideBreak(v, ax) {\n  var len = ax._rangebreaks.length;\n\n  for (var k = 0; k < len; k++) {\n    var brk = ax._rangebreaks[k];\n\n    if (v >= brk.min && v < brk.max) {\n      return brk.max;\n    }\n  }\n\n  return v;\n}\n\nfunction insideTicklabelposition(ax) {\n  return (ax.ticklabelposition || '').indexOf('inside') !== -1;\n}\n\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n  if (insideTicklabelposition(ax._anchorAxis || {})) {\n    if (ax._hideCounterAxisInsideTickLabels) {\n      ax._hideCounterAxisInsideTickLabels(opts);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/axes.js"],"names":["d3","require","isNumeric","Plots","Registry","Lib","strTranslate","svgTextUtils","Titles","Color","Drawing","axAttrs","cleanTicks","constants","ONEMAXYEAR","ONEAVGYEAR","ONEMINYEAR","ONEMAXQUARTER","ONEAVGQUARTER","ONEMINQUARTER","ONEMAXMONTH","ONEAVGMONTH","ONEMINMONTH","ONEWEEK","ONEDAY","HALFDAY","ONEHOUR","ONEMIN","ONESEC","MINUS_SIGN","BADNUM","ZERO_PATH","K","GRID_PATH","L","TICK_PATH","TICK_TEXT","alignmentConstants","MID_SHIFT","CAP_SHIFT","LINE_SPACING","OPPOSITE_SIDE","TEXTPAD","axes","module","exports","setConvert","autoType","axisIds","idSort","isLinked","id2name","name2id","cleanId","list","listIds","getFromId","getFromTrace","autorange","getAutoRange","findExtremes","epsilon","expandRange","range","delta","coerceRef","containerIn","containerOut","gd","attr","dflt","extraOption","axLetter","charAt","length","axlist","_fullLayout","_subplots","refAttr","attrDef","concat","map","x","valType","values","coerce","getRefType","ar","undefined","test","coercePosition","axRef","cleanPos","pos","axRefType","ensureNumber","ax","fraction2r","cleanPosition","redrawComponents","axIds","fullLayout","_redrawOneComp","moduleName","methodName","stashName","shortCircuit","method","getComponentMethod","stash","i","indices","j","ind","getDataConversions","trace","target","targetArray","d2cTarget","Array","isArray","type","autotypenumbers","_categories","d2c","c2d","toString","toNum","v","String","getDataToCoordFunc","counterLetter","id","minDtick","newDiff","newFirst","allow","indexOf","_minDtick","_forceTick0","saveRangeInitial","overwrite","axList","hasOneAxisChanged","isNew","_rangeInitial","hasChanged","slice","saveShowSpikeInitial","allSpikesEnabled","_showSpikeInitial","showspikes","_showspikes","_cartesianSpikesEnabled","autoBin","data","nbins","is2d","calendar","size","dataMin","aggNums","Math","min","dataMax","max","start","end","round","_dataSpan","dummyAx","simpleMap","c2r","dtick","tick0","size0","distinctData","distinctVals","msexp","pow","floor","log","minDiff","LN10","minSize","roundUp","stdev","autoTicks","finalSize","binStart","tickIncrement","tickFirst","binEnd","bincount","autoShiftNumericBins","autoShiftMonthBins","edgecount","midcount","intcount","blankCount","nearEdge","dataCount","binshift","stats","findExactDates","threshold","exactDays","numMonths","Number","substr","exactYears","exactMonths","nextBinStart","prepTicks","opts","rng","r2l","_dtickInit","_tick0Init","tickmode","nt","nticks","minPx","tickfont","bigFont","_length","_id","constrain","_name","_roughDTick","abs","l2r","ticklabelmode","adjustPeriodDelta","autoTickRound","nMonths","substring","definedDelta","mDate","isMDate","tickformat","getTickFormat","noDtick","_dowTick0","_rawTick0","_definedDelta","positionPeriodTicks","tickVals","value","a","b","A","B","actualDelta","periodLength","inBetween","endPeriod","rangebreaks","nAll","n","c","r","maskBreaks","drop","periodX","calcTicks","arrayTicks","exRng","startTick","endTick","axrev","minRange","maxRange","isDLog","isPeriod","_tmin","moveOutsideBreak","maxTicks","xPrevious","minor","push","flip","fontSize","prevL","NaN","splice","l","c2p","isAngular","pop","_tmax","_prevDateHead","_inCalcTicks","ticksOut","t","p","_minor","_value","tickText","text","vals","tickvals","ticktext","tickMin","tickMax","tickVal2l","d2l_noadd","d2l","vali","tickTextObj","filter","d","roundBase10","roundBase24","roundBase60","roundDays","roundLog1","roundLog2","roundAngles","roundDTick","roughDTick","base","roundingSet","getBase","dateTick0","roughX2","_hasDayOfWeekBreaks","ceil","olddtick","_tickexponent","_tickround","tick0ms","tick0str","replace","tick0len","tick1len","r2d","maxend","rangeexp","minexponent","isSIFormat","exponentformat","beyondSI","axSign","increment","tType","dtSigned","incrementMonth","tickset","x2","frac","mod","sRound","r0","tmin","dtNum","cnt","t0","t1","mult","newDTick","error","hover","noSuffixPrefix","out","arrayMode","extraPrecision","axType","_lBreaks","isHidden","showAttr","firstOrLast","first","last","hideexp","showexponent","formatDate","formatLog","formatCategory","formatMultiCategory","formatAngle","formatLinear","tickprefix","showtickprefix","ticksuffix","showticksuffix","tickson","showdividers","inbounds","l2p","xbnd","hoverLabelText","hoverformat","extendFlat","val","val2","logOffScale","tx","c2l","tf","dx","dy","font","family","fontColor","color","tr","fmt","y","m","M","S","dateStr","_dateFormat","_extraFormat","headStr","splitIndex","isInside","insideTicklabelposition","side","_realSide","dtChar0","numFormat","absP","exponentFormat","firstChar","tt","cats","tt2","text2","thetaunit","num","num2frac","deg2rad","isNeg","join","almostEq","findGCD","findPrecision","e","precision","number","gcd","SIPREFIXES","exponent","fmtoverride","tickRound","separatethousands","ah","_numFormat","dp","numSeparate","_separators","signedExponent","convertToMs","compareLogTicks","left","right","priority","leftPriority","rightPriority","isProperStop","convert","convertFn","leftDtick","rightDtick","isProperLogStop","isLeftDtickNull","isRightDtickNull","isDtickInRangeLeft","isDtickInRangeRight","tickstop","stopi","tickformatstops","enabled","dtickrange","getSubplots","subplotObj","allSubplots","cartesian","gl2d","findSubplotsWithAxis","sort","aParts","split","bParts","subplots","axMatch","RegExp","subplotsWithAx","sp","makeClipPaths","_hasOnlyLargeSploms","fullWidth","_offset","width","fullHeight","height","xaList","yaList","clipList","axClips","_clips","selectAll","enter","append","classed","_uid","exit","remove","each","select","draw","arg","_paper","plotinfo","_plots","xa","xaxis","ya","yaxis","xaxislayer","yaxislayer","gridlayer","zerolinelayer","_infolayer","syncOrAsync","axId","axDone","drawOne","_r","_rl","setScale","mainPlotinfo","_mainSubplot","mainAxLayer","mainLinePosition","_mainLinePosition","mainMirrorPosition","_mainMirrorPosition","_vals","axInfo","mirror","_selections","_tickAngles","_prevTickAngles","_depth","llbboxes","getLabelLevelBbox","suffix","cls","calcLabelLevelBbox","visible","transTickFn","makeTransTickFn","transTickLabelFn","makeTransTickLabelFn","valsClipped","insideTicks","ticks","outsideTicks","boundaryVals","getBoundaryVals","clipEnds","gridVals","_gridVals","dividerVals","getDividerVals","_subplotsWith","finishedGrids","counterAxis","mainCounterID","_mainAxis","gridPath","drawGrid","layer","path","transFn","drawZeroLine","tickSigns","getTickSigns","tickSubplots","mainTickPath","makeTickPath","mirrorTickPath","fullTickPath","_anchorAxis","tickPath","dividerLookup","drawTicks","Object","keys","_linepositions","linepositions","spTickPath","seq","drawLabels","labelFns","makeLabelFns","pad","bboxKey","standoff","getSecondaryLabelVals","repositionOnUpdate","secondary","drawDividers","title","hasOwnProperty","hasRangeSlider","s","sMirror","getPxPosition","outsideTickLen","ticklen","llbbox","mirrorPush","rangeSliderPush","automargin","bottom","domainIndices","top","reverse","rExtra","xr","lExtra","xl","bExtra","yb","tExtra","yt","anchor","position","domain","_dfltTitle","approxTitleDepth","linewidth","_counterDomainMin","_counterDomainMax","autoMargin","axAutoMarginID","axMirrorAutoMarginID","rangeSliderAutoMarginID","skipTitle","drawTitle","_push","bndIndex","xb","lookup","k","interp","current","reversed","Infinity","thisLabel","selectTickLabel","bb","bBox","node","parentNode","sideOpposite","main","uv","getTickLabelUV","u","getPosX","ticklabelposition","has","str","isTop","isLeft","isRight","isBottom","isAligned","tickwidth","shift","sgn","len","angle","insideTickLabels","labelsOverTicks","labelStandoff","labelShift","tickLen","rad","cos","sin","showticklabels","showline","x0","y0","ff","flipIt","xQ","tickangle","endSide","xFn","yFn","anchorFn","heightFn","h","ang","rA","tickDataFn","crisp","call","stroke","tickcolor","style","crispRound","hideCounterAxisInsideTickLabels","counterAx","showgrid","shouldShowZeroLine","isArrayMode","xi","grid","_gw","gridwidth","gridcolor","show","zl","da","db","zerolinecolor","defaultLine","zerolinewidth","tickAngle","prevAngle","tickLabels","labelsReady","newPromise","_promises","positionText","convertToTspans","then","positionLabels","mathjaxGroup","transform","nLines","lineCount","lineHeight","anchorHeight","empty","thisText","_adjustTickLabelsOverflow","mjWidth","mjShift","ticklabeloverflow","hideOverflow","isX","p0","p1","rl","visibleLabelMin","visibleLabelMax","adjust","subplot","anchorAx","_hideCounterAxisInsideTickLabels","partialOpts","anchoredAxes","forEach","idx","isPeriodLabel","sel","w","q","allLabelsReady","Promise","all","autoangle","fixLabelOverlaps","maxFontSize","lbbArray","gap","lbb","vLen","tickSpacing","_m","rotate90","bBoxIntersect","_redrawFromAutoMarginCount","_insideTickLabelsAutorange","computeFinalTickLabelBoundingBoxes","done","dividers","insert","dividercolor","dividerwidth","gs","_size","anchorAxis","extraLines","match","BR_TAG_ALL","titleStandoff","offsetBase","rotate","offset","avoid","selection","translation","getTranslate","offsetLeft","offsetTop","propContainer","propName","placeholder","attributes","zeroline","anyCounterAxLineAtZero","hasBarsOrFill","mainCounterAxis","zeroPosition","lineNearZero","ax2","tolerance","closeEnough","pos2","linePositions","mainplotinfo","overlays","counterLetterAxes","counterAxis2","fullData","_fullData","traceIs","orientation","fill","gTick","mj","allowAutoMargin","swap","traces","axGroups","makeAxisGroups","swapAxisGroup","groups","groupsi","yi","group0","groupj","mergeAxisGroups","intoSet","fromSet","xIds","yIds","xFullAxes","yFullAxes","layout","allAxKeys","noSwapAttrs","numericTypes","keyi","xVal","yVal","allEqual","coerceLinearX","coerceLinearY","xVali","yVali","swapAxisAttrs","annotations","ann","xref","yref","swapAttrs","key","dfltTitle","np","nestedProperty","get","set","_rangebreaks","brk"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\n\nvar ZERO_PATH = { K: 'zeroline' };\nvar GRID_PATH = { K: 'gridline', L: 'path' };\nvar TICK_PATH = { K: 'tick', L: 'path' };\nvar TICK_TEXT = { K: 'tick', L: 'text' };\n\nvar alignmentConstants = require('../../constants/alignment');\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\n\nvar TEXTPAD = 3;\n\nvar axes = module.exports = {};\n\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked;\n\n// tight coupling to chart studio\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\n\nvar epsilon = 0.0001;\nfunction expandRange(range) {\n    var delta = (range[1] - range[0]) * epsilon;\n    return [\n        range[0] - delta,\n        range[1] + delta\n    ];\n}\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {\n    var axLetter = attr.charAt(attr.length - 1);\n    var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n    var refAttr = attr + 'ref';\n    var attrDef = {};\n\n    if(!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n    if(!extraOption) extraOption = dflt;\n    axlist = axlist.concat(axlist.map(function(x) { return x + ' domain'; }));\n\n    // data-ref annotations are not supported in gl2d yet\n\n    attrDef[refAttr] = {\n        valType: 'enumerated',\n        values: axlist.concat(extraOption ?\n            (typeof extraOption === 'string' ? [extraOption] : extraOption) :\n            []),\n        dflt: dflt\n    };\n\n    // xref, yref\n    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\naxes.getRefType = function(ar) {\n    if(ar === undefined) { return ar; }\n    if(ar === 'paper') { return 'paper'; }\n    if(ar === 'pixel') { return 'pixel'; }\n    if(/( domain)$/.test(ar)) { return 'domain'; } else { return 'range'; }\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {\n    var cleanPos, pos;\n    var axRefType = axes.getRefType(axRef);\n    if(axRefType !== 'range') {\n        cleanPos = Lib.ensureNumber;\n        pos = coerce(attr, dflt);\n    } else {\n        var ax = axes.getFromId(gd, axRef);\n        dflt = ax.fraction2r(dflt);\n        pos = coerce(attr, dflt);\n        cleanPos = ax.cleanPos;\n    }\n    containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function(pos, gd, axRef) {\n    var cleanPos = (axRef === 'paper' || axRef === 'pixel') ?\n        Lib.ensureNumber :\n        axes.getFromId(gd, axRef).cleanPos;\n\n    return cleanPos(pos);\n};\n\naxes.redrawComponents = function(gd, axIds) {\n    axIds = axIds ? axIds : axes.listIds(gd);\n\n    var fullLayout = gd._fullLayout;\n\n    function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n        var method = Registry.getComponentMethod(moduleName, methodName);\n        var stash = {};\n\n        for(var i = 0; i < axIds.length; i++) {\n            var ax = fullLayout[axes.id2name(axIds[i])];\n            var indices = ax[stashName];\n\n            for(var j = 0; j < indices.length; j++) {\n                var ind = indices[j];\n\n                if(!stash[ind]) {\n                    method(gd, ind);\n                    stash[ind] = 1;\n                    // once is enough for images (which doesn't use the `i` arg anyway)\n                    if(shortCircuit) return;\n                }\n            }\n        }\n    }\n\n    // annotations and shapes 'draw' method is slow,\n    // use the finer-grained 'drawOne' method instead\n    _redrawOneComp('annotations', 'drawOne', '_annIndices');\n    _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n    _redrawOneComp('images', 'draw', '_imgIndices', true);\n};\n\nvar getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {\n    var ax;\n\n    // If target points to an axis, use the type we already have for that\n    // axis to find the data type. Otherwise use the values to autotype.\n    var d2cTarget = (target === 'x' || target === 'y' || target === 'z') ?\n        target :\n        targetArray;\n\n    // In the case of an array target, make a mock data array\n    // and call supplyDefaults to the data type and\n    // setup the data-to-calc method.\n    if(Array.isArray(d2cTarget)) {\n        ax = {\n            type: autoType(targetArray, undefined, {\n                autotypenumbers: gd._fullLayout.autotypenumbers\n            }),\n            _categories: []\n        };\n        axes.setConvert(ax);\n\n        // build up ax._categories (usually done during ax.makeCalcdata()\n        if(ax.type === 'category') {\n            for(var i = 0; i < targetArray.length; i++) {\n                ax.d2c(targetArray[i]);\n            }\n        }\n        // TODO what to do for transforms?\n    } else {\n        ax = axes.getFromTrace(gd, trace, d2cTarget);\n    }\n\n    // if 'target' has corresponding axis\n    // -> use setConvert method\n    if(ax) return {d2c: ax.d2c, c2d: ax.c2d};\n\n    // special case for 'ids'\n    // -> cast to String\n    if(d2cTarget === 'ids') return {d2c: toString, c2d: toString};\n\n    // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n    // -> cast to Number\n\n    return {d2c: toNum, c2d: toNum};\n};\n\nfunction toNum(v) { return +v; }\nfunction toString(v) { return String(v); }\n\naxes.getDataToCoordFunc = function(gd, trace, target, targetArray) {\n    return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function(id) {\n    var axLetter = id.charAt(0);\n    if(axLetter === 'x') return 'y';\n    if(axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function(ax, newDiff, newFirst, allow) {\n    // doesn't make sense to do forced min dTick on log or category axes,\n    // and the plot itself may decide to cancel (ie non-grouped bars)\n    if(['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n        ax._minDtick = 0;\n    } else if(ax._minDtick === undefined) {\n        // undefined means there's nothing there yet\n\n        ax._minDtick = newDiff;\n        ax._forceTick0 = newFirst;\n    } else if(ax._minDtick) {\n        if((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n            // existing minDtick is an integer multiple of newDiff\n            // (within rounding err)\n            // and forceTick0 can be shifted to newFirst\n\n                (((newFirst - ax._forceTick0) / newDiff % 1) +\n                    1.000001) % 1 < 2e-6) {\n            ax._minDtick = newDiff;\n            ax._forceTick0 = newFirst;\n        } else if((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n            // if the converse is true (newDiff is a multiple of minDtick and\n            // newFirst can be shifted to forceTick0) then do nothing - same\n            // forcing stands. Otherwise, cancel forced minimum\n\n                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +\n                    1.000001) % 1 > 2e-6) {\n            ax._minDtick = 0;\n        }\n    }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._rangeInitial === undefined);\n        var hasChanged = isNew || !(\n            ax.range[0] === ax._rangeInitial[0] &&\n            ax.range[1] === ax._rangeInitial[1]\n        );\n\n        if((isNew && ax.autorange === false) || (overwrite && hasChanged)) {\n            ax._rangeInitial = ax.range.slice();\n            hasOneAxisChanged = true;\n        }\n    }\n\n    return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n    var allSpikesEnabled = 'on';\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._showSpikeInitial === undefined);\n        var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n        if(isNew || (overwrite && hasChanged)) {\n            ax._showSpikeInitial = ax.showspikes;\n            hasOneAxisChanged = true;\n        }\n\n        if(allSpikesEnabled === 'on' && !ax.showspikes) {\n            allSpikesEnabled = 'off';\n        }\n    }\n    gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n    return hasOneAxisChanged;\n};\n\naxes.autoBin = function(data, ax, nbins, is2d, calendar, size) {\n    var dataMin = Lib.aggNums(Math.min, null, data);\n    var dataMax = Lib.aggNums(Math.max, null, data);\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        return {\n            start: dataMin - 0.5,\n            end: dataMax + 0.5,\n            size: Math.max(1, Math.round(size) || 1),\n            _dataSpan: dataMax - dataMin,\n        };\n    }\n\n    if(!calendar) calendar = ax.calendar;\n\n    // piggyback off tick code to make \"nice\" bin sizes and edges\n    var dummyAx;\n    if(ax.type === 'log') {\n        dummyAx = {\n            type: 'linear',\n            range: [dataMin, dataMax]\n        };\n    } else {\n        dummyAx = {\n            type: ax.type,\n            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n            calendar: calendar\n        };\n    }\n    axes.setConvert(dummyAx);\n\n    size = size && cleanTicks.dtick(size, dummyAx.type);\n\n    if(size) {\n        dummyAx.dtick = size;\n        dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n    } else {\n        var size0;\n        if(nbins) size0 = ((dataMax - dataMin) / nbins);\n        else {\n            // totally auto: scale off std deviation so the highest bin is\n            // somewhat taller than the total number of bins, but don't let\n            // the size get smaller than the 'nice' rounded down minimum\n            // difference between values\n            var distinctData = Lib.distinctVals(data);\n            var msexp = Math.pow(10, Math.floor(\n                Math.log(distinctData.minDiff) / Math.LN10));\n            var minSize = msexp * Lib.roundUp(\n                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n            size0 = Math.max(minSize, 2 * Lib.stdev(data) /\n                Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n            // fallback if ax.d2c output BADNUMs\n            // e.g. when user try to plot categorical bins\n            // on a layout.xaxis.type: 'linear'\n            if(!isNumeric(size0)) size0 = 1;\n        }\n\n        axes.autoTicks(dummyAx, size0);\n    }\n\n    var finalSize = dummyAx.dtick;\n    var binStart = axes.tickIncrement(\n            axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n    var binEnd, bincount;\n\n    // check for too many data points right at the edges of bins\n    // (>50% within 1% of bin edges) or all data points integral\n    // and offset the bins accordingly\n    if(typeof finalSize === 'number') {\n        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n\n        bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n        binEnd = binStart + bincount * finalSize;\n    } else {\n        // month ticks - should be the only nonlinear kind we have at this point.\n        // dtick (as supplied by axes.autoTick) only has nonlinear values on\n        // date and log axes, but even if you display a histogram on a log axis\n        // we bin it on a linear axis (which one could argue against, but that's\n        // a separate issue)\n        if(dummyAx.dtick.charAt(0) === 'M') {\n            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n        }\n\n        // calculate the endpoint for nonlinear ticks - you have to\n        // just increment until you're done\n        binEnd = binStart;\n        bincount = 0;\n        while(binEnd <= dataMax) {\n            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n            bincount++;\n        }\n    }\n\n    return {\n        start: ax.c2r(binStart, 0, calendar),\n        end: ax.c2r(binEnd, 0, calendar),\n        size: finalSize,\n        _dataSpan: dataMax - dataMin\n    };\n};\n\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n    var edgecount = 0;\n    var midcount = 0;\n    var intcount = 0;\n    var blankCount = 0;\n\n    function nearEdge(v) {\n        // is a value within 1% of a bin edge?\n        return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i] % 1 === 0) intcount++;\n        else if(!isNumeric(data[i])) blankCount++;\n\n        if(nearEdge(data[i])) edgecount++;\n        if(nearEdge(data[i] + ax.dtick / 2)) midcount++;\n    }\n    var dataCount = data.length - blankCount;\n\n    if(intcount === dataCount && ax.type !== 'date') {\n        if(ax.dtick < 1) {\n            // all integers: if bin size is <1, it's because\n            // that was specifically requested (large nbins)\n            // so respect that... but center the bins containing\n            // integers on those integers\n\n            binStart = dataMin - 0.5 * ax.dtick;\n        } else {\n            // otherwise start half an integer down regardless of\n            // the bin size, just enough to clear up endpoint\n            // ambiguity about which integers are in which bins.\n\n            binStart -= 0.5;\n            if(binStart + ax.dtick < dataMin) binStart += ax.dtick;\n        }\n    } else if(midcount < dataCount * 0.1) {\n        if(edgecount > dataCount * 0.3 ||\n                nearEdge(dataMin) || nearEdge(dataMax)) {\n            // lots of points at the edge, not many in the middle\n            // shift half a bin\n            var binshift = ax.dtick / 2;\n            binStart += (binStart + binshift < dataMin) ? binshift : -binshift;\n        }\n    }\n    return binStart;\n}\n\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n    var stats = Lib.findExactDates(data, calendar);\n    // number of data points that needs to be an exact value\n    // to shift that increment to (near) the bin center\n    var threshold = 0.8;\n\n    if(stats.exactDays > threshold) {\n        var numMonths = Number(dtick.substr(1));\n\n        if((stats.exactYears > threshold) && (numMonths % 12 === 0)) {\n            // The exact middle of a non-leap-year is 1.5 days into July\n            // so if we start the bins here, all but leap years will\n            // get hover-labeled as exact years.\n            binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n        } else if(stats.exactMonths > threshold) {\n            // Months are not as clean, but if we shift half the *longest*\n            // month (31/2 days) then 31-day months will get labeled exactly\n            // and shorter months will get labeled with the correct month\n            // but shifted 12-36 hours into it.\n            binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n        } else {\n            // Shifting half a day is exact, but since these are month bins it\n            // will always give a somewhat odd-looking label, until we do something\n            // smarter like showing the bin boundaries (or the bounds of the actual\n            // data in each bin)\n            binStart -= HALFDAY;\n        }\n        var nextBinStart = axes.tickIncrement(binStart, dtick);\n\n        if(nextBinStart <= dataMin) return nextBinStart;\n    }\n    return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function(ax, opts) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n    ax._dtickInit = ax.dtick;\n    ax._tick0Init = ax.tick0;\n\n    // calculate max number of (auto) ticks to display based on plot size\n    if(ax.tickmode === 'auto' || !ax.dtick) {\n        var nt = ax.nticks;\n        var minPx;\n\n        if(!nt) {\n            if(ax.type === 'category' || ax.type === 'multicategory') {\n                minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n                nt = ax._length / minPx;\n            } else {\n                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n            }\n\n            // radial axes span half their domain,\n            // multiply nticks value by two to get correct number of auto ticks.\n            if(ax._name === 'radialaxis') nt *= 2;\n        }\n\n        // add a couple of extra digits for filling in ticks when we\n        // have explicit tickvals without tick text\n        if(ax.tickmode === 'array') nt *= 100;\n\n\n        ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n        axes.autoTicks(ax, ax._roughDTick);\n\n        // check for a forced minimum dtick\n        if(ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n            ax.dtick = ax._minDtick;\n            ax.tick0 = ax.l2r(ax._forceTick0);\n        }\n    }\n\n    if(ax.ticklabelmode === 'period') {\n        adjustPeriodDelta(ax);\n    }\n\n    // check for missing tick0\n    if(!ax.tick0) {\n        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;\n    }\n\n    // ensure we don't try to make ticks below our minimum precision\n    // see https://github.com/plotly/plotly.js/issues/2892\n    if(ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n    // now figure out rounding of tick values\n    autoTickRound(ax);\n};\n\nfunction nMonths(dtick) {\n    return +(dtick.substring(1));\n}\n\nfunction adjustPeriodDelta(ax) { // adjusts ax.dtick and sets ax._definedDelta\n    var definedDelta;\n\n    function mDate() {\n        return !(\n            isNumeric(ax.dtick) ||\n            ax.dtick.charAt(0) !== 'M'\n        );\n    }\n    var isMDate = mDate();\n    var tickformat = axes.getTickFormat(ax);\n    if(tickformat) {\n        var noDtick = ax._dtickInit !== ax.dtick;\n        if(\n            !(/%[fLQsSMX]/.test(tickformat))\n            // %f: microseconds as a decimal number [000000, 999999]\n            // %L: milliseconds as a decimal number [000, 999]\n            // %Q: milliseconds since UNIX epoch\n            // %s: seconds since UNIX epoch\n            // %S: second as a decimal number [00,61]\n            // %M: minute as a decimal number [00,59]\n            // %X: the locale’s time, such as %-I:%M:%S %p\n        ) {\n            if(\n                /%[HI]/.test(tickformat)\n                // %H: hour (24-hour clock) as a decimal number [00,23]\n                // %I: hour (12-hour clock) as a decimal number [01,12]\n            ) {\n                definedDelta = ONEHOUR;\n                if(noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n            } else if(\n                /%p/.test(tickformat) // %p: either AM or PM\n            ) {\n                definedDelta = HALFDAY;\n                if(noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n            } else if(\n                /%[Aadejuwx]/.test(tickformat)\n                // %A: full weekday name\n                // %a: abbreviated weekday name\n                // %d: zero-padded day of the month as a decimal number [01,31]\n                // %e: space-padded day of the month as a decimal number [ 1,31]\n                // %j: day of the year as a decimal number [001,366]\n                // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n                // %w: Sunday-based weekday as a decimal number [0,6]\n                // %x: the locale’s date, such as %-m/%-d/%Y\n            ) {\n                definedDelta = ONEDAY;\n                if(noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n            } else if(\n                /%[UVW]/.test(tickformat)\n                // %U: Sunday-based week of the year as a decimal number [00,53]\n                // %V: ISO 8601 week of the year as a decimal number [01, 53]\n                // %W: Monday-based week of the year as a decimal number [00,53]\n            ) {\n                definedDelta = ONEWEEK;\n                if(noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n            } else if(\n                /%[Bbm]/.test(tickformat)\n                // %B: full month name\n                // %b: abbreviated month name\n                // %m: month as a decimal number [01,12]\n            ) {\n                definedDelta = ONEAVGMONTH;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)\n                ) ax.dtick = 'M1';\n            } else if(\n                /%[q]/.test(tickformat)\n                // %q: quarter of the year as a decimal number [1,4]\n            ) {\n                definedDelta = ONEAVGQUARTER;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)\n                ) ax.dtick = 'M3';\n            } else if(\n                /%[Yy]/.test(tickformat)\n                // %Y: year with century as a decimal number, such as 1999\n                // %y: year without century as a decimal number [00,99]\n            ) {\n                definedDelta = ONEAVGYEAR;\n                if(noDtick && (\n                    isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)\n                ) ax.dtick = 'M12';\n            }\n        }\n    }\n\n    isMDate = mDate();\n    if(isMDate && ax.tick0 === ax._dowTick0) {\n        // discard Sunday/Monday tweaks\n        ax.tick0 = ax._rawTick0;\n    }\n\n    ax._definedDelta = definedDelta;\n}\n\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n    for(var i = 0; i < tickVals.length; i++) {\n        var v = tickVals[i].value;\n\n        var a = i;\n        var b = i + 1;\n        if(i < tickVals.length - 1) {\n            a = i;\n            b = i + 1;\n        } else if(i > 0) {\n            a = i - 1;\n            b = i;\n        } else {\n            a = i;\n            b = i;\n        }\n\n        var A = tickVals[a].value;\n        var B = tickVals[b].value;\n        var actualDelta = Math.abs(B - A);\n        var delta = definedDelta || actualDelta;\n        var periodLength = 0;\n\n        if(delta >= ONEMINYEAR) {\n            if(actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGYEAR;\n            }\n        } else if(definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n            if(actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGQUARTER;\n            }\n        } else if(delta >= ONEMINMONTH) {\n            if(actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n                periodLength = actualDelta;\n            } else {\n                periodLength = ONEAVGMONTH;\n            }\n        } else if(definedDelta === ONEWEEK && delta >= ONEWEEK) {\n            periodLength = ONEWEEK;\n        } else if(delta >= ONEDAY) {\n            periodLength = ONEDAY;\n        } else if(definedDelta === HALFDAY && delta >= HALFDAY) {\n            periodLength = HALFDAY;\n        } else if(definedDelta === ONEHOUR && delta >= ONEHOUR) {\n            periodLength = ONEHOUR;\n        }\n\n        var inBetween;\n        if(periodLength >= actualDelta) {\n            // ensure new label positions remain between ticks\n            periodLength = actualDelta;\n            inBetween = true;\n        }\n\n        var endPeriod = v + periodLength;\n        if(ax.rangebreaks && periodLength > 0) {\n            var nAll = 84; // highly divisible 7 * 12\n            var n = 0;\n            for(var c = 0; c < nAll; c++) {\n                var r = (c + 0.5) / nAll;\n                if(ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n            }\n            periodLength *= n / nAll;\n\n            if(!periodLength) {\n                tickVals[i].drop = true;\n            }\n\n            if(inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n        }\n\n        if(\n            periodLength > 0 || // not instant\n            i === 0 // taking care first tick added\n        ) {\n            tickVals[i].periodX = v + periodLength / 2;\n        }\n    }\n}\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax, opts) {\n    axes.prepTicks(ax, opts);\n    var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n\n    // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n    if(ax.tickmode === 'array') return arrayTicks(ax);\n\n    // add a tiny bit so we get ticks which may have rounded out\n    var exRng = expandRange(rng);\n    var startTick = exRng[0];\n    var endTick = exRng[1];\n    // check for reversed axis\n    var axrev = (rng[1] < rng[0]);\n    var minRange = Math.min(rng[0], rng[1]);\n    var maxRange = Math.max(rng[0], rng[1]);\n\n    var isDLog = (ax.type === 'log') && !(isNumeric(ax.dtick) || ax.dtick.charAt(0) === 'L');\n    var isPeriod = ax.ticklabelmode === 'period';\n\n    // find the first tick\n    ax._tmin = axes.tickFirst(ax, opts);\n\n    // No visible ticks? Quit.\n    // I've only seen this on category axes with all categories off the edge.\n    if((ax._tmin < startTick) !== axrev) return [];\n\n    // return the full set of tick vals\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        endTick = (axrev) ? Math.max(-0.5, endTick) :\n            Math.min(ax._categories.length - 0.5, endTick);\n    }\n\n    var x = ax._tmin;\n\n    if(ax.rangebreaks && ax._tick0Init !== ax.tick0) {\n        // adjust tick0\n        x = moveOutsideBreak(x, ax);\n        if(!axrev) {\n            x = axes.tickIncrement(x, ax.dtick, !axrev, ax.calendar);\n        }\n    }\n\n    if(isPeriod) {\n        // add one item to label period before tick0\n        x = axes.tickIncrement(x, ax.dtick, !axrev, ax.calendar);\n    }\n\n    var maxTicks = Math.max(1000, ax._length || 0);\n    var tickVals = [];\n    var xPrevious = null;\n    for(;\n        (axrev) ? (x >= endTick) : (x <= endTick);\n        x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)\n    ) {\n        if(ax.rangebreaks) {\n            if(!axrev) {\n                if(x < startTick) continue;\n                if(ax.maskBreaks(x) === BADNUM && moveOutsideBreak(x, ax) >= maxRange) break;\n            }\n        }\n\n        // prevent infinite loops - no more than one tick per pixel,\n        // and make sure each value is different from the previous\n        if(tickVals.length > maxTicks || x === xPrevious) break;\n        xPrevious = x;\n\n        var minor = false;\n        if(isDLog && (x !== (x | 0))) {\n            minor = true;\n        }\n\n        tickVals.push({\n            minor: minor,\n            value: x\n        });\n    }\n\n    if(isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);\n\n    var i;\n    if(ax.rangebreaks) {\n        var flip = ax._id.charAt(0) === 'y';\n\n        var fontSize = 1; // one pixel minimum\n        if(ax.tickmode === 'auto') {\n            fontSize = ax.tickfont ? ax.tickfont.size : 12;\n        }\n\n        var prevL = NaN;\n        for(i = tickVals.length - 1; i > -1; i--) {\n            if(tickVals[i].drop) {\n                tickVals.splice(i, 1);\n                continue;\n            }\n\n            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);\n\n            // avoid overlaps\n            var l = ax.c2p(tickVals[i].value);\n            if(flip ?\n                (prevL > l - fontSize) :\n                (prevL < l + fontSize)\n            ) { // ensure one pixel minimum\n                tickVals.splice(axrev ? i + 1 : i, 1);\n            } else {\n                prevL = l;\n            }\n        }\n    }\n\n    // If same angle over a full circle, the last tick vals is a duplicate.\n    // TODO must do something similar for angular date axes.\n    if(isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n        tickVals.pop();\n    }\n\n    // save the last tick as well as first, so we can\n    // show the exponent only on the last one\n    ax._tmax = (tickVals[tickVals.length - 1] || {}).value;\n\n    // for showing the rest of a date when the main tick label is only the\n    // latter part: ax._prevDateHead holds what we showed most recently.\n    // Start with it cleared and mark that we're in calcTicks (ie calculating a\n    // whole string of these so we should care what the previous date head was!)\n    ax._prevDateHead = '';\n    ax._inCalcTicks = true;\n\n    var ticksOut = [];\n    var t, p;\n    for(i = 0; i < tickVals.length; i++) {\n        var _minor = tickVals[i].minor;\n        var _value = tickVals[i].value;\n\n        t = axes.tickText(\n            ax,\n            _value,\n            false, // hover\n            _minor // noSuffixPrefix\n        );\n\n        p = tickVals[i].periodX;\n        if(p !== undefined) {\n            t.periodX = p;\n            if(p > maxRange || p < minRange) { // hide label if outside the range\n                if(p > maxRange) t.periodX = maxRange;\n                if(p < minRange) t.periodX = minRange;\n\n                t.text = ' '; // don't use an empty string here which can confuse automargin (issue 5132)\n                ax._prevDateHead = '';\n            }\n        }\n\n        ticksOut.push(t);\n    }\n\n    ax._inCalcTicks = false;\n\n    return ticksOut;\n};\n\nfunction arrayTicks(ax) {\n    var vals = ax.tickvals;\n    var text = ax.ticktext;\n    var ticksOut = new Array(vals.length);\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var exRng = expandRange(rng);\n    var tickMin = Math.min(exRng[0], exRng[1]);\n    var tickMax = Math.max(exRng[0], exRng[1]);\n    var j = 0;\n\n    // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n    if(!Array.isArray(text)) text = [];\n\n    // make sure showing ticks doesn't accidentally add new categories\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    // array ticks on log axes always show the full number\n    // (if no explicit ticktext overrides it)\n    if(ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n        ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n    }\n\n    for(var i = 0; i < vals.length; i++) {\n        var vali = tickVal2l(vals[i]);\n        if(vali > tickMin && vali < tickMax) {\n            if(text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);\n            else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));\n            j++;\n        }\n    }\n\n    if(j < vals.length) ticksOut.splice(j, vals.length - j);\n\n    if(ax.rangebreaks) {\n        // remove ticks falling inside rangebreaks\n        ticksOut = ticksOut.filter(function(d) {\n            return ax.maskBreaks(d.x) !== BADNUM;\n        });\n    }\n\n    return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n    return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function(ax, roughDTick) {\n    var base;\n\n    function getBase(v) {\n        return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n    }\n\n    if(ax.type === 'date') {\n        ax.tick0 = Lib.dateTick0(ax.calendar, 0);\n\n        // the criteria below are all based on the rough spacing we calculate\n        // being > half of the final unit - so precalculate twice the rough val\n        var roughX2 = 2 * roughDTick;\n\n        if(roughX2 > ONEAVGYEAR) {\n            roughDTick /= ONEAVGYEAR;\n            base = getBase(10);\n            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));\n        } else if(roughX2 > ONEAVGMONTH) {\n            roughDTick /= ONEAVGMONTH;\n            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n        } else if(roughX2 > ONEDAY) {\n            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n            // get week ticks on sunday\n            // this will also move the base tick off 2000-01-01 if dtick is\n            // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n            var tickformat = axes.getTickFormat(ax);\n            var isPeriod = ax.ticklabelmode === 'period';\n            if(isPeriod) ax._rawTick0 = ax.tick0;\n\n            if(/%[uVW]/.test(tickformat)) {\n                ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n            } else {\n                ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n            }\n\n            if(isPeriod) ax._dowTick0 = ax.tick0;\n        } else if(roughX2 > ONEHOUR) {\n            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n        } else if(roughX2 > ONEMIN) {\n            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n        } else if(roughX2 > ONESEC) {\n            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n        } else {\n            // milliseconds\n            base = getBase(10);\n            ax.dtick = roundDTick(roughDTick, base, roundBase10);\n        }\n    } else if(ax.type === 'log') {\n        ax.tick0 = 0;\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n        if(roughDTick > 0.7) {\n            // only show powers of 10\n            ax.dtick = Math.ceil(roughDTick);\n        } else if(Math.abs(rng[1] - rng[0]) < 1) {\n            // span is less than one power of 10\n            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n            // ticks on a linear scale, labeled fully\n            roughDTick = Math.abs(Math.pow(10, rng[1]) -\n                Math.pow(10, rng[0])) / nt;\n            base = getBase(10);\n            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n        } else {\n            // include intermediates between powers of 10,\n            // labeled with small digits\n            // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';\n        }\n    } else if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax.tick0 = 0;\n        ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n    } else if(isAngular(ax)) {\n        ax.tick0 = 0;\n        base = 1;\n        ax.dtick = roundDTick(roughDTick, base, roundAngles);\n    } else {\n        // auto ticks always start at 0\n        ax.tick0 = 0;\n        base = getBase(10);\n        ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n\n    // prevent infinite loops\n    if(ax.dtick === 0) ax.dtick = 1;\n\n    // TODO: this is from log axis histograms with autorange off\n    if(!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n        var olddtick = ax.dtick;\n        ax.dtick = 1;\n        throw 'ax.dtick error: ' + String(olddtick);\n    }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n    var dtick = ax.dtick;\n\n    ax._tickexponent = 0;\n    if(!isNumeric(dtick) && typeof dtick !== 'string') {\n        dtick = 1;\n    }\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax._tickround = null;\n    }\n    if(ax.type === 'date') {\n        // If tick0 is unusual, give tickround a bit more information\n        // not necessarily *all* the information in tick0 though, if it's really odd\n        // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n        // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n        var tick0ms = ax.r2l(ax.tick0);\n        var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n        var tick0len = tick0str.length;\n\n        if(String(dtick).charAt(0) === 'M') {\n            // any tick0 more specific than a year: alway show the full date\n            if(tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n            // show the month unless ticks are full multiples of a year\n            else ax._tickround = (+(dtick.substr(1)) % 12 === 0) ? 'y' : 'm';\n        } else if((dtick >= ONEDAY && tick0len <= 10) || (dtick >= ONEDAY * 15)) ax._tickround = 'd';\n        else if((dtick >= ONEMIN && tick0len <= 16) || (dtick >= ONEHOUR)) ax._tickround = 'M';\n        else if((dtick >= ONESEC && tick0len <= 19) || (dtick >= ONEMIN)) ax._tickround = 'S';\n        else {\n            // tickround is a number of digits of fractional seconds\n            // of any two adjacent ticks, at least one will have the maximum fractional digits\n            // of all possible ticks - so take the max. length of tick0 and the next one\n            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n            ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n            // We shouldn't get here... but in case there's a situation I'm\n            // not thinking of where tick0str and tick1str are identical or\n            // something, fall back on maximum precision\n            if(ax._tickround < 0) ax._tickround = 4;\n        }\n    } else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {\n        // linear or log (except D1, D2)\n        var rng = ax.range.map(ax.r2d || Number);\n        if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n        // 2 digits past largest digit of dtick\n        ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n\n        var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n        var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n        var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n        if(Math.abs(rangeexp) > minexponent) {\n            if(isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n                ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n            } else ax._tickexponent = rangeexp;\n        }\n    } else {\n        // D1 or D2 (log)\n        ax._tickround = null;\n    }\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function(x, dtick, axrev, calendar) {\n    var axSign = axrev ? -1 : 1;\n\n    // includes linear, all dates smaller than month, and pure 10^n in log\n    if(isNumeric(dtick)) return Lib.increment(x, axSign * dtick);\n\n    // everything else is a string, one character plus a number\n    var tType = dtick.charAt(0);\n    var dtSigned = axSign * Number(dtick.substr(1));\n\n    // Dates: months (or years - see Lib.incrementMonth)\n    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n    // Log scales: Linear, Digits\n    if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n    // log10 of 2,5,10, or all digits (logs just have to be\n    // close enough to round)\n    if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var x2 = x + axSign * 0.01;\n        var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n\n        return Math.floor(x2) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n\n    throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function(ax, opts) {\n    var r2l = ax.r2l || Number;\n    var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n    var axrev = rng[1] < rng[0];\n    var sRound = axrev ? Math.floor : Math.ceil;\n    // add a tiny extra bit to make sure we get ticks\n    // that may have been rounded out\n    var r0 = expandRange(rng)[0];\n    var dtick = ax.dtick;\n    var tick0 = r2l(ax.tick0);\n\n    if(isNumeric(dtick)) {\n        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n        // make sure no ticks outside the category list\n        if(ax.type === 'category' || ax.type === 'multicategory') {\n            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n        }\n        return tmin;\n    }\n\n    var tType = dtick.charAt(0);\n    var dtNum = Number(dtick.substr(1));\n\n    // Dates: months (or years)\n    if(tType === 'M') {\n        var cnt = 0;\n        var t0 = tick0;\n        var t1, mult, newDTick;\n\n        // This algorithm should work for *any* nonlinear (but close to linear!)\n        // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n        while(cnt < 10) {\n            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n            if((t1 - r0) * (t0 - r0) <= 0) {\n                // t1 and t0 are on opposite sides of r0! we've succeeded!\n                if(axrev) return Math.min(t0, t1);\n                return Math.max(t0, t1);\n            }\n            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);\n            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);\n            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n            cnt++;\n        }\n        Lib.error('tickFirst did not converge', ax);\n        return t0;\n    } else if(tType === 'L') {\n        // Log scales: Linear, Digits\n\n        return Math.log(sRound(\n            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n    } else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n\n        return Math.floor(r0) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function(ax, x, hover, noSuffixPrefix) {\n    var out = tickTextObj(ax, x);\n    var arrayMode = ax.tickmode === 'array';\n    var extraPrecision = hover || arrayMode;\n    var axType = ax.type;\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n    var i;\n\n    if(arrayMode && Array.isArray(ax.ticktext)) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n\n        for(i = 0; i < ax.ticktext.length; i++) {\n            if(Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n        }\n        if(i < ax.ticktext.length) {\n            out.text = String(ax.ticktext[i]);\n            return out;\n        }\n    }\n\n    function isHidden(showAttr) {\n        if(showAttr === undefined) return true;\n        if(hover) return showAttr === 'none';\n\n        var firstOrLast = {\n            first: ax._tmin,\n            last: ax._tmax\n        }[showAttr];\n\n        return showAttr !== 'all' && x !== firstOrLast;\n    }\n\n    var hideexp = hover ?\n        'never' :\n        ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n\n    if(axType === 'date') formatDate(ax, out, hover, extraPrecision);\n    else if(axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);\n    else if(axType === 'category') formatCategory(ax, out);\n    else if(axType === 'multicategory') formatMultiCategory(ax, out, hover);\n    else if(isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);\n    else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n    // add prefix and suffix\n    if(!noSuffixPrefix) {\n        if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n        if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n    }\n\n    // Setup ticks and grid lines boundaries\n    // at 1/2 a 'category' to the left/bottom\n    if(ax.tickson === 'boundaries' || ax.showdividers) {\n        var inbounds = function(v) {\n            var p = ax.l2p(v);\n            return p >= 0 && p <= ax._length ? v : null;\n        };\n\n        out.xbnd = [\n            inbounds(out.x - 0.5),\n            inbounds(out.x + ax.dtick - 0.5)\n        ];\n    }\n\n    return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\naxes.hoverLabelText = function(ax, values, hoverformat) {\n    if(hoverformat) ax = Lib.extendFlat({}, ax, {hoverformat: hoverformat});\n\n    var val = Array.isArray(values) ? values[0] : values;\n    var val2 = Array.isArray(values) ? values[1] : undefined;\n    if(val2 !== undefined && val2 !== val) {\n        return (\n            axes.hoverLabelText(ax, val, hoverformat) + ' - ' +\n            axes.hoverLabelText(ax, val2, hoverformat)\n        );\n    }\n\n    var logOffScale = (ax.type === 'log' && val <= 0);\n    var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n    if(logOffScale) {\n        return val === 0 ? '0' : MINUS_SIGN + tx;\n    }\n\n    // TODO: should we do something special if the axis calendar and\n    // the data calendar are different? Somehow display both dates with\n    // their system names? Right now it will just display in the axis calendar\n    // but users could add the other one as text.\n    return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n    var tf = ax.tickfont || {};\n\n    return {\n        x: x,\n        dx: 0,\n        dy: 0,\n        text: text || '',\n        fontSize: tf.size,\n        font: tf.family,\n        fontColor: tf.color\n    };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n    var tr = ax._tickround;\n    var fmt = (hover && ax.hoverformat) || axes.getTickFormat(ax);\n\n    if(extraPrecision) {\n        // second or sub-second precision: extra always shows max digits.\n        // for other fields, extra precision just adds one field.\n        if(isNumeric(tr)) tr = 4;\n        else tr = {y: 'm', m: 'd', d: 'M', M: 'S', S: 4}[tr];\n    }\n\n    var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n    var headStr;\n\n    var splitIndex = dateStr.indexOf('\\n');\n    if(splitIndex !== -1) {\n        headStr = dateStr.substr(splitIndex + 1);\n        dateStr = dateStr.substr(0, splitIndex);\n    }\n\n    if(extraPrecision) {\n        // if extraPrecision led to trailing zeros, strip them off\n        // actually, this can lead to removing even more zeros than\n        // in the original rounding, but that's fine because in these\n        // contexts uniformity is not so important (if there's even\n        // anything to be uniform with!)\n\n        // can we remove the whole time part?\n        if(dateStr === '00:00:00' || dateStr === '00:00') {\n            dateStr = headStr;\n            headStr = '';\n        } else if(dateStr.length === 8) {\n            // strip off seconds if they're zero (zero fractional seconds\n            // are already omitted)\n            // but we never remove minutes and leave just hours\n            dateStr = dateStr.replace(/:00$/, '');\n        }\n    }\n\n    if(headStr) {\n        if(hover) {\n            // hover puts it all on one line, so headPart works best up front\n            // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n            if(tr === 'd') dateStr += ', ' + headStr;\n            else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n        } else {\n            if(\n                !ax._inCalcTicks ||\n                ax._prevDateHead !== headStr\n            ) {\n                ax._prevDateHead = headStr;\n                dateStr += '<br>' + headStr;\n            } else {\n                var isInside = insideTicklabelposition(ax);\n                var side = ax._realSide || ax.side; // polar mocks the side of the radial axis\n                if(\n                    (!isInside && side === 'top') ||\n                    (isInside && side === 'bottom')\n                ) {\n                    dateStr += '<br> ';\n                }\n            }\n        }\n    }\n\n    out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n    var dtick = ax.dtick;\n    var x = out.x;\n    var tickformat = ax.tickformat;\n    var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    }\n\n    if(extraPrecision && (dtChar0 !== 'L')) {\n        dtick = 'L3';\n        dtChar0 = 'L';\n    }\n\n    if(tickformat || (dtChar0 === 'L')) {\n        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n    } else if(isNumeric(dtick) || ((dtChar0 === 'D') && (Lib.mod(x + 0.01, 1) < 0.1))) {\n        var p = Math.round(x);\n        var absP = Math.abs(p);\n        var exponentFormat = ax.exponentformat;\n        if(exponentFormat === 'power' || (isSIFormat(exponentFormat) && beyondSI(p))) {\n            if(p === 0) out.text = 1;\n            else if(p === 1) out.text = '10';\n            else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n\n            out.fontSize *= 1.25;\n        } else if((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n            out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n        } else {\n            out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n            if(dtick === 'D1' && ax._id.charAt(0) === 'y') {\n                out.dy -= out.fontSize / 6;\n            }\n        }\n    } else if(dtChar0 === 'D') {\n        out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n        out.fontSize *= 0.75;\n    } else throw 'unrecognized dtick ' + String(dtick);\n\n    // if 9's are printed on log scale, move the 10's away a bit\n    if(ax.dtick === 'D1') {\n        var firstChar = String(out.text).charAt(0);\n        if(firstChar === '0' || firstChar === '1') {\n            if(ax._id.charAt(0) === 'y') {\n                out.dx -= out.fontSize / 4;\n            } else {\n                out.dy += out.fontSize / 2;\n                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *\n                    out.fontSize * (x < 0 ? 0.5 : 0.25);\n            }\n        }\n    }\n}\n\nfunction formatCategory(ax, out) {\n    var tt = ax._categories[Math.round(out.x)];\n    if(tt === undefined) tt = '';\n    out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n    var v = Math.round(out.x);\n    var cats = ax._categories[v] || [];\n    var tt = cats[1] === undefined ? '' : String(cats[1]);\n    var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n    if(hover) {\n        // TODO is this what we want?\n        out.text = tt2 + ' - ' + tt;\n    } else {\n        // setup for secondary labels\n        out.text = tt;\n        out.text2 = tt2;\n    }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    } else if(ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n        // don't add an exponent to zero if we're showing all exponents\n        // so the only reason you'd show an exponent on zero is if it's the\n        // ONLY tick to get an exponent (first or last)\n        hideexp = 'hide';\n    }\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n    if(ax.thetaunit === 'radians' && !hover) {\n        var num = out.x / 180;\n\n        if(num === 0) {\n            out.text = '0';\n        } else {\n            var frac = num2frac(num);\n\n            if(frac[1] >= 100) {\n                out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n            } else {\n                var isNeg = out.x < 0;\n\n                if(frac[1] === 1) {\n                    if(frac[0] === 1) out.text = 'π';\n                    else out.text = frac[0] + 'π';\n                } else {\n                    out.text = [\n                        '<sup>', frac[0], '</sup>',\n                        '⁄',\n                        '<sub>', frac[1], '</sub>',\n                        'π'\n                    ].join('');\n                }\n\n                if(isNeg) out.text = MINUS_SIGN + out.text;\n            }\n        }\n    } else {\n        out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n    }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n    function almostEq(a, b) {\n        return Math.abs(a - b) <= 1e-6;\n    }\n\n    function findGCD(a, b) {\n        return almostEq(b, 0) ? a : findGCD(b, a % b);\n    }\n\n    function findPrecision(n) {\n        var e = 1;\n        while(!almostEq(Math.round(n * e) / e, n)) {\n            e *= 10;\n        }\n        return e;\n    }\n\n    var precision = findPrecision(num);\n    var number = num * precision;\n    var gcd = Math.abs(findGCD(number, precision));\n\n    return [\n        // numerator\n        Math.round(number / gcd),\n        // denominator\n        Math.round(precision / gcd)\n    ];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n    return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n    return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n    var isNeg = v < 0;\n    // max number of digits past decimal point to show\n    var tickRound = ax._tickround;\n    var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n    var exponent = ax._tickexponent;\n    var tickformat = axes.getTickFormat(ax);\n    var separatethousands = ax.separatethousands;\n\n    // special case for hover: set exponent just for this value, and\n    // add a couple more digits of precision over tick labels\n    if(hover) {\n        // make a dummy axis obj to get the auto rounding and exponent\n        var ah = {\n            exponentformat: exponentFormat,\n            minexponent: ax.minexponent,\n            dtick: ax.showexponent === 'none' ? ax.dtick :\n                (isNumeric(v) ? Math.abs(v) || 1 : 1),\n            // if not showing any exponents, don't change the exponent\n            // from what we calculate\n            range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n        };\n        autoTickRound(ah);\n        tickRound = (Number(ah._tickround) || 0) + 4;\n        exponent = ah._tickexponent;\n        if(ax.hoverformat) tickformat = ax.hoverformat;\n    }\n\n    if(tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n    // 'epsilon' - rounding increment\n    var e = Math.pow(10, -tickRound) / 2;\n\n    // exponentFormat codes:\n    // 'e' (1.2e+6, default)\n    // 'E' (1.2E+6)\n    // 'SI' (1.2M)\n    // 'B' (same as SI except 10^9=B not G)\n    // 'none' (1200000)\n    // 'power' (1.2x10^6)\n    // 'hide' (1.2, use 3rd argument=='hide' to eg\n    //      only show exponent on last tick)\n    if(exponentFormat === 'none') exponent = 0;\n\n    // take the sign out, put it back manually at the end\n    // - makes cases easier\n    v = Math.abs(v);\n    if(v < e) {\n        // 0 is just 0, but may get exponent if it's the last tick\n        v = '0';\n        isNeg = false;\n    } else {\n        v += e;\n        // take out a common exponent, if any\n        if(exponent) {\n            v *= Math.pow(10, -exponent);\n            tickRound += exponent;\n        }\n        // round the mantissa\n        if(tickRound === 0) v = String(Math.floor(v));\n        else if(tickRound < 0) {\n            v = String(Math.round(v));\n            v = v.substr(0, v.length + tickRound);\n            for(var i = tickRound; i < 0; i++) v += '0';\n        } else {\n            v = String(v);\n            var dp = v.indexOf('.') + 1;\n            if(dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n        }\n        // insert appropriate decimal point and thousands separator\n        v = Lib.numSeparate(v, ax._separators, separatethousands);\n    }\n\n    // add exponent\n    if(exponent && exponentFormat !== 'hide') {\n        if(isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n\n        var signedExponent;\n        if(exponent < 0) signedExponent = MINUS_SIGN + -exponent;\n        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;\n        else signedExponent = String(exponent);\n\n        if(exponentFormat === 'e' || exponentFormat === 'E') {\n            v += exponentFormat + signedExponent;\n        } else if(exponentFormat === 'power') {\n            v += '×10<sup>' + signedExponent + '</sup>';\n        } else if(exponentFormat === 'B' && exponent === 9) {\n            v += 'B';\n        } else if(isSIFormat(exponentFormat)) {\n            v += SIPREFIXES[exponent / 3 + 5];\n        }\n    }\n\n    // put sign back in and return\n    // replace standard minus character (which is technically a hyphen)\n    // with a true minus sign\n    if(isNeg) return MINUS_SIGN + v;\n    return v;\n}\n\naxes.getTickFormat = function(ax) {\n    var i;\n\n    function convertToMs(dtick) {\n        return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n    }\n\n    function compareLogTicks(left, right) {\n        var priority = ['L', 'D'];\n        if(typeof left === typeof right) {\n            if(typeof left === 'number') {\n                return left - right;\n            } else {\n                var leftPriority = priority.indexOf(left.charAt(0));\n                var rightPriority = priority.indexOf(right.charAt(0));\n                if(leftPriority === rightPriority) {\n                    return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n                } else {\n                    return leftPriority - rightPriority;\n                }\n            }\n        } else {\n            return typeof left === 'number' ? 1 : -1;\n        }\n    }\n\n    function isProperStop(dtick, range, convert) {\n        var convertFn = convert || function(x) { return x;};\n        var leftDtick = range[0];\n        var rightDtick = range[1];\n        return ((!leftDtick && typeof leftDtick !== 'number') || convertFn(leftDtick) <= convertFn(dtick)) &&\n               ((!rightDtick && typeof rightDtick !== 'number') || convertFn(rightDtick) >= convertFn(dtick));\n    }\n\n    function isProperLogStop(dtick, range) {\n        var isLeftDtickNull = range[0] === null;\n        var isRightDtickNull = range[1] === null;\n        var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n        var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n        return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n    }\n\n    var tickstop, stopi;\n    if(ax.tickformatstops && ax.tickformatstops.length > 0) {\n        switch(ax.type) {\n            case 'date':\n            case 'linear': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            case 'log': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            default:\n        }\n    }\n    return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function(gd, ax) {\n    var subplotObj = gd._fullLayout._subplots;\n    var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n\n    var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n\n    out.sort(function(a, b) {\n        var aParts = a.substr(1).split('y');\n        var bParts = b.substr(1).split('y');\n\n        if(aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n        return +aParts[0] - +bParts[0];\n    });\n\n    return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function(subplots, ax) {\n    var axMatch = new RegExp(\n        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')\n    );\n    var subplotsWithAx = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        if(axMatch.test(sp)) subplotsWithAx.push(sp);\n    }\n\n    return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // for more info: https://github.com/plotly/plotly.js/issues/2595\n    if(fullLayout._hasOnlyLargeSploms) return;\n\n    var fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''};\n    var fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''};\n    var xaList = axes.list(gd, 'x', true);\n    var yaList = axes.list(gd, 'y', true);\n    var clipList = [];\n    var i, j;\n\n    for(i = 0; i < xaList.length; i++) {\n        clipList.push({x: xaList[i], y: fullHeight});\n        for(j = 0; j < yaList.length; j++) {\n            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});\n            clipList.push({x: xaList[i], y: yaList[j]});\n        }\n    }\n\n    // selectors don't work right with camelCase tags,\n    // have to use class instead\n    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n    var axClips = fullLayout._clips.selectAll('.axesclip')\n        .data(clipList, function(d) { return d.x._id + d.y._id; });\n\n    axClips.enter().append('clipPath')\n        .classed('axesclip', true)\n        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })\n      .append('rect');\n\n    axClips.exit().remove();\n\n    axClips.each(function(d) {\n        d3.select(this).select('rect').attr({\n            x: d.x._offset || 0,\n            y: d.y._offset || 0,\n            width: d.x._length || 1,\n            height: d.y._length || 1\n        });\n    });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function(gd, arg, opts) {\n    var fullLayout = gd._fullLayout;\n\n    if(arg === 'redraw') {\n        fullLayout._paper.selectAll('g.subplot').each(function(d) {\n            var id = d[0];\n            var plotinfo = fullLayout._plots[id];\n            if(plotinfo) {\n                var xa = plotinfo.xaxis;\n                var ya = plotinfo.yaxis;\n\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n                plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n                plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n\n                if(plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n                if(plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n                fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n                fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n            }\n        });\n    }\n\n    var axList = (!arg || arg === 'redraw') ? axes.listIds(gd) : arg;\n\n    return Lib.syncOrAsync(axList.map(function(axId) {\n        return function() {\n            if(!axId) return;\n\n            var ax = axes.getFromId(gd, axId);\n            var axDone = axes.drawOne(gd, ax, opts);\n\n            ax._r = ax.range.slice();\n            ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n            return axDone;\n        };\n    }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\naxes.drawOne = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var i, sp, plotinfo;\n\n    ax.setScale();\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var counterLetter = axes.counterLetter(axId);\n    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n    // this happens when updating matched group with 'missing' axes\n    if(!mainPlotinfo) return;\n\n    var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n    var mainLinePosition = ax._mainLinePosition;\n    var mainMirrorPosition = ax._mainMirrorPosition;\n\n    var vals = ax._vals = axes.calcTicks(ax);\n\n    // Add a couple of axis properties that should cause us to recreate\n    // elements. Used in d3 data function.\n    var axInfo = [ax.mirror, mainLinePosition, mainMirrorPosition].join('_');\n    for(i = 0; i < vals.length; i++) {\n        vals[i].axInfo = axInfo;\n    }\n\n    // stash selections to avoid DOM queries e.g.\n    // - stash tickLabels selection, so that drawTitle can use it to scoot title\n    ax._selections = {};\n    // stash tick angle (including the computed 'auto' values) per tick-label class\n    // linkup 'previous' tick angles on redraws\n    if(ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n    ax._tickAngles = {};\n    // measure [in px] between axis position and outward-most part of bounding box\n    // (touching either the tick label or ticks)\n    // depth can be expansive to compute, so we only do so when required\n    ax._depth = null;\n\n    // calcLabelLevelBbox can be expensive,\n    // so make sure to not call it twice during the same Axes.drawOne call\n    // by stashing label-level bounding boxes per tick-label class\n    var llbboxes = {};\n    function getLabelLevelBbox(suffix) {\n        var cls = axId + (suffix || 'tick');\n        if(!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls);\n        return llbboxes[cls];\n    }\n\n    if(!ax.visible) return;\n\n    var transTickFn = axes.makeTransTickFn(ax);\n    var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n\n    var tickVals;\n    // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n    // The key case here is removing zero lines when the axis bound is zero\n    var valsClipped;\n\n    var insideTicks = ax.ticks === 'inside';\n    var outsideTicks = ax.ticks === 'outside';\n\n    if(ax.tickson === 'boundaries') {\n        var boundaryVals = getBoundaryVals(ax, vals);\n        valsClipped = axes.clipEnds(ax, boundaryVals);\n        tickVals = insideTicks ? valsClipped : boundaryVals;\n    } else {\n        valsClipped = axes.clipEnds(ax, vals);\n        tickVals = (insideTicks && ax.ticklabelmode !== 'period') ? valsClipped : vals;\n    }\n\n    var gridVals = ax._gridVals = valsClipped;\n    var dividerVals = getDividerVals(ax, vals);\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        var subplotsWithAx = ax._subplotsWith;\n\n        // keep track of which subplots (by main counter axis) we've already\n        // drawn grids for, so we don't overdraw overlaying subplots\n        var finishedGrids = {};\n\n        for(i = 0; i < subplotsWithAx.length; i++) {\n            sp = subplotsWithAx[i];\n            plotinfo = fullLayout._plots[sp];\n\n            var counterAxis = plotinfo[counterLetter + 'axis'];\n            var mainCounterID = counterAxis._mainAxis._id;\n            if(finishedGrids[mainCounterID]) continue;\n            finishedGrids[mainCounterID] = 1;\n\n            var gridPath = axLetter === 'x' ?\n                'M0,' + counterAxis._offset + 'v' + counterAxis._length :\n                'M' + counterAxis._offset + ',0h' + counterAxis._length;\n\n            axes.drawGrid(gd, ax, {\n                vals: gridVals,\n                counterAxis: counterAxis,\n                layer: plotinfo.gridlayer.select('.' + axId),\n                path: gridPath,\n                transFn: transTickFn\n            });\n            axes.drawZeroLine(gd, ax, {\n                counterAxis: counterAxis,\n                layer: plotinfo.zerolinelayer,\n                path: gridPath,\n                transFn: transTickFn\n            });\n        }\n    }\n\n    var tickSigns = axes.getTickSigns(ax);\n    var tickSubplots = [];\n\n    if(ax.ticks) {\n        var mainTickPath = axes.makeTickPath(ax, mainLinePosition, tickSigns[2]);\n        var mirrorTickPath;\n        var fullTickPath;\n        if(ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n            mirrorTickPath = axes.makeTickPath(ax, mainMirrorPosition, tickSigns[3]);\n            fullTickPath = mainTickPath + mirrorTickPath;\n        } else {\n            mirrorTickPath = '';\n            fullTickPath = mainTickPath;\n        }\n\n        var tickPath;\n        if(ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n            var dividerLookup = {};\n            for(i = 0; i < dividerVals.length; i++) {\n                dividerLookup[dividerVals[i].x] = 1;\n            }\n            tickPath = function(d) {\n                return dividerLookup[d.x] ? mirrorTickPath : fullTickPath;\n            };\n        } else {\n            tickPath = fullTickPath;\n        }\n\n        axes.drawTicks(gd, ax, {\n            vals: tickVals,\n            layer: mainAxLayer,\n            path: tickPath,\n            transFn: transTickFn\n        });\n\n        if(ax.mirror === 'allticks') {\n            tickSubplots = Object.keys(ax._linepositions || {});\n        }\n    }\n\n    for(i = 0; i < tickSubplots.length; i++) {\n        sp = tickSubplots[i];\n        plotinfo = fullLayout._plots[sp];\n        // [bottom or left, top or right], free and main are handled above\n        var linepositions = ax._linepositions[sp] || [];\n        var spTickPath = axes.makeTickPath(ax, linepositions[0], tickSigns[0]) +\n            axes.makeTickPath(ax, linepositions[1], tickSigns[1]);\n\n        axes.drawTicks(gd, ax, {\n            vals: tickVals,\n            layer: plotinfo[axLetter + 'axislayer'],\n            path: spTickPath,\n            transFn: transTickFn\n        });\n    }\n\n    var seq = [];\n\n    // tick labels - for now just the main labels.\n    // TODO: mirror labels, esp for subplots\n\n    seq.push(function() {\n        return axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: mainAxLayer,\n            plotinfo: plotinfo,\n            transFn: transTickLabelFn,\n            labelFns: axes.makeLabelFns(ax, mainLinePosition)\n        });\n    });\n\n    if(ax.type === 'multicategory') {\n        var pad = {x: 2, y: 10}[axLetter];\n\n        seq.push(function() {\n            var bboxKey = {x: 'height', y: 'width'}[axLetter];\n            var standoff = getLabelLevelBbox()[bboxKey] + pad +\n                (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n\n            return axes.drawLabels(gd, ax, {\n                vals: getSecondaryLabelVals(ax, vals),\n                layer: mainAxLayer,\n                cls: axId + 'tick2',\n                repositionOnUpdate: true,\n                secondary: true,\n                transFn: transTickFn,\n                labelFns: axes.makeLabelFns(ax, mainLinePosition + standoff * tickSigns[4])\n            });\n        });\n\n        seq.push(function() {\n            ax._depth = tickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePosition);\n\n            return drawDividers(gd, ax, {\n                vals: dividerVals,\n                layer: mainAxLayer,\n                path: axes.makeTickPath(ax, mainLinePosition, tickSigns[4], ax._depth),\n                transFn: transTickFn\n            });\n        });\n    } else if(ax.title.hasOwnProperty('standoff')) {\n        seq.push(function() {\n            ax._depth = tickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePosition);\n        });\n    }\n\n    var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n\n    seq.push(function() {\n        var s = ax.side.charAt(0);\n        var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n        var pos = axes.getPxPosition(gd, ax);\n        var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n        var llbbox;\n\n        var push;\n        var mirrorPush;\n        var rangeSliderPush;\n\n        if(ax.automargin || hasRangeSlider) {\n            if(ax.type === 'multicategory') {\n                llbbox = getLabelLevelBbox('tick2');\n            } else {\n                llbbox = getLabelLevelBbox();\n                if(axLetter === 'x' && s === 'b') {\n                    ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n                }\n            }\n        }\n\n        if(ax.automargin) {\n            push = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n            var domainIndices = [0, 1];\n\n            if(axLetter === 'x') {\n                if(s === 'b') {\n                    push[s] = ax._depth;\n                } else {\n                    push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.width > 0) {\n                    var rExtra = llbbox.right - (ax._offset + ax._length);\n                    if(rExtra > 0) {\n                        push.xr = 1;\n                        push.r = rExtra;\n                    }\n                    var lExtra = ax._offset - llbbox.left;\n                    if(lExtra > 0) {\n                        push.xl = 0;\n                        push.l = lExtra;\n                    }\n                }\n            } else {\n                if(s === 'l') {\n                    push[s] = ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n                } else {\n                    push[s] = ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n                    domainIndices.reverse();\n                }\n\n                if(llbbox.height > 0) {\n                    var bExtra = llbbox.bottom - (ax._offset + ax._length);\n                    if(bExtra > 0) {\n                        push.yb = 0;\n                        push.b = bExtra;\n                    }\n                    var tExtra = ax._offset - llbbox.top;\n                    if(tExtra > 0) {\n                        push.yt = 1;\n                        push.t = tExtra;\n                    }\n                }\n            }\n\n            push[counterLetter] = ax.anchor === 'free' ?\n                ax.position :\n                ax._anchorAxis.domain[domainIndices[0]];\n\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n            }\n\n            if(ax.mirror && ax.anchor !== 'free') {\n                mirrorPush = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n\n                mirrorPush[sMirror] = ax.linewidth;\n                if(ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n\n                if(ax.mirror === true || ax.mirror === 'ticks') {\n                    mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n                } else if(ax.mirror === 'all' || ax.mirror === 'allticks') {\n                    mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n                }\n            }\n        }\n\n        if(hasRangeSlider) {\n            rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n        }\n\n        Plots.autoMargin(gd, axAutoMarginID(ax), push);\n        Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n        Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n    });\n\n    if(!opts.skipTitle &&\n        !(hasRangeSlider && ax.side === 'bottom')\n    ) {\n        seq.push(function() { return drawTitle(gd, ax); });\n    }\n\n    return Lib.syncOrAsync(seq);\n};\n\nfunction getBoundaryVals(ax, vals) {\n    var out = [];\n    var i;\n\n    // boundaryVals are never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            _push(vals[i], 0);\n        }\n        _push(vals[i - 1], 1);\n    }\n\n    return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n    var out = [];\n    var lookup = {};\n\n    for(var i = 0; i < vals.length; i++) {\n        var d = vals[i];\n        if(lookup[d.text2]) {\n            lookup[d.text2].push(d.x);\n        } else {\n            lookup[d.text2] = [d.x];\n        }\n    }\n\n    for(var k in lookup) {\n        out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n    }\n\n    return out;\n}\n\nfunction getDividerVals(ax, vals) {\n    var out = [];\n    var i, current;\n\n    var reversed = (vals.length && vals[vals.length - 1].x < vals[0].x);\n\n    // never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(ax.showdividers && vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            var d = vals[i];\n            if(d.text2 !== current) {\n                _push(d, reversed ? 1 : 0);\n            }\n            current = d.text2;\n        }\n        _push(vals[i - 1], reversed ? 0 : 1);\n    }\n\n    return out;\n}\n\nfunction calcLabelLevelBbox(ax, cls) {\n    var top, bottom;\n    var left, right;\n\n    if(ax._selections[cls].size()) {\n        top = Infinity;\n        bottom = -Infinity;\n        left = Infinity;\n        right = -Infinity;\n        ax._selections[cls].each(function() {\n            var thisLabel = selectTickLabel(this);\n            // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n            // retrieve a bbox computed with transform info\n            //\n            // To improve perf, it would be nice to use `thisLabel.node()`\n            // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n            // together with the makeLabelFns outputs and `tickangle`\n            // to compute one bbox per (tick value x tick style)\n            var bb = Drawing.bBox(thisLabel.node().parentNode);\n            top = Math.min(top, bb.top);\n            bottom = Math.max(bottom, bb.bottom);\n            left = Math.min(left, bb.left);\n            right = Math.max(right, bb.right);\n        });\n    } else {\n        top = 0;\n        bottom = 0;\n        left = 0;\n        right = 0;\n    }\n\n    return {\n        top: top,\n        bottom: bottom,\n        left: left,\n        right: right,\n        height: bottom - top,\n        width: right - left\n    };\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\naxes.getTickSigns = function(ax) {\n    var axLetter = ax._id.charAt(0);\n    var sideOpposite = {x: 'top', y: 'right'}[axLetter];\n    var main = ax.side === sideOpposite ? 1 : -1;\n    var out = [-1, 1, main, -main];\n    // then we flip if outside XOR y axis\n    if((ax.ticks !== 'inside') === (axLetter === 'x')) {\n        out = out.map(function(v) { return -v; });\n    }\n    // independent of `ticks`; do not flip this one\n    if(ax.side) {\n        out.push({l: -1, t: -1, r: 1, b: 1}[ax.side.charAt(0)]);\n    }\n    return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransTickFn = function(ax) {\n    return ax._id.charAt(0) === 'x' ?\n        function(d) { return strTranslate(ax._offset + ax.l2p(d.x), 0); } :\n        function(d) { return strTranslate(0, ax._offset + ax.l2p(d.x)); };\n};\n\naxes.makeTransTickLabelFn = function(ax) {\n    var uv = getTickLabelUV(ax);\n    var u = uv[0];\n    var v = uv[1];\n\n    return ax._id.charAt(0) === 'x' ?\n        function(d) {\n            return strTranslate(\n                u + ax._offset + ax.l2p(getPosX(d)),\n                v\n            );\n        } :\n        function(d) {\n            return strTranslate(\n                v,\n                u + ax._offset + ax.l2p(getPosX(d))\n            );\n        };\n};\n\nfunction getPosX(d) {\n    return d.periodX !== undefined ? d.periodX : d.x;\n}\n\n// u is a shift along the axis,\n// v is a shift perpendicular to the axis\nfunction getTickLabelUV(ax) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isInside = has('inside');\n\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    // early return\n    if(!isAligned && !isInside) return [0, 0];\n\n    var side = ax.side;\n\n    var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n    var v = TEXTPAD;\n\n    var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    if(isBottom || isTop) {\n        u += fontSize * CAP_SHIFT;\n        v += (ax.linewidth || 0) / 2;\n    }\n    if(isLeft || isRight) {\n        u += (ax.linewidth || 0) / 2;\n        v += TEXTPAD;\n    }\n    if(isInside && side === 'top') {\n        v -= fontSize * (1 - CAP_SHIFT);\n    }\n\n    if(isLeft || isTop) u = -u;\n    if(side === 'bottom' || side === 'right') v = -v;\n\n    return [\n        isAligned ? u : 0,\n        isInside ? v : 0\n    ];\n}\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function(ax, shift, sgn, len) {\n    len = len !== undefined ? len : ax.ticklen;\n\n    var axLetter = ax._id.charAt(0);\n    var pad = (ax.linewidth || 1) / 2;\n\n    return axLetter === 'x' ?\n        'M0,' + (shift + pad * sgn) + 'v' + (len * sgn) :\n        'M' + (shift + pad * sgn) + ',0h' + (len * sgn);\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\naxes.makeLabelFns = function(ax, shift, angle) {\n    var ticklabelposition = ax.ticklabelposition || '';\n    var has = function(str) {\n        return ticklabelposition.indexOf(str) !== -1;\n    };\n\n    var isTop = has('top');\n    var isLeft = has('left');\n    var isRight = has('right');\n    var isBottom = has('bottom');\n    var isAligned = isBottom || isLeft || isTop || isRight;\n\n    var insideTickLabels = has('inside');\n    var labelsOverTicks =\n        (ticklabelposition === 'inside' && ax.ticks === 'inside') ||\n        (!insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries');\n\n    var labelStandoff = 0;\n    var labelShift = 0;\n\n    var tickLen = labelsOverTicks ? ax.ticklen : 0;\n    if(insideTickLabels) {\n        tickLen *= -1;\n    } else if(isAligned) {\n        tickLen = 0;\n    }\n\n    if(labelsOverTicks) {\n        labelStandoff += tickLen;\n        if(angle) {\n            var rad = Lib.deg2rad(angle);\n            labelStandoff = tickLen * Math.cos(rad) + 1;\n            labelShift = tickLen * Math.sin(rad);\n        }\n    }\n\n    if(ax.showticklabels && (labelsOverTicks || ax.showline)) {\n        labelStandoff += 0.2 * ax.tickfont.size;\n    }\n    labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n\n    var out = {\n        labelStandoff: labelStandoff,\n        labelShift: labelShift\n    };\n\n    var x0, y0, ff, flipIt;\n    var xQ = 0;\n\n    var side = ax.side;\n    var axLetter = ax._id.charAt(0);\n    var tickangle = ax.tickangle;\n    var endSide;\n    if(axLetter === 'x') {\n        endSide =\n            (!insideTickLabels && side === 'bottom') ||\n            (insideTickLabels && side === 'top');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelShift * flipIt;\n        y0 = shift + labelStandoff * flipIt;\n        ff = endSide ? 1 : -0.2;\n        if(Math.abs(tickangle) === 90) {\n            if(insideTickLabels) {\n                ff += MID_SHIFT;\n            } else {\n                if(tickangle === -90 && side === 'bottom') {\n                    ff = CAP_SHIFT;\n                } else if(tickangle === 90 && side === 'top') {\n                    ff = MID_SHIFT;\n                } else {\n                    ff = 0.5;\n                }\n            }\n\n            xQ = (MID_SHIFT / 2) * (tickangle / 90);\n        }\n\n        out.xFn = function(d) { return d.dx + x0 + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * ff; };\n        out.anchorFn = function(d, a) {\n            if(isAligned) {\n                if(isLeft) return 'end';\n                if(isRight) return 'start';\n            }\n\n            if(!isNumeric(a) || a === 0 || a === 180) {\n                return 'middle';\n            }\n\n            return ((a * flipIt < 0) !== insideTickLabels) ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            return (a < -60 || a > 60) ? -0.5 * h :\n                ((ax.side === 'top') !== insideTickLabels) ? -h :\n                0;\n        };\n    } else if(axLetter === 'y') {\n        endSide =\n            (!insideTickLabels && side === 'left') ||\n            (insideTickLabels && side === 'right');\n\n        flipIt = endSide ? 1 : -1;\n        if(insideTickLabels) flipIt *= -1;\n\n        x0 = labelStandoff;\n        y0 = labelShift * flipIt;\n        ff = 0;\n        if(!insideTickLabels && Math.abs(tickangle) === 90) {\n            if(\n                (tickangle === -90 && side === 'left') ||\n                (tickangle === 90 && side === 'right')\n            ) {\n                ff = CAP_SHIFT;\n            } else {\n                ff = 0.5;\n            }\n        }\n\n        if(insideTickLabels) {\n            var ang = isNumeric(tickangle) ? +tickangle : 0;\n            if(ang !== 0) {\n                var rA = Lib.deg2rad(ang);\n                xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n                ff = 0;\n            }\n        }\n\n        out.xFn = function(d) { return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize; };\n        out.yFn = function(d) { return d.dy + y0 + d.fontSize * MID_SHIFT; };\n        out.anchorFn = function(d, a) {\n            if(isNumeric(a) && Math.abs(a) === 90) {\n                return 'middle';\n            }\n\n            return endSide ? 'end' : 'start';\n        };\n        out.heightFn = function(d, a, h) {\n            if(ax.side === 'right') a *= -1;\n\n            return a < -30 ? -h :\n                a < 30 ? -0.5 * h :\n                0;\n        };\n    }\n\n    return out;\n};\n\nfunction tickDataFn(d) {\n    return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'tick';\n\n    var vals = opts.vals;\n    if(\n        ax.ticklabelmode === 'period'\n    ) {\n        // drop very first tick that we added to handle period\n        vals = vals.slice();\n        vals.shift();\n    }\n\n    var ticks = opts.layer.selectAll('path.' + cls)\n        .data(ax.ticks ? vals : [], tickDataFn);\n\n    ticks.exit().remove();\n\n    ticks.enter().append('path')\n        .classed(cls, 1)\n        .classed('ticks', 1)\n        .classed('crisp', opts.crisp !== false)\n        .call(Color.stroke, ax.tickcolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.tickwidth, 1) + 'px')\n        .attr('d', opts.path)\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n\n    ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'grid';\n    var vals = opts.vals;\n    var counterAx = opts.counterAxis;\n    if(ax.showgrid === false) {\n        vals = [];\n    } else if(counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n        var isArrayMode = ax.tickmode === 'array';\n        for(var i = 0; i < vals.length; i++) {\n            var xi = vals[i].x;\n            if(isArrayMode ? !xi : (Math.abs(xi) < ax.dtick / 100)) {\n                vals = vals.slice(0, i).concat(vals.slice(i + 1));\n                // In array mode you can in principle have multiple\n                // ticks at 0, so test them all. Otherwise once we found\n                // one we can stop.\n                if(isArrayMode) i--;\n                else break;\n            }\n        }\n    }\n\n    var grid = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    grid.exit().remove();\n\n    grid.enter().append('path')\n        .classed(cls, 1)\n        .classed('crisp', opts.crisp !== false);\n\n    ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n\n    grid.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.gridcolor || '#ddd')\n        .style('stroke-width', ax._gw + 'px')\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [GRID_PATH]);\n\n    if(typeof opts.path === 'function') grid.attr('d', opts.path);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function(gd, ax, opts) {\n    opts = opts || opts;\n\n    var cls = ax._id + 'zl';\n    var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n\n    var zl = opts.layer.selectAll('path.' + cls)\n        .data(show ? [{x: 0, id: ax._id}] : []);\n\n    zl.exit().remove();\n\n    zl.enter().append('path')\n        .classed(cls, 1)\n        .classed('zl', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function() {\n            // use the fact that only one element can enter to trigger a sort.\n            // If several zerolines enter at the same time we will sort once per,\n            // but generally this should be a minimal overhead.\n            opts.layer.selectAll('path').sort(function(da, db) {\n                return idSort(da.id, db.id);\n            });\n        });\n\n    zl.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)\n        .style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px')\n        .style('display', null); // visible\n\n    hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\naxes.drawLabels = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var cls = opts.cls || axId + 'tick';\n    var vals = opts.vals;\n\n    var labelFns = opts.labelFns;\n    var tickAngle = opts.secondary ? 0 : ax.tickangle;\n    var prevAngle = (ax._prevTickAngles || {})[cls];\n\n    var tickLabels = opts.layer.selectAll('g.' + cls)\n        .data(ax.showticklabels ? vals : [], tickDataFn);\n\n    var labelsReady = [];\n\n    tickLabels.enter().append('g')\n        .classed(cls, 1)\n        .append('text')\n            // only so tex has predictable alignment that we can\n            // alter later\n            .attr('text-anchor', 'middle')\n            .each(function(d) {\n                var thisLabel = d3.select(this);\n                var newPromise = gd._promises.length;\n\n                thisLabel\n                    .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d))\n                    .call(Drawing.font, d.font, d.fontSize, d.fontColor)\n                    .text(d.text)\n                    .call(svgTextUtils.convertToTspans, gd);\n\n                if(gd._promises[newPromise]) {\n                    // if we have an async label, we'll deal with that\n                    // all here so take it out of gd._promises and\n                    // instead position the label and promise this in\n                    // labelsReady\n                    labelsReady.push(gd._promises.pop().then(function() {\n                        positionLabels(thisLabel, tickAngle);\n                    }));\n                } else {\n                    // sync label: just position it now.\n                    positionLabels(thisLabel, tickAngle);\n                }\n            });\n\n    hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n\n    tickLabels.exit().remove();\n\n    if(opts.repositionOnUpdate) {\n        tickLabels.each(function(d) {\n            d3.select(this).select('text')\n                .call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n        });\n    }\n\n    function positionLabels(s, angle) {\n        s.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n            var anchor = labelFns.anchorFn(d, angle);\n\n            var transform = opts.transFn.call(thisLabel.node(), d) +\n                ((isNumeric(angle) && +angle !== 0) ?\n                (' rotate(' + angle + ',' + labelFns.xFn(d) + ',' +\n                    (labelFns.yFn(d) - d.fontSize / 2) + ')') :\n                '');\n\n            // how much to shift a multi-line label to center it vertically.\n            var nLines = svgTextUtils.lineCount(thisLabel);\n            var lineHeight = LINE_SPACING * d.fontSize;\n            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n\n            if(anchorHeight) {\n                transform += strTranslate(0, anchorHeight);\n            }\n\n            if(mathjaxGroup.empty()) {\n                var thisText = thisLabel.select('text');\n                thisText.attr({\n                    transform: transform,\n                    'text-anchor': anchor\n                });\n\n                thisText.style('opacity', 1); // visible\n\n                if(ax._adjustTickLabelsOverflow) {\n                    ax._adjustTickLabelsOverflow();\n                }\n            } else {\n                var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n                var mjShift = mjWidth * {end: -0.5, start: 0.5}[anchor];\n                mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n            }\n        });\n    }\n\n    ax._adjustTickLabelsOverflow = function() {\n        var ticklabeloverflow = ax.ticklabeloverflow;\n        if(!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n\n        var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n\n        var isX = ax._id.charAt(0) === 'x';\n        // div positions\n        var p0 = 0;\n        var p1 = isX ?\n            gd._fullLayout.width :\n            gd._fullLayout.height;\n\n        if(ticklabeloverflow.indexOf('domain') !== -1) {\n            // domain positions\n            var rl = Lib.simpleMap(ax.range, ax.r2l);\n            p0 = ax.l2p(rl[0]) + ax._offset;\n            p1 = ax.l2p(rl[1]) + ax._offset;\n        }\n\n        var min = Math.min(p0, p1);\n        var max = Math.max(p0, p1);\n\n        var side = ax.side;\n\n        var visibleLabelMin = Infinity;\n        var visibleLabelMax = -Infinity;\n\n        tickLabels.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n\n            if(mathjaxGroup.empty()) {\n                var bb = Drawing.bBox(thisLabel.node());\n                var adjust = 0;\n                if(isX) {\n                    if(bb.right > max) adjust = 1;\n                    else if(bb.left < min) adjust = 1;\n                } else {\n                    if(bb.bottom > max) adjust = 1;\n                    else if(bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n                }\n\n                var t = thisLabel.select('text');\n                if(adjust) {\n                    if(hideOverflow) t.style('opacity', 0); // hidden\n                } else {\n                    t.style('opacity', 1); // visible\n\n                    if(side === 'bottom' || side === 'right') {\n                        visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n                    } else {\n                        visibleLabelMin = -Infinity;\n                    }\n\n                    if(side === 'top' || side === 'left') {\n                        visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n                    } else {\n                        visibleLabelMax = Infinity;\n                    }\n                }\n            } // TODO: hide mathjax?\n        });\n\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n            if(anchorAx) {\n                anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n                anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n            }\n        }\n    };\n\n    ax._hideCounterAxisInsideTickLabels = function(partialOpts) {\n        var isX = ax._id.charAt(0) === 'x';\n\n        var anchoredAxes = [];\n        for(var subplot in fullLayout._plots) {\n            var plotinfo = fullLayout._plots[subplot];\n            if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n        }\n\n        anchoredAxes.forEach(function(anchorAx, idx) {\n            if(anchorAx && insideTicklabelposition(anchorAx)) {\n                (partialOpts || [\n                    ZERO_PATH,\n                    GRID_PATH,\n                    TICK_PATH,\n                    TICK_TEXT\n                ]).forEach(function(e) {\n                    var isPeriodLabel =\n                        e.K === 'tick' &&\n                        e.L === 'text' &&\n                        ax.ticklabelmode === 'period';\n\n                    var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n\n                    var sel;\n                    if(e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');\n                    else if(e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);\n                    else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n\n                    sel.each(function() {\n                        var w = d3.select(this);\n                        if(e.L) w = w.selectAll(e.L);\n\n                        w.each(function(d) {\n                            var q = ax.l2p(\n                                isPeriodLabel ? getPosX(d) : d.x\n                            ) + ax._offset;\n\n                            var t = d3.select(this);\n                            if(\n                                q < ax['_visibleLabelMax_' + anchorAx._id] &&\n                                q > ax['_visibleLabelMin_' + anchorAx._id]\n                            ) {\n                                t.style('display', 'none'); // hidden\n                            } else if(e.K === 'tick' && !idx) {\n                                t.style('display', null); // visible\n                            }\n                        });\n                    });\n                });\n            }\n        });\n    };\n\n    // make sure all labels are correctly positioned at their base angle\n    // the positionLabels call above is only for newly drawn labels.\n    // do this without waiting, using the last calculated angle to\n    // minimize flicker, then do it again when we know all labels are\n    // there, putting back the prescribed angle to check for overlaps.\n    positionLabels(tickLabels, (prevAngle + 1) ? prevAngle : tickAngle);\n\n    function allLabelsReady() {\n        return labelsReady.length && Promise.all(labelsReady);\n    }\n\n    var autoangle = null;\n\n    function fixLabelOverlaps() {\n        positionLabels(tickLabels, tickAngle);\n\n        // check for auto-angling if x labels overlap\n        // don't auto-angle at all for log axes with\n        // base and digit format\n        if(vals.length && axLetter === 'x' && !isNumeric(tickAngle) &&\n            (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')\n        ) {\n            autoangle = 0;\n\n            var maxFontSize = 0;\n            var lbbArray = [];\n            var i;\n\n            tickLabels.each(function(d) {\n                maxFontSize = Math.max(maxFontSize, d.fontSize);\n\n                var x = ax.l2p(d.x);\n                var thisLabel = selectTickLabel(this);\n                var bb = Drawing.bBox(thisLabel.node());\n\n                lbbArray.push({\n                    // ignore about y, just deal with x overlaps\n                    top: 0,\n                    bottom: 10,\n                    height: 10,\n                    left: x - bb.width / 2,\n                    // impose a 2px gap\n                    right: x + bb.width / 2 + 2,\n                    width: bb.width + 2\n                });\n            });\n\n            if((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n                var gap = 2;\n                if(ax.ticks) gap += ax.tickwidth / 2;\n\n                // TODO should secondary labels also fall into this fix-overlap regime?\n\n                for(i = 0; i < lbbArray.length; i++) {\n                    var xbnd = vals[i].xbnd;\n                    var lbb = lbbArray[i];\n                    if(\n                        (xbnd[0] !== null && (lbb.left - ax.l2p(xbnd[0])) < gap) ||\n                        (xbnd[1] !== null && (ax.l2p(xbnd[1]) - lbb.right) < gap)\n                    ) {\n                        autoangle = 90;\n                        break;\n                    }\n                }\n            } else {\n                var vLen = vals.length;\n                var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n\n                var ticklabelposition = ax.ticklabelposition || '';\n                var has = function(str) {\n                    return ticklabelposition.indexOf(str) !== -1;\n                };\n                var isTop = has('top');\n                var isLeft = has('left');\n                var isRight = has('right');\n                var isBottom = has('bottom');\n                var isAligned = isBottom || isLeft || isTop || isRight;\n                var pad = !isAligned ? 0 :\n                    (ax.tickwidth || 0) + 2 * TEXTPAD;\n\n                var rotate90 = (tickSpacing < maxFontSize * 2.5) || ax.type === 'multicategory';\n\n                // any overlap at all - set 30 degrees or 90 degrees\n                for(i = 0; i < lbbArray.length - 1; i++) {\n                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n                        autoangle = rotate90 ? 90 : 30;\n                        break;\n                    }\n                }\n            }\n\n            if(autoangle) {\n                positionLabels(tickLabels, autoangle);\n            }\n        }\n    }\n\n    if(ax._selections) {\n        ax._selections[cls] = tickLabels;\n    }\n\n    var seq = [allLabelsReady];\n\n    // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n    // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n    // as this can lead to infinite redraw loops!\n    if(ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n        autoangle = 90;\n        seq.push(function() {\n            positionLabels(tickLabels, prevAngle);\n        });\n    } else {\n        seq.push(fixLabelOverlaps);\n    }\n\n    // save current tick angle for future redraws\n    if(ax._tickAngles) {\n        seq.push(function() {\n            ax._tickAngles[cls] = autoangle === null ?\n                (isNumeric(tickAngle) ? tickAngle : 0) :\n                autoangle;\n        });\n    }\n\n    var anchorAx = ax._anchorAxis;\n    if(\n        anchorAx && anchorAx.autorange &&\n        insideTicklabelposition(ax) &&\n        !isLinked(fullLayout, ax._id)\n    ) {\n        if(!fullLayout._insideTickLabelsAutorange) {\n            fullLayout._insideTickLabelsAutorange = {};\n        }\n        fullLayout._insideTickLabelsAutorange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n\n        seq.push(\n            function computeFinalTickLabelBoundingBoxes() {\n                tickLabels.each(function(d, i) {\n                    var thisLabel = selectTickLabel(this);\n                    var mathjaxGroup = thisLabel.select('.text-math-group');\n                    if(mathjaxGroup.empty()) {\n                        ax._vals[i].bb = Drawing.bBox(thisLabel.node());\n                    }\n                });\n            }\n        );\n    }\n\n    var done = Lib.syncOrAsync(seq);\n    if(done && done.then) gd._promises.push(done);\n    return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n    var cls = ax._id + 'divider';\n    var vals = opts.vals;\n\n    var dividers = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    dividers.exit().remove();\n\n    dividers.enter().insert('path', ':first-child')\n        .classed(cls, 1)\n        .classed('crisp', 1)\n        .call(Color.stroke, ax.dividercolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n\n    dividers\n        .attr('transform', opts.transFn)\n        .attr('d', opts.path);\n}\n\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\naxes.getPxPosition = function(gd, ax) {\n    var gs = gd._fullLayout._size;\n    var axLetter = ax._id.charAt(0);\n    var side = ax.side;\n    var anchorAxis;\n\n    if(ax.anchor !== 'free') {\n        anchorAxis = ax._anchorAxis;\n    } else if(axLetter === 'x') {\n        anchorAxis = {\n            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n            _length: 0\n        };\n    } else if(axLetter === 'y') {\n        anchorAxis = {\n            _offset: gs.l + (ax.position || 0) * gs.w,\n            _length: 0\n        };\n    }\n\n    if(side === 'top' || side === 'left') {\n        return anchorAxis._offset;\n    } else if(side === 'bottom' || side === 'right') {\n        return anchorAxis._offset + anchorAxis._length;\n    }\n};\n\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\nfunction approxTitleDepth(ax) {\n    var fontSize = ax.title.font.size;\n    var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n    if(ax.title.hasOwnProperty('standoff')) {\n        return extraLines ?\n            fontSize * (CAP_SHIFT + (extraLines * LINE_SPACING)) :\n            fontSize * CAP_SHIFT;\n    } else {\n        return extraLines ?\n            fontSize * (extraLines + 1) * LINE_SPACING :\n            fontSize;\n    }\n}\n\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\nfunction drawTitle(gd, ax) {\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var fontSize = ax.title.font.size;\n    var titleStandoff;\n\n    if(ax.title.hasOwnProperty('standoff')) {\n        titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);\n    } else {\n        var isInside = insideTicklabelposition(ax);\n\n        if(ax.type === 'multicategory') {\n            titleStandoff = ax._depth;\n        } else {\n            var offsetBase = 1.5 * fontSize;\n            if(isInside) {\n                offsetBase = 0.5 * fontSize;\n                if(ax.ticks === 'outside') {\n                    offsetBase += ax.ticklen;\n                }\n            }\n            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n        }\n\n        if(!isInside) {\n            if(axLetter === 'x') {\n                titleStandoff += ax.side === 'top' ?\n                    fontSize * (ax.showticklabels ? 1 : 0) :\n                    fontSize * (ax.showticklabels ? 1.5 : 0.5);\n            } else {\n                titleStandoff += ax.side === 'right' ?\n                    fontSize * (ax.showticklabels ? 1 : 0.5) :\n                    fontSize * (ax.showticklabels ? 0.5 : 0);\n            }\n        }\n    }\n\n    var pos = axes.getPxPosition(gd, ax);\n    var transform, x, y;\n\n    if(axLetter === 'x') {\n        x = ax._offset + ax._length / 2;\n        y = (ax.side === 'top') ? pos - titleStandoff : pos + titleStandoff;\n    } else {\n        y = ax._offset + ax._length / 2;\n        x = (ax.side === 'right') ? pos + titleStandoff : pos - titleStandoff;\n        transform = {rotate: '-90', offset: 0};\n    }\n\n    var avoid;\n\n    if(ax.type !== 'multicategory') {\n        var tickLabels = ax._selections[ax._id + 'tick'];\n\n        avoid = {\n            selection: tickLabels,\n            side: ax.side\n        };\n\n        if(tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n            var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n            avoid.offsetLeft = translation.x;\n            avoid.offsetTop = translation.y;\n        }\n\n        if(ax.title.hasOwnProperty('standoff')) {\n            avoid.pad = 0;\n        }\n    }\n\n    return Titles.draw(gd, axId + 'title', {\n        propContainer: ax,\n        propName: ax._name + '.title.text',\n        placeholder: fullLayout._dfltTitle[axLetter],\n        avoid: avoid,\n        transform: transform,\n        attributes: {x: x, y: y, 'text-anchor': 'middle'}\n    });\n}\n\naxes.shouldShowZeroLine = function(gd, ax, counterAxis) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    return (\n        (rng[0] * rng[1] <= 0) &&\n        ax.zeroline &&\n        (ax.type === 'linear' || ax.type === '-') &&\n        !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) &&\n        (\n            clipEnds(ax, 0) ||\n            !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) ||\n            hasBarsOrFill(gd, ax)\n        )\n    );\n};\n\naxes.clipEnds = function(ax, vals) {\n    return vals.filter(function(d) { return clipEnds(ax, d.x); });\n};\n\nfunction clipEnds(ax, l) {\n    var p = ax.l2p(l);\n    return (p > 1 && p < ax._length - 1);\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n    var mainCounterAxis = counterAxis._mainAxis;\n    if(!mainCounterAxis) return;\n\n    var fullLayout = gd._fullLayout;\n    var axLetter = ax._id.charAt(0);\n    var counterLetter = axes.counterLetter(ax._id);\n\n    var zeroPosition = ax._offset + (\n        ((Math.abs(rng[0]) < Math.abs(rng[1])) === (axLetter === 'x')) ?\n        0 : ax._length\n    );\n\n    function lineNearZero(ax2) {\n        if(!ax2.showline || !ax2.linewidth) return false;\n        var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n        function closeEnough(pos2) {\n            return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n        }\n\n        if(closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n            return true;\n        }\n        var linePositions = ax2._linepositions || {};\n        for(var k in linePositions) {\n            if(closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n                return true;\n            }\n        }\n    }\n\n    var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n    if(!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n        return lineNearZero(counterAxis, zeroPosition);\n    }\n\n    var counterLetterAxes = axes.list(gd, counterLetter);\n    for(var i = 0; i < counterLetterAxes.length; i++) {\n        var counterAxis2 = counterLetterAxes[i];\n        if(\n            counterAxis2._mainAxis === mainCounterAxis &&\n            lineNearZero(counterAxis2, zeroPosition)\n        ) {\n            return true;\n        }\n    }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n    var fullData = gd._fullData;\n    var subplot = ax._mainSubplot;\n    var axLetter = ax._id.charAt(0);\n\n    for(var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if(trace.visible === true && (trace.xaxis + trace.yaxis) === subplot) {\n            if(\n                Registry.traceIs(trace, 'bar-like') &&\n                trace.orientation === {x: 'h', y: 'v'}[axLetter]\n            ) return true;\n\n            if(\n                trace.fill &&\n                trace.fill.charAt(trace.fill.length - 1) === axLetter\n            ) return true;\n        }\n    }\n    return false;\n}\n\nfunction selectTickLabel(gTick) {\n    var s = d3.select(gTick);\n    var mj = s.select('.text-math-group');\n    return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function(gd) {\n    var axList = axes.list(gd, '', true);\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.automargin) {\n            Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n            if(ax.mirror) {\n                Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n            }\n        }\n        if(Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n        }\n    }\n};\n\nfunction axAutoMarginID(ax) { return ax._id + '.automargin'; }\nfunction axMirrorAutoMarginID(ax) { return axAutoMarginID(ax) + '.mirror'; }\nfunction rangeSliderAutoMarginID(ax) { return ax._id + '.rangeslider'; }\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function(gd, traces) {\n    var axGroups = makeAxisGroups(gd, traces);\n\n    for(var i = 0; i < axGroups.length; i++) {\n        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n    }\n};\n\nfunction makeAxisGroups(gd, traces) {\n    var groups = [];\n    var i, j;\n\n    for(i = 0; i < traces.length; i++) {\n        var groupsi = [];\n        var xi = gd._fullData[traces[i]].xaxis;\n        var yi = gd._fullData[traces[i]].yaxis;\n        if(!xi || !yi) continue; // not a 2D cartesian trace?\n\n        for(j = 0; j < groups.length; j++) {\n            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n                groupsi.push(j);\n            }\n        }\n\n        if(!groupsi.length) {\n            groups.push({x: [xi], y: [yi]});\n            continue;\n        }\n\n        var group0 = groups[groupsi[0]];\n        var groupj;\n\n        if(groupsi.length > 1) {\n            for(j = 1; j < groupsi.length; j++) {\n                groupj = groups[groupsi[j]];\n                mergeAxisGroups(group0.x, groupj.x);\n                mergeAxisGroups(group0.y, groupj.y);\n            }\n        }\n        mergeAxisGroups(group0.x, [xi]);\n        mergeAxisGroups(group0.y, [yi]);\n    }\n\n    return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n    for(var i = 0; i < fromSet.length; i++) {\n        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n    }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n    var xFullAxes = [];\n    var yFullAxes = [];\n    var layout = gd.layout;\n    var i, j;\n\n    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n    var allAxKeys = Object.keys(axAttrs);\n\n    var noSwapAttrs = [\n        'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'\n    ];\n    var numericTypes = ['linear', 'log'];\n\n    for(i = 0; i < allAxKeys.length; i++) {\n        var keyi = allAxKeys[i];\n        var xVal = xFullAxes[0][keyi];\n        var yVal = yFullAxes[0][keyi];\n        var allEqual = true;\n        var coerceLinearX = false;\n        var coerceLinearY = false;\n        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||\n                noSwapAttrs.indexOf(keyi) !== -1) {\n            continue;\n        }\n        for(j = 1; j < xFullAxes.length && allEqual; j++) {\n            var xVali = xFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&\n                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearX = true;\n            } else if(xVali !== xVal) allEqual = false;\n        }\n        for(j = 1; j < yFullAxes.length && allEqual; j++) {\n            var yVali = yFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&\n                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearY = true;\n            } else if(yFullAxes[j][keyi] !== yVal) allEqual = false;\n        }\n        if(allEqual) {\n            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n        }\n    }\n\n    // now swap x&y for any annotations anchored to these x & y\n    for(i = 0; i < gd._fullLayout.annotations.length; i++) {\n        var ann = gd._fullLayout.annotations[i];\n        if(xIds.indexOf(ann.xref) !== -1 &&\n                yIds.indexOf(ann.yref) !== -1) {\n            Lib.swapAttrs(layout.annotations[i], ['?']);\n        }\n    }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n    // in case the value is the default for either axis,\n    // look at the first axis in each list and see if\n    // this key's value is undefined\n    var np = Lib.nestedProperty;\n    var xVal = np(layout[xFullAxes[0]._name], key).get();\n    var yVal = np(layout[yFullAxes[0]._name], key).get();\n    var i;\n\n    if(key === 'title') {\n        // special handling of placeholder titles\n        if(xVal && xVal.text === dfltTitle.x) {\n            xVal.text = dfltTitle.y;\n        }\n        if(yVal && yVal.text === dfltTitle.y) {\n            yVal.text = dfltTitle.x;\n        }\n    }\n\n    for(i = 0; i < xFullAxes.length; i++) {\n        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n    }\n    for(i = 0; i < yFullAxes.length; i++) {\n        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n    }\n}\n\nfunction isAngular(ax) {\n    return ax._id === 'angularaxis';\n}\n\nfunction moveOutsideBreak(v, ax) {\n    var len = ax._rangebreaks.length;\n    for(var k = 0; k < len; k++) {\n        var brk = ax._rangebreaks[k];\n        if(v >= brk.min && v < brk.max) {\n            return brk.max;\n        }\n    }\n    return v;\n}\n\nfunction insideTicklabelposition(ax) {\n    return ((ax.ticklabelposition || '').indexOf('inside') !== -1);\n}\n\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n    if(insideTicklabelposition(ax._anchorAxis || {})) {\n        if(ax._hideCounterAxisInsideTickLabels) {\n            ax._hideCounterAxisInsideTickLabels(opts);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}