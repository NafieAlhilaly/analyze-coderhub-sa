{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n/**\n * aggNums() returns the result of an aggregate function applied to an array of\n * values, where non-numerical values have been tossed out.\n *\n * @param {function} f - aggregation function (e.g., Math.min)\n * @param {Number} v - initial value (continuing from previous calls)\n *      if there's no continuing value, use null for selector-type\n *      functions (max,min), or 0 for summations\n * @param {Array} a - array to aggregate (may be nested, we will recurse,\n *                    but all elements must have the same dimension)\n * @param {Number} len - maximum length of a to aggregate\n * @return {Number} - result of f applied to a starting from v\n */\n\n\nexports.aggNums = function (f, v, a, len) {\n  var i, b;\n  if (!len || len > a.length) len = a.length;\n  if (!isNumeric(v)) v = false;\n\n  if (isArrayOrTypedArray(a[0])) {\n    b = new Array(len);\n\n    for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);\n\n    a = b;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (!isNumeric(v)) v = a[i];else if (isNumeric(a[i])) v = f(+v, +a[i]);\n  }\n\n  return v;\n};\n/**\n * mean & std dev functions using aggNums, so it handles non-numerics nicely\n * even need to use aggNums instead of .length, to toss out non-numerics\n */\n\n\nexports.len = function (data) {\n  return exports.aggNums(function (a) {\n    return a + 1;\n  }, 0, data);\n};\n\nexports.mean = function (data, len) {\n  if (!len) len = exports.len(data);\n  return exports.aggNums(function (a, b) {\n    return a + b;\n  }, 0, data) / len;\n};\n\nexports.midRange = function (numArr) {\n  if (numArr === undefined || numArr.length === 0) return undefined;\n  return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;\n};\n\nexports.variance = function (data, len, mean) {\n  if (!len) len = exports.len(data);\n  if (!isNumeric(mean)) mean = exports.mean(data, len);\n  return exports.aggNums(function (a, b) {\n    return a + Math.pow(b - mean, 2);\n  }, 0, data) / len;\n};\n\nexports.stdev = function (data, len, mean) {\n  return Math.sqrt(exports.variance(data, len, mean));\n};\n/**\n * median of a finite set of numbers\n * reference page: https://en.wikipedia.org/wiki/Median#Finite_set_of_numbers\n**/\n\n\nexports.median = function (data) {\n  var b = data.slice().sort();\n  return exports.interp(b, 0.5);\n};\n/**\n * interp() computes a percentile (quantile) for a given distribution.\n * We interpolate the distribution (to compute quantiles, we follow method #10 here:\n * http://www.amstat.org/publications/jse/v14n3/langford.html).\n * Typically the index or rank (n * arr.length) may be non-integer.\n * For reference: ends are clipped to the extreme values in the array;\n * For box plots: index you get is half a point too high (see\n * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition\n * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).\n *\n * @param {Array} arr - This array contains the values that make up the distribution.\n * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.\n * For example, the 50th percentile (or median) corresponds to n = 0.5\n * @return {Number} - percentile\n */\n\n\nexports.interp = function (arr, n) {\n  if (!isNumeric(n)) throw 'n should be a finite number';\n  n = n * arr.length - 0.5;\n  if (n < 0) return arr[0];\n  if (n > arr.length - 1) return arr[arr.length - 1];\n  var frac = n % 1;\n  return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/lib/stats.js"],"names":["isNumeric","require","isArrayOrTypedArray","exports","aggNums","f","v","a","len","i","b","length","Array","data","mean","midRange","numArr","undefined","Math","max","min","variance","pow","stdev","sqrt","median","slice","sort","interp","arr","n","frac","ceil","floor"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAD,CAAvB;;AACA,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,mBAA7C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,OAAO,CAACC,OAAR,GAAkB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,GAAlB,EAAuB;AACrC,MAAIC,CAAJ,EACIC,CADJ;AAEA,MAAG,CAACF,GAAD,IAAQA,GAAG,GAAGD,CAAC,CAACI,MAAnB,EAA2BH,GAAG,GAAGD,CAAC,CAACI,MAAR;AAC3B,MAAG,CAACX,SAAS,CAACM,CAAD,CAAb,EAAkBA,CAAC,GAAG,KAAJ;;AAClB,MAAGJ,mBAAmB,CAACK,CAAC,CAAC,CAAD,CAAF,CAAtB,EAA8B;AAC1BG,IAAAA,CAAC,GAAG,IAAIE,KAAJ,CAAUJ,GAAV,CAAJ;;AACA,SAAIC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGD,GAAf,EAAoBC,CAAC,EAArB,EAAyBC,CAAC,CAACD,CAAD,CAAD,GAAON,OAAO,CAACC,OAAR,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAC,CAACE,CAAD,CAAvB,CAAP;;AACzBF,IAAAA,CAAC,GAAGG,CAAJ;AACH;;AAED,OAAID,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGD,GAAf,EAAoBC,CAAC,EAArB,EAAyB;AACrB,QAAG,CAACT,SAAS,CAACM,CAAD,CAAb,EAAkBA,CAAC,GAAGC,CAAC,CAACE,CAAD,CAAL,CAAlB,KACK,IAAGT,SAAS,CAACO,CAAC,CAACE,CAAD,CAAF,CAAZ,EAAoBH,CAAC,GAAGD,CAAC,CAAC,CAACC,CAAF,EAAK,CAACC,CAAC,CAACE,CAAD,CAAP,CAAL;AAC5B;;AACD,SAAOH,CAAP;AACH,CAhBD;AAkBA;AACA;AACA;AACA;;;AACAH,OAAO,CAACK,GAAR,GAAc,UAASK,IAAT,EAAe;AACzB,SAAOV,OAAO,CAACC,OAAR,CAAgB,UAASG,CAAT,EAAY;AAAE,WAAOA,CAAC,GAAG,CAAX;AAAe,GAA7C,EAA+C,CAA/C,EAAkDM,IAAlD,CAAP;AACH,CAFD;;AAIAV,OAAO,CAACW,IAAR,GAAe,UAASD,IAAT,EAAeL,GAAf,EAAoB;AAC/B,MAAG,CAACA,GAAJ,EAASA,GAAG,GAAGL,OAAO,CAACK,GAAR,CAAYK,IAAZ,CAAN;AACT,SAAOV,OAAO,CAACC,OAAR,CAAgB,UAASG,CAAT,EAAYG,CAAZ,EAAe;AAAE,WAAOH,CAAC,GAAGG,CAAX;AAAe,GAAhD,EAAkD,CAAlD,EAAqDG,IAArD,IAA6DL,GAApE;AACH,CAHD;;AAKAL,OAAO,CAACY,QAAR,GAAmB,UAASC,MAAT,EAAiB;AAChC,MAAGA,MAAM,KAAKC,SAAX,IAAwBD,MAAM,CAACL,MAAP,KAAkB,CAA7C,EAAgD,OAAOM,SAAP;AAChD,SAAO,CAACd,OAAO,CAACC,OAAR,CAAgBc,IAAI,CAACC,GAArB,EAA0B,IAA1B,EAAgCH,MAAhC,IAA0Cb,OAAO,CAACC,OAAR,CAAgBc,IAAI,CAACE,GAArB,EAA0B,IAA1B,EAAgCJ,MAAhC,CAA3C,IAAsF,CAA7F;AACH,CAHD;;AAKAb,OAAO,CAACkB,QAAR,GAAmB,UAASR,IAAT,EAAeL,GAAf,EAAoBM,IAApB,EAA0B;AACzC,MAAG,CAACN,GAAJ,EAASA,GAAG,GAAGL,OAAO,CAACK,GAAR,CAAYK,IAAZ,CAAN;AACT,MAAG,CAACb,SAAS,CAACc,IAAD,CAAb,EAAqBA,IAAI,GAAGX,OAAO,CAACW,IAAR,CAAaD,IAAb,EAAmBL,GAAnB,CAAP;AAErB,SAAOL,OAAO,CAACC,OAAR,CAAgB,UAASG,CAAT,EAAYG,CAAZ,EAAe;AAClC,WAAOH,CAAC,GAAGW,IAAI,CAACI,GAAL,CAASZ,CAAC,GAAGI,IAAb,EAAmB,CAAnB,CAAX;AACH,GAFM,EAEJ,CAFI,EAEDD,IAFC,IAEOL,GAFd;AAGH,CAPD;;AASAL,OAAO,CAACoB,KAAR,GAAgB,UAASV,IAAT,EAAeL,GAAf,EAAoBM,IAApB,EAA0B;AACtC,SAAOI,IAAI,CAACM,IAAL,CAAUrB,OAAO,CAACkB,QAAR,CAAiBR,IAAjB,EAAuBL,GAAvB,EAA4BM,IAA5B,CAAV,CAAP;AACH,CAFD;AAIA;AACA;AACA;AACA;;;AACAX,OAAO,CAACsB,MAAR,GAAiB,UAASZ,IAAT,EAAe;AAC5B,MAAIH,CAAC,GAAGG,IAAI,CAACa,KAAL,GAAaC,IAAb,EAAR;AACA,SAAOxB,OAAO,CAACyB,MAAR,CAAelB,CAAf,EAAkB,GAAlB,CAAP;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAP,OAAO,CAACyB,MAAR,GAAiB,UAASC,GAAT,EAAcC,CAAd,EAAiB;AAC9B,MAAG,CAAC9B,SAAS,CAAC8B,CAAD,CAAb,EAAkB,MAAM,6BAAN;AAClBA,EAAAA,CAAC,GAAGA,CAAC,GAAGD,GAAG,CAAClB,MAAR,GAAiB,GAArB;AACA,MAAGmB,CAAC,GAAG,CAAP,EAAU,OAAOD,GAAG,CAAC,CAAD,CAAV;AACV,MAAGC,CAAC,GAAGD,GAAG,CAAClB,MAAJ,GAAa,CAApB,EAAuB,OAAOkB,GAAG,CAACA,GAAG,CAAClB,MAAJ,GAAa,CAAd,CAAV;AACvB,MAAIoB,IAAI,GAAGD,CAAC,GAAG,CAAf;AACA,SAAOC,IAAI,GAAGF,GAAG,CAACX,IAAI,CAACc,IAAL,CAAUF,CAAV,CAAD,CAAV,GAA2B,CAAC,IAAIC,IAAL,IAAaF,GAAG,CAACX,IAAI,CAACe,KAAL,CAAWH,CAAX,CAAD,CAAlD;AACH,CAPD","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n\n/**\n * aggNums() returns the result of an aggregate function applied to an array of\n * values, where non-numerical values have been tossed out.\n *\n * @param {function} f - aggregation function (e.g., Math.min)\n * @param {Number} v - initial value (continuing from previous calls)\n *      if there's no continuing value, use null for selector-type\n *      functions (max,min), or 0 for summations\n * @param {Array} a - array to aggregate (may be nested, we will recurse,\n *                    but all elements must have the same dimension)\n * @param {Number} len - maximum length of a to aggregate\n * @return {Number} - result of f applied to a starting from v\n */\nexports.aggNums = function(f, v, a, len) {\n    var i,\n        b;\n    if(!len || len > a.length) len = a.length;\n    if(!isNumeric(v)) v = false;\n    if(isArrayOrTypedArray(a[0])) {\n        b = new Array(len);\n        for(i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);\n        a = b;\n    }\n\n    for(i = 0; i < len; i++) {\n        if(!isNumeric(v)) v = a[i];\n        else if(isNumeric(a[i])) v = f(+v, +a[i]);\n    }\n    return v;\n};\n\n/**\n * mean & std dev functions using aggNums, so it handles non-numerics nicely\n * even need to use aggNums instead of .length, to toss out non-numerics\n */\nexports.len = function(data) {\n    return exports.aggNums(function(a) { return a + 1; }, 0, data);\n};\n\nexports.mean = function(data, len) {\n    if(!len) len = exports.len(data);\n    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;\n};\n\nexports.midRange = function(numArr) {\n    if(numArr === undefined || numArr.length === 0) return undefined;\n    return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;\n};\n\nexports.variance = function(data, len, mean) {\n    if(!len) len = exports.len(data);\n    if(!isNumeric(mean)) mean = exports.mean(data, len);\n\n    return exports.aggNums(function(a, b) {\n        return a + Math.pow(b - mean, 2);\n    }, 0, data) / len;\n};\n\nexports.stdev = function(data, len, mean) {\n    return Math.sqrt(exports.variance(data, len, mean));\n};\n\n/**\n * median of a finite set of numbers\n * reference page: https://en.wikipedia.org/wiki/Median#Finite_set_of_numbers\n**/\nexports.median = function(data) {\n    var b = data.slice().sort();\n    return exports.interp(b, 0.5);\n};\n\n/**\n * interp() computes a percentile (quantile) for a given distribution.\n * We interpolate the distribution (to compute quantiles, we follow method #10 here:\n * http://www.amstat.org/publications/jse/v14n3/langford.html).\n * Typically the index or rank (n * arr.length) may be non-integer.\n * For reference: ends are clipped to the extreme values in the array;\n * For box plots: index you get is half a point too high (see\n * http://en.wikipedia.org/wiki/Percentile#Nearest_rank) but note that this definition\n * indexes from 1 rather than 0, so we subtract 1/2 (instead of add).\n *\n * @param {Array} arr - This array contains the values that make up the distribution.\n * @param {Number} n - Between 0 and 1, n = p/100 is such that we compute the p^th percentile.\n * For example, the 50th percentile (or median) corresponds to n = 0.5\n * @return {Number} - percentile\n */\nexports.interp = function(arr, n) {\n    if(!isNumeric(n)) throw 'n should be a finite number';\n    n = n * arr.length - 0.5;\n    if(n < 0) return arr[0];\n    if(n > arr.length - 1) return arr[arr.length - 1];\n    var frac = n % 1;\n    return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];\n};\n"]},"metadata":{},"sourceType":"script"}