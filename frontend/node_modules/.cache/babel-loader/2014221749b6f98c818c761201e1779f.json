{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\n\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar barPlot = require('../bar/plot');\n\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\n\nvar constants = require('./constants');\n\nvar drawAncestors = require('./draw_ancestors');\n\nfunction getKey(pt) {\n  return helpers.isHierarchyRoot(pt) ? '' : // don't use the dummyId\n  helpers.getPtId(pt);\n}\n\nmodule.exports = function plotOne(gd, cd, element, transitionOpts, drawDescendants) {\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var type = trace.type;\n  var isIcicle = type === 'icicle';\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var gTrace = d3.select(element);\n  var selAncestors = gTrace.selectAll('g.pathbar');\n  var selDescendants = gTrace.selectAll('g.slice');\n\n  if (!entry) {\n    selAncestors.remove();\n    selDescendants.remove();\n    return;\n  }\n\n  var isRoot = helpers.isHierarchyRoot(entry);\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var maxDepth = helpers.getMaxDepth(trace);\n\n  var hasVisibleDepth = function (pt) {\n    return pt.data.depth - entry.data.depth < maxDepth;\n  };\n\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var barW = vpw;\n  var barH = trace.pathbar.thickness;\n  var barPad = trace.marker.line.width + constants.gapWithPathbar;\n  var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n  var pathbarOrigin = {\n    x0: barW,\n    // slide to the right\n    x1: barW,\n    y0: barDifY,\n    y1: barDifY + barH\n  };\n\n  var findClosestEdge = function (pt, ref, size) {\n    var e = trace.tiling.pad;\n\n    var isLeftOfRect = function (x) {\n      return x - e <= ref.x0;\n    };\n\n    var isRightOfRect = function (x) {\n      return x + e >= ref.x1;\n    };\n\n    var isBottomOfRect = function (y) {\n      return y - e <= ref.y0;\n    };\n\n    var isTopOfRect = function (y) {\n      return y + e >= ref.y1;\n    };\n\n    if (pt.x0 === ref.x0 && pt.x1 === ref.x1 && pt.y0 === ref.y0 && pt.y1 === ref.y1) {\n      return {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n    }\n\n    return {\n      x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n      x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n      y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n      y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n    };\n  }; // stash of 'previous' position data used by tweening functions\n\n\n  var prevEntry = null;\n  var prevLookupPathbar = {};\n  var prevLookupSlices = {};\n  var nextOfPrevEntry = null;\n\n  var getPrev = function (pt, onPathbar) {\n    return onPathbar ? prevLookupPathbar[getKey(pt)] : prevLookupSlices[getKey(pt)];\n  };\n\n  var getOrigin = function (pt, onPathbar, refRect, size) {\n    if (onPathbar) {\n      return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n    } else {\n      var ref = prevLookupSlices[trace.level] || refRect;\n\n      if (hasVisibleDepth(pt)) {\n        // case of an empty object - happens when maxdepth is set\n        return findClosestEdge(pt, ref, size);\n      }\n    }\n\n    return {};\n  }; // N.B. handle multiple-root special case\n\n\n  if (cd0.hasMultipleRoots && isRoot) {\n    maxDepth++;\n  }\n\n  trace._maxDepth = maxDepth;\n  trace._backgroundColor = fullLayout.paper_bgcolor;\n  trace._entryDepth = entry.data.depth;\n  trace._atRootLevel = isRoot;\n  var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n  var viewMapX = function (x) {\n    return cenX + x;\n  };\n\n  var viewMapY = function (y) {\n    return cenY + y;\n  };\n\n  var barY0 = viewMapY(0);\n  var barX0 = viewMapX(0);\n\n  var viewBarX = function (x) {\n    return barX0 + x;\n  };\n\n  var viewBarY = function (y) {\n    return barY0 + y;\n  };\n\n  function pos(x, y) {\n    return x + ',' + y;\n  }\n\n  var xStart = viewBarX(0);\n\n  var limitX0 = function (p) {\n    p.x = Math.max(xStart, p.x);\n  };\n\n  var edgeshape = trace.pathbar.edgeshape; // pathbar(directory) path generation fn\n\n  var pathAncestor = function (d) {\n    var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n\n    var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n\n    var _y0 = viewBarY(d.y0);\n\n    var _y1 = viewBarY(d.y1);\n\n    var halfH = barH / 2;\n    var pL = {};\n    var pR = {};\n    pL.x = _x0;\n    pR.x = _x1;\n    pL.y = pR.y = (_y0 + _y1) / 2;\n    var pA = {\n      x: _x0,\n      y: _y0\n    };\n    var pB = {\n      x: _x1,\n      y: _y0\n    };\n    var pC = {\n      x: _x1,\n      y: _y1\n    };\n    var pD = {\n      x: _x0,\n      y: _y1\n    };\n\n    if (edgeshape === '>') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pC.x -= halfH;\n      pD.x -= halfH;\n    } else if (edgeshape === '/') {\n      pC.x -= halfH;\n      pD.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '\\\\') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '<') {\n      pL.x -= halfH;\n      pR.x -= halfH;\n    }\n\n    limitX0(pA);\n    limitX0(pD);\n    limitX0(pL);\n    limitX0(pB);\n    limitX0(pC);\n    limitX0(pR);\n    return 'M' + pos(pA.x, pA.y) + 'L' + pos(pB.x, pB.y) + 'L' + pos(pR.x, pR.y) + 'L' + pos(pC.x, pC.y) + 'L' + pos(pD.x, pD.y) + 'L' + pos(pL.x, pL.y) + 'Z';\n  }; // slice path generation fn\n\n\n  var pathDescendant = function (d) {\n    var _x0 = viewMapX(d.x0);\n\n    var _x1 = viewMapX(d.x1);\n\n    var _y0 = viewMapY(d.y0);\n\n    var _y1 = viewMapY(d.y1);\n\n    var dx = _x1 - _x0;\n    var dy = _y1 - _y0;\n    if (!dx || !dy) return '';\n    var FILLET = 0; // TODO: may expose this constant\n\n    var r = dx > 2 * FILLET && dy > 2 * FILLET ? FILLET : 0;\n\n    var arc = function (rx, ry) {\n      return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : '';\n    };\n\n    return 'M' + pos(_x0, _y0 + r) + arc(r, -r) + 'L' + pos(_x1 - r, _y0) + arc(r, r) + 'L' + pos(_x1, _y1 - r) + arc(-r, r) + 'L' + pos(_x0 + r, _y1) + arc(-r, -r) + 'Z';\n  };\n\n  var toMoveInsideSlice = function (pt, opts) {\n    var x0 = pt.x0;\n    var x1 = pt.x1;\n    var y0 = pt.y0;\n    var y1 = pt.y1;\n    var textBB = pt.textBB;\n\n    var hasFlag = function (f) {\n      return trace.textposition.indexOf(f) !== -1;\n    };\n\n    var hasBottom = hasFlag('bottom');\n    var hasTop = hasFlag('top') || opts.isHeader && !hasBottom;\n    var anchor = hasTop ? 'start' : hasBottom ? 'end' : 'middle';\n    var hasRight = hasFlag('right');\n    var hasLeft = hasFlag('left') || opts.onPathbar;\n    var leftToRight = hasLeft ? -1 : hasRight ? 1 : 0; // Note that `pad` is just an integer for `icicle`` traces where\n    // `pad` is a hashmap for treemap: pad.t, pad.b, pad.l, and pad.r\n\n    var pad = trace[isIcicle ? 'tiling' : 'marker'].pad;\n\n    if (opts.isHeader) {\n      x0 += (isIcicle ? pad : pad.l) - TEXTPAD;\n      x1 -= (isIcicle ? pad : pad.r) - TEXTPAD;\n\n      if (x0 >= x1) {\n        var mid = (x0 + x1) / 2;\n        x0 = mid;\n        x1 = mid;\n      } // limit the drawing area for headers\n\n\n      var limY;\n\n      if (hasBottom) {\n        limY = y1 - (isIcicle ? pad : pad.b);\n        if (y0 < limY && limY < y1) y0 = limY;\n      } else {\n        limY = y0 + (isIcicle ? pad : pad.t);\n        if (y0 < limY && limY < y1) y1 = limY;\n      }\n    } // position the text relative to the slice\n\n\n    var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: false,\n      constrained: true,\n      angle: 0,\n      anchor: anchor,\n      leftToRight: leftToRight\n    });\n    transform.fontSize = opts.fontSize;\n    transform.targetX = viewMapX(transform.targetX);\n    transform.targetY = viewMapY(transform.targetY);\n\n    if (isNaN(transform.targetX) || isNaN(transform.targetY)) {\n      return {};\n    }\n\n    if (x0 !== x1 && y0 !== y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return {\n      scale: transform.scale,\n      rotate: transform.rotate,\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY\n    };\n  };\n\n  var interpFromParent = function (pt, onPathbar) {\n    var parentPrev;\n    var i = 0;\n    var Q = pt;\n\n    while (!parentPrev && i < maxDepth) {\n      // loop to find a parent/grandParent on the previous graph\n      i++;\n      Q = Q.parent;\n\n      if (Q) {\n        parentPrev = getPrev(Q, onPathbar);\n      } else i = maxDepth;\n    }\n\n    return parentPrev || {};\n  };\n\n  var makeExitSliceInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev = getPrev(pt, onPathbar);\n    var next;\n\n    if (onPathbar) {\n      next = pathbarOrigin;\n    } else {\n      var entryPrev = getPrev(entry, onPathbar);\n\n      if (entryPrev) {\n        // 'entryPrev' is here has the previous coordinates of the entry\n        // node, which corresponds to the last \"clicked\" node when zooming in\n        next = findClosestEdge(pt, entryPrev, size);\n      } else {\n        // this happens when maxdepth is set, when leaves must\n        // be removed and the entry is new (i.e. does not have a 'prev' object)\n        next = {};\n      }\n    }\n\n    return interpolate(prev, next);\n  };\n\n  var makeUpdateSliceInterpolator = function (pt, onPathbar, refRect, size, opts) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev;\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (onPathbar) {\n        prev = pathbarOrigin;\n      } else {\n        if (prevEntry) {\n          // if trace was visible before\n          if (pt.parent) {\n            var ref = nextOfPrevEntry || refRect;\n\n            if (ref && !onPathbar) {\n              prev = findClosestEdge(pt, ref, size);\n            } else {\n              // if new leaf (when maxdepth is set),\n              // grow it from its parent node\n              prev = {};\n              Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n          } else {\n            prev = Lib.extendFlat({}, pt);\n\n            if (isIcicle) {\n              if (opts.orientation === 'h') {\n                if (opts.flipX) prev.x0 = pt.x1;else prev.x1 = 0;\n              } else {\n                if (opts.flipY) prev.y0 = pt.y1;else prev.y1 = 0;\n              }\n            }\n          }\n        } else {\n          prev = {};\n        }\n      }\n    }\n\n    return interpolate(prev, {\n      x0: pt.x0,\n      x1: pt.x1,\n      y0: pt.y0,\n      y1: pt.y1\n    });\n  };\n\n  var makeUpdateTextInterpolator = function (pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev = {};\n    var origin = getOrigin(pt, onPathbar, refRect, size);\n    Lib.extendFlat(prev, {\n      transform: toMoveInsideSlice({\n        x0: origin.x0,\n        x1: origin.x1,\n        y0: origin.y0,\n        y1: origin.y1,\n        textBB: pt.textBB,\n        _text: pt._text\n      }, {\n        isHeader: helpers.isHeader(pt, trace)\n      })\n    });\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (pt.parent) {\n        Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n      }\n    }\n\n    var transform = pt.transform;\n\n    if (pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return interpolate(prev, {\n      transform: {\n        scale: transform.scale,\n        rotate: transform.rotate,\n        textX: transform.textX,\n        textY: transform.textY,\n        anchorX: transform.anchorX,\n        anchorY: transform.anchorY,\n        targetX: transform.targetX,\n        targetY: transform.targetY\n      }\n    });\n  };\n\n  var handleSlicesExit = function (slices, onPathbar, refRect, size, pathSlice) {\n    var width = size[0];\n    var height = size[1];\n\n    if (hasTransition) {\n      slices.exit().transition().each(function () {\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.select('path.surface');\n        slicePath.transition().attrTween('d', function (pt2) {\n          var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n          return function (t) {\n            return pathSlice(interp(t));\n          };\n        });\n        var sliceTextGroup = sliceTop.select('g.slicetext');\n        sliceTextGroup.attr('opacity', 0);\n      }).remove();\n    } else {\n      slices.exit().remove();\n    }\n  };\n\n  var strTransform = function (d) {\n    var transform = d.transform;\n\n    if (d.x0 !== d.x1 && d.y0 !== d.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return Lib.getTextTransform({\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY,\n      scale: transform.scale,\n      rotate: transform.rotate\n    });\n  };\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    selAncestors.each(function (pt) {\n      prevLookupPathbar[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupPathbar[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n    });\n    selDescendants.each(function (pt) {\n      prevLookupSlices[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupSlices[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n\n  nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n    width: vpw,\n    height: vph,\n    viewX: viewMapX,\n    viewY: viewMapY,\n    pathSlice: pathDescendant,\n    toMoveInsideSlice: toMoveInsideSlice,\n    prevEntry: prevEntry,\n    makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n    makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n    handleSlicesExit: handleSlicesExit,\n    hasTransition: hasTransition,\n    strTransform: strTransform\n  });\n\n  if (trace.pathbar.visible) {\n    drawAncestors(gd, cd, entry, selAncestors, {\n      barDifY: barDifY,\n      width: barW,\n      height: barH,\n      viewX: viewBarX,\n      viewY: viewBarY,\n      pathSlice: pathAncestor,\n      toMoveInsideSlice: toMoveInsideSlice,\n      makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n      makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n      handleSlicesExit: handleSlicesExit,\n      hasTransition: hasTransition,\n      strTransform: strTransform\n    });\n  } else {\n    selAncestors.remove();\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/treemap/plot_one.js"],"names":["d3","require","interpolate","helpers","Lib","TEXTPAD","barPlot","toMoveInsideBar","uniformText","recordMinTextSize","constants","drawAncestors","getKey","pt","isHierarchyRoot","getPtId","module","exports","plotOne","gd","cd","element","transitionOpts","drawDescendants","fullLayout","_fullLayout","cd0","trace","type","isIcicle","hierarchy","entry","findEntryWithLevel","level","gTrace","select","selAncestors","selectAll","selDescendants","remove","isRoot","hasTransition","uniformtext","mode","maxDepth","getMaxDepth","hasVisibleDepth","data","depth","gs","_size","domain","vpw","w","x","vph","h","y","barW","barH","pathbar","thickness","barPad","marker","line","width","gapWithPathbar","barDifY","visible","side","indexOf","pathbarOrigin","x0","x1","y0","y1","findClosestEdge","ref","size","e","tiling","pad","isLeftOfRect","isRightOfRect","isBottomOfRect","isTopOfRect","prevEntry","prevLookupPathbar","prevLookupSlices","nextOfPrevEntry","getPrev","onPathbar","getOrigin","refRect","hasMultipleRoots","_maxDepth","_backgroundColor","paper_bgcolor","_entryDepth","_atRootLevel","cenX","l","cenY","t","viewMapX","viewMapY","barY0","barX0","viewBarX","viewBarY","pos","xStart","limitX0","p","Math","max","edgeshape","pathAncestor","d","_x0","min","_x1","_y0","_y1","halfH","pL","pR","pA","pB","pC","pD","pathDescendant","dx","dy","FILLET","r","arc","rx","ry","toMoveInsideSlice","opts","textBB","hasFlag","f","textposition","hasBottom","hasTop","isHeader","anchor","hasRight","hasLeft","leftToRight","mid","limY","b","transform","isHorizontal","constrained","angle","fontSize","targetX","targetY","isNaN","scale","rotate","textX","textY","anchorX","anchorY","interpFromParent","parentPrev","i","Q","parent","makeExitSliceInterpolator","prev","next","entryPrev","makeUpdateSliceInterpolator","prev0","extendFlat","orientation","flipX","flipY","makeUpdateTextInterpolator","origin","_text","handleSlicesExit","slices","pathSlice","height","exit","transition","each","sliceTop","slicePath","attrTween","pt2","interp","sliceTextGroup","attr","strTransform","getTextTransform","isEntry","viewX","viewY"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\nvar barPlot = require('../bar/plot');\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar constants = require('./constants');\nvar drawAncestors = require('./draw_ancestors');\n\nfunction getKey(pt) {\n    return helpers.isHierarchyRoot(pt) ?\n        '' : // don't use the dummyId\n        helpers.getPtId(pt);\n}\n\nmodule.exports = function plotOne(gd, cd, element, transitionOpts, drawDescendants) {\n    var fullLayout = gd._fullLayout;\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var type = trace.type;\n    var isIcicle = type === 'icicle';\n\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n\n    var gTrace = d3.select(element);\n    var selAncestors = gTrace.selectAll('g.pathbar');\n    var selDescendants = gTrace.selectAll('g.slice');\n\n    if(!entry) {\n        selAncestors.remove();\n        selDescendants.remove();\n        return;\n    }\n\n    var isRoot = helpers.isHierarchyRoot(entry);\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var maxDepth = helpers.getMaxDepth(trace);\n    var hasVisibleDepth = function(pt) {\n        return pt.data.depth - entry.data.depth < maxDepth;\n    };\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var barW = vpw;\n    var barH = trace.pathbar.thickness;\n    var barPad = trace.marker.line.width + constants.gapWithPathbar;\n    var barDifY = !trace.pathbar.visible ? 0 :\n        trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n\n    var pathbarOrigin = {\n        x0: barW, // slide to the right\n        x1: barW,\n        y0: barDifY,\n        y1: barDifY + barH\n    };\n\n    var findClosestEdge = function(pt, ref, size) {\n        var e = trace.tiling.pad;\n        var isLeftOfRect = function(x) { return x - e <= ref.x0; };\n        var isRightOfRect = function(x) { return x + e >= ref.x1; };\n        var isBottomOfRect = function(y) { return y - e <= ref.y0; };\n        var isTopOfRect = function(y) { return y + e >= ref.y1; };\n\n        if(pt.x0 === ref.x0 && pt.x1 === ref.x1 && pt.y0 === ref.y0 && pt.y1 === ref.y1) {\n            return {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n        }\n\n        return {\n            x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n            x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n            y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n            y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n        };\n    };\n\n    // stash of 'previous' position data used by tweening functions\n    var prevEntry = null;\n    var prevLookupPathbar = {};\n    var prevLookupSlices = {};\n    var nextOfPrevEntry = null;\n    var getPrev = function(pt, onPathbar) {\n        return onPathbar ?\n            prevLookupPathbar[getKey(pt)] :\n            prevLookupSlices[getKey(pt)];\n    };\n\n    var getOrigin = function(pt, onPathbar, refRect, size) {\n        if(onPathbar) {\n            return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n        } else {\n            var ref = prevLookupSlices[trace.level] || refRect;\n\n            if(hasVisibleDepth(pt)) { // case of an empty object - happens when maxdepth is set\n                return findClosestEdge(pt, ref, size);\n            }\n        }\n        return {};\n    };\n\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && isRoot) {\n        maxDepth++;\n    }\n\n    trace._maxDepth = maxDepth;\n    trace._backgroundColor = fullLayout.paper_bgcolor;\n    trace._entryDepth = entry.data.depth;\n    trace._atRootLevel = isRoot;\n\n    var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n    var viewMapX = function(x) { return cenX + x; };\n    var viewMapY = function(y) { return cenY + y; };\n\n    var barY0 = viewMapY(0);\n    var barX0 = viewMapX(0);\n\n    var viewBarX = function(x) { return barX0 + x; };\n    var viewBarY = function(y) { return barY0 + y; };\n\n    function pos(x, y) {\n        return x + ',' + y;\n    }\n\n    var xStart = viewBarX(0);\n    var limitX0 = function(p) { p.x = Math.max(xStart, p.x); };\n\n    var edgeshape = trace.pathbar.edgeshape;\n\n    // pathbar(directory) path generation fn\n    var pathAncestor = function(d) {\n        var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n        var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n        var _y0 = viewBarY(d.y0);\n        var _y1 = viewBarY(d.y1);\n\n        var halfH = barH / 2;\n\n        var pL = {};\n        var pR = {};\n\n        pL.x = _x0;\n        pR.x = _x1;\n\n        pL.y = pR.y = (_y0 + _y1) / 2;\n\n        var pA = {x: _x0, y: _y0};\n        var pB = {x: _x1, y: _y0};\n        var pC = {x: _x1, y: _y1};\n        var pD = {x: _x0, y: _y1};\n\n        if(edgeshape === '>') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pC.x -= halfH;\n            pD.x -= halfH;\n        } else if(edgeshape === '/') {\n            pC.x -= halfH;\n            pD.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '\\\\') {\n            pA.x -= halfH;\n            pB.x -= halfH;\n            pL.x -= halfH / 2;\n            pR.x -= halfH / 2;\n        } else if(edgeshape === '<') {\n            pL.x -= halfH;\n            pR.x -= halfH;\n        }\n\n        limitX0(pA);\n        limitX0(pD);\n        limitX0(pL);\n\n        limitX0(pB);\n        limitX0(pC);\n        limitX0(pR);\n\n        return (\n           'M' + pos(pA.x, pA.y) +\n           'L' + pos(pB.x, pB.y) +\n           'L' + pos(pR.x, pR.y) +\n           'L' + pos(pC.x, pC.y) +\n           'L' + pos(pD.x, pD.y) +\n           'L' + pos(pL.x, pL.y) +\n           'Z'\n        );\n    };\n\n    // slice path generation fn\n    var pathDescendant = function(d) {\n        var _x0 = viewMapX(d.x0);\n        var _x1 = viewMapX(d.x1);\n        var _y0 = viewMapY(d.y0);\n        var _y1 = viewMapY(d.y1);\n\n        var dx = _x1 - _x0;\n        var dy = _y1 - _y0;\n        if(!dx || !dy) return '';\n\n        var FILLET = 0; // TODO: may expose this constant\n\n        var r = (\n            dx > 2 * FILLET &&\n            dy > 2 * FILLET\n        ) ? FILLET : 0;\n\n        var arc = function(rx, ry) { return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : ''; };\n\n        return (\n           'M' + pos(_x0, _y0 + r) +\n           arc(r, -r) +\n           'L' + pos(_x1 - r, _y0) +\n           arc(r, r) +\n           'L' + pos(_x1, _y1 - r) +\n           arc(-r, r) +\n           'L' + pos(_x0 + r, _y1) +\n           arc(-r, -r) + 'Z'\n        );\n    };\n\n    var toMoveInsideSlice = function(pt, opts) {\n        var x0 = pt.x0;\n        var x1 = pt.x1;\n        var y0 = pt.y0;\n        var y1 = pt.y1;\n        var textBB = pt.textBB;\n\n        var hasFlag = function(f) { return trace.textposition.indexOf(f) !== -1; };\n\n        var hasBottom = hasFlag('bottom');\n        var hasTop = hasFlag('top') || (opts.isHeader && !hasBottom);\n\n        var anchor =\n            hasTop ? 'start' :\n            hasBottom ? 'end' : 'middle';\n\n        var hasRight = hasFlag('right');\n        var hasLeft = hasFlag('left') || opts.onPathbar;\n\n        var leftToRight =\n            hasLeft ? -1 :\n            hasRight ? 1 : 0;\n\n        // Note that `pad` is just an integer for `icicle`` traces where\n        // `pad` is a hashmap for treemap: pad.t, pad.b, pad.l, and pad.r\n        var pad = trace[isIcicle ? 'tiling' : 'marker'].pad;\n        if(opts.isHeader) {\n            x0 += (isIcicle ? pad : pad.l) - TEXTPAD;\n            x1 -= (isIcicle ? pad : pad.r) - TEXTPAD;\n            if(x0 >= x1) {\n                var mid = (x0 + x1) / 2;\n                x0 = mid;\n                x1 = mid;\n            }\n\n            // limit the drawing area for headers\n            var limY;\n            if(hasBottom) {\n                limY = y1 - (isIcicle ? pad : pad.b);\n                if(y0 < limY && limY < y1) y0 = limY;\n            } else {\n                limY = y0 + (isIcicle ? pad : pad.t);\n                if(y0 < limY && limY < y1) y1 = limY;\n            }\n        }\n\n        // position the text relative to the slice\n        var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: false,\n            constrained: true,\n            angle: 0,\n            anchor: anchor,\n            leftToRight: leftToRight\n        });\n        transform.fontSize = opts.fontSize;\n\n        transform.targetX = viewMapX(transform.targetX);\n        transform.targetY = viewMapY(transform.targetY);\n\n        if(isNaN(transform.targetX) || isNaN(transform.targetY)) {\n            return {};\n        }\n\n        if(x0 !== x1 && y0 !== y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return {\n            scale: transform.scale,\n            rotate: transform.rotate,\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY\n        };\n    };\n\n    var interpFromParent = function(pt, onPathbar) {\n        var parentPrev;\n        var i = 0;\n        var Q = pt;\n        while(!parentPrev && i < maxDepth) { // loop to find a parent/grandParent on the previous graph\n            i++;\n            Q = Q.parent;\n            if(Q) {\n                parentPrev = getPrev(Q, onPathbar);\n            } else i = maxDepth;\n        }\n        return parentPrev || {};\n    };\n\n    var makeExitSliceInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev = getPrev(pt, onPathbar);\n        var next;\n\n        if(onPathbar) {\n            next = pathbarOrigin;\n        } else {\n            var entryPrev = getPrev(entry, onPathbar);\n            if(entryPrev) {\n                // 'entryPrev' is here has the previous coordinates of the entry\n                // node, which corresponds to the last \"clicked\" node when zooming in\n                next = findClosestEdge(pt, entryPrev, size);\n            } else {\n                // this happens when maxdepth is set, when leaves must\n                // be removed and the entry is new (i.e. does not have a 'prev' object)\n                next = {};\n            }\n        }\n\n        return interpolate(prev, next);\n    };\n\n    var makeUpdateSliceInterpolator = function(pt, onPathbar, refRect, size, opts) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev;\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(onPathbar) {\n                prev = pathbarOrigin;\n            } else {\n                if(prevEntry) {\n                    // if trace was visible before\n                    if(pt.parent) {\n                        var ref = nextOfPrevEntry || refRect;\n\n                        if(ref && !onPathbar) {\n                            prev = findClosestEdge(pt, ref, size);\n                        } else {\n                            // if new leaf (when maxdepth is set),\n                            // grow it from its parent node\n                            prev = {};\n                            Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n                        }\n                    } else {\n                        prev = Lib.extendFlat({}, pt);\n                        if(isIcicle) {\n                            if(opts.orientation === 'h') {\n                                if(opts.flipX) prev.x0 = pt.x1;\n                                else prev.x1 = 0;\n                            } else {\n                                if(opts.flipY) prev.y0 = pt.y1;\n                                else prev.y1 = 0;\n                            }\n                        }\n                    }\n                } else {\n                    prev = {};\n                }\n            }\n        }\n\n        return interpolate(prev, {\n            x0: pt.x0,\n            x1: pt.x1,\n            y0: pt.y0,\n            y1: pt.y1\n        });\n    };\n\n    var makeUpdateTextInterpolator = function(pt, onPathbar, refRect, size) {\n        var prev0 = getPrev(pt, onPathbar);\n        var prev = {};\n        var origin = getOrigin(pt, onPathbar, refRect, size);\n\n        Lib.extendFlat(prev, {\n            transform: toMoveInsideSlice({\n                x0: origin.x0,\n                x1: origin.x1,\n                y0: origin.y0,\n                y1: origin.y1,\n                textBB: pt.textBB,\n                _text: pt._text\n            }, {\n                isHeader: helpers.isHeader(pt, trace)\n            })\n        });\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(pt.parent) {\n                Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n        }\n\n        var transform = pt.transform;\n        if(pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return interpolate(prev, {\n            transform: {\n                scale: transform.scale,\n                rotate: transform.rotate,\n                textX: transform.textX,\n                textY: transform.textY,\n                anchorX: transform.anchorX,\n                anchorY: transform.anchorY,\n                targetX: transform.targetX,\n                targetY: transform.targetY\n            }\n        });\n    };\n\n    var handleSlicesExit = function(slices, onPathbar, refRect, size, pathSlice) {\n        var width = size[0];\n        var height = size[1];\n\n        if(hasTransition) {\n            slices.exit().transition()\n                .each(function() {\n                    var sliceTop = d3.select(this);\n\n                    var slicePath = sliceTop.select('path.surface');\n                    slicePath.transition().attrTween('d', function(pt2) {\n                        var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n                        return function(t) { return pathSlice(interp(t)); };\n                    });\n\n                    var sliceTextGroup = sliceTop.select('g.slicetext');\n                    sliceTextGroup.attr('opacity', 0);\n                })\n                .remove();\n        } else {\n            slices.exit().remove();\n        }\n    };\n\n    var strTransform = function(d) {\n        var transform = d.transform;\n\n        if(d.x0 !== d.x1 && d.y0 !== d.y1) {\n            recordMinTextSize(trace.type, transform, fullLayout);\n        }\n\n        return Lib.getTextTransform({\n            textX: transform.textX,\n            textY: transform.textY,\n            anchorX: transform.anchorX,\n            anchorY: transform.anchorY,\n            targetX: transform.targetX,\n            targetY: transform.targetY,\n            scale: transform.scale,\n            rotate: transform.rotate\n        });\n    };\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n\n        selAncestors.each(function(pt) {\n            prevLookupPathbar[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupPathbar[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n        });\n\n        selDescendants.each(function(pt) {\n            prevLookupSlices[getKey(pt)] = {\n                x0: pt.x0,\n                x1: pt.x1,\n                y0: pt.y0,\n                y1: pt.y1\n            };\n\n            if(pt.transform) {\n                prevLookupSlices[getKey(pt)].transform = {\n                    textX: pt.transform.textX,\n                    textY: pt.transform.textY,\n                    anchorX: pt.transform.anchorX,\n                    anchorY: pt.transform.anchorY,\n                    targetX: pt.transform.targetX,\n                    targetY: pt.transform.targetY,\n                    scale: pt.transform.scale,\n                    rotate: pt.transform.rotate\n                };\n            }\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n        width: vpw,\n        height: vph,\n\n        viewX: viewMapX,\n        viewY: viewMapY,\n\n        pathSlice: pathDescendant,\n        toMoveInsideSlice: toMoveInsideSlice,\n\n        prevEntry: prevEntry,\n        makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n        makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n        handleSlicesExit: handleSlicesExit,\n        hasTransition: hasTransition,\n        strTransform: strTransform\n    });\n\n    if(trace.pathbar.visible) {\n        drawAncestors(gd, cd, entry, selAncestors, {\n            barDifY: barDifY,\n            width: barW,\n            height: barH,\n\n            viewX: viewBarX,\n            viewY: viewBarY,\n\n            pathSlice: pathAncestor,\n            toMoveInsideSlice: toMoveInsideSlice,\n\n            makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n            makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n\n            handleSlicesExit: handleSlicesExit,\n            hasTransition: hasTransition,\n            strTransform: strTransform\n        });\n    } else {\n        selAncestors.remove();\n    }\n};\n"]},"metadata":{},"sourceType":"script"}