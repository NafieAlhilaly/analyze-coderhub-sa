{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Projects/reactApp/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"C:/Projects/reactApp/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar createScatter = require('regl-scatter2d');\n\nvar pick = require('pick-by-alias');\n\nvar getBounds = require('array-bounds');\n\nvar raf = require('raf');\n\nvar arrRange = require('array-range');\n\nvar rect = require('parse-rect');\n\nvar flatten = require('flatten-vertex-data');\n\nmodule.exports = SPLOM; // @constructor\n\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options); // render passes\n\n  this.traces = []; // passes for scatter, combined across traces\n\n  this.passes = {};\n  this.regl = regl; // main scatter drawing instance\n\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n} // update & draw passes once per frame\n\n\nSPLOM.prototype.render = function () {\n  var _this = this;\n\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw(); // make sure draw is not called more often than once a frame\n\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(function () {\n        _this.draw();\n\n        _this.dirty = true;\n        _this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(function () {\n      _this.dirty = false;\n    });\n  }\n\n  return this;\n}; // update passes\n\n\nSPLOM.prototype.update = function () {\n  var _this$scatter;\n\n  if (!arguments.length) return;\n\n  for (var i = 0; i < arguments.length; i++) {\n    this.updateItem(i, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  } // remove nulled passes\n\n\n  this.traces = this.traces.filter(Boolean); // FIXME: update passes independently\n\n  var passes = [];\n  var offset = 0;\n\n  for (var _i = 0; _i < this.traces.length; _i++) {\n    var trace = this.traces[_i];\n    var tracePasses = this.traces[_i].passes;\n\n    for (var j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    } // save offset of passes\n\n\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n\n  (_this$scatter = this.scatter).update.apply(_this$scatter, passes);\n\n  return this;\n}; // update trace by index, not supposed to be called directly\n\n\nSPLOM.prototype.updateItem = function (i, options) {\n  var regl = this.regl; // remove pass if null\n\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n\n  if (!options) return this;\n  var o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  }); // we provide regl buffer per-trace, since trace data can be changed\n\n  var trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  }); // save styles\n\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower; // put flattened data into buffer\n\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length; // detect bounds per-column\n\n    trace.bounds = [];\n\n    for (var _i2 = 0; _i2 < trace.columns; _i2++) {\n      trace.bounds[_i2] = getBounds(o.data[_i2], 1);\n    }\n  } // add proper range updating markers\n\n\n  var multirange;\n\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n\n  var multipadding = false;\n\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    } // single padding\n    else {\n      trace.padding = getPad(o.padding);\n    }\n  } // create passes\n\n\n  var m = trace.columns;\n  var n = trace.count;\n  var w = trace.viewport.width;\n  var h = trace.viewport.height;\n  var left = trace.viewport.x;\n  var top = trace.viewport.y;\n  var iw = w / m;\n  var ih = h / m;\n  trace.passes = [];\n\n  for (var _i3 = 0; _i3 < m; _i3++) {\n    for (var j = 0; j < m; j++) {\n      if (!trace.diagonal && j === _i3) continue;\n      if (!trace.upper && _i3 > j) continue;\n      if (!trace.lower && _i3 < j) continue;\n      var key = passId(trace.id, _i3, j);\n      var pass = this.passes[key] || (this.passes[key] = {});\n\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3 * n,\n              count: n\n            }\n          };\n        }\n\n        pass.bounds = getBox(trace.bounds, _i3, j);\n      }\n\n      if (o.domain || o.viewport || o.data) {\n        var pad = multipadding ? getBox(trace.padding, _i3, j) : trace.padding;\n\n        if (trace.domain) {\n          var _getBox = getBox(trace.domain, _i3, j),\n              _getBox2 = _slicedToArray(_getBox, 4),\n              lox = _getBox2[0],\n              loy = _getBox2[1],\n              hix = _getBox2[2],\n              hiy = _getBox2[3];\n\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        } // consider auto-domain equipartial\n        else {\n          pass.viewport = [left + j * iw + iw * pad[0], top + _i3 * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (_i3 + 1) * ih - ih * pad[3]];\n        }\n      }\n\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, _i3, j) : trace.range || pass.bounds;\n      }\n\n      trace.passes.push(key);\n    }\n  }\n\n  return this;\n}; // draw all or passed passes\n\n\nSPLOM.prototype.draw = function () {\n  var _this2 = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    (function () {\n      var _this2$scatter;\n\n      var idx = [];\n\n      for (var i = 0; i < args.length; i++) {\n        // draw(0, 2, 5) - draw traces\n        if (typeof args[i] === 'number') {\n          var _this2$traces$args$i = _this2.traces[args[i]],\n              passes = _this2$traces$args$i.passes,\n              passOffset = _this2$traces$args$i.passOffset;\n          idx.push.apply(idx, _toConsumableArray(arrRange(passOffset, passOffset + passes.length)));\n        } // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n        else if (args[i].length) {\n          (function () {\n            var els = args[i];\n            var _this2$traces$i = _this2.traces[i],\n                passes = _this2$traces$i.passes,\n                passOffset = _this2$traces$i.passOffset;\n            passes = passes.map(function (passId, i) {\n              idx[passOffset + i] = els;\n            });\n          })();\n        }\n      }\n\n      (_this2$scatter = _this2.scatter).draw.apply(_this2$scatter, idx);\n    })();\n  }\n\n  return this;\n}; // dispose resources\n\n\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(function (trace) {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n}; // return pass corresponding to trace i- j- square\n\n\nfunction passId(trace, i, j) {\n  var id = trace.id != null ? trace.id : trace;\n  var n = i;\n  var m = j;\n  var key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n} // return bounding box corresponding to a pass\n\n\nfunction getBox(items, i, j) {\n  var ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  var iitem = items[i],\n      jitem = items[j];\n\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n\n  return [jlox, iloy, jhix, ihiy];\n}\n\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    var box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/regl-splom/index.js"],"names":["createScatter","require","pick","getBounds","raf","arrRange","rect","flatten","module","exports","SPLOM","regl","options","traces","passes","scatter","canvas","prototype","render","length","update","attributes","preserveDrawingBuffer","draw","dirty","planned","i","updateItem","filter","Boolean","offset","trace","tracePasses","j","push","passOffset","o","data","snap","size","color","opacity","borderSize","borderColor","marker","range","viewport","domain","padding","transpose","diagonal","upper","lower","id","buffer","usage","type","Uint8Array","_gl","drawingBufferWidth","drawingBufferHeight","columns","count","bounds","multirange","multipadding","Array","isArray","map","getPad","m","n","w","width","h","height","left","x","top","y","iw","ih","key","passId","pass","positions","stride","getBox","pad","lox","loy","hix","hiy","args","idx","els","destroy","forEach","items","ilox","iloy","ihix","ihiy","jlox","jloy","jhix","jhiy","iitem","jitem","arg","box"],"mappings":"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","sourcesContent":["'use strict'\n\n\nconst createScatter = require('regl-scatter2d')\nconst pick = require('pick-by-alias')\nconst getBounds = require('array-bounds')\nconst raf = require('raf')\nconst arrRange = require('array-range')\nconst rect = require('parse-rect')\nconst flatten = require('flatten-vertex-data')\n\n\nmodule.exports = SPLOM\n\n\n// @constructor\nfunction SPLOM (regl, options) {\n\tif (!(this instanceof SPLOM)) return new SPLOM(regl, options)\n\n\t// render passes\n\tthis.traces = []\n\n\t// passes for scatter, combined across traces\n\tthis.passes = {}\n\n\tthis.regl = regl\n\n\t// main scatter drawing instance\n\tthis.scatter = createScatter(regl)\n\n\tthis.canvas = this.scatter.canvas\n}\n\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tif (this.regl.attributes.preserveDrawingBuffer) return this.draw()\n\n\t// make sure draw is not called more often than once a frame\n\tif (this.dirty) {\n\t\tif (this.planned == null) {\n\t\t\tthis.planned = raf(() => {\n\t\t\t\tthis.draw()\n\t\t\t\tthis.dirty = true\n\t\t\t\tthis.planned = null\n\t\t\t})\n\t\t}\n\t}\n\telse {\n\t\tthis.draw()\n\t\tthis.dirty = true\n\t\traf(() => {\n\t\t\tthis.dirty = false\n\t\t})\n\t}\n\n\treturn this\n}\n\n\n// update passes\nSPLOM.prototype.update = function (...args) {\n\tif (!args.length) return\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tthis.updateItem(i, args[i])\n\t}\n\n\t// remove nulled passes\n\tthis.traces = this.traces.filter(Boolean)\n\n\t// FIXME: update passes independently\n\tlet passes = []\n\tlet offset = 0\n\tfor (let i = 0; i < this.traces.length; i++) {\n\t\tlet trace = this.traces[i]\n\t\tlet tracePasses = this.traces[i].passes\n\t\tfor (let j = 0; j < tracePasses.length; j++) {\n\t\t\tpasses.push(this.passes[tracePasses[j]])\n\t\t}\n\t\t// save offset of passes\n\t\ttrace.passOffset = offset\n\t\toffset += trace.passes.length\n\t}\n\n\tthis.scatter.update(...passes)\n\n\treturn this\n}\n\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n\tlet { regl } = this\n\n\t// remove pass if null\n\tif (options === null) {\n\t\tthis.traces[i] = null\n\t\treturn this\n\t}\n\n\tif (!options) return this\n\n\tlet o = pick(options, {\n\t\tdata: 'data items columns rows values dimensions samples x',\n\t\tsnap: 'snap cluster',\n\t\tsize: 'sizes size radius',\n\t\tcolor: 'colors color fill fill-color fillColor',\n\t\topacity: 'opacity alpha transparency opaque',\n\t\tborderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n\t\tborderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n\t\tmarker: 'markers marker shape',\n\t\trange: 'range ranges databox dataBox',\n\t\tviewport: 'viewport viewBox viewbox',\n\t\tdomain: 'domain domains area areas',\n\t\tpadding: 'pad padding paddings pads margin margins',\n\t\ttranspose: 'transpose transposed',\n\t\tdiagonal: 'diagonal diag showDiagonal',\n\t\tupper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n\t\tlower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n\t})\n\n\t// we provide regl buffer per-trace, since trace data can be changed\n\tlet trace = (this.traces[i] || (this.traces[i] = {\n\t\tid: i,\n\t\tbuffer: regl.buffer({\n\t\t\tusage: 'dynamic',\n\t\t\ttype: 'float',\n\t\t\tdata: new Uint8Array()\n\t\t}),\n\t\tcolor: 'black',\n\t\tmarker: null,\n\t\tsize: 12,\n\t\tborderColor: 'transparent',\n\t\tborderSize: 1,\n\t\tviewport:  rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n\t\tpadding: [0, 0, 0, 0],\n\t\topacity: 1,\n\t\tdiagonal: true,\n\t\tupper: true,\n\t\tlower: true\n\t}))\n\n\n\t// save styles\n\tif (o.color != null) {\n\t\ttrace.color = o.color\n\t}\n\tif (o.size != null) {\n\t\ttrace.size = o.size\n\t}\n\tif (o.marker != null) {\n\t\ttrace.marker = o.marker\n\t}\n\tif (o.borderColor != null) {\n\t\ttrace.borderColor = o.borderColor\n\t}\n\tif (o.borderSize != null) {\n\t\ttrace.borderSize = o.borderSize\n\t}\n\tif (o.opacity != null) {\n\t\ttrace.opacity = o.opacity\n\t}\n\tif (o.viewport) {\n\t\ttrace.viewport = rect(o.viewport)\n\t}\n\tif (o.diagonal != null) trace.diagonal = o.diagonal\n\tif (o.upper != null) trace.upper = o.upper\n\tif (o.lower != null) trace.lower = o.lower\n\n\t// put flattened data into buffer\n\tif (o.data) {\n\t\ttrace.buffer(flatten(o.data))\n\t\ttrace.columns = o.data.length\n\t\ttrace.count = o.data[0].length\n\n\t\t// detect bounds per-column\n\t\ttrace.bounds = []\n\n\t\tfor (let i = 0; i < trace.columns; i++) {\n\t\t\ttrace.bounds[i] = getBounds(o.data[i], 1)\n\t\t}\n\t}\n\n\t// add proper range updating markers\n\tlet multirange\n\tif (o.range) {\n\t\ttrace.range = o.range\n\t\tmultirange = trace.range && typeof trace.range[0] !== 'number'\n\t}\n\n\tif (o.domain) {\n\t\ttrace.domain = o.domain\n\t}\n\tlet multipadding = false\n\tif (o.padding != null) {\n\t\t// multiple paddings\n\t\tif (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n\t\t\ttrace.padding = o.padding.map(getPad)\n\t\t\tmultipadding = true\n\t\t}\n\t\t// single padding\n\t\telse {\n\t\t\ttrace.padding = getPad(o.padding)\n\t\t}\n\t}\n\n\t// create passes\n\tlet m = trace.columns\n\tlet n = trace.count\n\n\tlet w = trace.viewport.width\n\tlet h = trace.viewport.height\n\tlet left = trace.viewport.x\n\tlet top = trace.viewport.y\n\tlet iw = w / m\n\tlet ih = h / m\n\n\ttrace.passes = []\n\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\tif (!trace.diagonal && j === i) continue\n\t\t\tif (!trace.upper && i > j) continue\n\t\t\tif (!trace.lower && i < j) continue\n\n\t\t\tlet key = passId(trace.id, i, j)\n\n\t\t\tlet pass = this.passes[key] || (this.passes[key] = {})\n\n\t\t\tif (o.data) {\n\t\t\t\tif (o.transpose) {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j, count: n, stride: m},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i, count: n, stride: m}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j * n, count: n},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i * n, count: n}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpass.bounds = getBox(trace.bounds, i, j)\n\t\t\t}\n\n\t\t\tif (o.domain || o.viewport || o.data) {\n\t\t\t\tlet pad = multipadding ? getBox(trace.padding, i, j) : trace.padding\n\t\t\t\tif (trace.domain) {\n\t\t\t\t\tlet [lox, loy, hix, hiy] = getBox(trace.domain, i, j)\n\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + lox * w + pad[0],\n\t\t\t\t\t\ttop + loy * h + pad[1],\n\t\t\t\t\t\tleft + hix * w - pad[2],\n\t\t\t\t\t\ttop + hiy * h - pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t// consider auto-domain equipartial\n\t\t\t\telse {\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + j * iw + iw * pad[0],\n\t\t\t\t\t\ttop + i * ih + ih * pad[1],\n\t\t\t\t\t\tleft + (j + 1) * iw - iw * pad[2],\n\t\t\t\t\t\ttop + (i + 1) * ih - ih * pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.color) pass.color = trace.color\n\t\t\tif (o.size) pass.size = trace.size\n\t\t\tif (o.marker) pass.marker = trace.marker\n\t\t\tif (o.borderSize) pass.borderSize = trace.borderSize\n\t\t\tif (o.borderColor) pass.borderColor = trace.borderColor\n\t\t\tif (o.opacity) pass.opacity = trace.opacity\n\n\t\t\tif (o.range) {\n\t\t\t\tpass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds\n\t\t\t}\n\n\t\t\ttrace.passes.push(key)\n\t\t}\n\t}\n\n\treturn this\n}\n\n\n// draw all or passed passes\nSPLOM.prototype.draw = function (...args) {\n\tif (!args.length) {\n\t\tthis.scatter.draw()\n\t}\n\telse {\n\t\tlet idx = []\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t// draw(0, 2, 5) - draw traces\n\t\t\tif (typeof args[i] === 'number' ) {\n\t\t\t\tlet { passes, passOffset } = this.traces[args[i]]\n\t\t\t\tidx.push(...arrRange(passOffset, passOffset + passes.length))\n\t\t\t}\n\t\t\t// draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n\t\t\telse if (args[i].length) {\n\t\t\t\tlet els = args[i]\n\t\t\t\tlet { passes, passOffset } = this.traces[i]\n\t\t\t\tpasses = passes.map((passId, i) => {\n\t\t\t\t\tidx[passOffset + i] = els\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tthis.scatter.draw(...idx)\n\t}\n\n\treturn this\n}\n\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n\tthis.traces.forEach(trace => {\n\t\tif (trace.buffer && trace.buffer.destroy) trace.buffer.destroy()\n\t})\n\tthis.traces = null\n\tthis.passes = null\n\n\tthis.scatter.destroy()\n\n\treturn this\n}\n\n\n// return pass corresponding to trace i- j- square\nfunction passId (trace, i, j) {\n\tlet id = (trace.id != null ? trace.id : trace)\n\tlet n = i\n\tlet m = j\n\tlet key = id << 16 | (n & 0xff) << 8 | m & 0xff\n\n\treturn key\n}\n\n\n// return bounding box corresponding to a pass\nfunction getBox (items, i, j) {\n\tlet ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy\n\tlet iitem = items[i], jitem = items[j]\n\n\tif (iitem.length > 2) {\n\t\tilox = iitem[0]\n\t\tihix = iitem[2]\n\t\tiloy = iitem[1]\n\t\tihiy = iitem[3]\n\t}\n\telse if (iitem.length) {\n\t\tilox = iloy = iitem[0]\n\t\tihix = ihiy = iitem[1]\n\t}\n\telse {\n\t\tilox = iitem.x\n\t\tiloy = iitem.y\n\t\tihix = iitem.x + iitem.width\n\t\tihiy = iitem.y + iitem.height\n\t}\n\n\tif (jitem.length > 2) {\n\t\tjlox = jitem[0]\n\t\tjhix = jitem[2]\n\t\tjloy = jitem[1]\n\t\tjhiy = jitem[3]\n\t}\n\telse if (jitem.length) {\n\t\tjlox = jloy = jitem[0]\n\t\tjhix = jhiy = jitem[1]\n\t}\n\telse {\n\t\tjlox = jitem.x\n\t\tjloy = jitem.y\n\t\tjhix = jitem.x + jitem.width\n\t\tjhiy = jitem.y + jitem.height\n\t}\n\n\treturn [ jlox, iloy, jhix, ihiy ]\n}\n\n\nfunction getPad (arg) {\n\tif (typeof arg === 'number') return [arg, arg, arg, arg]\n\telse if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]]\n\telse {\n\t\tlet box = rect(arg)\n\t\treturn [box.x, box.y, box.x + box.width, box.y + box.height]\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}