{"ast":null,"code":"'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib'); // special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\n\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\n\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\n\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\n\nexports.extractPathCoords = function (path, paramsToUse) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n  });\n  return extractedCoordinates;\n};\n\nexports.getDataToPixel = function (gd, axis, isVertical, refType) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n\n  if (axis) {\n    if (refType === 'domain') {\n      dataToPixel = function (v) {\n        return axis._length * (isVertical ? 1 - v : v) + axis._offset;\n      };\n    } else {\n      var d2r = exports.shapePositionToRange(axis);\n\n      dataToPixel = function (v) {\n        return axis._offset + axis.r2p(d2r(v, true));\n      };\n\n      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n  } else if (isVertical) {\n    dataToPixel = function (v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function (v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  return dataToPixel;\n};\n\nexports.getPixelToData = function (gd, axis, isVertical, opt) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n\n  if (axis) {\n    if (opt === 'domain') {\n      pixelToData = function (p) {\n        var q = (p - axis._offset) / axis._length;\n        return isVertical ? 1 - q : q;\n      };\n    } else {\n      var r2d = exports.rangeToShapePosition(axis);\n\n      pixelToData = function (p) {\n        return r2d(axis.p2r(p - axis._offset));\n      };\n    }\n  } else if (isVertical) {\n    pixelToData = function (p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function (p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n\n  return pixelToData;\n};\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\n\n\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/shapes/helpers.js"],"names":["constants","require","Lib","exports","rangeToShapePosition","ax","type","r2d","v","shapePositionToRange","d2r","decodeDate","convertToPx","replace","encodeDate","convertToDate","extractPathCoords","path","paramsToUse","extractedCoordinates","segments","match","segmentRE","forEach","segment","relevantParamIdx","charAt","drawn","undefined","params","substr","paramRE","length","push","cleanNumber","getDataToPixel","gd","axis","isVertical","refType","gs","_fullLayout","_size","dataToPixel","_length","_offset","r2p","t","h","l","w","getPixelToData","opt","pixelToData","p","q","p2r","roundPositionForSharpStrokeRendering","pos","strokeWidth","strokeWidthIsOdd","Math","round","posValAsInt","makeOptionsAndPlotinfo","index","options","shapes","plotinfo","_plots","xref","yref","hasPlotinfo","_hadPlotinfo","xaxis","yaxis","xsizemode","ysizemode","xanchor","yanchor"],"mappings":"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","sourcesContent":["'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function(ax) {\n    return (ax.type === 'log') ? ax.r2d : function(v) { return v; };\n};\n\nexports.shapePositionToRange = function(ax) {\n    return (ax.type === 'log') ? ax.d2r : function(v) { return v; };\n};\n\nexports.decodeDate = function(convertToPx) {\n    return function(v) {\n        if(v.replace) v = v.replace('_', ' ');\n        return convertToPx(v);\n    };\n};\n\nexports.encodeDate = function(convertToDate) {\n    return function(v) { return convertToDate(v).replace(' ', '_'); };\n};\n\nexports.extractPathCoords = function(path, paramsToUse) {\n    var extractedCoordinates = [];\n\n    var segments = path.match(constants.segmentRE);\n    segments.forEach(function(segment) {\n        var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n        if(relevantParamIdx === undefined) return;\n\n        var params = segment.substr(1).match(constants.paramRE);\n        if(!params || params.length < relevantParamIdx) return;\n\n        extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n    });\n\n    return extractedCoordinates;\n};\n\nexports.getDataToPixel = function(gd, axis, isVertical, refType) {\n    var gs = gd._fullLayout._size;\n    var dataToPixel;\n\n    if(axis) {\n        if(refType === 'domain') {\n            dataToPixel = function(v) {\n                return axis._length * (isVertical ? (1 - v) : v) + axis._offset;\n            };\n        } else {\n            var d2r = exports.shapePositionToRange(axis);\n\n            dataToPixel = function(v) {\n                return axis._offset + axis.r2p(d2r(v, true));\n            };\n\n            if(axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n        }\n    } else if(isVertical) {\n        dataToPixel = function(v) { return gs.t + gs.h * (1 - v); };\n    } else {\n        dataToPixel = function(v) { return gs.l + gs.w * v; };\n    }\n\n    return dataToPixel;\n};\n\nexports.getPixelToData = function(gd, axis, isVertical, opt) {\n    var gs = gd._fullLayout._size;\n    var pixelToData;\n\n    if(axis) {\n        if(opt === 'domain') {\n            pixelToData = function(p) {\n                var q = (p - axis._offset) / axis._length;\n                return isVertical ? 1 - q : q;\n            };\n        } else {\n            var r2d = exports.rangeToShapePosition(axis);\n            pixelToData = function(p) { return r2d(axis.p2r(p - axis._offset)); };\n        }\n    } else if(isVertical) {\n        pixelToData = function(p) { return 1 - (p - gs.t) / gs.h; };\n    } else {\n        pixelToData = function(p) { return (p - gs.l) / gs.w; };\n    }\n\n    return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {\n    var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n    var posValAsInt = Math.round(pos);\n\n    return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeOptionsAndPlotinfo = function(gd, index) {\n    var options = gd._fullLayout.shapes[index] || {};\n\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    var hasPlotinfo = !!plotinfo;\n    if(hasPlotinfo) {\n        plotinfo._hadPlotinfo = true;\n    } else {\n        plotinfo = {};\n        if(options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n        if(options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n    }\n\n    plotinfo.xsizemode = options.xsizemode;\n    plotinfo.ysizemode = options.ysizemode;\n    plotinfo.xanchor = options.xanchor;\n    plotinfo.yanchor = options.yanchor;\n\n    return {\n        options: options,\n        plotinfo: plotinfo\n    };\n};\n"]},"metadata":{},"sourceType":"script"}