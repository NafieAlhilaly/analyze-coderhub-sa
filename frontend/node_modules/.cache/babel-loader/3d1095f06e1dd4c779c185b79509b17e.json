{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function clean2dArray(zOld, trace, xa, ya) {\n  var rowlen, collen, getCollen, old2new, i, j;\n\n  function cleanZvalue(v) {\n    if (!isNumeric(v)) return undefined;\n    return +v;\n  }\n\n  if (trace && trace.transpose) {\n    rowlen = 0;\n\n    for (i = 0; i < zOld.length; i++) rowlen = Math.max(rowlen, zOld[i].length);\n\n    if (rowlen === 0) return false;\n\n    getCollen = function (zOld) {\n      return zOld.length;\n    };\n\n    old2new = function (zOld, i, j) {\n      return (zOld[j] || [])[i];\n    };\n  } else {\n    rowlen = zOld.length;\n\n    getCollen = function (zOld, i) {\n      return zOld[i].length;\n    };\n\n    old2new = function (zOld, i, j) {\n      return (zOld[i] || [])[j];\n    };\n  }\n\n  var padOld2new = function (zOld, i, j) {\n    if (i === BADNUM || j === BADNUM) return BADNUM;\n    return old2new(zOld, i, j);\n  };\n\n  function axisMapping(ax) {\n    if (trace && trace.type !== 'carpet' && trace.type !== 'contourcarpet' && ax && ax.type === 'category' && trace['_' + ax._id.charAt(0)].length) {\n      var axLetter = ax._id.charAt(0);\n\n      var axMapping = {};\n      var traceCategories = trace['_' + axLetter + 'CategoryMap'] || trace[axLetter];\n\n      for (i = 0; i < traceCategories.length; i++) {\n        axMapping[traceCategories[i]] = i;\n      }\n\n      return function (i) {\n        var ind = axMapping[ax._categories[i]];\n        return ind + 1 ? ind : BADNUM;\n      };\n    } else {\n      return Lib.identity;\n    }\n  }\n\n  var xMap = axisMapping(xa);\n  var yMap = axisMapping(ya);\n  if (ya && ya.type === 'category') rowlen = ya._categories.length;\n  var zNew = new Array(rowlen);\n\n  for (i = 0; i < rowlen; i++) {\n    if (xa && xa.type === 'category') {\n      collen = xa._categories.length;\n    } else {\n      collen = getCollen(zOld, i);\n    }\n\n    zNew[i] = new Array(collen);\n\n    for (j = 0; j < collen; j++) zNew[i][j] = cleanZvalue(padOld2new(zOld, yMap(i), xMap(j)));\n  }\n\n  return zNew;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/heatmap/clean_2d_array.js"],"names":["isNumeric","require","Lib","BADNUM","module","exports","clean2dArray","zOld","trace","xa","ya","rowlen","collen","getCollen","old2new","i","j","cleanZvalue","v","undefined","transpose","length","Math","max","padOld2new","axisMapping","ax","type","_id","charAt","axLetter","axMapping","traceCategories","ind","_categories","identity","xMap","yMap","zNew","Array"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function clean2dArray(zOld, trace, xa, ya) {\n    var rowlen, collen, getCollen, old2new, i, j;\n\n    function cleanZvalue(v) {\n        if(!isNumeric(v)) return undefined;\n        return +v;\n    }\n\n    if(trace && trace.transpose) {\n        rowlen = 0;\n        for(i = 0; i < zOld.length; i++) rowlen = Math.max(rowlen, zOld[i].length);\n        if(rowlen === 0) return false;\n        getCollen = function(zOld) { return zOld.length; };\n        old2new = function(zOld, i, j) { return (zOld[j] || [])[i]; };\n    } else {\n        rowlen = zOld.length;\n        getCollen = function(zOld, i) { return zOld[i].length; };\n        old2new = function(zOld, i, j) { return (zOld[i] || [])[j]; };\n    }\n\n    var padOld2new = function(zOld, i, j) {\n        if(i === BADNUM || j === BADNUM) return BADNUM;\n        return old2new(zOld, i, j);\n    };\n\n    function axisMapping(ax) {\n        if(trace && trace.type !== 'carpet' && trace.type !== 'contourcarpet' &&\n            ax && ax.type === 'category' && trace['_' + ax._id.charAt(0)].length) {\n            var axLetter = ax._id.charAt(0);\n            var axMapping = {};\n            var traceCategories = trace['_' + axLetter + 'CategoryMap'] || trace[axLetter];\n            for(i = 0; i < traceCategories.length; i++) {\n                axMapping[traceCategories[i]] = i;\n            }\n            return function(i) {\n                var ind = axMapping[ax._categories[i]];\n                return ind + 1 ? ind : BADNUM;\n            };\n        } else {\n            return Lib.identity;\n        }\n    }\n\n    var xMap = axisMapping(xa);\n    var yMap = axisMapping(ya);\n\n    if(ya && ya.type === 'category') rowlen = ya._categories.length;\n    var zNew = new Array(rowlen);\n\n    for(i = 0; i < rowlen; i++) {\n        if(xa && xa.type === 'category') {\n            collen = xa._categories.length;\n        } else {\n            collen = getCollen(zOld, i);\n        }\n        zNew[i] = new Array(collen);\n        for(j = 0; j < collen; j++) zNew[i][j] = cleanZvalue(padOld2new(zOld, yMap(i), xMap(j)));\n    }\n\n    return zNew;\n};\n"]},"metadata":{},"sourceType":"script"}