{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectIter;\n\nvar pool = require('typedarray-pool');\n\nvar bits = require('bit-twiddle');\n\nvar bruteForce = require('./brute');\n\nvar bruteForcePartial = bruteForce.partial;\nvar bruteForceFull = bruteForce.full;\n\nvar sweep = require('./sweep');\n\nvar findMedian = require('./median');\n\nvar genPartition = require('./partition'); //Twiddle parameters\n\n\nvar BRUTE_FORCE_CUTOFF = 128; //Cut off for brute force search\n\nvar SCAN_CUTOFF = 1 << 22; //Cut off for two way scan\n\nvar SCAN_COMPLETE_CUTOFF = 1 << 22; //Partition functions\n\nvar partitionInteriorContainsInterval = genPartition('!(lo>=p0)&&!(p1>=hi)');\nvar partitionStartEqual = genPartition('lo===p0');\nvar partitionStartLessThan = genPartition('lo<p0');\nvar partitionEndLessThanEqual = genPartition('hi<=p0');\nvar partitionContainsPoint = genPartition('lo<=p0&&p0<=hi');\nvar partitionContainsPointProper = genPartition('lo<p0&&p0<=hi'); //Frame size for iterative loop\n\nvar IFRAME_SIZE = 6;\nvar DFRAME_SIZE = 2; //Data for box statck\n\nvar INIT_CAPACITY = 1024;\nvar BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);\nvar BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY); //Initialize iterative loop queue\n\nfunction iterInit(d, count) {\n  var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;\n  var maxInts = bits.nextPow2(IFRAME_SIZE * levels);\n\n  if (BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK);\n    BOX_ISTACK = pool.mallocInt32(maxInts);\n  }\n\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);\n\n  if (BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK);\n    BOX_DSTACK = pool.mallocDouble(maxDoubles);\n  }\n} //Append item to queue\n\n\nfunction iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {\n  var iptr = IFRAME_SIZE * ptr;\n  BOX_ISTACK[iptr] = axis;\n  BOX_ISTACK[iptr + 1] = redStart;\n  BOX_ISTACK[iptr + 2] = redEnd;\n  BOX_ISTACK[iptr + 3] = blueStart;\n  BOX_ISTACK[iptr + 4] = blueEnd;\n  BOX_ISTACK[iptr + 5] = state;\n  var dptr = DFRAME_SIZE * ptr;\n  BOX_DSTACK[dptr] = lo;\n  BOX_DSTACK[dptr + 1] = hi;\n} //Special case:  Intersect single point with list of intervals\n\n\nfunction onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n\n    if (flip && blueX === r0) {\n      continue;\n    }\n\n    var redId = redIndex[i];\n\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n\n    var retval;\n\n    if (flip) {\n      retval = visit(blueId, redId);\n    } else {\n      retval = visit(redId, blueId);\n    }\n\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n} //Special case:  Intersect one point with list of intervals\n\n\nfunction onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var redId = redIndex[i];\n\n    if (redId === blueId) {\n      continue;\n    }\n\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n\n    var retval = visit(redId, blueId);\n\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n} //The main box intersection routine\n\n\nfunction boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize);\n  var top = 0;\n  var elemSize = 2 * d;\n  var retval;\n  iterPush(top++, 0, 0, xSize, 0, ySize, initFull ? 16 : 0, -Infinity, Infinity);\n\n  if (!initFull) {\n    iterPush(top++, 0, 0, ySize, 0, xSize, 1, -Infinity, Infinity);\n  }\n\n  while (top > 0) {\n    top -= 1;\n    var iptr = top * IFRAME_SIZE;\n    var axis = BOX_ISTACK[iptr];\n    var redStart = BOX_ISTACK[iptr + 1];\n    var redEnd = BOX_ISTACK[iptr + 2];\n    var blueStart = BOX_ISTACK[iptr + 3];\n    var blueEnd = BOX_ISTACK[iptr + 4];\n    var state = BOX_ISTACK[iptr + 5];\n    var dptr = top * DFRAME_SIZE;\n    var lo = BOX_DSTACK[dptr];\n    var hi = BOX_DSTACK[dptr + 1]; //Unpack state info\n\n    var flip = state & 1;\n    var full = !!(state & 16); //Unpack indices\n\n    var red = xBoxes;\n    var redIndex = xIndex;\n    var blue = yBoxes;\n    var blueIndex = yIndex;\n\n    if (flip) {\n      red = yBoxes;\n      redIndex = yIndex;\n      blue = xBoxes;\n      blueIndex = xIndex;\n    }\n\n    if (state & 2) {\n      redEnd = partitionStartLessThan(d, axis, redStart, redEnd, red, redIndex, hi);\n\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n\n    if (state & 4) {\n      redStart = partitionEndLessThanEqual(d, axis, redStart, redEnd, red, redIndex, lo);\n\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n\n    var redCount = redEnd - redStart;\n    var blueCount = blueEnd - blueStart;\n\n    if (full) {\n      if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      }\n    } else {\n      if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      } else if (d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n\n        continue;\n      }\n    } //First, find all red intervals whose interior contains (lo,hi)\n\n\n    var red0 = partitionInteriorContainsInterval(d, axis, redStart, redEnd, red, redIndex, lo, hi); //Lower dimensional case\n\n    if (redStart < red0) {\n      if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(d, axis + 1, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (axis === d - 2) {\n        if (flip) {\n          retval = sweep.sweepBipartite(d, visit, blueStart, blueEnd, blue, blueIndex, redStart, red0, red, redIndex);\n        } else {\n          retval = sweep.sweepBipartite(d, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        }\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else {\n        iterPush(top++, axis + 1, redStart, red0, blueStart, blueEnd, flip, -Infinity, Infinity);\n        iterPush(top++, axis + 1, blueStart, blueEnd, redStart, red0, flip ^ 1, -Infinity, Infinity);\n      }\n    } //Divide and conquer phase\n\n\n    if (red0 < redEnd) {\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(d, axis, blueStart, blueEnd, blue, blueIndex);\n      var mid = blue[elemSize * blue0 + axis];\n      var blue1 = partitionStartEqual(d, axis, blue0, blueEnd, blue, blueIndex, mid); //Right case\n\n      if (blue1 < blueEnd) {\n        iterPush(top++, axis, red0, redEnd, blue1, blueEnd, (flip | 4) + (full ? 16 : 0), mid, hi);\n      } //Left case\n\n\n      if (blueStart < blue0) {\n        iterPush(top++, axis, red0, redEnd, blueStart, blue0, (flip | 2) + (full ? 16 : 0), lo, mid);\n      } //Center case (the hard part)\n\n\n      if (blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if (full) {\n          retval = onePointFull(d, axis, visit, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        } else {\n          retval = onePointPartial(d, axis, visit, flip, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        }\n\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (blue0 < blue1) {\n        var red1;\n\n        if (full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n\n          if (red0 < red1) {\n            var redX = partitionStartEqual(d, axis, red0, red1, red, redIndex, mid);\n\n            if (axis === d - 2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if (red0 < redX) {\n                retval = sweep.sweepComplete(d, visit, red0, redX, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              } //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n\n\n              if (redX < red1) {\n                retval = sweep.sweepBipartite(d, visit, redX, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            } else {\n              if (red0 < redX) {\n                iterPush(top++, axis + 1, red0, redX, blue0, blue1, 16, -Infinity, Infinity);\n              }\n\n              if (redX < red1) {\n                iterPush(top++, axis + 1, redX, red1, blue0, blue1, 0, -Infinity, Infinity);\n                iterPush(top++, axis + 1, blue0, blue1, redX, red1, 1, -Infinity, Infinity);\n              }\n            }\n          }\n        } else {\n          if (flip) {\n            red1 = partitionContainsPointProper(d, axis, red0, redEnd, red, redIndex, mid);\n          } else {\n            red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n          }\n\n          if (red0 < red1) {\n            if (axis === d - 2) {\n              if (flip) {\n                retval = sweep.sweepBipartite(d, visit, blue0, blue1, blue, blueIndex, red0, red1, red, redIndex);\n              } else {\n                retval = sweep.sweepBipartite(d, visit, red0, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n              }\n            } else {\n              iterPush(top++, axis + 1, red0, red1, blue0, blue1, flip, -Infinity, Infinity);\n              iterPush(top++, axis + 1, blue0, blue1, red0, red1, flip ^ 1, -Infinity, Infinity);\n            }\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/box-intersect/lib/intersect.js"],"names":["module","exports","boxIntersectIter","pool","require","bits","bruteForce","bruteForcePartial","partial","bruteForceFull","full","sweep","findMedian","genPartition","BRUTE_FORCE_CUTOFF","SCAN_CUTOFF","SCAN_COMPLETE_CUTOFF","partitionInteriorContainsInterval","partitionStartEqual","partitionStartLessThan","partitionEndLessThanEqual","partitionContainsPoint","partitionContainsPointProper","IFRAME_SIZE","DFRAME_SIZE","INIT_CAPACITY","BOX_ISTACK","mallocInt32","BOX_DSTACK","mallocDouble","iterInit","d","count","levels","log2","maxInts","nextPow2","length","free","maxDoubles","iterPush","ptr","axis","redStart","redEnd","blueStart","blueEnd","state","lo","hi","iptr","dptr","onePointPartial","visit","flip","red","redIndex","blueOffset","blue","blueId","elemSize","bluePtr","blueX","red_loop","i","redPtr","r0","r1","redId","j","b0","b1","retval","onePointFull","initFull","xSize","xBoxes","xIndex","ySize","yBoxes","yIndex","top","Infinity","blueIndex","redCount","blueCount","scanComplete","Math","min","scanBipartite","red0","sweepBipartite","blue0","mid","blue1","red1","redX","sweepComplete"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = boxIntersectIter\r\n\r\nvar pool = require('typedarray-pool')\r\nvar bits = require('bit-twiddle')\r\nvar bruteForce = require('./brute')\r\nvar bruteForcePartial = bruteForce.partial\r\nvar bruteForceFull = bruteForce.full\r\nvar sweep = require('./sweep')\r\nvar findMedian = require('./median')\r\nvar genPartition = require('./partition')\r\n\r\n//Twiddle parameters\r\nvar BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search\r\nvar SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan\r\nvar SCAN_COMPLETE_CUTOFF  = (1<<22)\r\n\r\n//Partition functions\r\nvar partitionInteriorContainsInterval = genPartition(\r\n  '!(lo>=p0)&&!(p1>=hi)')\r\n\r\nvar partitionStartEqual = genPartition(\r\n  'lo===p0')\r\n\r\nvar partitionStartLessThan = genPartition(\r\n  'lo<p0')\r\n\r\nvar partitionEndLessThanEqual = genPartition(\r\n  'hi<=p0')\r\n\r\nvar partitionContainsPoint = genPartition(\r\n  'lo<=p0&&p0<=hi')\r\n\r\nvar partitionContainsPointProper = genPartition(\r\n  'lo<p0&&p0<=hi')\r\n\r\n//Frame size for iterative loop\r\nvar IFRAME_SIZE = 6\r\nvar DFRAME_SIZE = 2\r\n\r\n//Data for box statck\r\nvar INIT_CAPACITY = 1024\r\nvar BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)\r\nvar BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)\r\n\r\n//Initialize iterative loop queue\r\nfunction iterInit(d, count) {\r\n  var levels = (8 * bits.log2(count+1) * (d+1))|0\r\n  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)\r\n  if(BOX_ISTACK.length < maxInts) {\r\n    pool.free(BOX_ISTACK)\r\n    BOX_ISTACK = pool.mallocInt32(maxInts)\r\n  }\r\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)\r\n  if(BOX_DSTACK.length < maxDoubles) {\r\n    pool.free(BOX_DSTACK)\r\n    BOX_DSTACK = pool.mallocDouble(maxDoubles)\r\n  }\r\n}\r\n\r\n//Append item to queue\r\nfunction iterPush(ptr,\r\n  axis,\r\n  redStart, redEnd,\r\n  blueStart, blueEnd,\r\n  state,\r\n  lo, hi) {\r\n\r\n  var iptr = IFRAME_SIZE * ptr\r\n  BOX_ISTACK[iptr]   = axis\r\n  BOX_ISTACK[iptr+1] = redStart\r\n  BOX_ISTACK[iptr+2] = redEnd\r\n  BOX_ISTACK[iptr+3] = blueStart\r\n  BOX_ISTACK[iptr+4] = blueEnd\r\n  BOX_ISTACK[iptr+5] = state\r\n\r\n  var dptr = DFRAME_SIZE * ptr\r\n  BOX_DSTACK[dptr]   = lo\r\n  BOX_DSTACK[dptr+1] = hi\r\n}\r\n\r\n//Special case:  Intersect single point with list of intervals\r\nfunction onePointPartial(\r\n  d, axis, visit, flip,\r\n  redStart, redEnd, red, redIndex,\r\n  blueOffset, blue, blueId) {\r\n\r\n  var elemSize = 2 * d\r\n  var bluePtr  = blueOffset * elemSize\r\n  var blueX    = blue[bluePtr + axis]\r\n\r\nred_loop:\r\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\r\n    var r0 = red[redPtr+axis]\r\n    var r1 = red[redPtr+axis+d]\r\n    if(blueX < r0 || r1 < blueX) {\r\n      continue\r\n    }\r\n    if(flip && blueX === r0) {\r\n      continue\r\n    }\r\n    var redId = redIndex[i]\r\n    for(var j=axis+1; j<d; ++j) {\r\n      var r0 = red[redPtr+j]\r\n      var r1 = red[redPtr+j+d]\r\n      var b0 = blue[bluePtr+j]\r\n      var b1 = blue[bluePtr+j+d]\r\n      if(r1 < b0 || b1 < r0) {\r\n        continue red_loop\r\n      }\r\n    }\r\n    var retval\r\n    if(flip) {\r\n      retval = visit(blueId, redId)\r\n    } else {\r\n      retval = visit(redId, blueId)\r\n    }\r\n    if(retval !== void 0) {\r\n      return retval\r\n    }\r\n  }\r\n}\r\n\r\n//Special case:  Intersect one point with list of intervals\r\nfunction onePointFull(\r\n  d, axis, visit,\r\n  redStart, redEnd, red, redIndex,\r\n  blueOffset, blue, blueId) {\r\n\r\n  var elemSize = 2 * d\r\n  var bluePtr  = blueOffset * elemSize\r\n  var blueX    = blue[bluePtr + axis]\r\n\r\nred_loop:\r\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\r\n    var redId = redIndex[i]\r\n    if(redId === blueId) {\r\n      continue\r\n    }\r\n    var r0 = red[redPtr+axis]\r\n    var r1 = red[redPtr+axis+d]\r\n    if(blueX < r0 || r1 < blueX) {\r\n      continue\r\n    }\r\n    for(var j=axis+1; j<d; ++j) {\r\n      var r0 = red[redPtr+j]\r\n      var r1 = red[redPtr+j+d]\r\n      var b0 = blue[bluePtr+j]\r\n      var b1 = blue[bluePtr+j+d]\r\n      if(r1 < b0 || b1 < r0) {\r\n        continue red_loop\r\n      }\r\n    }\r\n    var retval = visit(redId, blueId)\r\n    if(retval !== void 0) {\r\n      return retval\r\n    }\r\n  }\r\n}\r\n\r\n//The main box intersection routine\r\nfunction boxIntersectIter(\r\n  d, visit, initFull,\r\n  xSize, xBoxes, xIndex,\r\n  ySize, yBoxes, yIndex) {\r\n\r\n  //Reserve memory for stack\r\n  iterInit(d, xSize + ySize)\r\n\r\n  var top  = 0\r\n  var elemSize = 2 * d\r\n  var retval\r\n\r\n  iterPush(top++,\r\n      0,\r\n      0, xSize,\r\n      0, ySize,\r\n      initFull ? 16 : 0,\r\n      -Infinity, Infinity)\r\n  if(!initFull) {\r\n    iterPush(top++,\r\n      0,\r\n      0, ySize,\r\n      0, xSize,\r\n      1,\r\n      -Infinity, Infinity)\r\n  }\r\n\r\n  while(top > 0) {\r\n    top  -= 1\r\n\r\n    var iptr = top * IFRAME_SIZE\r\n    var axis      = BOX_ISTACK[iptr]\r\n    var redStart  = BOX_ISTACK[iptr+1]\r\n    var redEnd    = BOX_ISTACK[iptr+2]\r\n    var blueStart = BOX_ISTACK[iptr+3]\r\n    var blueEnd   = BOX_ISTACK[iptr+4]\r\n    var state     = BOX_ISTACK[iptr+5]\r\n\r\n    var dptr = top * DFRAME_SIZE\r\n    var lo        = BOX_DSTACK[dptr]\r\n    var hi        = BOX_DSTACK[dptr+1]\r\n\r\n    //Unpack state info\r\n    var flip      = (state & 1)\r\n    var full      = !!(state & 16)\r\n\r\n    //Unpack indices\r\n    var red       = xBoxes\r\n    var redIndex  = xIndex\r\n    var blue      = yBoxes\r\n    var blueIndex = yIndex\r\n    if(flip) {\r\n      red         = yBoxes\r\n      redIndex    = yIndex\r\n      blue        = xBoxes\r\n      blueIndex   = xIndex\r\n    }\r\n\r\n    if(state & 2) {\r\n      redEnd = partitionStartLessThan(\r\n        d, axis,\r\n        redStart, redEnd, red, redIndex,\r\n        hi)\r\n      if(redStart >= redEnd) {\r\n        continue\r\n      }\r\n    }\r\n    if(state & 4) {\r\n      redStart = partitionEndLessThanEqual(\r\n        d, axis,\r\n        redStart, redEnd, red, redIndex,\r\n        lo)\r\n      if(redStart >= redEnd) {\r\n        continue\r\n      }\r\n    }\r\n\r\n    var redCount  = redEnd  - redStart\r\n    var blueCount = blueEnd - blueStart\r\n\r\n    if(full) {\r\n      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\r\n        retval = sweep.scanComplete(\r\n          d, axis, visit,\r\n          redStart, redEnd, red, redIndex,\r\n          blueStart, blueEnd, blue, blueIndex)\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n        continue\r\n      }\r\n    } else {\r\n      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\r\n        //If input small, then use brute force\r\n        retval = bruteForcePartial(\r\n            d, axis, visit, flip,\r\n            redStart,  redEnd,  red,  redIndex,\r\n            blueStart, blueEnd, blue, blueIndex)\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n        continue\r\n      } else if(d * redCount * blueCount < SCAN_CUTOFF) {\r\n        //If input medium sized, then use sweep and prune\r\n        retval = sweep.scanBipartite(\r\n          d, axis, visit, flip,\r\n          redStart, redEnd, red, redIndex,\r\n          blueStart, blueEnd, blue, blueIndex)\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n        continue\r\n      }\r\n    }\r\n\r\n    //First, find all red intervals whose interior contains (lo,hi)\r\n    var red0 = partitionInteriorContainsInterval(\r\n      d, axis,\r\n      redStart, redEnd, red, redIndex,\r\n      lo, hi)\r\n\r\n    //Lower dimensional case\r\n    if(redStart < red0) {\r\n\r\n      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\r\n        //Special case for small inputs: use brute force\r\n        retval = bruteForceFull(\r\n          d, axis+1, visit,\r\n          redStart, red0, red, redIndex,\r\n          blueStart, blueEnd, blue, blueIndex)\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n      } else if(axis === d-2) {\r\n        if(flip) {\r\n          retval = sweep.sweepBipartite(\r\n            d, visit,\r\n            blueStart, blueEnd, blue, blueIndex,\r\n            redStart, red0, red, redIndex)\r\n        } else {\r\n          retval = sweep.sweepBipartite(\r\n            d, visit,\r\n            redStart, red0, red, redIndex,\r\n            blueStart, blueEnd, blue, blueIndex)\r\n        }\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n      } else {\r\n        iterPush(top++,\r\n          axis+1,\r\n          redStart, red0,\r\n          blueStart, blueEnd,\r\n          flip,\r\n          -Infinity, Infinity)\r\n        iterPush(top++,\r\n          axis+1,\r\n          blueStart, blueEnd,\r\n          redStart, red0,\r\n          flip^1,\r\n          -Infinity, Infinity)\r\n      }\r\n    }\r\n\r\n    //Divide and conquer phase\r\n    if(red0 < redEnd) {\r\n\r\n      //Cut blue into 3 parts:\r\n      //\r\n      //  Points < mid point\r\n      //  Points = mid point\r\n      //  Points > mid point\r\n      //\r\n      var blue0 = findMedian(\r\n        d, axis,\r\n        blueStart, blueEnd, blue, blueIndex)\r\n      var mid = blue[elemSize * blue0 + axis]\r\n      var blue1 = partitionStartEqual(\r\n        d, axis,\r\n        blue0, blueEnd, blue, blueIndex,\r\n        mid)\r\n\r\n      //Right case\r\n      if(blue1 < blueEnd) {\r\n        iterPush(top++,\r\n          axis,\r\n          red0, redEnd,\r\n          blue1, blueEnd,\r\n          (flip|4) + (full ? 16 : 0),\r\n          mid, hi)\r\n      }\r\n\r\n      //Left case\r\n      if(blueStart < blue0) {\r\n        iterPush(top++,\r\n          axis,\r\n          red0, redEnd,\r\n          blueStart, blue0,\r\n          (flip|2) + (full ? 16 : 0),\r\n          lo, mid)\r\n      }\r\n\r\n      //Center case (the hard part)\r\n      if(blue0 + 1 === blue1) {\r\n        //Optimization: Range with exactly 1 point, use a brute force scan\r\n        if(full) {\r\n          retval = onePointFull(\r\n            d, axis, visit,\r\n            red0, redEnd, red, redIndex,\r\n            blue0, blue, blueIndex[blue0])\r\n        } else {\r\n          retval = onePointPartial(\r\n            d, axis, visit, flip,\r\n            red0, redEnd, red, redIndex,\r\n            blue0, blue, blueIndex[blue0])\r\n        }\r\n        if(retval !== void 0) {\r\n          return retval\r\n        }\r\n      } else if(blue0 < blue1) {\r\n        var red1\r\n        if(full) {\r\n          //If full intersection, need to handle special case\r\n          red1 = partitionContainsPoint(\r\n            d, axis,\r\n            red0, redEnd, red, redIndex,\r\n            mid)\r\n          if(red0 < red1) {\r\n            var redX = partitionStartEqual(\r\n              d, axis,\r\n              red0, red1, red, redIndex,\r\n              mid)\r\n            if(axis === d-2) {\r\n              //Degenerate sweep intersection:\r\n              //  [red0, redX] with [blue0, blue1]\r\n              if(red0 < redX) {\r\n                retval = sweep.sweepComplete(\r\n                  d, visit,\r\n                  red0, redX, red, redIndex,\r\n                  blue0, blue1, blue, blueIndex)\r\n                if(retval !== void 0) {\r\n                  return retval\r\n                }\r\n              }\r\n\r\n              //Normal sweep intersection:\r\n              //  [redX, red1] with [blue0, blue1]\r\n              if(redX < red1) {\r\n                retval = sweep.sweepBipartite(\r\n                  d, visit,\r\n                  redX, red1, red, redIndex,\r\n                  blue0, blue1, blue, blueIndex)\r\n                if(retval !== void 0) {\r\n                  return retval\r\n                }\r\n              }\r\n            } else {\r\n              if(red0 < redX) {\r\n                iterPush(top++,\r\n                  axis+1,\r\n                  red0, redX,\r\n                  blue0, blue1,\r\n                  16,\r\n                  -Infinity, Infinity)\r\n              }\r\n              if(redX < red1) {\r\n                iterPush(top++,\r\n                  axis+1,\r\n                  redX, red1,\r\n                  blue0, blue1,\r\n                  0,\r\n                  -Infinity, Infinity)\r\n                iterPush(top++,\r\n                  axis+1,\r\n                  blue0, blue1,\r\n                  redX, red1,\r\n                  1,\r\n                  -Infinity, Infinity)\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          if(flip) {\r\n            red1 = partitionContainsPointProper(\r\n              d, axis,\r\n              red0, redEnd, red, redIndex,\r\n              mid)\r\n          } else {\r\n            red1 = partitionContainsPoint(\r\n              d, axis,\r\n              red0, redEnd, red, redIndex,\r\n              mid)\r\n          }\r\n          if(red0 < red1) {\r\n            if(axis === d-2) {\r\n              if(flip) {\r\n                retval = sweep.sweepBipartite(\r\n                  d, visit,\r\n                  blue0, blue1, blue, blueIndex,\r\n                  red0, red1, red, redIndex)\r\n              } else {\r\n                retval = sweep.sweepBipartite(\r\n                  d, visit,\r\n                  red0, red1, red, redIndex,\r\n                  blue0, blue1, blue, blueIndex)\r\n              }\r\n            } else {\r\n              iterPush(top++,\r\n                axis+1,\r\n                red0, red1,\r\n                blue0, blue1,\r\n                flip,\r\n                -Infinity, Infinity)\r\n              iterPush(top++,\r\n                axis+1,\r\n                blue0, blue1,\r\n                red0, red1,\r\n                flip^1,\r\n                -Infinity, Infinity)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"script"}