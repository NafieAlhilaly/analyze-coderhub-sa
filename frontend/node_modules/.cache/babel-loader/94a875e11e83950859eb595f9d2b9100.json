{"ast":null,"code":"'use strict';\n\nvar parse = require('parse-svg-path');\n\nvar abs = require('abs-svg-path');\n\nvar normalize = require('normalize-svg-path');\n\nvar isSvgPath = require('is-svg-path');\n\nmodule.exports = pathBounds;\n\nfunction pathBounds(path) {\n  // ES6 string tpl call\n  if (Array.isArray(path) && path.length === 1 && typeof path[0] === 'string') path = path[0]; // svg path string\n\n  if (typeof path === 'string') {\n    if (!isSvgPath(path)) throw Error('String is not an SVG path.');\n    path = parse(path);\n  }\n\n  if (!Array.isArray(path)) throw Error('Argument should be a string or an array of path segments.');\n  path = abs(path);\n  path = normalize(path);\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (var i = 0, l = path.length; i < l; i++) {\n    var points = path[i].slice(1);\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/svg-path-bounds/index.js"],"names":["parse","require","abs","normalize","isSvgPath","module","exports","pathBounds","path","Array","isArray","length","Error","bounds","Infinity","i","l","points","slice","j"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,cAAD,CAAjB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAvB;;AAEAI,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAGA,SAASA,UAAT,CAAoBC,IAApB,EAA0B;AACxB;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcF,IAAd,KAAuBA,IAAI,CAACG,MAAL,KAAgB,CAAvC,IAA4C,OAAOH,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAnE,EAA6EA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAX,CAFrD,CAIxB;;AACA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,CAACJ,SAAS,CAACI,IAAD,CAAd,EAAsB,MAAMI,KAAK,CAAC,4BAAD,CAAX;AACtBJ,IAAAA,IAAI,GAAGR,KAAK,CAACQ,IAAD,CAAZ;AACD;;AAED,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B,MAAMI,KAAK,CAAC,2DAAD,CAAX;AAE1BJ,EAAAA,IAAI,GAAGN,GAAG,CAACM,IAAD,CAAV;AACAA,EAAAA,IAAI,GAAGL,SAAS,CAACK,IAAD,CAAhB;AAEA,MAAI,CAACA,IAAI,CAACG,MAAV,EAAkB,OAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAP;AAElB,MAAIE,MAAM,GAAG,CAACC,QAAD,EAAWA,QAAX,EAAqB,CAACA,QAAtB,EAAgC,CAACA,QAAjC,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGR,IAAI,CAACG,MAAzB,EAAiCI,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,QAAIE,MAAM,GAAGT,IAAI,CAACO,CAAD,CAAJ,CAAQG,KAAR,CAAc,CAAd,CAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACN,MAA3B,EAAmCQ,CAAC,IAAI,CAAxC,EAA2C;AACzC,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAChC;AACF;;AAED,SAAON,MAAP;AACD","sourcesContent":["'use strict'\r\n\r\nvar parse = require('parse-svg-path')\r\nvar abs = require('abs-svg-path')\r\nvar normalize = require('normalize-svg-path')\r\nvar isSvgPath = require('is-svg-path')\r\n\r\nmodule.exports = pathBounds\r\n\r\n\r\nfunction pathBounds(path) {\r\n  // ES6 string tpl call\r\n  if (Array.isArray(path) && path.length === 1 && typeof path[0] === 'string') path = path[0]\r\n\r\n  // svg path string\r\n  if (typeof path === 'string') {\r\n    if (!isSvgPath(path)) throw Error('String is not an SVG path.')\r\n    path = parse(path)\r\n  }\r\n\r\n  if (!Array.isArray(path)) throw Error('Argument should be a string or an array of path segments.')\r\n\r\n  path = abs(path)\r\n  path = normalize(path)\r\n\r\n  if (!path.length) return [0, 0, 0, 0]\r\n\r\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity]\r\n\r\n  for (var i = 0, l = path.length; i < l; i++) {\r\n    var points = path[i].slice(1)\r\n\r\n    for (var j = 0; j < points.length; j += 2) {\r\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0]\r\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1]\r\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0]\r\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1]\r\n    }\r\n  }\r\n\r\n  return bounds\r\n}\r\n"]},"metadata":{},"sourceType":"script"}