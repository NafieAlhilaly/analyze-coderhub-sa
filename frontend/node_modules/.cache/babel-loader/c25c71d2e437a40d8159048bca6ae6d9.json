{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\n\nvar delta = require('../../constants/delta.js');\n\nvar DIRSYMBOL = {\n  increasing: delta.INCREASING.SYMBOL,\n  decreasing: delta.DECREASING.SYMBOL\n};\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n\n  if (trace.hoverlabel.split) {\n    return hoverSplit(pointData, xval, yval, hovermode);\n  }\n\n  return hoverOnPoints(pointData, xval, yval, hovermode);\n}\n\nfunction _getClosestPoint(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var type = trace.type;\n  var minAttr = type === 'ohlc' ? 'l' : 'min';\n  var maxAttr = type === 'ohlc' ? 'h' : 'max';\n  var hoverPseudoDistance, spikePseudoDistance; // potentially shift xval for grouped candlesticks\n\n  var centerShift = t.bPos || 0;\n\n  var shiftPos = function (di) {\n    return di.pos + centerShift - xval;\n  }; // ohlc and candlestick call displayHalfWidth different things...\n\n\n  var displayHalfWidth = t.bdPos || t.tickLen;\n  var hoverHalfWidth = t.wHover; // if two figures are overlaying, let the narrowest one win\n\n  var pseudoDistance = Math.min(1, displayHalfWidth / Math.abs(xa.r2c(xa.range[1]) - xa.r2c(xa.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n  function dx(di) {\n    var pos = shiftPos(di);\n    return Fx.inbox(pos - hoverHalfWidth, pos + hoverHalfWidth, hoverPseudoDistance);\n  }\n\n  function dy(di) {\n    var min = di[minAttr];\n    var max = di[maxAttr];\n    return min === max || Fx.inbox(min - yval, max - yval, hoverPseudoDistance);\n  }\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n  if (pointData.index === false) return null;\n  var di = cd[pointData.index];\n  if (di.empty) return null;\n  var dir = di.dir;\n  var container = trace[dir];\n  var lc = container.line.color;\n  if (Color.opacity(lc) && container.line.width) pointData.color = lc;else pointData.color = container.fillcolor;\n  pointData.x0 = xa.c2p(di.pos + centerShift - displayHalfWidth, true);\n  pointData.x1 = xa.c2p(di.pos + centerShift + displayHalfWidth, true);\n  pointData.xLabelVal = di.orig_p !== undefined ? di.orig_p : di.pos;\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData.xSpike = xa.c2p(di.pos, true);\n  return pointData;\n}\n\nfunction hoverSplit(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var closeBoxData = [];\n\n  var closestPoint = _getClosestPoint(pointData, xval, yval, hovermode); // skip the rest (for this trace) if we didn't find a close point\n\n\n  if (!closestPoint) return [];\n  var cdIndex = closestPoint.index;\n  var di = cd[cdIndex];\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var hoverParts = hoverinfo.split('+');\n  var isAll = hoverinfo === 'all';\n  var hasY = isAll || hoverParts.indexOf('y') !== -1; // similar to hoverOnPoints, we return nothing\n  // if all or y is not present.\n\n  if (!hasY) return [];\n  var attrs = ['high', 'open', 'close', 'low']; // several attributes can have the same y-coordinate. We will\n  // bunch them together in a single text block. For this, we keep\n  // a dictionary mapping y-coord -> point data.\n\n  var usedVals = {};\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var val = trace[attr][closestPoint.index];\n    var valPx = ya.c2p(val, true);\n    var pointData2;\n\n    if (val in usedVals) {\n      pointData2 = usedVals[val];\n      pointData2.yLabel += '<br>' + t.labels[attr] + Axes.hoverLabelText(ya, val, trace.yhoverformat);\n    } else {\n      // copy out to a new object for each new y-value to label\n      pointData2 = Lib.extendFlat({}, closestPoint);\n      pointData2.y0 = pointData2.y1 = valPx;\n      pointData2.yLabelVal = val;\n      pointData2.yLabel = t.labels[attr] + Axes.hoverLabelText(ya, val, trace.yhoverformat);\n      pointData2.name = '';\n      closeBoxData.push(pointData2);\n      usedVals[val] = pointData2;\n    }\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n\n  var closestPoint = _getClosestPoint(pointData, xval, yval, hovermode); // skip the rest (for this trace) if we didn't find a close point\n\n\n  if (!closestPoint) return []; // we don't make a calcdata point if we're missing any piece (x/o/h/l/c)\n  // so we need to fix the index here to point to the data arrays\n\n  var cdIndex = closestPoint.index;\n  var di = cd[cdIndex];\n  var i = closestPoint.index = di.i;\n  var dir = di.dir;\n\n  function getLabelLine(attr) {\n    return t.labels[attr] + Axes.hoverLabelText(ya, trace[attr][i], trace.yhoverformat);\n  }\n\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var hoverParts = hoverinfo.split('+');\n  var isAll = hoverinfo === 'all';\n  var hasY = isAll || hoverParts.indexOf('y') !== -1;\n  var hasText = isAll || hoverParts.indexOf('text') !== -1;\n  var textParts = hasY ? [getLabelLine('open'), getLabelLine('high'), getLabelLine('low'), getLabelLine('close') + '  ' + DIRSYMBOL[dir]] : [];\n  if (hasText) fillText(di, trace, textParts); // don't make .yLabelVal or .text, since we're managing hoverinfo\n  // put it all in .extraText\n\n  closestPoint.extraText = textParts.join('<br>'); // this puts the label *and the spike* at the midpoint of the box, ie\n  // halfway between open and close, not between high and low.\n\n  closestPoint.y0 = closestPoint.y1 = ya.c2p(di.yc, true);\n  return [closestPoint];\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverSplit: hoverSplit,\n  hoverOnPoints: hoverOnPoints\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/ohlc/hover.js"],"names":["Axes","require","Lib","Fx","Color","fillText","delta","DIRSYMBOL","increasing","INCREASING","SYMBOL","decreasing","DECREASING","hoverPoints","pointData","xval","yval","hovermode","cd","trace","hoverlabel","split","hoverSplit","hoverOnPoints","_getClosestPoint","xa","t","type","minAttr","maxAttr","hoverPseudoDistance","spikePseudoDistance","centerShift","bPos","shiftPos","di","pos","displayHalfWidth","bdPos","tickLen","hoverHalfWidth","wHover","pseudoDistance","Math","min","abs","r2c","range","maxHoverDistance","maxSpikeDistance","dx","inbox","dy","max","dxy","distfn","getDistanceFunction","getClosest","index","empty","dir","container","lc","line","color","opacity","width","fillcolor","x0","c2p","x1","xLabelVal","orig_p","undefined","spikeDistance","xSpike","ya","closeBoxData","closestPoint","cdIndex","hoverinfo","hi","hoverParts","isAll","hasY","indexOf","attrs","usedVals","i","length","attr","val","valPx","pointData2","yLabel","labels","hoverLabelText","yhoverformat","extendFlat","y0","y1","yLabelVal","name","push","getLabelLine","hasText","textParts","extraText","join","yc","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillText = require('../../lib').fillText;\nvar delta = require('../../constants/delta.js');\n\nvar DIRSYMBOL = {\n    increasing: delta.INCREASING.SYMBOL,\n    decreasing: delta.DECREASING.SYMBOL\n};\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n\n    if(trace.hoverlabel.split) {\n        return hoverSplit(pointData, xval, yval, hovermode);\n    }\n\n    return hoverOnPoints(pointData, xval, yval, hovermode);\n}\n\nfunction _getClosestPoint(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n\n    var type = trace.type;\n    var minAttr = type === 'ohlc' ? 'l' : 'min';\n    var maxAttr = type === 'ohlc' ? 'h' : 'max';\n\n    var hoverPseudoDistance, spikePseudoDistance;\n\n    // potentially shift xval for grouped candlesticks\n    var centerShift = t.bPos || 0;\n    var shiftPos = function(di) { return di.pos + centerShift - xval; };\n\n    // ohlc and candlestick call displayHalfWidth different things...\n    var displayHalfWidth = t.bdPos || t.tickLen;\n    var hoverHalfWidth = t.wHover;\n\n    // if two figures are overlaying, let the narrowest one win\n    var pseudoDistance = Math.min(1, displayHalfWidth / Math.abs(xa.r2c(xa.range[1]) - xa.r2c(xa.range[0])));\n    hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n    spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n    function dx(di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos - hoverHalfWidth, pos + hoverHalfWidth, hoverPseudoDistance);\n    }\n\n    function dy(di) {\n        var min = di[minAttr];\n        var max = di[maxAttr];\n        return min === max || Fx.inbox(min - yval, max - yval, hoverPseudoDistance);\n    }\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    if(pointData.index === false) return null;\n\n    var di = cd[pointData.index];\n\n    if(di.empty) return null;\n\n    var dir = di.dir;\n    var container = trace[dir];\n    var lc = container.line.color;\n\n    if(Color.opacity(lc) && container.line.width) pointData.color = lc;\n    else pointData.color = container.fillcolor;\n\n    pointData.x0 = xa.c2p(di.pos + centerShift - displayHalfWidth, true);\n    pointData.x1 = xa.c2p(di.pos + centerShift + displayHalfWidth, true);\n\n    pointData.xLabelVal = di.orig_p !== undefined ? di.orig_p : di.pos;\n\n    pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n    pointData.xSpike = xa.c2p(di.pos, true);\n\n    return pointData;\n}\n\nfunction hoverSplit(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var closeBoxData = [];\n\n    var closestPoint = _getClosestPoint(pointData, xval, yval, hovermode);\n    // skip the rest (for this trace) if we didn't find a close point\n    if(!closestPoint) return [];\n\n    var cdIndex = closestPoint.index;\n    var di = cd[cdIndex];\n    var hoverinfo = di.hi || trace.hoverinfo;\n    var hoverParts = hoverinfo.split('+');\n    var isAll = hoverinfo === 'all';\n    var hasY = isAll || hoverParts.indexOf('y') !== -1;\n\n    // similar to hoverOnPoints, we return nothing\n    // if all or y is not present.\n    if(!hasY) return [];\n\n    var attrs = ['high', 'open', 'close', 'low'];\n\n    // several attributes can have the same y-coordinate. We will\n    // bunch them together in a single text block. For this, we keep\n    // a dictionary mapping y-coord -> point data.\n    var usedVals = {};\n\n    for(var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n\n        var val = trace[attr][closestPoint.index];\n        var valPx = ya.c2p(val, true);\n        var pointData2;\n        if(val in usedVals) {\n            pointData2 = usedVals[val];\n            pointData2.yLabel += '<br>' + t.labels[attr] + Axes.hoverLabelText(ya, val, trace.yhoverformat);\n        } else {\n            // copy out to a new object for each new y-value to label\n            pointData2 = Lib.extendFlat({}, closestPoint);\n\n            pointData2.y0 = pointData2.y1 = valPx;\n            pointData2.yLabelVal = val;\n            pointData2.yLabel = t.labels[attr] + Axes.hoverLabelText(ya, val, trace.yhoverformat);\n\n            pointData2.name = '';\n\n            closeBoxData.push(pointData2);\n            usedVals[val] = pointData2;\n        }\n    }\n\n    return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n\n    var closestPoint = _getClosestPoint(pointData, xval, yval, hovermode);\n    // skip the rest (for this trace) if we didn't find a close point\n    if(!closestPoint) return [];\n\n    // we don't make a calcdata point if we're missing any piece (x/o/h/l/c)\n    // so we need to fix the index here to point to the data arrays\n    var cdIndex = closestPoint.index;\n    var di = cd[cdIndex];\n    var i = closestPoint.index = di.i;\n    var dir = di.dir;\n\n    function getLabelLine(attr) {\n        return t.labels[attr] + Axes.hoverLabelText(ya, trace[attr][i], trace.yhoverformat);\n    }\n\n    var hoverinfo = di.hi || trace.hoverinfo;\n    var hoverParts = hoverinfo.split('+');\n    var isAll = hoverinfo === 'all';\n    var hasY = isAll || hoverParts.indexOf('y') !== -1;\n    var hasText = isAll || hoverParts.indexOf('text') !== -1;\n\n    var textParts = hasY ? [\n        getLabelLine('open'),\n        getLabelLine('high'),\n        getLabelLine('low'),\n        getLabelLine('close') + '  ' + DIRSYMBOL[dir]\n    ] : [];\n    if(hasText) fillText(di, trace, textParts);\n\n    // don't make .yLabelVal or .text, since we're managing hoverinfo\n    // put it all in .extraText\n    closestPoint.extraText = textParts.join('<br>');\n\n    // this puts the label *and the spike* at the midpoint of the box, ie\n    // halfway between open and close, not between high and low.\n    closestPoint.y0 = closestPoint.y1 = ya.c2p(di.yc, true);\n\n    return [closestPoint];\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverSplit: hoverSplit,\n    hoverOnPoints: hoverOnPoints\n};\n"]},"metadata":{},"sourceType":"script"}