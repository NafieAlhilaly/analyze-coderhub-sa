{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar loggers = require('./loggers');\n\nvar identity = require('./identity');\n\nvar BADNUM = require('../constants/numerical').BADNUM; // don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\n\n\nvar roundingError = 1e-9;\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\n\nexports.findBin = function (val, bins, linelow) {\n  if (isNumeric(bins.start)) {\n    return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);\n  } else {\n    var n1 = 0;\n    var n2 = bins.length;\n    var c = 0;\n    var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n    var n, test;\n\n    if (binSize >= 0) {\n      test = linelow ? lessThan : lessOrEqual;\n    } else {\n      test = linelow ? greaterOrEqual : greaterThan;\n    }\n\n    val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1); // c is just to avoid infinite loops if there's an error\n\n    while (n1 < n2 && c++ < 100) {\n      n = Math.floor((n1 + n2) / 2);\n      if (test(bins[n], val)) n1 = n + 1;else n2 = n;\n    }\n\n    if (c > 90) loggers.log('Long binary search...');\n    return n1 - 1;\n  }\n};\n\nfunction lessThan(a, b) {\n  return a < b;\n}\n\nfunction lessOrEqual(a, b) {\n  return a <= b;\n}\n\nfunction greaterThan(a, b) {\n  return a > b;\n}\n\nfunction greaterOrEqual(a, b) {\n  return a >= b;\n}\n\nexports.sorterAsc = function (a, b) {\n  return a - b;\n};\n\nexports.sorterDes = function (a, b) {\n  return b - a;\n};\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\n\n\nexports.distinctVals = function (valsIn) {\n  var vals = valsIn.slice(); // otherwise we sort the original array...\n\n  vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11\n\n  var last;\n\n  for (last = vals.length - 1; last > -1; last--) {\n    if (vals[last] !== BADNUM) break;\n  }\n\n  var minDiff = vals[last] - vals[0] || 1;\n  var errDiff = minDiff / (last || 1) / 10000;\n  var newVals = [];\n  var preV;\n\n  for (var i = 0; i <= last; i++) {\n    var v = vals[i]; // make sure values aren't just off by a rounding error\n\n    var diff = v - preV;\n\n    if (preV === undefined) {\n      newVals.push(v);\n      preV = v;\n    } else if (diff > errDiff) {\n      minDiff = Math.min(minDiff, diff);\n      newVals.push(v);\n      preV = v;\n    }\n  }\n\n  return {\n    vals: newVals,\n    minDiff: minDiff\n  };\n};\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\n\n\nexports.roundUp = function (val, arrayIn, reverse) {\n  var low = 0;\n  var high = arrayIn.length - 1;\n  var mid;\n  var c = 0;\n  var dlow = reverse ? 0 : 1;\n  var dhigh = reverse ? 1 : 0;\n  var rounded = reverse ? Math.ceil : Math.floor; // c is just to avoid infinite loops if there's an error\n\n  while (low < high && c++ < 100) {\n    mid = rounded((low + high) / 2);\n    if (arrayIn[mid] <= val) low = mid + dlow;else high = mid - dhigh;\n  }\n\n  return arrayIn[low];\n};\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\n\n\nexports.sort = function (array, sortFn) {\n  var notOrdered = 0;\n  var notReversed = 0;\n\n  for (var i = 1; i < array.length; i++) {\n    var pairOrder = sortFn(array[i], array[i - 1]);\n    if (pairOrder < 0) notOrdered = 1;else if (pairOrder > 0) notReversed = 1;\n    if (notOrdered && notReversed) return array.sort(sortFn);\n  }\n\n  return notReversed ? array : array.reverse();\n};\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\n\n\nexports.findIndexOfMin = function (arr, fn) {\n  fn = fn || identity;\n  var min = Infinity;\n  var ind;\n\n  for (var i = 0; i < arr.length; i++) {\n    var v = fn(arr[i]);\n\n    if (v < min) {\n      min = v;\n      ind = i;\n    }\n  }\n\n  return ind;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/lib/search.js"],"names":["isNumeric","require","loggers","identity","BADNUM","roundingError","exports","findBin","val","bins","linelow","start","Math","ceil","size","floor","n1","n2","length","c","binSize","n","test","lessThan","lessOrEqual","greaterOrEqual","greaterThan","log","a","b","sorterAsc","sorterDes","distinctVals","valsIn","vals","slice","sort","last","minDiff","errDiff","newVals","preV","i","v","diff","undefined","push","min","roundUp","arrayIn","reverse","low","high","mid","dlow","dhigh","rounded","array","sortFn","notOrdered","notReversed","pairOrder","findIndexOfMin","arr","fn","Infinity","ind"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar loggers = require('./loggers');\nvar identity = require('./identity');\nvar BADNUM = require('../constants/numerical').BADNUM;\n\n// don't trust floating point equality - fraction of bin size to call\n// \"on the line\" and ensure that they go the right way specified by\n// linelow\nvar roundingError = 1e-9;\n\n\n/**\n * findBin - find the bin for val - note that it can return outside the\n * bin range any pos. or neg. integer for linear bins, or -1 or\n * bins.length-1 for explicit.\n * bins is either an object {start,size,end} or an array length #bins+1\n * bins can be either increasing or decreasing but must be monotonic\n * for linear bins, we can just calculate. For listed bins, run a binary\n * search linelow (truthy) says the bin boundary should be attributed to\n * the lower bin rather than the default upper bin\n */\nexports.findBin = function(val, bins, linelow) {\n    if(isNumeric(bins.start)) {\n        return linelow ?\n            Math.ceil((val - bins.start) / bins.size - roundingError) - 1 :\n            Math.floor((val - bins.start) / bins.size + roundingError);\n    } else {\n        var n1 = 0;\n        var n2 = bins.length;\n        var c = 0;\n        var binSize = (n2 > 1) ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;\n        var n, test;\n        if(binSize >= 0) {\n            test = linelow ? lessThan : lessOrEqual;\n        } else {\n            test = linelow ? greaterOrEqual : greaterThan;\n        }\n        val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);\n        // c is just to avoid infinite loops if there's an error\n        while(n1 < n2 && c++ < 100) {\n            n = Math.floor((n1 + n2) / 2);\n            if(test(bins[n], val)) n1 = n + 1;\n            else n2 = n;\n        }\n        if(c > 90) loggers.log('Long binary search...');\n        return n1 - 1;\n    }\n};\n\nfunction lessThan(a, b) { return a < b; }\nfunction lessOrEqual(a, b) { return a <= b; }\nfunction greaterThan(a, b) { return a > b; }\nfunction greaterOrEqual(a, b) { return a >= b; }\n\nexports.sorterAsc = function(a, b) { return a - b; };\nexports.sorterDes = function(a, b) { return b - a; };\n\n/**\n * find distinct values in an array, lumping together ones that appear to\n * just be off by a rounding error\n * return the distinct values and the minimum difference between any two\n */\nexports.distinctVals = function(valsIn) {\n    var vals = valsIn.slice();  // otherwise we sort the original array...\n    vals.sort(exports.sorterAsc); // undefined listed in the end - also works on IE11\n\n    var last;\n    for(last = vals.length - 1; last > -1; last--) {\n        if(vals[last] !== BADNUM) break;\n    }\n\n    var minDiff = (vals[last] - vals[0]) || 1;\n    var errDiff = minDiff / (last || 1) / 10000;\n    var newVals = [];\n    var preV;\n    for(var i = 0; i <= last; i++) {\n        var v = vals[i];\n\n        // make sure values aren't just off by a rounding error\n        var diff = v - preV;\n\n        if(preV === undefined) {\n            newVals.push(v);\n            preV = v;\n        } else if(diff > errDiff) {\n            minDiff = Math.min(minDiff, diff);\n\n            newVals.push(v);\n            preV = v;\n        }\n    }\n\n    return {vals: newVals, minDiff: minDiff};\n};\n\n/**\n * return the smallest element from (sorted) array arrayIn that's bigger than val,\n * or (reverse) the largest element smaller than val\n * used to find the best tick given the minimum (non-rounded) tick\n * particularly useful for date/time where things are not powers of 10\n * binary search is probably overkill here...\n */\nexports.roundUp = function(val, arrayIn, reverse) {\n    var low = 0;\n    var high = arrayIn.length - 1;\n    var mid;\n    var c = 0;\n    var dlow = reverse ? 0 : 1;\n    var dhigh = reverse ? 1 : 0;\n    var rounded = reverse ? Math.ceil : Math.floor;\n    // c is just to avoid infinite loops if there's an error\n    while(low < high && c++ < 100) {\n        mid = rounded((low + high) / 2);\n        if(arrayIn[mid] <= val) low = mid + dlow;\n        else high = mid - dhigh;\n    }\n    return arrayIn[low];\n};\n\n/**\n * Tweak to Array.sort(sortFn) that improves performance for pre-sorted arrays\n *\n * Note that newer browsers (such as Chrome v70+) are starting to pick up\n * on pre-sorted arrays which may render the following optimization unnecessary\n * in the future.\n *\n * Motivation: sometimes we need to sort arrays but the input is likely to\n * already be sorted. Browsers don't seem to pick up on pre-sorted arrays,\n * and in fact Chrome is actually *slower* sorting pre-sorted arrays than purely\n * random arrays. FF is at least faster if the array is pre-sorted, but still\n * not as fast as it could be.\n * Here's how this plays out sorting a length-1e6 array:\n *\n * Calls to Sort FN  |  Chrome bare  |  FF bare  |  Chrome tweak  |  FF tweak\n *                   |  v68.0 Mac    |  v61.0 Mac|                |\n * ------------------+---------------+-----------+----------------+------------\n * ordered           |  30.4e6       |  10.1e6   |  1e6           |  1e6\n * reversed          |  29.4e6       |  9.9e6    |  1e6 + reverse |  1e6 + reverse\n * random            |  ~21e6        |  ~18.7e6  |  ~21e6         |  ~18.7e6\n *\n * So this is a substantial win for pre-sorted (ordered or exactly reversed)\n * arrays. Including this wrapper on an unsorted array adds a penalty that will\n * in general be only a few calls to the sort function. The only case this\n * penalty will be significant is if the array is mostly sorted but there are\n * a few unsorted items near the end, but the penalty is still at most N calls\n * out of (for N=1e6) ~20N total calls\n *\n * @param {Array} array: the array, to be sorted in place\n * @param {function} sortFn: As in Array.sort, function(a, b) that puts\n *     item a before item b if the return is negative, a after b if positive,\n *     and no change if zero.\n * @return {Array}: the original array, sorted in place.\n */\nexports.sort = function(array, sortFn) {\n    var notOrdered = 0;\n    var notReversed = 0;\n    for(var i = 1; i < array.length; i++) {\n        var pairOrder = sortFn(array[i], array[i - 1]);\n        if(pairOrder < 0) notOrdered = 1;\n        else if(pairOrder > 0) notReversed = 1;\n        if(notOrdered && notReversed) return array.sort(sortFn);\n    }\n    return notReversed ? array : array.reverse();\n};\n\n/**\n * find index in array 'arr' that minimizes 'fn'\n *\n * @param {array} arr : array where to search\n * @param {fn (optional)} fn : function to minimize,\n *   if not given, fn is the identity function\n * @return {integer}\n */\nexports.findIndexOfMin = function(arr, fn) {\n    fn = fn || identity;\n\n    var min = Infinity;\n    var ind;\n\n    for(var i = 0; i < arr.length; i++) {\n        var v = fn(arr[i]);\n        if(v < min) {\n            min = v;\n            ind = i;\n        }\n    }\n    return ind;\n};\n"]},"metadata":{},"sourceType":"script"}