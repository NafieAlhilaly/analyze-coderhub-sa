{"ast":null,"code":"'use strict';\n\nmodule.exports = extractContour;\n\nvar ndarray = require('ndarray');\n\nvar pool = require('typedarray-pool');\n\nvar ndsort = require('ndarray-sort');\n\nvar contourAlgorithm = require('./lib/codegen');\n\nfunction getDimension(cells) {\n  var numCells = cells.length;\n  var d = 0;\n\n  for (var i = 0; i < numCells; ++i) {\n    d = Math.max(d, cells[i].length) | 0;\n  }\n\n  return d - 1;\n}\n\nfunction getSigns(values, level) {\n  var numVerts = values.length;\n  var vertexSigns = pool.mallocUint8(numVerts);\n\n  for (var i = 0; i < numVerts; ++i) {\n    vertexSigns[i] = values[i] < level | 0;\n  }\n\n  return vertexSigns;\n}\n\nfunction getEdges(cells, d) {\n  var numCells = cells.length;\n  var maxEdges = d * (d + 1) / 2 * numCells | 0;\n  var edges = pool.mallocUint32(maxEdges * 2);\n  var ePtr = 0;\n\n  for (var i = 0; i < numCells; ++i) {\n    var c = cells[i];\n    var d = c.length;\n\n    for (var j = 0; j < d; ++j) {\n      for (var k = 0; k < j; ++k) {\n        var a = c[k];\n        var b = c[j];\n        edges[ePtr++] = Math.min(a, b) | 0;\n        edges[ePtr++] = Math.max(a, b) | 0;\n      }\n    }\n  }\n\n  var nedges = ePtr / 2 | 0;\n  ndsort(ndarray(edges, [nedges, 2]));\n  var ptr = 2;\n\n  for (var i = 2; i < ePtr; i += 2) {\n    if (edges[i - 2] === edges[i] && edges[i - 1] === edges[i + 1]) {\n      continue;\n    }\n\n    edges[ptr++] = edges[i];\n    edges[ptr++] = edges[i + 1];\n  }\n\n  return ndarray(edges, [ptr / 2 | 0, 2]);\n}\n\nfunction getCrossingWeights(edges, values, signs, level) {\n  var edata = edges.data;\n  var numEdges = edges.shape[0];\n  var weights = pool.mallocDouble(numEdges);\n  var ptr = 0;\n\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n    var b = edata[2 * i + 1];\n\n    if (signs[a] === signs[b]) {\n      continue;\n    }\n\n    var va = values[a];\n    var vb = values[b];\n    edata[2 * ptr] = a;\n    edata[2 * ptr + 1] = b;\n    weights[ptr++] = (vb - level) / (vb - va);\n  }\n\n  edges.shape[0] = ptr;\n  return ndarray(weights, [ptr]);\n}\n\nfunction getCascade(edges, numVerts) {\n  var result = pool.mallocInt32(numVerts * 2);\n  var numEdges = edges.shape[0];\n  var edata = edges.data;\n  result[0] = 0;\n  var lastV = 0;\n\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n\n    if (a !== lastV) {\n      result[2 * lastV + 1] = i;\n\n      while (++lastV < a) {\n        result[2 * lastV] = i;\n        result[2 * lastV + 1] = i;\n      }\n\n      result[2 * lastV] = i;\n    }\n  }\n\n  result[2 * lastV + 1] = numEdges;\n\n  while (++lastV < numVerts) {\n    result[2 * lastV] = result[2 * lastV + 1] = numEdges;\n  }\n\n  return result;\n}\n\nfunction unpackEdges(edges) {\n  var ne = edges.shape[0] | 0;\n  var edata = edges.data;\n  var result = new Array(ne);\n\n  for (var i = 0; i < ne; ++i) {\n    result[i] = [edata[2 * i], edata[2 * i + 1]];\n  }\n\n  return result;\n}\n\nfunction extractContour(cells, values, level, d) {\n  level = level || 0.0; //If user didn't specify `d`, use brute force scan\n\n  if (typeof d === 'undefined') {\n    d = getDimension(cells);\n  } //Count number of cells\n\n\n  var numCells = cells.length;\n\n  if (numCells === 0 || d < 1) {\n    return {\n      cells: [],\n      vertexIds: [],\n      vertexWeights: []\n    };\n  } //Read in vertex signs\n\n\n  var vertexSigns = getSigns(values, +level); //First get 1-skeleton, find all crossings\n\n  var edges = getEdges(cells, d);\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level); //Build vertex cascade to speed up binary search\n\n  var vcascade = getCascade(edges, values.length | 0); //Then construct cells\n\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns); //Unpack data into pretty format\n\n  var uedges = unpackEdges(edges);\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0]); //Release data\n\n  pool.free(vertexSigns);\n  pool.free(edges.data);\n  pool.free(weights.data);\n  pool.free(vcascade);\n  return {\n    cells: faces,\n    vertexIds: uedges,\n    vertexWeights: uweights\n  };\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/simplicial-complex-contour/contour.js"],"names":["module","exports","extractContour","ndarray","require","pool","ndsort","contourAlgorithm","getDimension","cells","numCells","length","d","i","Math","max","getSigns","values","level","numVerts","vertexSigns","mallocUint8","getEdges","maxEdges","edges","mallocUint32","ePtr","c","j","k","a","b","min","nedges","ptr","getCrossingWeights","signs","edata","data","numEdges","shape","weights","mallocDouble","va","vb","getCascade","result","mallocInt32","lastV","unpackEdges","ne","Array","vertexIds","vertexWeights","vcascade","faces","uedges","uweights","slice","call","free"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = extractContour\r\n\r\nvar ndarray = require('ndarray')\r\nvar pool    = require('typedarray-pool')\r\nvar ndsort  = require('ndarray-sort')\r\n\r\nvar contourAlgorithm = require('./lib/codegen')\r\n\r\nfunction getDimension(cells) {\r\n  var numCells = cells.length\r\n  var d = 0\r\n  for(var i=0; i<numCells; ++i) {\r\n    d = Math.max(d, cells[i].length)|0\r\n  }\r\n  return d-1\r\n}\r\n\r\nfunction getSigns(values, level) {\r\n  var numVerts    = values.length\r\n  var vertexSigns = pool.mallocUint8(numVerts)\r\n  for(var i=0; i<numVerts; ++i) {\r\n    vertexSigns[i] = (values[i] < level)|0\r\n  }\r\n  return vertexSigns\r\n}\r\n\r\nfunction getEdges(cells, d) {\r\n  var numCells = cells.length\r\n  var maxEdges = ((d * (d+1)/2) * numCells)|0\r\n  var edges    = pool.mallocUint32(maxEdges*2)\r\n  var ePtr     = 0\r\n  for(var i=0; i<numCells; ++i) {\r\n    var c = cells[i]\r\n    var d = c.length\r\n    for(var j=0; j<d; ++j) {\r\n      for(var k=0; k<j; ++k) {\r\n        var a = c[k]\r\n        var b = c[j]\r\n        edges[ePtr++] = Math.min(a,b)|0\r\n        edges[ePtr++] = Math.max(a,b)|0\r\n      }\r\n    }\r\n  }\r\n  var nedges = (ePtr/2)|0\r\n  ndsort(ndarray(edges, [nedges,2])) \r\n  var ptr = 2\r\n  for(var i=2; i<ePtr; i+=2) {\r\n    if(edges[i-2] === edges[i] &&\r\n       edges[i-1] === edges[i+1]) {\r\n      continue\r\n    }\r\n    edges[ptr++] = edges[i]\r\n    edges[ptr++] = edges[i+1]\r\n  }\r\n\r\n  return ndarray(edges, [(ptr/2)|0, 2])\r\n}\r\n\r\nfunction getCrossingWeights(edges, values, signs, level) {\r\n  var edata     = edges.data\r\n  var numEdges  = edges.shape[0]\r\n  var weights   = pool.mallocDouble(numEdges)\r\n  var ptr       = 0\r\n  for(var i=0; i<numEdges; ++i) {\r\n    var a  = edata[2*i]\r\n    var b  = edata[2*i+1]\r\n    if(signs[a] === signs[b]) {\r\n      continue\r\n    }\r\n    var va = values[a]\r\n    var vb = values[b]\r\n    edata[2*ptr]     = a\r\n    edata[2*ptr+1]   = b\r\n    weights[ptr++]   = (vb - level) / (vb - va)\r\n  }\r\n  edges.shape[0] = ptr\r\n  return ndarray(weights, [ptr])\r\n}\r\n\r\nfunction getCascade(edges, numVerts) {\r\n  var result   = pool.mallocInt32(numVerts*2)\r\n  var numEdges = edges.shape[0]\r\n  var edata    = edges.data\r\n  result[0]    = 0\r\n  var lastV    = 0\r\n  for(var i=0; i<numEdges; ++i) {\r\n    var a = edata[2*i]\r\n    if(a !== lastV) {\r\n      result[2*lastV+1] = i\r\n      while(++lastV < a) {\r\n        result[2*lastV] = i\r\n        result[2*lastV+1] = i\r\n      }\r\n      result[2*lastV] = i\r\n    }\r\n  }\r\n  result[2*lastV+1] = numEdges\r\n  while(++lastV < numVerts) {\r\n    result[2*lastV] = result[2*lastV+1] = numEdges\r\n  }\r\n  return result\r\n}\r\n\r\nfunction unpackEdges(edges) {\r\n  var ne = edges.shape[0]|0\r\n  var edata = edges.data\r\n  var result = new Array(ne)\r\n  for(var i=0; i<ne; ++i) {\r\n    result[i] = [edata[2*i], edata[2*i+1]]\r\n  }\r\n  return result\r\n}\r\n\r\nfunction extractContour(cells, values, level, d) {\r\n  level = level||0.0\r\n\r\n  //If user didn't specify `d`, use brute force scan\r\n  if(typeof d === 'undefined') {\r\n    d = getDimension(cells)\r\n  }\r\n\r\n  //Count number of cells\r\n  var numCells = cells.length\r\n  if(numCells === 0 || d < 1) {\r\n    return {\r\n      cells:         [],\r\n      vertexIds:     [],\r\n      vertexWeights: []\r\n    }\r\n  }\r\n\r\n  //Read in vertex signs\r\n  var vertexSigns = getSigns(values, +level)\r\n\r\n  //First get 1-skeleton, find all crossings\r\n  var edges   = getEdges(cells, d)\r\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level)\r\n\r\n  //Build vertex cascade to speed up binary search\r\n  var vcascade = getCascade(edges, values.length|0)\r\n\r\n  //Then construct cells\r\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns)\r\n\r\n  //Unpack data into pretty format\r\n  var uedges   = unpackEdges(edges)\r\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0])\r\n\r\n  //Release data\r\n  pool.free(vertexSigns)\r\n  pool.free(edges.data)\r\n  pool.free(weights.data)\r\n  pool.free(vcascade)\r\n  \r\n  return {\r\n    cells:         faces,\r\n    vertexIds:     uedges,\r\n    vertexWeights: uweights\r\n  }\r\n}"]},"metadata":{},"sourceType":"script"}