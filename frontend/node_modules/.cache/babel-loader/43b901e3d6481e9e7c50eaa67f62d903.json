{"ast":null,"code":"'use strict';\n\nmodule.exports = function (pathinfo, contours) {\n  var pi0 = pathinfo[0];\n  var z = pi0.z;\n  var i;\n\n  switch (contours.type) {\n    case 'levels':\n      // Why (just) use z[0][0] and z[0][1]?\n      //\n      // N.B. using boundaryMin instead of edgeVal2 here makes the\n      //      `contour_scatter` mock fail\n      var edgeVal2 = Math.min(z[0][0], z[0][1]);\n\n      for (i = 0; i < pathinfo.length; i++) {\n        var pi = pathinfo[i];\n        pi.prefixBoundary = !pi.edgepaths.length && (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);\n      }\n\n      break;\n\n    case 'constraint':\n      // after convertToConstraints, pathinfo has length=0\n      pi0.prefixBoundary = false; // joinAllPaths does enough already when edgepaths are present\n\n      if (pi0.edgepaths.length) return;\n      var na = pi0.x.length;\n      var nb = pi0.y.length;\n      var boundaryMax = -Infinity;\n      var boundaryMin = Infinity;\n\n      for (i = 0; i < nb; i++) {\n        boundaryMin = Math.min(boundaryMin, z[i][0]);\n        boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n        boundaryMax = Math.max(boundaryMax, z[i][0]);\n        boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n      }\n\n      for (i = 1; i < na - 1; i++) {\n        boundaryMin = Math.min(boundaryMin, z[0][i]);\n        boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n        boundaryMax = Math.max(boundaryMax, z[0][i]);\n        boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n      }\n\n      var contoursValue = contours.value;\n      var v1, v2;\n\n      switch (contours._operation) {\n        case '>':\n          if (contoursValue > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '<':\n          if (contoursValue < boundaryMin || pi0.starts.length && contoursValue === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '[]':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n\n          if (v2 < boundaryMin || v1 > boundaryMax || pi0.starts.length && v2 === boundaryMin) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n\n        case '][':\n          v1 = Math.min(contoursValue[0], contoursValue[1]);\n          v2 = Math.max(contoursValue[0], contoursValue[1]);\n\n          if (v1 < boundaryMin && v2 > boundaryMax) {\n            pi0.prefixBoundary = true;\n          }\n\n          break;\n      }\n\n      break;\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/contour/close_boundaries.js"],"names":["module","exports","pathinfo","contours","pi0","z","i","type","edgeVal2","Math","min","length","pi","prefixBoundary","edgepaths","level","starts","na","x","nb","y","boundaryMax","Infinity","boundaryMin","max","contoursValue","value","v1","v2","_operation"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(pathinfo, contours) {\n    var pi0 = pathinfo[0];\n    var z = pi0.z;\n    var i;\n\n    switch(contours.type) {\n        case 'levels':\n            // Why (just) use z[0][0] and z[0][1]?\n            //\n            // N.B. using boundaryMin instead of edgeVal2 here makes the\n            //      `contour_scatter` mock fail\n            var edgeVal2 = Math.min(z[0][0], z[0][1]);\n\n            for(i = 0; i < pathinfo.length; i++) {\n                var pi = pathinfo[i];\n                pi.prefixBoundary = !pi.edgepaths.length &&\n                    (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);\n            }\n            break;\n        case 'constraint':\n            // after convertToConstraints, pathinfo has length=0\n            pi0.prefixBoundary = false;\n\n            // joinAllPaths does enough already when edgepaths are present\n            if(pi0.edgepaths.length) return;\n\n            var na = pi0.x.length;\n            var nb = pi0.y.length;\n            var boundaryMax = -Infinity;\n            var boundaryMin = Infinity;\n\n            for(i = 0; i < nb; i++) {\n                boundaryMin = Math.min(boundaryMin, z[i][0]);\n                boundaryMin = Math.min(boundaryMin, z[i][na - 1]);\n                boundaryMax = Math.max(boundaryMax, z[i][0]);\n                boundaryMax = Math.max(boundaryMax, z[i][na - 1]);\n            }\n            for(i = 1; i < na - 1; i++) {\n                boundaryMin = Math.min(boundaryMin, z[0][i]);\n                boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);\n                boundaryMax = Math.max(boundaryMax, z[0][i]);\n                boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);\n            }\n\n            var contoursValue = contours.value;\n            var v1, v2;\n\n            switch(contours._operation) {\n                case '>':\n                    if(contoursValue > boundaryMax) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '<':\n                    if(contoursValue < boundaryMin ||\n                        (pi0.starts.length && contoursValue === boundaryMin)) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '[]':\n                    v1 = Math.min(contoursValue[0], contoursValue[1]);\n                    v2 = Math.max(contoursValue[0], contoursValue[1]);\n                    if(v2 < boundaryMin || v1 > boundaryMax ||\n                        (pi0.starts.length && v2 === boundaryMin)) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n                case '][':\n                    v1 = Math.min(contoursValue[0], contoursValue[1]);\n                    v2 = Math.max(contoursValue[0], contoursValue[1]);\n                    if(v1 < boundaryMin && v2 > boundaryMax) {\n                        pi0.prefixBoundary = true;\n                    }\n                    break;\n            }\n            break;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}