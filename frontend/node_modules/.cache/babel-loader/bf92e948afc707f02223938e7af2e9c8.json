{"ast":null,"code":"'use strict';\n\nmodule.exports = findMedian;\n\nvar genPartition = require('./partition');\n\nvar partitionStartLessThan = genPartition('lo<p0');\nvar PARTITION_THRESHOLD = 8; //Cut off for using insertion sort in findMedian\n//Base case for median finding:  Use insertion sort\n\nfunction insertionSort(d, axis, start, end, boxes, ids) {\n  var elemSize = 2 * d;\n  var boxPtr = elemSize * (start + 1) + axis;\n\n  for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {\n    var x = boxes[boxPtr];\n\n    for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {\n      //Swap\n      var aPtr = ptr;\n      var bPtr = ptr + elemSize;\n\n      for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {\n        var y = boxes[aPtr];\n        boxes[aPtr] = boxes[bPtr];\n        boxes[bPtr] = y;\n      }\n\n      var tmp = ids[j];\n      ids[j] = ids[j - 1];\n      ids[j - 1] = tmp;\n    }\n  }\n} //Find median using quick select algorithm\n//  takes O(n) time with high probability\n\n\nfunction findMedian(d, axis, start, end, boxes, ids) {\n  if (end <= start + 1) {\n    return start;\n  }\n\n  var lo = start;\n  var hi = end;\n  var mid = end + start >>> 1;\n  var elemSize = 2 * d;\n  var pivot = mid;\n  var value = boxes[elemSize * mid + axis];\n\n  while (lo < hi) {\n    if (hi - lo < PARTITION_THRESHOLD) {\n      insertionSort(d, axis, lo, hi, boxes, ids);\n      value = boxes[elemSize * mid + axis];\n      break;\n    } //Select pivot using median-of-3\n\n\n    var count = hi - lo;\n    var pivot0 = Math.random() * count + lo | 0;\n    var value0 = boxes[elemSize * pivot0 + axis];\n    var pivot1 = Math.random() * count + lo | 0;\n    var value1 = boxes[elemSize * pivot1 + axis];\n    var pivot2 = Math.random() * count + lo | 0;\n    var value2 = boxes[elemSize * pivot2 + axis];\n\n    if (value0 <= value1) {\n      if (value2 >= value1) {\n        pivot = pivot1;\n        value = value1;\n      } else if (value0 >= value2) {\n        pivot = pivot0;\n        value = value0;\n      } else {\n        pivot = pivot2;\n        value = value2;\n      }\n    } else {\n      if (value1 >= value2) {\n        pivot = pivot1;\n        value = value1;\n      } else if (value2 >= value0) {\n        pivot = pivot0;\n        value = value0;\n      } else {\n        pivot = pivot2;\n        value = value2;\n      }\n    } //Swap pivot to end of array\n\n\n    var aPtr = elemSize * (hi - 1);\n    var bPtr = elemSize * pivot;\n\n    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr];\n      boxes[aPtr] = boxes[bPtr];\n      boxes[bPtr] = x;\n    }\n\n    var y = ids[hi - 1];\n    ids[hi - 1] = ids[pivot];\n    ids[pivot] = y; //Partition using pivot\n\n    pivot = partitionStartLessThan(d, axis, lo, hi - 1, boxes, ids, value); //Swap pivot back\n\n    var aPtr = elemSize * (hi - 1);\n    var bPtr = elemSize * pivot;\n\n    for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr];\n      boxes[aPtr] = boxes[bPtr];\n      boxes[bPtr] = x;\n    }\n\n    var y = ids[hi - 1];\n    ids[hi - 1] = ids[pivot];\n    ids[pivot] = y; //Swap pivot to last pivot\n\n    if (mid < pivot) {\n      hi = pivot - 1;\n\n      while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {\n        hi -= 1;\n      }\n\n      hi += 1;\n    } else if (pivot < mid) {\n      lo = pivot + 1;\n\n      while (lo < hi && boxes[elemSize * lo + axis] === value) {\n        lo += 1;\n      }\n    } else {\n      break;\n    }\n  } //Make sure pivot is at start\n\n\n  return partitionStartLessThan(d, axis, start, mid, boxes, ids, boxes[elemSize * mid + axis]);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/box-intersect/lib/median.js"],"names":["module","exports","findMedian","genPartition","require","partitionStartLessThan","PARTITION_THRESHOLD","insertionSort","d","axis","start","end","boxes","ids","elemSize","boxPtr","i","x","j","ptr","aPtr","bPtr","k","y","tmp","lo","hi","mid","pivot","value","count","pivot0","Math","random","value0","pivot1","value1","pivot2","value2"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = findMedian\r\n\r\nvar genPartition = require('./partition')\r\n\r\nvar partitionStartLessThan = genPartition('lo<p0')\r\n\r\nvar PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian\r\n\r\n//Base case for median finding:  Use insertion sort\r\nfunction insertionSort(d, axis, start, end, boxes, ids) {\r\n  var elemSize = 2 * d\r\n  var boxPtr = elemSize * (start+1) + axis\r\n  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {\r\n    var x = boxes[boxPtr]\r\n    for(var j=i, ptr=elemSize*(i-1);\r\n        j>start && boxes[ptr+axis] > x;\r\n        --j, ptr-=elemSize) {\r\n      //Swap\r\n      var aPtr = ptr\r\n      var bPtr = ptr+elemSize\r\n      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {\r\n        var y = boxes[aPtr]\r\n        boxes[aPtr] = boxes[bPtr]\r\n        boxes[bPtr] = y\r\n      }\r\n      var tmp = ids[j]\r\n      ids[j] = ids[j-1]\r\n      ids[j-1] = tmp\r\n    }\r\n  }\r\n}\r\n\r\n//Find median using quick select algorithm\r\n//  takes O(n) time with high probability\r\nfunction findMedian(d, axis, start, end, boxes, ids) {\r\n  if(end <= start+1) {\r\n    return start\r\n  }\r\n\r\n  var lo       = start\r\n  var hi       = end\r\n  var mid      = ((end + start) >>> 1)\r\n  var elemSize = 2*d\r\n  var pivot    = mid\r\n  var value    = boxes[elemSize*mid+axis]\r\n\r\n  while(lo < hi) {\r\n    if(hi - lo < PARTITION_THRESHOLD) {\r\n      insertionSort(d, axis, lo, hi, boxes, ids)\r\n      value = boxes[elemSize*mid+axis]\r\n      break\r\n    }\r\n\r\n    //Select pivot using median-of-3\r\n    var count  = hi - lo\r\n    var pivot0 = (Math.random()*count+lo)|0\r\n    var value0 = boxes[elemSize*pivot0 + axis]\r\n    var pivot1 = (Math.random()*count+lo)|0\r\n    var value1 = boxes[elemSize*pivot1 + axis]\r\n    var pivot2 = (Math.random()*count+lo)|0\r\n    var value2 = boxes[elemSize*pivot2 + axis]\r\n    if(value0 <= value1) {\r\n      if(value2 >= value1) {\r\n        pivot = pivot1\r\n        value = value1\r\n      } else if(value0 >= value2) {\r\n        pivot = pivot0\r\n        value = value0\r\n      } else {\r\n        pivot = pivot2\r\n        value = value2\r\n      }\r\n    } else {\r\n      if(value1 >= value2) {\r\n        pivot = pivot1\r\n        value = value1\r\n      } else if(value2 >= value0) {\r\n        pivot = pivot0\r\n        value = value0\r\n      } else {\r\n        pivot = pivot2\r\n        value = value2\r\n      }\r\n    }\r\n\r\n    //Swap pivot to end of array\r\n    var aPtr = elemSize * (hi-1)\r\n    var bPtr = elemSize * pivot\r\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\r\n      var x = boxes[aPtr]\r\n      boxes[aPtr] = boxes[bPtr]\r\n      boxes[bPtr] = x\r\n    }\r\n    var y = ids[hi-1]\r\n    ids[hi-1] = ids[pivot]\r\n    ids[pivot] = y\r\n\r\n    //Partition using pivot\r\n    pivot = partitionStartLessThan(\r\n      d, axis,\r\n      lo, hi-1, boxes, ids,\r\n      value)\r\n\r\n    //Swap pivot back\r\n    var aPtr = elemSize * (hi-1)\r\n    var bPtr = elemSize * pivot\r\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\r\n      var x = boxes[aPtr]\r\n      boxes[aPtr] = boxes[bPtr]\r\n      boxes[bPtr] = x\r\n    }\r\n    var y = ids[hi-1]\r\n    ids[hi-1] = ids[pivot]\r\n    ids[pivot] = y\r\n\r\n    //Swap pivot to last pivot\r\n    if(mid < pivot) {\r\n      hi = pivot-1\r\n      while(lo < hi &&\r\n        boxes[elemSize*(hi-1)+axis] === value) {\r\n        hi -= 1\r\n      }\r\n      hi += 1\r\n    } else if(pivot < mid) {\r\n      lo = pivot + 1\r\n      while(lo < hi &&\r\n        boxes[elemSize*lo+axis] === value) {\r\n        lo += 1\r\n      }\r\n    } else {\r\n      break\r\n    }\r\n  }\r\n\r\n  //Make sure pivot is at start\r\n  return partitionStartLessThan(\r\n    d, axis,\r\n    start, mid, boxes, ids,\r\n    boxes[elemSize*mid+axis])\r\n}"]},"metadata":{},"sourceType":"script"}