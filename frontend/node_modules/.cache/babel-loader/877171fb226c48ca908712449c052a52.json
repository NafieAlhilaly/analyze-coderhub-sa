{"ast":null,"code":"(function (window) {\n  var re = {\n    not_string: /[^s]/,\n    number: /[diefg]/,\n    json: /[j]/,\n    not_json: /[^j]/,\n    text: /^[^\\x25]+/,\n    modulo: /^\\x25{2}/,\n    placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijosuxX])/,\n    key: /^([a-z_][a-z_\\d]*)/i,\n    key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n    index_access: /^\\[(\\d+)\\]/,\n    sign: /^[\\+\\-]/\n  };\n\n  function sprintf() {\n    var key = arguments[0],\n        cache = sprintf.cache;\n\n    if (!(cache[key] && cache.hasOwnProperty(key))) {\n      cache[key] = sprintf.parse(key);\n    }\n\n    return sprintf.format.call(null, cache[key], arguments);\n  }\n\n  sprintf.format = function (parse_tree, argv) {\n    var cursor = 1,\n        tree_length = parse_tree.length,\n        node_type = \"\",\n        arg,\n        output = [],\n        i,\n        k,\n        match,\n        pad,\n        pad_character,\n        pad_length,\n        is_positive = true,\n        sign = \"\";\n\n    for (i = 0; i < tree_length; i++) {\n      node_type = get_type(parse_tree[i]);\n\n      if (node_type === \"string\") {\n        output[output.length] = parse_tree[i];\n      } else if (node_type === \"array\") {\n        match = parse_tree[i]; // convenience purposes only\n\n        if (match[2]) {\n          // keyword argument\n          arg = argv[cursor];\n\n          for (k = 0; k < match[2].length; k++) {\n            if (!arg.hasOwnProperty(match[2][k])) {\n              throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]));\n            }\n\n            arg = arg[match[2][k]];\n          }\n        } else if (match[1]) {\n          // positional argument (explicit)\n          arg = argv[match[1]];\n        } else {\n          // positional argument (implicit)\n          arg = argv[cursor++];\n        }\n\n        if (get_type(arg) == \"function\") {\n          arg = arg();\n        }\n\n        if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && get_type(arg) != \"number\" && isNaN(arg)) {\n          throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)));\n        }\n\n        if (re.number.test(match[8])) {\n          is_positive = arg >= 0;\n        }\n\n        switch (match[8]) {\n          case \"b\":\n            arg = arg.toString(2);\n            break;\n\n          case \"c\":\n            arg = String.fromCharCode(arg);\n            break;\n\n          case \"d\":\n          case \"i\":\n            arg = parseInt(arg, 10);\n            break;\n\n          case \"j\":\n            arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);\n            break;\n\n          case \"e\":\n            arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();\n            break;\n\n          case \"f\":\n            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);\n            break;\n\n          case \"g\":\n            arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);\n            break;\n\n          case \"o\":\n            arg = arg.toString(8);\n            break;\n\n          case \"s\":\n            arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case \"u\":\n            arg = arg >>> 0;\n            break;\n\n          case \"x\":\n            arg = arg.toString(16);\n            break;\n\n          case \"X\":\n            arg = arg.toString(16).toUpperCase();\n            break;\n        }\n\n        if (re.json.test(match[8])) {\n          output[output.length] = arg;\n        } else {\n          if (re.number.test(match[8]) && (!is_positive || match[3])) {\n            sign = is_positive ? \"+\" : \"-\";\n            arg = arg.toString().replace(re.sign, \"\");\n          } else {\n            sign = \"\";\n          }\n\n          pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \";\n          pad_length = match[6] - (sign + arg).length;\n          pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\" : \"\";\n          output[output.length] = match[5] ? sign + arg + pad : pad_character === \"0\" ? sign + pad + arg : pad + sign + arg;\n        }\n      }\n    }\n\n    return output.join(\"\");\n  };\n\n  sprintf.cache = {};\n\n  sprintf.parse = function (fmt) {\n    var _fmt = fmt,\n        match = [],\n        parse_tree = [],\n        arg_names = 0;\n\n    while (_fmt) {\n      if ((match = re.text.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = match[0];\n      } else if ((match = re.modulo.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = \"%\";\n      } else if ((match = re.placeholder.exec(_fmt)) !== null) {\n        if (match[2]) {\n          arg_names |= 1;\n          var field_list = [],\n              replacement_field = match[2],\n              field_match = [];\n\n          if ((field_match = re.key.exec(replacement_field)) !== null) {\n            field_list[field_list.length] = field_match[1];\n\n            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n              if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else {\n                throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n              }\n            }\n          } else {\n            throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n          }\n\n          match[2] = field_list;\n        } else {\n          arg_names |= 2;\n        }\n\n        if (arg_names === 3) {\n          throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\");\n        }\n\n        parse_tree[parse_tree.length] = match;\n      } else {\n        throw new SyntaxError(\"[sprintf] unexpected placeholder\");\n      }\n\n      _fmt = _fmt.substring(match[0].length);\n    }\n\n    return parse_tree;\n  };\n\n  var vsprintf = function (fmt, argv, _argv) {\n    _argv = (argv || []).slice(0);\n\n    _argv.splice(0, 0, fmt);\n\n    return sprintf.apply(null, _argv);\n  };\n  /**\n   * helpers\n   */\n\n\n  function get_type(variable) {\n    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n  }\n\n  function str_repeat(input, multiplier) {\n    return Array(multiplier + 1).join(input);\n  }\n  /**\n   * export to either browser or node.js\n   */\n\n\n  if (typeof exports !== \"undefined\") {\n    exports.sprintf = sprintf;\n    exports.vsprintf = vsprintf;\n  } else {\n    window.sprintf = sprintf;\n    window.vsprintf = vsprintf;\n\n    if (typeof define === \"function\" && define.amd) {\n      define(function () {\n        return {\n          sprintf: sprintf,\n          vsprintf: vsprintf\n        };\n      });\n    }\n  }\n})(typeof window === \"undefined\" ? this : window);","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/sprintf-js/src/sprintf.js"],"names":["window","re","not_string","number","json","not_json","text","modulo","placeholder","key","key_access","index_access","sign","sprintf","arguments","cache","hasOwnProperty","parse","format","call","parse_tree","argv","cursor","tree_length","length","node_type","arg","output","i","k","match","pad","pad_character","pad_length","is_positive","get_type","Error","test","isNaN","TypeError","toString","String","fromCharCode","parseInt","JSON","stringify","toExponential","parseFloat","toFixed","toPrecision","substring","toUpperCase","replace","charAt","str_repeat","join","fmt","_fmt","arg_names","exec","field_list","replacement_field","field_match","SyntaxError","vsprintf","_argv","slice","splice","apply","variable","Object","prototype","toLowerCase","input","multiplier","Array","exports","define","amd"],"mappings":"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","sourcesContent":["(function(window) {\n    var re = {\n        not_string: /[^s]/,\n        number: /[diefg]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijosuxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf() {\n        var key = arguments[0], cache = sprintf.cache\n        if (!(cache[key] && cache.hasOwnProperty(key))) {\n            cache[key] = sprintf.parse(key)\n        }\n        return sprintf.format.call(null, cache[key], arguments)\n    }\n\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = \"\", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = \"\"\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i])\n            if (node_type === \"string\") {\n                output[output.length] = parse_tree[i]\n            }\n            else if (node_type === \"array\") {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf(\"[sprintf] property '%s' does not exist\", match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (get_type(arg) == \"function\") {\n                    arg = arg()\n                }\n\n                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != \"number\" && isNaN(arg))) {\n                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case \"b\":\n                        arg = arg.toString(2)\n                    break\n                    case \"c\":\n                        arg = String.fromCharCode(arg)\n                    break\n                    case \"d\":\n                    case \"i\":\n                        arg = parseInt(arg, 10)\n                    break\n                    case \"j\":\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                    break\n                    case \"e\":\n                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()\n                    break\n                    case \"f\":\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                    break\n                    case \"g\":\n                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)\n                    break\n                    case \"o\":\n                        arg = arg.toString(8)\n                    break\n                    case \"s\":\n                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case \"u\":\n                        arg = arg >>> 0\n                    break\n                    case \"x\":\n                        arg = arg.toString(16)\n                    break\n                    case \"X\":\n                        arg = arg.toString(16).toUpperCase()\n                    break\n                }\n                if (re.json.test(match[8])) {\n                    output[output.length] = arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? \"+\" : \"-\"\n                        arg = arg.toString().replace(re.sign, \"\")\n                    }\n                    else {\n                        sign = \"\"\n                    }\n                    pad_character = match[4] ? match[4] === \"0\" ? \"0\" : match[4].charAt(1) : \" \"\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : \"\") : \"\"\n                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === \"0\" ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output.join(\"\")\n    }\n\n    sprintf.cache = {}\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = match[0]\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = \"%\"\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list[field_list.length] = field_match[1]\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \"\") {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else {\n                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n                }\n                parse_tree[parse_tree.length] = match\n            }\n            else {\n                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return parse_tree\n    }\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = (argv || []).slice(0)\n        _argv.splice(0, 0, fmt)\n        return sprintf.apply(null, _argv)\n    }\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n    }\n\n    function str_repeat(input, multiplier) {\n        return Array(multiplier + 1).join(input)\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    if (typeof exports !== \"undefined\") {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    else {\n        window.sprintf = sprintf\n        window.vsprintf = vsprintf\n\n        if (typeof define === \"function\" && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                }\n            })\n        }\n    }\n})(typeof window === \"undefined\" ? this : window);\n"]},"metadata":{},"sourceType":"script"}