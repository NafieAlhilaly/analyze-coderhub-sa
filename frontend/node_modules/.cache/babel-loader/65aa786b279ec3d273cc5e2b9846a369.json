{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Plots = require('../../plots/plots');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar constants = require('./constants');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nmodule.exports = function draw(gd) {\n  var fullLayout = gd._fullLayout;\n  var sliderData = makeSliderData(fullLayout, gd); // draw a container for *all* sliders:\n\n  var sliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);\n\n  sliders.enter().append('g').classed(constants.containerClassName, true).style('cursor', 'ew-resize');\n\n  function clearSlider(sliderOpts) {\n    if (sliderOpts._commandObserver) {\n      sliderOpts._commandObserver.remove();\n\n      delete sliderOpts._commandObserver;\n    } // Most components don't need to explicitly remove autoMargin, because\n    // marginPushers does this - but slider updates don't go through\n    // a full replot so we need to explicitly remove it.\n\n\n    Plots.autoMargin(gd, autoMarginId(sliderOpts));\n  }\n\n  sliders.exit().each(function () {\n    d3.select(this).selectAll('g.' + constants.groupClassName).each(clearSlider);\n  }).remove(); // Return early if no menus visible:\n\n  if (sliderData.length === 0) return;\n  var sliderGroups = sliders.selectAll('g.' + constants.groupClassName).data(sliderData, keyFunction);\n  sliderGroups.enter().append('g').classed(constants.groupClassName, true);\n  sliderGroups.exit().each(clearSlider).remove(); // Find the dimensions of the sliders:\n\n  for (var i = 0; i < sliderData.length; i++) {\n    var sliderOpts = sliderData[i];\n    findDimensions(gd, sliderOpts);\n  }\n\n  sliderGroups.each(function (sliderOpts) {\n    var gSlider = d3.select(this);\n    computeLabelSteps(sliderOpts);\n    Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function (data) {\n      // NB: Same as below. This is *not* always the same as sliderOpts since\n      // if a new set of steps comes in, the reference in this callback would\n      // be invalid. We need to refetch it from the slider group, which is\n      // the join data that creates this slider. So if this slider still exists,\n      // the group should be valid, *to the best of my knowledge.* If not,\n      // we'd have to look it up by d3 data join index/key.\n      var opts = gSlider.data()[0];\n      if (opts.active === data.index) return;\n      if (opts._dragging) return;\n      setActive(gd, gSlider, opts, data.index, false, true);\n    });\n    drawSlider(gd, d3.select(this), sliderOpts);\n  });\n};\n\nfunction autoMarginId(sliderOpts) {\n  return constants.autoMarginIdRoot + sliderOpts._index;\n} // This really only just filters by visibility:\n\n\nfunction makeSliderData(fullLayout, gd) {\n  var contOpts = fullLayout[constants.name];\n  var sliderData = [];\n\n  for (var i = 0; i < contOpts.length; i++) {\n    var item = contOpts[i];\n    if (!item.visible) continue;\n    item._gd = gd;\n    sliderData.push(item);\n  }\n\n  return sliderData;\n} // This is set in the defaults step:\n\n\nfunction keyFunction(opts) {\n  return opts._index;\n} // Compute the dimensions (mutates sliderOpts):\n\n\nfunction findDimensions(gd, sliderOpts) {\n  var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass).data(sliderOpts._visibleSteps);\n  sliderLabels.enter().append('g').classed(constants.labelGroupClass, true); // loop over fake buttons to find width / height\n\n  var maxLabelWidth = 0;\n  var labelHeight = 0;\n  sliderLabels.each(function (stepOpts) {\n    var labelGroup = d3.select(this);\n    var text = drawLabel(labelGroup, {\n      step: stepOpts\n    }, sliderOpts);\n    var textNode = text.node();\n\n    if (textNode) {\n      var bBox = Drawing.bBox(textNode);\n      labelHeight = Math.max(labelHeight, bBox.height);\n      maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n    }\n  });\n  sliderLabels.remove();\n  var dims = sliderOpts._dims = {};\n  dims.inputAreaWidth = Math.max(constants.railWidth, constants.gripHeight); // calculate some overall dimensions - some of these are needed for\n  // calculating the currentValue dimensions\n\n  var graphSize = gd._fullLayout._size;\n  dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n  dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n\n  if (sliderOpts.lenmode === 'fraction') {\n    // fraction:\n    dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n  } else {\n    // pixels:\n    dims.outerLength = sliderOpts.len;\n  } // The length of the rail, *excluding* padding on either end:\n\n\n  dims.inputAreaStart = 0;\n  dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n  var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n  var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n  var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n  dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n  dims.labelHeight = labelHeight; // loop over all possible values for currentValue to find the\n  // area we need for it\n\n  dims.currentValueMaxWidth = 0;\n  dims.currentValueHeight = 0;\n  dims.currentValueTotalHeight = 0;\n  dims.currentValueMaxLines = 1;\n\n  if (sliderOpts.currentvalue.visible) {\n    // Get the dimensions of the current value label:\n    var dummyGroup = Drawing.tester.append('g');\n    sliderLabels.each(function (stepOpts) {\n      var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n      var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || {\n        width: 0,\n        height: 0\n      };\n      var lines = svgTextUtils.lineCount(curValPrefix);\n      dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n      dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n      dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n    });\n    dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n    dummyGroup.remove();\n  }\n\n  dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n  var xanchor = 'left';\n\n  if (Lib.isRightAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength;\n    xanchor = 'right';\n  }\n\n  if (Lib.isCenterAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength / 2;\n    xanchor = 'center';\n  }\n\n  var yanchor = 'top';\n\n  if (Lib.isBottomAnchor(sliderOpts)) {\n    dims.ly -= dims.height;\n    yanchor = 'bottom';\n  }\n\n  if (Lib.isMiddleAnchor(sliderOpts)) {\n    dims.ly -= dims.height / 2;\n    yanchor = 'middle';\n  }\n\n  dims.outerLength = Math.ceil(dims.outerLength);\n  dims.height = Math.ceil(dims.height);\n  dims.lx = Math.round(dims.lx);\n  dims.ly = Math.round(dims.ly);\n  var marginOpts = {\n    y: sliderOpts.y,\n    b: dims.height * FROM_BR[yanchor],\n    t: dims.height * FROM_TL[yanchor]\n  };\n\n  if (sliderOpts.lenmode === 'fraction') {\n    marginOpts.l = 0;\n    marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n    marginOpts.r = 0;\n    marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n  } else {\n    marginOpts.x = sliderOpts.x;\n    marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n    marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n  }\n\n  Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\n\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n  // This is related to the other long notes in this file regarding what happens\n  // when slider steps disappear. This particular fix handles what happens when\n  // the *current* slider step is removed. The drawing functions will error out\n  // when they fail to find it, so the fix for now is that it will just draw the\n  // slider in the first position but will not execute the command.\n  if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {\n    sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n  } // These are carefully ordered for proper z-ordering:\n\n\n  sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);\n  var dims = sliderOpts._dims; // Position the rectangle:\n\n  Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n  sliderGroup.call(setGripPosition, sliderOpts, false);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n}\n\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n  if (!sliderOpts.currentvalue.visible) return;\n  var dims = sliderOpts._dims;\n  var x0, textAnchor;\n\n  switch (sliderOpts.currentvalue.xanchor) {\n    case 'right':\n      // This is anchored left and adjusted by the width of the longest label\n      // so that the prefix doesn't move. The goal of this is to emphasize\n      // what's actually changing and make the update less distracting.\n      x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n      textAnchor = 'left';\n      break;\n\n    case 'center':\n      x0 = dims.inputAreaLength * 0.5;\n      textAnchor = 'middle';\n      break;\n\n    default:\n      x0 = constants.currentValueInset;\n      textAnchor = 'left';\n  }\n\n  var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function (s) {\n    s.attr({\n      'text-anchor': textAnchor,\n      'data-notex': 1\n    });\n  });\n  var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n\n  if (typeof valueOverride === 'string') {\n    str += valueOverride;\n  } else {\n    var curVal = sliderOpts.steps[sliderOpts.active].label;\n    var _meta = sliderOpts._gd._fullLayout._meta;\n    if (_meta) curVal = Lib.templateString(curVal, _meta);\n    str += curVal;\n  }\n\n  if (sliderOpts.currentvalue.suffix) {\n    str += sliderOpts.currentvalue.suffix;\n  }\n\n  text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  var lines = svgTextUtils.lineCount(text);\n  var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;\n  svgTextUtils.positionText(text, x0, y0);\n  return text;\n}\n\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n  var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  grip.attr({\n    width: constants.gripWidth,\n    height: constants.gripHeight,\n    rx: constants.gripRadius,\n    ry: constants.gripRadius\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n}\n\nfunction drawLabel(item, data, sliderOpts) {\n  var text = Lib.ensureSingle(item, 'text', constants.labelClass, function (s) {\n    s.attr({\n      'text-anchor': 'middle',\n      'data-notex': 1\n    });\n  });\n  var tx = data.step.label;\n  var _meta = sliderOpts._gd._fullLayout._meta;\n  if (_meta) tx = Lib.templateString(tx, _meta);\n  text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  return text;\n}\n\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n  var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n  var dims = sliderOpts._dims;\n  var labelItems = labels.selectAll('g.' + constants.labelGroupClass).data(dims.labelSteps);\n  labelItems.enter().append('g').classed(constants.labelGroupClass, true);\n  labelItems.exit().remove();\n  labelItems.each(function (d) {\n    var item = d3.select(this);\n    item.call(drawLabel, d, sliderOpts);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, d.fraction), constants.tickOffset + sliderOpts.ticklen + // position is the baseline of the top line of text only, even\n    // if the label spans multiple lines\n    sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight);\n  });\n}\n\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n  var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n  var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n\n  if (quantizedIndex !== sliderOpts.active) {\n    setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n  }\n}\n\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n  var previousActive = sliderOpts.active;\n  sliderOpts.active = index; // due to templating, it's possible this slider doesn't even exist yet\n\n  arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate('active', index);\n  var step = sliderOpts.steps[sliderOpts.active];\n  sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n  gd.emit('plotly_sliderchange', {\n    slider: sliderOpts,\n    step: sliderOpts.steps[sliderOpts.active],\n    interaction: doCallback,\n    previousActive: previousActive\n  });\n\n  if (step && step.method && doCallback) {\n    if (sliderGroup._nextMethod) {\n      // If we've already queued up an update, just overwrite it with the most recent:\n      sliderGroup._nextMethod.step = step;\n      sliderGroup._nextMethod.doCallback = doCallback;\n      sliderGroup._nextMethod.doTransition = doTransition;\n    } else {\n      sliderGroup._nextMethod = {\n        step: step,\n        doCallback: doCallback,\n        doTransition: doTransition\n      };\n      sliderGroup._nextMethodRaf = window.requestAnimationFrame(function () {\n        var _step = sliderGroup._nextMethod.step;\n        if (!_step.method) return;\n\n        if (_step.execute) {\n          Plots.executeAPICommand(gd, _step.method, _step.args);\n        }\n\n        sliderGroup._nextMethod = null;\n        sliderGroup._nextMethodRaf = null;\n      });\n    }\n  }\n}\n\nfunction attachGripEvents(item, gd, sliderGroup) {\n  var node = sliderGroup.node();\n  var $gd = d3.select(gd); // NB: This is *not* the same as sliderOpts itself! These callbacks\n  // are in a closure so this array won't actually be correct if the\n  // steps have changed since this was initialized. The sliderGroup,\n  // however, has not changed since that *is* the slider, so it must\n  // be present to receive mouse events.\n\n  function getSliderOpts() {\n    return sliderGroup.data()[0];\n  }\n\n  function mouseDownHandler() {\n    var sliderOpts = getSliderOpts();\n    gd.emit('plotly_sliderstart', {\n      slider: sliderOpts\n    });\n    var grip = sliderGroup.select('.' + constants.gripRectClass);\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n    grip.call(Color.fill, sliderOpts.activebgcolor);\n    var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n    handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n    sliderOpts._dragging = true;\n\n    function mouseMoveHandler() {\n      var sliderOpts = getSliderOpts();\n      var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n      handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n    }\n\n    $gd.on('mousemove', mouseMoveHandler);\n    $gd.on('touchmove', mouseMoveHandler);\n\n    function mouseUpHandler() {\n      var sliderOpts = getSliderOpts();\n      sliderOpts._dragging = false;\n      grip.call(Color.fill, sliderOpts.bgcolor);\n      $gd.on('mouseup', null);\n      $gd.on('mousemove', null);\n      $gd.on('touchend', null);\n      $gd.on('touchmove', null);\n      gd.emit('plotly_sliderend', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active]\n      });\n    }\n\n    $gd.on('mouseup', mouseUpHandler);\n    $gd.on('touchend', mouseUpHandler);\n  }\n\n  item.on('mousedown', mouseDownHandler);\n  item.on('touchstart', mouseDownHandler);\n}\n\nfunction drawTicks(sliderGroup, sliderOpts) {\n  var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass).data(sliderOpts._visibleSteps);\n  var dims = sliderOpts._dims;\n  tick.enter().append('rect').classed(constants.tickRectClass, true);\n  tick.exit().remove();\n  tick.attr({\n    width: sliderOpts.tickwidth + 'px',\n    'shape-rendering': 'crispEdges'\n  });\n  tick.each(function (d, i) {\n    var isMajor = i % dims.labelStride === 0;\n    var item = d3.select(this);\n    item.attr({\n      height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen\n    }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth, (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight);\n  });\n}\n\nfunction computeLabelSteps(sliderOpts) {\n  var dims = sliderOpts._dims;\n  dims.labelSteps = [];\n  var nsteps = sliderOpts._stepCount;\n\n  for (var i = 0; i < nsteps; i += dims.labelStride) {\n    dims.labelSteps.push({\n      fraction: i / (nsteps - 1),\n      step: sliderOpts._visibleSteps[i]\n    });\n  }\n}\n\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n  var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n  var quantizedIndex = 0;\n\n  for (var i = 0; i < sliderOpts._stepCount; i++) {\n    if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n      quantizedIndex = i;\n      break;\n    }\n  }\n\n  var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1)); // If this is true, then *this component* is already invoking its own command\n  // and has triggered its own animation.\n\n  if (sliderOpts._invokingCommand) return;\n  var el = grip;\n\n  if (doTransition && sliderOpts.transition.duration > 0) {\n    el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);\n  } // Drawing.setTranslate doesn't work here because of the transition duck-typing.\n  // It's also not necessary because there are no other transitions to preserve.\n\n\n  el.attr('transform', strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));\n} // Convert a number from [0-1] to a pixel position relative to the slider group container:\n\n\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n  var dims = sliderOpts._dims;\n  return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n} // Convert a position relative to the slider group to a nubmer in [0, 1]\n\n\nfunction positionToNormalizedValue(sliderOpts, position) {\n  var dims = sliderOpts._dims;\n  return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\n\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  rect.attr({\n    width: dims.inputAreaLength,\n    height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n  }).call(Color.fill, sliderOpts.bgcolor).attr('opacity', 0);\n  Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\n\nfunction drawRail(sliderGroup, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var computedLength = dims.inputAreaLength - constants.railInset * 2;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n  rect.attr({\n    width: computedLength,\n    height: constants.railWidth,\n    rx: constants.railRadius,\n    ry: constants.railRadius,\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n  Drawing.setTranslate(rect, constants.railInset, (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/components/sliders/draw.js"],"names":["d3","require","Plots","Color","Drawing","Lib","strTranslate","svgTextUtils","arrayEditor","constants","alignmentConstants","LINE_SPACING","FROM_TL","FROM_BR","module","exports","draw","gd","fullLayout","_fullLayout","sliderData","makeSliderData","sliders","_infolayer","selectAll","containerClassName","data","length","enter","append","classed","style","clearSlider","sliderOpts","_commandObserver","remove","autoMargin","autoMarginId","exit","each","select","groupClassName","sliderGroups","keyFunction","i","findDimensions","gSlider","computeLabelSteps","manageCommandObserver","_visibleSteps","opts","active","index","_dragging","setActive","drawSlider","autoMarginIdRoot","_index","contOpts","name","item","visible","_gd","push","sliderLabels","tester","labelGroupClass","maxLabelWidth","labelHeight","stepOpts","labelGroup","text","drawLabel","step","textNode","node","bBox","Math","max","height","width","dims","_dims","inputAreaWidth","railWidth","gripHeight","graphSize","_size","lx","l","w","x","ly","t","h","y","lenmode","outerLength","round","len","inputAreaStart","inputAreaLength","pad","r","textableInputLength","stepInset","availableSpacePerLabel","_stepCount","computedSpacePerLabel","labelPadding","labelStride","ceil","currentValueMaxWidth","currentValueHeight","currentValueTotalHeight","currentValueMaxLines","currentvalue","dummyGroup","curValPrefix","drawCurrentValue","label","curValSize","lines","lineCount","offset","tickOffset","ticklen","labelOffset","b","xanchor","isRightAnchor","isCenterAnchor","yanchor","isBottomAnchor","isMiddleAnchor","marginOpts","xl","xr","sliderGroup","steps","call","drawRail","drawLabelGroup","drawTicks","drawTouchRect","drawGrip","setTranslate","setGripPosition","valueOverride","x0","textAnchor","currentValueInset","ensureSingle","labelClass","s","attr","str","prefix","curVal","_meta","templateString","suffix","font","convertToTspans","y0","size","positionText","grip","gripRectClass","attachGripEvents","gripWidth","rx","gripRadius","ry","stroke","bordercolor","fill","bgcolor","borderwidth","tx","labels","labelsClass","labelItems","labelSteps","d","normalizedValueToPosition","fraction","handleInput","normalizedPosition","doTransition","quantizedPosition","quantizedIndex","doCallback","previousActive","layout","applyUpdate","emit","slider","interaction","method","_nextMethod","_nextMethodRaf","window","requestAnimationFrame","_step","execute","executeAPICommand","args","$gd","getSliderOpts","mouseDownHandler","event","stopPropagation","preventDefault","activebgcolor","positionToNormalizedValue","mouse","mouseMoveHandler","on","mouseUpHandler","tick","tickRectClass","tickwidth","isMajor","minorticklen","tickcolor","minorTickOffset","nsteps","_invokingCommand","el","transition","duration","ease","easing","min","position","rect","railTouchRectClass","computedLength","railInset","railRectClass","railRadius"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Plots = require('../../plots/plots');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar constants = require('./constants');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nmodule.exports = function draw(gd) {\n    var fullLayout = gd._fullLayout;\n    var sliderData = makeSliderData(fullLayout, gd);\n\n    // draw a container for *all* sliders:\n    var sliders = fullLayout._infolayer\n        .selectAll('g.' + constants.containerClassName)\n        .data(sliderData.length > 0 ? [0] : []);\n\n    sliders.enter().append('g')\n        .classed(constants.containerClassName, true)\n        .style('cursor', 'ew-resize');\n\n    function clearSlider(sliderOpts) {\n        if(sliderOpts._commandObserver) {\n            sliderOpts._commandObserver.remove();\n            delete sliderOpts._commandObserver;\n        }\n\n        // Most components don't need to explicitly remove autoMargin, because\n        // marginPushers does this - but slider updates don't go through\n        // a full replot so we need to explicitly remove it.\n        Plots.autoMargin(gd, autoMarginId(sliderOpts));\n    }\n\n    sliders.exit().each(function() {\n        d3.select(this).selectAll('g.' + constants.groupClassName)\n            .each(clearSlider);\n    })\n    .remove();\n\n    // Return early if no menus visible:\n    if(sliderData.length === 0) return;\n\n    var sliderGroups = sliders.selectAll('g.' + constants.groupClassName)\n        .data(sliderData, keyFunction);\n\n    sliderGroups.enter().append('g')\n        .classed(constants.groupClassName, true);\n\n    sliderGroups.exit()\n        .each(clearSlider)\n        .remove();\n\n    // Find the dimensions of the sliders:\n    for(var i = 0; i < sliderData.length; i++) {\n        var sliderOpts = sliderData[i];\n        findDimensions(gd, sliderOpts);\n    }\n\n    sliderGroups.each(function(sliderOpts) {\n        var gSlider = d3.select(this);\n\n        computeLabelSteps(sliderOpts);\n\n        Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function(data) {\n            // NB: Same as below. This is *not* always the same as sliderOpts since\n            // if a new set of steps comes in, the reference in this callback would\n            // be invalid. We need to refetch it from the slider group, which is\n            // the join data that creates this slider. So if this slider still exists,\n            // the group should be valid, *to the best of my knowledge.* If not,\n            // we'd have to look it up by d3 data join index/key.\n            var opts = gSlider.data()[0];\n\n            if(opts.active === data.index) return;\n            if(opts._dragging) return;\n\n            setActive(gd, gSlider, opts, data.index, false, true);\n        });\n\n        drawSlider(gd, d3.select(this), sliderOpts);\n    });\n};\n\nfunction autoMarginId(sliderOpts) {\n    return constants.autoMarginIdRoot + sliderOpts._index;\n}\n\n// This really only just filters by visibility:\nfunction makeSliderData(fullLayout, gd) {\n    var contOpts = fullLayout[constants.name];\n    var sliderData = [];\n\n    for(var i = 0; i < contOpts.length; i++) {\n        var item = contOpts[i];\n        if(!item.visible) continue;\n        item._gd = gd;\n        sliderData.push(item);\n    }\n\n    return sliderData;\n}\n\n// This is set in the defaults step:\nfunction keyFunction(opts) {\n    return opts._index;\n}\n\n// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd, sliderOpts) {\n    var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass)\n        .data(sliderOpts._visibleSteps);\n\n    sliderLabels.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    // loop over fake buttons to find width / height\n    var maxLabelWidth = 0;\n    var labelHeight = 0;\n    sliderLabels.each(function(stepOpts) {\n        var labelGroup = d3.select(this);\n\n        var text = drawLabel(labelGroup, {step: stepOpts}, sliderOpts);\n\n        var textNode = text.node();\n        if(textNode) {\n            var bBox = Drawing.bBox(textNode);\n            labelHeight = Math.max(labelHeight, bBox.height);\n            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n        }\n    });\n\n    sliderLabels.remove();\n\n    var dims = sliderOpts._dims = {};\n\n    dims.inputAreaWidth = Math.max(\n        constants.railWidth,\n        constants.gripHeight\n    );\n\n    // calculate some overall dimensions - some of these are needed for\n    // calculating the currentValue dimensions\n    var graphSize = gd._fullLayout._size;\n    dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n    dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n\n    if(sliderOpts.lenmode === 'fraction') {\n        // fraction:\n        dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n    } else {\n        // pixels:\n        dims.outerLength = sliderOpts.len;\n    }\n\n    // The length of the rail, *excluding* padding on either end:\n    dims.inputAreaStart = 0;\n    dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n\n    var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n    var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n    var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n    dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n    dims.labelHeight = labelHeight;\n\n    // loop over all possible values for currentValue to find the\n    // area we need for it\n    dims.currentValueMaxWidth = 0;\n    dims.currentValueHeight = 0;\n    dims.currentValueTotalHeight = 0;\n    dims.currentValueMaxLines = 1;\n\n    if(sliderOpts.currentvalue.visible) {\n        // Get the dimensions of the current value label:\n        var dummyGroup = Drawing.tester.append('g');\n\n        sliderLabels.each(function(stepOpts) {\n            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n            var curValSize = (curValPrefix.node() && Drawing.bBox(curValPrefix.node())) || {width: 0, height: 0};\n            var lines = svgTextUtils.lineCount(curValPrefix);\n            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n        });\n\n        dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n\n        dummyGroup.remove();\n    }\n\n    dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n\n    var xanchor = 'left';\n    if(Lib.isRightAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength;\n        xanchor = 'right';\n    }\n    if(Lib.isCenterAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength / 2;\n        xanchor = 'center';\n    }\n\n    var yanchor = 'top';\n    if(Lib.isBottomAnchor(sliderOpts)) {\n        dims.ly -= dims.height;\n        yanchor = 'bottom';\n    }\n    if(Lib.isMiddleAnchor(sliderOpts)) {\n        dims.ly -= dims.height / 2;\n        yanchor = 'middle';\n    }\n\n    dims.outerLength = Math.ceil(dims.outerLength);\n    dims.height = Math.ceil(dims.height);\n    dims.lx = Math.round(dims.lx);\n    dims.ly = Math.round(dims.ly);\n\n    var marginOpts = {\n        y: sliderOpts.y,\n        b: dims.height * FROM_BR[yanchor],\n        t: dims.height * FROM_TL[yanchor]\n    };\n\n    if(sliderOpts.lenmode === 'fraction') {\n        marginOpts.l = 0;\n        marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n        marginOpts.r = 0;\n        marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n    } else {\n        marginOpts.x = sliderOpts.x;\n        marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n        marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n    }\n\n    Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\n\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n    // This is related to the other long notes in this file regarding what happens\n    // when slider steps disappear. This particular fix handles what happens when\n    // the *current* slider step is removed. The drawing functions will error out\n    // when they fail to find it, so the fix for now is that it will just draw the\n    // slider in the first position but will not execute the command.\n    if(!((sliderOpts.steps[sliderOpts.active] || {}).visible)) {\n        sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n    }\n\n    // These are carefully ordered for proper z-ordering:\n    sliderGroup\n        .call(drawCurrentValue, sliderOpts)\n        .call(drawRail, sliderOpts)\n        .call(drawLabelGroup, sliderOpts)\n        .call(drawTicks, sliderOpts)\n        .call(drawTouchRect, gd, sliderOpts)\n        .call(drawGrip, gd, sliderOpts);\n\n    var dims = sliderOpts._dims;\n\n    // Position the rectangle:\n    Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n\n    sliderGroup.call(setGripPosition, sliderOpts, false);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n}\n\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n    if(!sliderOpts.currentvalue.visible) return;\n\n    var dims = sliderOpts._dims;\n    var x0, textAnchor;\n\n    switch(sliderOpts.currentvalue.xanchor) {\n        case 'right':\n            // This is anchored left and adjusted by the width of the longest label\n            // so that the prefix doesn't move. The goal of this is to emphasize\n            // what's actually changing and make the update less distracting.\n            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n            textAnchor = 'left';\n            break;\n        case 'center':\n            x0 = dims.inputAreaLength * 0.5;\n            textAnchor = 'middle';\n            break;\n        default:\n            x0 = constants.currentValueInset;\n            textAnchor = 'left';\n    }\n\n    var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function(s) {\n        s.attr({\n            'text-anchor': textAnchor,\n            'data-notex': 1\n        });\n    });\n\n    var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n\n    if(typeof valueOverride === 'string') {\n        str += valueOverride;\n    } else {\n        var curVal = sliderOpts.steps[sliderOpts.active].label;\n        var _meta = sliderOpts._gd._fullLayout._meta;\n        if(_meta) curVal = Lib.templateString(curVal, _meta);\n        str += curVal;\n    }\n\n    if(sliderOpts.currentvalue.suffix) {\n        str += sliderOpts.currentvalue.suffix;\n    }\n\n    text.call(Drawing.font, sliderOpts.currentvalue.font)\n        .text(str)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    var lines = svgTextUtils.lineCount(text);\n\n    var y0 = (dims.currentValueMaxLines + 1 - lines) *\n        sliderOpts.currentvalue.font.size * LINE_SPACING;\n\n    svgTextUtils.positionText(text, x0, y0);\n\n    return text;\n}\n\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n    var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    grip.attr({\n        width: constants.gripWidth,\n        height: constants.gripHeight,\n        rx: constants.gripRadius,\n        ry: constants.gripRadius,\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n}\n\nfunction drawLabel(item, data, sliderOpts) {\n    var text = Lib.ensureSingle(item, 'text', constants.labelClass, function(s) {\n        s.attr({\n            'text-anchor': 'middle',\n            'data-notex': 1\n        });\n    });\n\n    var tx = data.step.label;\n    var _meta = sliderOpts._gd._fullLayout._meta;\n    if(_meta) tx = Lib.templateString(tx, _meta);\n\n    text.call(Drawing.font, sliderOpts.font)\n        .text(tx)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    return text;\n}\n\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n    var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n    var dims = sliderOpts._dims;\n\n    var labelItems = labels.selectAll('g.' + constants.labelGroupClass)\n        .data(dims.labelSteps);\n\n    labelItems.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    labelItems.exit().remove();\n\n    labelItems.each(function(d) {\n        var item = d3.select(this);\n\n        item.call(drawLabel, d, sliderOpts);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, d.fraction),\n            constants.tickOffset +\n                sliderOpts.ticklen +\n                // position is the baseline of the top line of text only, even\n                // if the label spans multiple lines\n                sliderOpts.font.size * LINE_SPACING +\n                constants.labelOffset +\n                dims.currentValueTotalHeight\n        );\n    });\n}\n\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n    var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n    var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n\n    if(quantizedIndex !== sliderOpts.active) {\n        setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n    }\n}\n\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n    var previousActive = sliderOpts.active;\n    sliderOpts.active = index;\n\n    // due to templating, it's possible this slider doesn't even exist yet\n    arrayEditor(gd.layout, constants.name, sliderOpts)\n        .applyUpdate('active', index);\n\n    var step = sliderOpts.steps[sliderOpts.active];\n\n    sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n\n    gd.emit('plotly_sliderchange', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active],\n        interaction: doCallback,\n        previousActive: previousActive\n    });\n\n    if(step && step.method && doCallback) {\n        if(sliderGroup._nextMethod) {\n            // If we've already queued up an update, just overwrite it with the most recent:\n            sliderGroup._nextMethod.step = step;\n            sliderGroup._nextMethod.doCallback = doCallback;\n            sliderGroup._nextMethod.doTransition = doTransition;\n        } else {\n            sliderGroup._nextMethod = {step: step, doCallback: doCallback, doTransition: doTransition};\n            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {\n                var _step = sliderGroup._nextMethod.step;\n                if(!_step.method) return;\n\n                if(_step.execute) {\n                    Plots.executeAPICommand(gd, _step.method, _step.args);\n                }\n\n                sliderGroup._nextMethod = null;\n                sliderGroup._nextMethodRaf = null;\n            });\n        }\n    }\n}\n\nfunction attachGripEvents(item, gd, sliderGroup) {\n    var node = sliderGroup.node();\n    var $gd = d3.select(gd);\n\n    // NB: This is *not* the same as sliderOpts itself! These callbacks\n    // are in a closure so this array won't actually be correct if the\n    // steps have changed since this was initialized. The sliderGroup,\n    // however, has not changed since that *is* the slider, so it must\n    // be present to receive mouse events.\n    function getSliderOpts() {\n        return sliderGroup.data()[0];\n    }\n\n    function mouseDownHandler() {\n        var sliderOpts = getSliderOpts();\n        gd.emit('plotly_sliderstart', {slider: sliderOpts});\n\n        var grip = sliderGroup.select('.' + constants.gripRectClass);\n\n        d3.event.stopPropagation();\n        d3.event.preventDefault();\n        grip.call(Color.fill, sliderOpts.activebgcolor);\n\n        var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n        handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n        sliderOpts._dragging = true;\n\n        function mouseMoveHandler() {\n            var sliderOpts = getSliderOpts();\n            var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n            handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n        }\n\n        $gd.on('mousemove', mouseMoveHandler);\n        $gd.on('touchmove', mouseMoveHandler);\n\n        function mouseUpHandler() {\n            var sliderOpts = getSliderOpts();\n            sliderOpts._dragging = false;\n            grip.call(Color.fill, sliderOpts.bgcolor);\n            $gd.on('mouseup', null);\n            $gd.on('mousemove', null);\n            $gd.on('touchend', null);\n            $gd.on('touchmove', null);\n\n            gd.emit('plotly_sliderend', {\n                slider: sliderOpts,\n                step: sliderOpts.steps[sliderOpts.active]\n            });\n        }\n\n        $gd.on('mouseup', mouseUpHandler);\n        $gd.on('touchend', mouseUpHandler);\n    }\n\n    item.on('mousedown', mouseDownHandler);\n    item.on('touchstart', mouseDownHandler);\n}\n\nfunction drawTicks(sliderGroup, sliderOpts) {\n    var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass)\n        .data(sliderOpts._visibleSteps);\n    var dims = sliderOpts._dims;\n\n    tick.enter().append('rect')\n        .classed(constants.tickRectClass, true);\n\n    tick.exit().remove();\n\n    tick.attr({\n        width: sliderOpts.tickwidth + 'px',\n        'shape-rendering': 'crispEdges'\n    });\n\n    tick.each(function(d, i) {\n        var isMajor = i % dims.labelStride === 0;\n        var item = d3.select(this);\n\n        item\n            .attr({height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen})\n            .call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,\n            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight\n        );\n    });\n}\n\nfunction computeLabelSteps(sliderOpts) {\n    var dims = sliderOpts._dims;\n    dims.labelSteps = [];\n    var nsteps = sliderOpts._stepCount;\n\n    for(var i = 0; i < nsteps; i += dims.labelStride) {\n        dims.labelSteps.push({\n            fraction: i / (nsteps - 1),\n            step: sliderOpts._visibleSteps[i]\n        });\n    }\n}\n\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n    var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n\n    var quantizedIndex = 0;\n    for(var i = 0; i < sliderOpts._stepCount; i++) {\n        if(sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n            quantizedIndex = i;\n            break;\n        }\n    }\n\n    var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));\n\n    // If this is true, then *this component* is already invoking its own command\n    // and has triggered its own animation.\n    if(sliderOpts._invokingCommand) return;\n\n    var el = grip;\n    if(doTransition && sliderOpts.transition.duration > 0) {\n        el = el.transition()\n            .duration(sliderOpts.transition.duration)\n            .ease(sliderOpts.transition.easing);\n    }\n\n    // Drawing.setTranslate doesn't work here because of the transition duck-typing.\n    // It's also not necessary because there are no other transitions to preserve.\n    el.attr('transform', strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));\n}\n\n// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n    var dims = sliderOpts._dims;\n    return dims.inputAreaStart + constants.stepInset +\n        (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n}\n\n// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts, position) {\n    var dims = sliderOpts._dims;\n    return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\n\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    rect.attr({\n        width: dims.inputAreaLength,\n        height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n    })\n        .call(Color.fill, sliderOpts.bgcolor)\n        .attr('opacity', 0);\n\n    Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\n\nfunction drawRail(sliderGroup, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var computedLength = dims.inputAreaLength - constants.railInset * 2;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n\n    rect.attr({\n        width: computedLength,\n        height: constants.railWidth,\n        rx: constants.railRadius,\n        ry: constants.railRadius,\n        'shape-rendering': 'crispEdges'\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n\n    Drawing.setTranslate(rect,\n        constants.railInset,\n        (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight\n    );\n}\n"]},"metadata":{},"sourceType":"script"}