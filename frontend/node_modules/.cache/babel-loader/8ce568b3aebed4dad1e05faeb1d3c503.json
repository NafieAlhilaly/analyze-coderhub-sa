{"ast":null,"code":"'use strict';\n\nvar traceIs = require('../../registry').traceIs;\n\nvar autoType = require('./axis_autotype');\n/*\n *  data: the plot data to use in choosing auto type\n *  name: axis object name (ie 'xaxis') if one should be stored\n */\n\n\nmodule.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {\n  coerce('autotypenumbers', options.autotypenumbersDflt);\n  var axType = coerce('type', (options.splomStash || {}).type);\n\n  if (axType === '-') {\n    setAutoType(containerOut, options.data);\n\n    if (containerOut.type === '-') {\n      containerOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      containerIn.type = containerOut.type;\n    }\n  }\n};\n\nfunction setAutoType(ax, data) {\n  // new logic: let people specify any type they want,\n  // only autotype if type is '-'\n  if (ax.type !== '-') return;\n  var id = ax._id;\n  var axLetter = id.charAt(0);\n  var i; // support 3d\n\n  if (id.indexOf('scene') !== -1) id = axLetter;\n  var d0 = getFirstNonEmptyTrace(data, id, axLetter);\n  if (!d0) return; // first check for histograms, as the count direction\n  // should always default to a linear axis\n\n  if (d0.type === 'histogram' && axLetter === {\n    v: 'y',\n    h: 'x'\n  }[d0.orientation || 'v']) {\n    ax.type = 'linear';\n    return;\n  }\n\n  var calAttr = axLetter + 'calendar';\n  var calendar = d0[calAttr];\n  var opts = {\n    noMultiCategory: !traceIs(d0, 'cartesian') || traceIs(d0, 'noMultiCategory')\n  }; // To not confuse 2D x/y used for per-box sample points for multicategory coordinates\n\n  if (d0.type === 'box' && d0._hasPreCompStats && axLetter === {\n    h: 'x',\n    v: 'y'\n  }[d0.orientation || 'v']) {\n    opts.noMultiCategory = true;\n  }\n\n  opts.autotypenumbers = ax.autotypenumbers; // check all boxes on this x axis to see\n  // if they're dates, numbers, or categories\n\n  if (isBoxWithoutPositionCoords(d0, axLetter)) {\n    var posLetter = getBoxPosLetter(d0);\n    var boxPositions = [];\n\n    for (i = 0; i < data.length; i++) {\n      var trace = data[i];\n      if (!traceIs(trace, 'box-violin') || (trace[axLetter + 'axis'] || axLetter) !== id) continue;\n      if (trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);else if (trace.name !== undefined) boxPositions.push(trace.name);else boxPositions.push('text');\n      if (trace[calAttr] !== calendar) calendar = undefined;\n    }\n\n    ax.type = autoType(boxPositions, calendar, opts);\n  } else if (d0.type === 'splom') {\n    var dimensions = d0.dimensions;\n    var dim = dimensions[d0._axesDim[id]];\n    if (dim.visible) ax.type = autoType(dim.values, calendar, opts);\n  } else {\n    ax.type = autoType(d0[axLetter] || [d0[axLetter + '0']], calendar, opts);\n  }\n}\n\nfunction getFirstNonEmptyTrace(data, id, axLetter) {\n  for (var i = 0; i < data.length; i++) {\n    var trace = data[i];\n\n    if (trace.type === 'splom' && trace._length > 0 && (trace['_' + axLetter + 'axes'] || {})[id]) {\n      return trace;\n    }\n\n    if ((trace[axLetter + 'axis'] || axLetter) === id) {\n      if (isBoxWithoutPositionCoords(trace, axLetter)) {\n        return trace;\n      } else if ((trace[axLetter] || []).length || trace[axLetter + '0']) {\n        return trace;\n      }\n    }\n  }\n}\n\nfunction getBoxPosLetter(trace) {\n  return {\n    v: 'x',\n    h: 'y'\n  }[trace.orientation || 'v'];\n}\n\nfunction isBoxWithoutPositionCoords(trace, axLetter) {\n  var posLetter = getBoxPosLetter(trace);\n  var isBox = traceIs(trace, 'box-violin');\n  var isCandlestick = traceIs(trace._fullInput || {}, 'candlestick');\n  return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === undefined && trace[posLetter + '0'] === undefined;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/type_defaults.js"],"names":["traceIs","require","autoType","module","exports","handleTypeDefaults","containerIn","containerOut","coerce","options","autotypenumbersDflt","axType","splomStash","type","setAutoType","data","ax","id","_id","axLetter","charAt","i","indexOf","d0","getFirstNonEmptyTrace","v","h","orientation","calAttr","calendar","opts","noMultiCategory","_hasPreCompStats","autotypenumbers","isBoxWithoutPositionCoords","posLetter","getBoxPosLetter","boxPositions","length","trace","undefined","push","name","dimensions","dim","_axesDim","visible","values","_length","isBox","isCandlestick","_fullInput"],"mappings":"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","sourcesContent":["'use strict';\n\nvar traceIs = require('../../registry').traceIs;\nvar autoType = require('./axis_autotype');\n\n/*\n *  data: the plot data to use in choosing auto type\n *  name: axis object name (ie 'xaxis') if one should be stored\n */\nmodule.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {\n    coerce('autotypenumbers', options.autotypenumbersDflt);\n    var axType = coerce('type', (options.splomStash || {}).type);\n\n    if(axType === '-') {\n        setAutoType(containerOut, options.data);\n\n        if(containerOut.type === '-') {\n            containerOut.type = 'linear';\n        } else {\n            // copy autoType back to input axis\n            // note that if this object didn't exist\n            // in the input layout, we have to put it in\n            // this happens in the main supplyDefaults function\n            containerIn.type = containerOut.type;\n        }\n    }\n};\n\nfunction setAutoType(ax, data) {\n    // new logic: let people specify any type they want,\n    // only autotype if type is '-'\n    if(ax.type !== '-') return;\n\n    var id = ax._id;\n    var axLetter = id.charAt(0);\n    var i;\n\n    // support 3d\n    if(id.indexOf('scene') !== -1) id = axLetter;\n\n    var d0 = getFirstNonEmptyTrace(data, id, axLetter);\n    if(!d0) return;\n\n    // first check for histograms, as the count direction\n    // should always default to a linear axis\n    if(d0.type === 'histogram' &&\n        axLetter === {v: 'y', h: 'x'}[d0.orientation || 'v']\n    ) {\n        ax.type = 'linear';\n        return;\n    }\n\n    var calAttr = axLetter + 'calendar';\n    var calendar = d0[calAttr];\n    var opts = {noMultiCategory: !traceIs(d0, 'cartesian') || traceIs(d0, 'noMultiCategory')};\n\n    // To not confuse 2D x/y used for per-box sample points for multicategory coordinates\n    if(d0.type === 'box' && d0._hasPreCompStats &&\n        axLetter === {h: 'x', v: 'y'}[d0.orientation || 'v']\n    ) {\n        opts.noMultiCategory = true;\n    }\n\n    opts.autotypenumbers = ax.autotypenumbers;\n\n    // check all boxes on this x axis to see\n    // if they're dates, numbers, or categories\n    if(isBoxWithoutPositionCoords(d0, axLetter)) {\n        var posLetter = getBoxPosLetter(d0);\n        var boxPositions = [];\n\n        for(i = 0; i < data.length; i++) {\n            var trace = data[i];\n            if(!traceIs(trace, 'box-violin') || (trace[axLetter + 'axis'] || axLetter) !== id) continue;\n\n            if(trace[posLetter] !== undefined) boxPositions.push(trace[posLetter][0]);\n            else if(trace.name !== undefined) boxPositions.push(trace.name);\n            else boxPositions.push('text');\n\n            if(trace[calAttr] !== calendar) calendar = undefined;\n        }\n\n        ax.type = autoType(boxPositions, calendar, opts);\n    } else if(d0.type === 'splom') {\n        var dimensions = d0.dimensions;\n        var dim = dimensions[d0._axesDim[id]];\n        if(dim.visible) ax.type = autoType(dim.values, calendar, opts);\n    } else {\n        ax.type = autoType(d0[axLetter] || [d0[axLetter + '0']], calendar, opts);\n    }\n}\n\nfunction getFirstNonEmptyTrace(data, id, axLetter) {\n    for(var i = 0; i < data.length; i++) {\n        var trace = data[i];\n\n        if(trace.type === 'splom' &&\n                trace._length > 0 &&\n                (trace['_' + axLetter + 'axes'] || {})[id]\n        ) {\n            return trace;\n        }\n\n        if((trace[axLetter + 'axis'] || axLetter) === id) {\n            if(isBoxWithoutPositionCoords(trace, axLetter)) {\n                return trace;\n            } else if((trace[axLetter] || []).length || trace[axLetter + '0']) {\n                return trace;\n            }\n        }\n    }\n}\n\nfunction getBoxPosLetter(trace) {\n    return {v: 'x', h: 'y'}[trace.orientation || 'v'];\n}\n\nfunction isBoxWithoutPositionCoords(trace, axLetter) {\n    var posLetter = getBoxPosLetter(trace);\n    var isBox = traceIs(trace, 'box-violin');\n    var isCandlestick = traceIs(trace._fullInput || {}, 'candlestick');\n\n    return (\n        isBox &&\n        !isCandlestick &&\n        axLetter === posLetter &&\n        trace[posLetter] === undefined &&\n        trace[posLetter + '0'] === undefined\n    );\n}\n"]},"metadata":{},"sourceType":"script"}