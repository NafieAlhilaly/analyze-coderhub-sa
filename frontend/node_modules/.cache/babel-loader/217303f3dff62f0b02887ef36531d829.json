{"ast":null,"code":"'use strict';\n/* eslint-disable consistent-return */\n\nvar str2arr = require('../common').str2arr;\n\nvar sliceEq = require('../common').sliceEq;\n\nvar readUInt16LE = require('../common').readUInt16LE;\n\nvar readUInt16BE = require('../common').readUInt16BE;\n\nvar readUInt32LE = require('../common').readUInt32LE;\n\nvar readUInt32BE = require('../common').readUInt32BE;\n\nvar SIG_1 = str2arr('II\\x2A\\0');\nvar SIG_2 = str2arr('MM\\0\\x2A');\n\nfunction readUInt16(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt16BE(buffer, offset) : readUInt16LE(buffer, offset);\n}\n\nfunction readUInt32(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt32BE(buffer, offset) : readUInt32LE(buffer, offset);\n}\n\nfunction readIFDValue(data, data_offset, is_big_endian) {\n  var type = readUInt16(data, data_offset + 2, is_big_endian);\n  var values = readUInt32(data, data_offset + 4, is_big_endian);\n  if (values !== 1 || type !== 3 && type !== 4) return null;\n\n  if (type === 3) {\n    return readUInt16(data, data_offset + 8, is_big_endian);\n  }\n\n  return readUInt32(data, data_offset + 8, is_big_endian);\n}\n\nmodule.exports = function (data) {\n  if (data.length < 8) return; // check TIFF signature\n\n  if (!sliceEq(data, 0, SIG_1) && !sliceEq(data, 0, SIG_2)) return;\n  var is_big_endian = data[0] === 77\n  /* 'MM' */\n  ;\n  var count = readUInt32(data, 4, is_big_endian) - 8;\n  if (count < 0) return; // skip until IFD\n\n  var offset = count + 8;\n  if (data.length - offset < 2) return; // read number of IFD entries\n\n  var ifd_size = readUInt16(data, offset + 0, is_big_endian) * 12;\n  if (ifd_size <= 0) return;\n  offset += 2; // read all IFD entries\n\n  if (data.length - offset < ifd_size) return;\n  var i, width, height, tag;\n\n  for (i = 0; i < ifd_size; i += 12) {\n    tag = readUInt16(data, offset + i, is_big_endian);\n\n    if (tag === 256) {\n      width = readIFDValue(data, offset + i, is_big_endian);\n    } else if (tag === 257) {\n      height = readIFDValue(data, offset + i, is_big_endian);\n    }\n  }\n\n  if (width && height) {\n    return {\n      width: width,\n      height: height,\n      type: 'tiff',\n      mime: 'image/tiff',\n      wUnits: 'px',\n      hUnits: 'px'\n    };\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/probe-image-size/lib/parse_sync/tiff.js"],"names":["str2arr","require","sliceEq","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","SIG_1","SIG_2","readUInt16","buffer","offset","is_big_endian","readUInt32","readIFDValue","data","data_offset","type","values","module","exports","length","count","ifd_size","i","width","height","tag","mime","wUnits","hUnits"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr = require('../common').str2arr;\nvar sliceEq = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt16BE = require('../common').readUInt16BE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar readUInt32BE = require('../common').readUInt32BE;\n\n\nvar SIG_1 = str2arr('II\\x2A\\0');\nvar SIG_2 = str2arr('MM\\0\\x2A');\n\n\nfunction readUInt16(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt16BE(buffer, offset) : readUInt16LE(buffer, offset);\n}\n\nfunction readUInt32(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt32BE(buffer, offset) : readUInt32LE(buffer, offset);\n}\n\nfunction readIFDValue(data, data_offset, is_big_endian) {\n  var type       = readUInt16(data, data_offset + 2, is_big_endian);\n  var values     = readUInt32(data, data_offset + 4, is_big_endian);\n\n  if (values !== 1 || (type !== 3 && type !== 4)) return null;\n\n  if (type === 3) {\n    return readUInt16(data, data_offset + 8, is_big_endian);\n  }\n\n  return readUInt32(data, data_offset + 8, is_big_endian);\n}\n\nmodule.exports = function (data) {\n  if (data.length < 8) return;\n\n  // check TIFF signature\n  if (!sliceEq(data, 0, SIG_1) && !sliceEq(data, 0, SIG_2)) return;\n\n  var is_big_endian = (data[0] === 77 /* 'MM' */);\n  var count = readUInt32(data, 4, is_big_endian) - 8;\n\n  if (count < 0) return;\n\n  // skip until IFD\n  var offset = count + 8;\n\n  if (data.length - offset < 2) return;\n\n  // read number of IFD entries\n  var ifd_size = readUInt16(data, offset + 0, is_big_endian) * 12;\n\n  if (ifd_size <= 0) return;\n\n  offset += 2;\n\n  // read all IFD entries\n  if (data.length - offset < ifd_size) return;\n\n  var i, width, height, tag;\n\n  for (i = 0; i < ifd_size; i += 12) {\n    tag = readUInt16(data, offset + i, is_big_endian);\n\n    if (tag === 256) {\n      width = readIFDValue(data, offset + i, is_big_endian);\n    } else if (tag === 257) {\n      height = readIFDValue(data, offset + i, is_big_endian);\n    }\n  }\n\n  if (width && height) {\n    return {\n      width:  width,\n      height: height,\n      type:   'tiff',\n      mime:   'image/tiff',\n      wUnits: 'px',\n      hUnits: 'px'\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}