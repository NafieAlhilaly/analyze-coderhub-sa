{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\n\nvar handleArrayContainerDefaults = require('../array_container_defaults');\n\nvar layoutAttributes = require('./layout_attributes');\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: 'mapbox',\n    attributes: layoutAttributes,\n    handleDefaults: handleDefaults,\n    partition: 'y',\n    accessToken: layoutOut._mapboxAccessToken\n  });\n};\n\nfunction handleDefaults(containerIn, containerOut, coerce, opts) {\n  coerce('accesstoken', opts.accessToken);\n  coerce('style');\n  coerce('center.lon');\n  coerce('center.lat');\n  coerce('zoom');\n  coerce('bearing');\n  coerce('pitch');\n  handleArrayContainerDefaults(containerIn, containerOut, {\n    name: 'layers',\n    handleItemDefaults: handleLayerDefaults\n  }); // copy ref to input container to update 'center' and 'zoom' on map move\n\n  containerOut._input = containerIn;\n}\n\nfunction handleLayerDefaults(layerIn, layerOut) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(layerIn, layerOut, layoutAttributes.layers, attr, dflt);\n  }\n\n  var visible = coerce('visible');\n\n  if (visible) {\n    var sourceType = coerce('sourcetype');\n    var mustBeRasterLayer = sourceType === 'raster' || sourceType === 'image';\n    coerce('source');\n    coerce('sourceattribution');\n\n    if (sourceType === 'vector') {\n      coerce('sourcelayer');\n    }\n\n    if (sourceType === 'image') {\n      coerce('coordinates');\n    }\n\n    var typeDflt;\n    if (mustBeRasterLayer) typeDflt = 'raster';\n    var type = coerce('type', typeDflt);\n\n    if (mustBeRasterLayer && type !== 'raster') {\n      type = layerOut.type = 'raster';\n      Lib.log('Source types *raster* and *image* must drawn *raster* layer type.');\n    }\n\n    coerce('below');\n    coerce('color');\n    coerce('opacity');\n    coerce('minzoom');\n    coerce('maxzoom');\n\n    if (type === 'circle') {\n      coerce('circle.radius');\n    }\n\n    if (type === 'line') {\n      coerce('line.width');\n      coerce('line.dash');\n    }\n\n    if (type === 'fill') {\n      coerce('fill.outlinecolor');\n    }\n\n    if (type === 'symbol') {\n      coerce('symbol.icon');\n      coerce('symbol.iconsize');\n      coerce('symbol.text');\n      Lib.coerceFont(coerce, 'symbol.textfont');\n      coerce('symbol.textposition');\n      coerce('symbol.placement');\n    }\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/mapbox/layout_defaults.js"],"names":["Lib","require","handleSubplotDefaults","handleArrayContainerDefaults","layoutAttributes","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","type","attributes","handleDefaults","partition","accessToken","_mapboxAccessToken","containerIn","containerOut","coerce","opts","name","handleItemDefaults","handleLayerDefaults","_input","layerIn","layerOut","attr","dflt","layers","visible","sourceType","mustBeRasterLayer","typeDflt","log","coerceFont"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\nvar handleArrayContainerDefaults = require('../array_container_defaults');\nvar layoutAttributes = require('./layout_attributes');\n\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n        type: 'mapbox',\n        attributes: layoutAttributes,\n        handleDefaults: handleDefaults,\n        partition: 'y',\n        accessToken: layoutOut._mapboxAccessToken\n    });\n};\n\nfunction handleDefaults(containerIn, containerOut, coerce, opts) {\n    coerce('accesstoken', opts.accessToken);\n    coerce('style');\n    coerce('center.lon');\n    coerce('center.lat');\n    coerce('zoom');\n    coerce('bearing');\n    coerce('pitch');\n\n    handleArrayContainerDefaults(containerIn, containerOut, {\n        name: 'layers',\n        handleItemDefaults: handleLayerDefaults\n    });\n\n    // copy ref to input container to update 'center' and 'zoom' on map move\n    containerOut._input = containerIn;\n}\n\nfunction handleLayerDefaults(layerIn, layerOut) {\n    function coerce(attr, dflt) {\n        return Lib.coerce(layerIn, layerOut, layoutAttributes.layers, attr, dflt);\n    }\n\n    var visible = coerce('visible');\n    if(visible) {\n        var sourceType = coerce('sourcetype');\n        var mustBeRasterLayer = sourceType === 'raster' || sourceType === 'image';\n\n        coerce('source');\n        coerce('sourceattribution');\n\n        if(sourceType === 'vector') {\n            coerce('sourcelayer');\n        }\n\n        if(sourceType === 'image') {\n            coerce('coordinates');\n        }\n\n        var typeDflt;\n        if(mustBeRasterLayer) typeDflt = 'raster';\n\n        var type = coerce('type', typeDflt);\n\n        if(mustBeRasterLayer && type !== 'raster') {\n            type = layerOut.type = 'raster';\n            Lib.log('Source types *raster* and *image* must drawn *raster* layer type.');\n        }\n\n        coerce('below');\n        coerce('color');\n        coerce('opacity');\n        coerce('minzoom');\n        coerce('maxzoom');\n\n        if(type === 'circle') {\n            coerce('circle.radius');\n        }\n\n        if(type === 'line') {\n            coerce('line.width');\n            coerce('line.dash');\n        }\n\n        if(type === 'fill') {\n            coerce('fill.outlinecolor');\n        }\n\n        if(type === 'symbol') {\n            coerce('symbol.icon');\n            coerce('symbol.iconsize');\n\n            coerce('symbol.text');\n            Lib.coerceFont(coerce, 'symbol.textfont');\n            coerce('symbol.textposition');\n            coerce('symbol.placement');\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}