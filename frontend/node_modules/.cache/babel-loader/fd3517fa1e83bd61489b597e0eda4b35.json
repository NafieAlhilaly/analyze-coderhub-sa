{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nmodule.exports = function (vectorfield, bounds) {\n  var positions = vectorfield.positions;\n  var vectors = vectorfield.vectors;\n  var geo = {\n    positions: [],\n    vertexIntensity: [],\n    vertexIntensityBounds: vectorfield.vertexIntensityBounds,\n    vectors: [],\n    cells: [],\n    coneOffset: vectorfield.coneOffset,\n    colormap: vectorfield.colormap\n  };\n\n  if (vectorfield.positions.length === 0) {\n    if (bounds) {\n      bounds[0] = [0, 0, 0];\n      bounds[1] = [0, 0, 0];\n    }\n\n    return geo;\n  } // Compute bounding box for the dataset.\n  // Compute maximum velocity for the dataset to use for scaling the cones.\n\n\n  var maxNorm = 0;\n  var minX = Infinity,\n      maxX = -Infinity;\n  var minY = Infinity,\n      maxY = -Infinity;\n  var minZ = Infinity,\n      maxZ = -Infinity;\n  var p2 = null;\n  var u2 = null;\n  var positionVectors = [];\n  var vectorScale = Infinity;\n  var skipIt = false;\n\n  for (var i = 0; i < positions.length; i++) {\n    var p = positions[i];\n    minX = Math.min(p[0], minX);\n    maxX = Math.max(p[0], maxX);\n    minY = Math.min(p[1], minY);\n    maxY = Math.max(p[1], maxY);\n    minZ = Math.min(p[2], minZ);\n    maxZ = Math.max(p[2], maxZ);\n    var u = vectors[i];\n\n    if (vec3.length(u) > maxNorm) {\n      maxNorm = vec3.length(u);\n    }\n\n    if (i) {\n      // Find vector scale [w/ units of time] using \"successive\" positions\n      // (not \"adjacent\" with would be O(n^2)),\n      //\n      // The vector scale corresponds to the minimum \"time\" to travel across two\n      // two adjacent positions at the average velocity of those two adjacent positions\n      var q = 2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u));\n\n      if (q) {\n        vectorScale = Math.min(vectorScale, q);\n        skipIt = false;\n      } else {\n        skipIt = true;\n      }\n    }\n\n    if (!skipIt) {\n      p2 = p;\n      u2 = u;\n    }\n\n    positionVectors.push(u);\n  }\n\n  var minV = [minX, minY, minZ];\n  var maxV = [maxX, maxY, maxZ];\n\n  if (bounds) {\n    bounds[0] = minV;\n    bounds[1] = maxV;\n  }\n\n  if (maxNorm === 0) {\n    maxNorm = 1;\n  } // Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\n\n  var invertedMaxNorm = 1 / maxNorm;\n\n  if (!isFinite(vectorScale)) {\n    vectorScale = 1.0;\n  }\n\n  geo.vectorScale = vectorScale;\n  var coneScale = vectorfield.coneSize || 0.5;\n\n  if (vectorfield.absoluteConeSize) {\n    coneScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n  }\n\n  geo.coneScale = coneScale; // Build the cone model.\n\n  for (var i = 0, j = 0; i < positions.length; i++) {\n    var p = positions[i];\n    var x = p[0],\n        y = p[1],\n        z = p[2];\n    var d = positionVectors[i];\n    var intensity = vec3.length(d) * invertedMaxNorm;\n\n    for (var k = 0, l = 8; k < l; k++) {\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      var m = geo.positions.length;\n      geo.cells.push([m - 6, m - 5, m - 4], [m - 3, m - 2, m - 1]);\n    }\n  }\n\n  return geo;\n};\n\nvar shaders = require('./lib/shaders');\n\nmodule.exports.createMesh = require('./create_mesh');\n\nmodule.exports.createConeMesh = function (gl, params) {\n  return module.exports.createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'cone'\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/gl-cone3d/cone.js"],"names":["vec3","require","module","exports","vectorfield","bounds","positions","vectors","geo","vertexIntensity","vertexIntensityBounds","cells","coneOffset","colormap","length","maxNorm","minX","Infinity","maxX","minY","maxY","minZ","maxZ","p2","u2","positionVectors","vectorScale","skipIt","i","p","Math","min","max","u","q","distance","push","minV","maxV","invertedMaxNorm","isFinite","coneScale","coneSize","absoluteConeSize","j","x","y","z","d","intensity","k","l","m","shaders","createMesh","createConeMesh","gl","params","traceType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nmodule.exports = function(vectorfield, bounds) {\n\tvar positions = vectorfield.positions;\n\tvar vectors = vectorfield.vectors;\n\tvar geo = {\n\t\tpositions: [],\n\t\tvertexIntensity: [],\n\t\tvertexIntensityBounds: vectorfield.vertexIntensityBounds,\n\t\tvectors: [],\n\t\tcells: [],\n\t\tconeOffset: vectorfield.coneOffset,\n\t\tcolormap: vectorfield.colormap\n\t};\n\n\tif (vectorfield.positions.length === 0) {\n\t\tif (bounds) {\n\t\t\tbounds[0] = [0,0,0];\n\t\t\tbounds[1] = [0,0,0];\n\t\t}\n\t\treturn geo;\n\t}\n\n\t// Compute bounding box for the dataset.\n\t// Compute maximum velocity for the dataset to use for scaling the cones.\n\tvar maxNorm = 0;\n\tvar minX = Infinity, maxX = -Infinity;\n\tvar minY = Infinity, maxY = -Infinity;\n\tvar minZ = Infinity, maxZ = -Infinity;\n\tvar p2 = null;\n\tvar u2 = null;\n\tvar positionVectors = [];\n\tvar vectorScale = Infinity;\n\tvar skipIt = false;\n\tfor (var i = 0; i < positions.length; i++) {\n\t\tvar p = positions[i];\n\t\tminX = Math.min(p[0], minX);\n\t\tmaxX = Math.max(p[0], maxX);\n\t\tminY = Math.min(p[1], minY);\n\t\tmaxY = Math.max(p[1], maxY);\n\t\tminZ = Math.min(p[2], minZ);\n\t\tmaxZ = Math.max(p[2], maxZ);\n\t\tvar u = vectors[i];\n\n\t\tif (vec3.length(u) > maxNorm) {\n\t\t\tmaxNorm = vec3.length(u);\n\t\t}\n\t\tif (i) {\n\t\t\t// Find vector scale [w/ units of time] using \"successive\" positions\n\t\t\t// (not \"adjacent\" with would be O(n^2)),\n\t\t\t//\n\t\t\t// The vector scale corresponds to the minimum \"time\" to travel across two\n\t\t\t// two adjacent positions at the average velocity of those two adjacent positions\n\n\t\t\tvar q = (2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u)));\n\t\t\tif(q) {\n\t\t\t\tvectorScale = Math.min(vectorScale, q);\n\t\t\t\tskipIt = false;\n\t\t\t} else {\n\t\t\t\tskipIt = true;\n\t\t\t}\n\t\t}\n\t\tif(!skipIt) {\n\t\t\tp2 = p;\n\t\t\tu2 = u;\n\t\t}\n\t\tpositionVectors.push(u);\n\t}\n\tvar minV = [minX, minY, minZ];\n\tvar maxV = [maxX, maxY, maxZ];\n\tif (bounds) {\n\t\tbounds[0] = minV;\n\t\tbounds[1] = maxV;\n\t}\n\tif (maxNorm === 0) {\n\t\tmaxNorm = 1;\n\t}\n\n\t// Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\tvar invertedMaxNorm = 1 / maxNorm;\n\n\tif (!isFinite(vectorScale)) {\n\t\tvectorScale = 1.0;\n\t}\n\tgeo.vectorScale = vectorScale;\n\n\tvar coneScale = vectorfield.coneSize || 0.5;\n\n\tif (vectorfield.absoluteConeSize) {\n\t\tconeScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n\t}\n\n\tgeo.coneScale = coneScale;\n\n\t// Build the cone model.\n\tfor (var i = 0, j = 0; i < positions.length; i++) {\n\t\tvar p = positions[i];\n\t\tvar x = p[0], y = p[1], z = p[2];\n\t\tvar d = positionVectors[i];\n\t\tvar intensity = vec3.length(d) * invertedMaxNorm;\n\t\tfor (var k = 0, l = 8; k < l; k++) {\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\n\t\t\tvar m = geo.positions.length;\n\t\t\tgeo.cells.push([m-6, m-5, m-4], [m-3, m-2, m-1]);\n\t\t}\n\t}\n\n\treturn geo;\n};\n\nvar shaders = require('./lib/shaders');\nmodule.exports.createMesh = require('./create_mesh');\nmodule.exports.createConeMesh = function(gl, params) {\n\treturn module.exports.createMesh(gl, params, {\n\t\tshaders: shaders,\n\t\ttraceType: 'cone'\n\t});\n}\n"]},"metadata":{},"sourceType":"script"}