{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar alignPeriod = require('../../plots/cartesian/align_period');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar _ = Lib._;\n\nmodule.exports = function calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n  var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n  var cd = []; // N.B. violin reuses same Box.calc\n\n  var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n  var i, j;\n  var valAxis, valLetter;\n  var posAxis, posLetter;\n  var hasPeriod;\n\n  if (trace.orientation === 'h') {\n    valAxis = xa;\n    valLetter = 'x';\n    posAxis = ya;\n    posLetter = 'y';\n    hasPeriod = !!trace.yperiodalignment;\n  } else {\n    valAxis = ya;\n    valLetter = 'y';\n    posAxis = xa;\n    posLetter = 'x';\n    hasPeriod = !!trace.xperiodalignment;\n  }\n\n  var allPosArrays = getPosArrays(trace, posLetter, posAxis, fullLayout[numKey]);\n  var posArray = allPosArrays[0];\n  var origPos = allPosArrays[1];\n  var dv = Lib.distinctVals(posArray, posAxis);\n  var posDistinct = dv.vals;\n  var dPos = dv.minDiff / 2; // item in trace calcdata\n\n  var cdi; // array of {v: v, i, i} sample pts\n\n  var pts; // values of the `pts` array of objects\n\n  var boxVals; // length of sample\n\n  var N; // single sample point\n\n  var pt; // single sample value\n\n  var v; // filter function for outlier pts\n  // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n\n  var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ? Lib.identity : function (pt) {\n    return pt.v < cdi.lf || pt.v > cdi.uf;\n  };\n\n  if (trace._hasPreCompStats) {\n    var valArrayRaw = trace[valLetter];\n\n    var d2c = function (k) {\n      return valAxis.d2c((trace[k] || [])[i]);\n    };\n\n    var minVal = Infinity;\n    var maxVal = -Infinity;\n\n    for (i = 0; i < trace._length; i++) {\n      var posi = posArray[i];\n      if (!isNumeric(posi)) continue;\n      cdi = {};\n      cdi.pos = cdi[posLetter] = posi;\n\n      if (hasPeriod && origPos) {\n        cdi.orig_p = origPos[i]; // used by hover\n      }\n\n      cdi.q1 = d2c('q1');\n      cdi.med = d2c('median');\n      cdi.q3 = d2c('q3');\n      pts = [];\n\n      if (valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n        for (j = 0; j < valArrayRaw[i].length; j++) {\n          v = valAxis.d2c(valArrayRaw[i][j]);\n\n          if (v !== BADNUM) {\n            pt = {\n              v: v,\n              i: [i, j]\n            };\n            arraysToCalcdata(pt, trace, [i, j]);\n            pts.push(pt);\n          }\n        }\n      }\n\n      cdi.pts = pts.sort(sortByVal);\n      boxVals = cdi[valLetter] = pts.map(extractVal);\n      N = boxVals.length;\n\n      if (cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM && cdi.med >= cdi.q1 && cdi.q3 >= cdi.med) {\n        var lf = d2c('lowerfence');\n        cdi.lf = lf !== BADNUM && lf <= cdi.q1 ? lf : computeLowerFence(cdi, boxVals, N);\n        var uf = d2c('upperfence');\n        cdi.uf = uf !== BADNUM && uf >= cdi.q3 ? uf : computeUpperFence(cdi, boxVals, N);\n        var mean = d2c('mean');\n        cdi.mean = mean !== BADNUM ? mean : N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2;\n        var sd = d2c('sd');\n        cdi.sd = mean !== BADNUM && sd >= 0 ? sd : N ? Lib.stdev(boxVals, N, cdi.mean) : cdi.q3 - cdi.q1;\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi);\n        var ns = d2c('notchspan');\n        ns = ns !== BADNUM && ns > 0 ? ns : computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - ns;\n        cdi.un = cdi.med + ns;\n        var imin = cdi.lf;\n        var imax = cdi.uf;\n\n        if (trace.boxpoints && boxVals.length) {\n          imin = Math.min(imin, boxVals[0]);\n          imax = Math.max(imax, boxVals[N - 1]);\n        }\n\n        if (trace.notched) {\n          imin = Math.min(imin, cdi.ln);\n          imax = Math.max(imax, cdi.un);\n        }\n\n        cdi.min = imin;\n        cdi.max = imax;\n      } else {\n        Lib.warn(['Invalid input - make sure that q1 <= median <= q3', 'q1 = ' + cdi.q1, 'median = ' + cdi.med, 'q3 = ' + cdi.q3].join('\\n'));\n        var v0;\n\n        if (cdi.med !== BADNUM) {\n          v0 = cdi.med;\n        } else if (cdi.q1 !== BADNUM) {\n          if (cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;else v0 = cdi.q1;\n        } else if (cdi.q3 !== BADNUM) {\n          v0 = cdi.q3;\n        } else {\n          v0 = 0;\n        } // draw box as line segment\n\n\n        cdi.med = v0;\n        cdi.q1 = cdi.q3 = v0;\n        cdi.lf = cdi.uf = v0;\n        cdi.mean = cdi.sd = v0;\n        cdi.ln = cdi.un = v0;\n        cdi.min = cdi.max = v0;\n      }\n\n      minVal = Math.min(minVal, cdi.min);\n      maxVal = Math.max(maxVal, cdi.max);\n      cdi.pts2 = pts.filter(ptFilterFn);\n      cd.push(cdi);\n    }\n\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, [minVal, maxVal], {\n      padded: true\n    });\n  } else {\n    var valArray = valAxis.makeCalcdata(trace, valLetter);\n    var posBins = makeBins(posDistinct, dPos);\n    var pLen = posDistinct.length;\n    var ptsPerBin = initNestedArray(pLen); // bin pts info per position bins\n\n    for (i = 0; i < trace._length; i++) {\n      v = valArray[i];\n      if (!isNumeric(v)) continue;\n      var n = Lib.findBin(posArray[i], posBins);\n\n      if (n >= 0 && n < pLen) {\n        pt = {\n          v: v,\n          i: i\n        };\n        arraysToCalcdata(pt, trace, i);\n        ptsPerBin[n].push(pt);\n      }\n    }\n\n    var minLowerNotch = Infinity;\n    var maxUpperNotch = -Infinity;\n    var quartilemethod = trace.quartilemethod;\n    var usesExclusive = quartilemethod === 'exclusive';\n    var usesInclusive = quartilemethod === 'inclusive'; // build calcdata trace items, one item per distinct position\n\n    for (i = 0; i < pLen; i++) {\n      if (ptsPerBin[i].length > 0) {\n        cdi = {};\n        cdi.pos = cdi[posLetter] = posDistinct[i];\n        pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n        boxVals = cdi[valLetter] = pts.map(extractVal);\n        N = boxVals.length;\n        cdi.min = boxVals[0];\n        cdi.max = boxVals[N - 1];\n        cdi.mean = Lib.mean(boxVals, N);\n        cdi.sd = Lib.stdev(boxVals, N, cdi.mean);\n        cdi.med = Lib.interp(boxVals, 0.5);\n\n        if (N % 2 && (usesExclusive || usesInclusive)) {\n          var lower;\n          var upper;\n\n          if (usesExclusive) {\n            // do NOT include the median in either half\n            lower = boxVals.slice(0, N / 2);\n            upper = boxVals.slice(N / 2 + 1);\n          } else if (usesInclusive) {\n            // include the median in either half\n            lower = boxVals.slice(0, N / 2 + 1);\n            upper = boxVals.slice(N / 2);\n          }\n\n          cdi.q1 = Lib.interp(lower, 0.5);\n          cdi.q3 = Lib.interp(upper, 0.5);\n        } else {\n          cdi.q1 = Lib.interp(boxVals, 0.25);\n          cdi.q3 = Lib.interp(boxVals, 0.75);\n        } // lower and upper fences\n\n\n        cdi.lf = computeLowerFence(cdi, boxVals, N);\n        cdi.uf = computeUpperFence(cdi, boxVals, N); // lower and upper outliers bounds\n\n        cdi.lo = computeLowerOutlierBound(cdi);\n        cdi.uo = computeUpperOutlierBound(cdi); // lower and upper notches\n\n        var mci = computeNotchSpan(cdi, N);\n        cdi.ln = cdi.med - mci;\n        cdi.un = cdi.med + mci;\n        minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n        maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n        cdi.pts2 = pts.filter(ptFilterFn);\n        cd.push(cdi);\n      }\n    }\n\n    trace._extremes[valAxis._id] = Axes.findExtremes(valAxis, trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray, {\n      padded: true\n    });\n  }\n\n  calcSelection(cd, trace);\n\n  if (cd.length > 0) {\n    cd[0].t = {\n      num: fullLayout[numKey],\n      dPos: dPos,\n      posLetter: posLetter,\n      valLetter: valLetter,\n      labels: {\n        med: _(gd, 'median:'),\n        min: _(gd, 'min:'),\n        q1: _(gd, 'q1:'),\n        q3: _(gd, 'q3:'),\n        max: _(gd, 'max:'),\n        mean: trace.boxmean === 'sd' ? _(gd, 'mean ± σ:') : _(gd, 'mean:'),\n        lf: _(gd, 'lower fence:'),\n        uf: _(gd, 'upper fence:')\n      }\n    };\n    fullLayout[numKey]++;\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}; // In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\n\n\nfunction getPosArrays(trace, posLetter, posAxis, num) {\n  var hasPosArray = (posLetter in trace);\n  var hasPos0 = (posLetter + '0' in trace);\n  var hasPosStep = ('d' + posLetter in trace);\n\n  if (hasPosArray || hasPos0 && hasPosStep) {\n    var origPos = posAxis.makeCalcdata(trace, posLetter);\n    var pos = alignPeriod(trace, posAxis, posLetter, origPos).vals;\n    return [pos, origPos];\n  }\n\n  var pos0;\n\n  if (hasPos0) {\n    pos0 = trace[posLetter + '0'];\n  } else if ('name' in trace && (posAxis.type === 'category' || isNumeric(trace.name) && ['linear', 'log'].indexOf(posAxis.type) !== -1 || Lib.isDateTime(trace.name) && posAxis.type === 'date')) {\n    pos0 = trace.name;\n  } else {\n    pos0 = num;\n  }\n\n  var pos0c = posAxis.type === 'multicategory' ? posAxis.r2c_just_indices(pos0) : posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n  var len = trace._length;\n  var out = new Array(len);\n\n  for (var i = 0; i < len; i++) out[i] = pos0c;\n\n  return [out];\n}\n\nfunction makeBins(x, dx) {\n  var len = x.length;\n  var bins = new Array(len + 1);\n\n  for (var i = 0; i < len; i++) {\n    bins[i] = x[i] - dx;\n  }\n\n  bins[len] = x[len - 1] + dx;\n  return bins;\n}\n\nfunction initNestedArray(len) {\n  var arr = new Array(len);\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = [];\n  }\n\n  return arr;\n}\n\nvar TRACE_TO_CALC = {\n  text: 'tx',\n  hovertext: 'htx'\n};\n\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n  for (var k in TRACE_TO_CALC) {\n    if (Lib.isArrayOrTypedArray(trace[k])) {\n      if (Array.isArray(ptNumber)) {\n        if (Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n          pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n        }\n      } else {\n        pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n      }\n    }\n  }\n}\n\nfunction calcSelection(cd, trace) {\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    for (var i = 0; i < cd.length; i++) {\n      var pts = cd[i].pts || [];\n      var ptNumber2cdIndex = {};\n\n      for (var j = 0; j < pts.length; j++) {\n        ptNumber2cdIndex[pts[j].i] = j;\n      }\n\n      Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n    }\n  }\n}\n\nfunction sortByVal(a, b) {\n  return a.v - b.v;\n}\n\nfunction extractVal(o) {\n  return o.v;\n} // last point below 1.5 * IQR\n\n\nfunction computeLowerFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q1;\n  return Math.min(cdi.q1, boxVals[Math.min(Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1, N - 1)]);\n} // last point above 1.5 * IQR\n\n\nfunction computeUpperFence(cdi, boxVals, N) {\n  if (N === 0) return cdi.q3;\n  return Math.max(cdi.q3, boxVals[Math.max(Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals), 0)]);\n} // 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\n\n\nfunction computeLowerOutlierBound(cdi) {\n  return 4 * cdi.q1 - 3 * cdi.q3;\n} // 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\n\n\nfunction computeUpperOutlierBound(cdi) {\n  return 4 * cdi.q3 - 3 * cdi.q1;\n} // 95% confidence intervals for median\n\n\nfunction computeNotchSpan(cdi, N) {\n  if (N === 0) return 0;\n  return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/box/calc.js"],"names":["isNumeric","require","Axes","alignPeriod","Lib","BADNUM","_","module","exports","calc","gd","trace","fullLayout","_fullLayout","xa","getFromId","xaxis","ya","yaxis","cd","numKey","type","i","j","valAxis","valLetter","posAxis","posLetter","hasPeriod","orientation","yperiodalignment","xperiodalignment","allPosArrays","getPosArrays","posArray","origPos","dv","distinctVals","posDistinct","vals","dPos","minDiff","cdi","pts","boxVals","N","pt","v","ptFilterFn","boxpoints","points","identity","lf","uf","_hasPreCompStats","valArrayRaw","d2c","k","minVal","Infinity","maxVal","_length","posi","pos","orig_p","q1","med","q3","isArrayOrTypedArray","length","arraysToCalcdata","push","sort","sortByVal","map","extractVal","computeLowerFence","computeUpperFence","mean","sd","stdev","lo","computeLowerOutlierBound","uo","computeUpperOutlierBound","ns","computeNotchSpan","ln","un","imin","imax","Math","min","max","notched","warn","join","v0","pts2","filter","_extremes","_id","findExtremes","padded","valArray","makeCalcdata","posBins","makeBins","pLen","ptsPerBin","initNestedArray","n","findBin","minLowerNotch","maxUpperNotch","quartilemethod","usesExclusive","usesInclusive","interp","lower","upper","slice","mci","concat","calcSelection","t","num","labels","boxmean","empty","hasPosArray","hasPos0","hasPosStep","pos0","name","indexOf","isDateTime","pos0c","r2c_just_indices","len","out","Array","x","dx","bins","arr","TRACE_TO_CALC","text","hovertext","ptNumber","isArray","selectedpoints","ptNumber2cdIndex","tagSelected","a","b","o","sqrt"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAD,CAAvB;;AAEA,IAAIC,IAAI,GAAGD,OAAO,CAAC,4BAAD,CAAlB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,oCAAD,CAAzB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,WAAD,CAAjB;;AAEA,IAAII,MAAM,GAAGJ,OAAO,CAAC,2BAAD,CAAP,CAAqCI,MAAlD;;AACA,IAAIC,CAAC,GAAGF,GAAG,CAACE,CAAZ;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAcC,EAAd,EAAkBC,KAAlB,EAAyB;AACtC,MAAIC,UAAU,GAAGF,EAAE,CAACG,WAApB;AACA,MAAIC,EAAE,GAAGZ,IAAI,CAACa,SAAL,CAAeL,EAAf,EAAmBC,KAAK,CAACK,KAAN,IAAe,GAAlC,CAAT;AACA,MAAIC,EAAE,GAAGf,IAAI,CAACa,SAAL,CAAeL,EAAf,EAAmBC,KAAK,CAACO,KAAN,IAAe,GAAlC,CAAT;AACA,MAAIC,EAAE,GAAG,EAAT,CAJsC,CAMtC;;AACA,MAAIC,MAAM,GAAGT,KAAK,CAACU,IAAN,KAAe,QAAf,GAA0B,aAA1B,GAA0C,WAAvD;AAEA,MAAIC,CAAJ,EAAOC,CAAP;AACA,MAAIC,OAAJ,EAAaC,SAAb;AACA,MAAIC,OAAJ,EAAaC,SAAb;AAEA,MAAIC,SAAJ;;AACA,MAAGjB,KAAK,CAACkB,WAAN,KAAsB,GAAzB,EAA8B;AAC1BL,IAAAA,OAAO,GAAGV,EAAV;AACAW,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,OAAO,GAAGT,EAAV;AACAU,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,CAAC,CAACjB,KAAK,CAACmB,gBAApB;AACH,GAND,MAMO;AACHN,IAAAA,OAAO,GAAGP,EAAV;AACAQ,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,OAAO,GAAGZ,EAAV;AACAa,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,CAAC,CAACjB,KAAK,CAACoB,gBAApB;AACH;;AAED,MAAIC,YAAY,GAAGC,YAAY,CAACtB,KAAD,EAAQgB,SAAR,EAAmBD,OAAnB,EAA4Bd,UAAU,CAACQ,MAAD,CAAtC,CAA/B;AACA,MAAIc,QAAQ,GAAGF,YAAY,CAAC,CAAD,CAA3B;AACA,MAAIG,OAAO,GAAGH,YAAY,CAAC,CAAD,CAA1B;AACA,MAAII,EAAE,GAAGhC,GAAG,CAACiC,YAAJ,CAAiBH,QAAjB,EAA2BR,OAA3B,CAAT;AACA,MAAIY,WAAW,GAAGF,EAAE,CAACG,IAArB;AACA,MAAIC,IAAI,GAAGJ,EAAE,CAACK,OAAH,GAAa,CAAxB,CAjCsC,CAmCtC;;AACA,MAAIC,GAAJ,CApCsC,CAqCtC;;AACA,MAAIC,GAAJ,CAtCsC,CAuCtC;;AACA,MAAIC,OAAJ,CAxCsC,CAyCtC;;AACA,MAAIC,CAAJ,CA1CsC,CA2CtC;;AACA,MAAIC,EAAJ,CA5CsC,CA6CtC;;AACA,MAAIC,CAAJ,CA9CsC,CAgDtC;AACA;;AACA,MAAIC,UAAU,GAAG,CAACrC,KAAK,CAACsC,SAAN,IAAmBtC,KAAK,CAACuC,MAA1B,MAAsC,KAAtC,GACb9C,GAAG,CAAC+C,QADS,GAEb,UAASL,EAAT,EAAa;AAAE,WAAQA,EAAE,CAACC,CAAH,GAAOL,GAAG,CAACU,EAAX,IAAiBN,EAAE,CAACC,CAAH,GAAOL,GAAG,CAACW,EAApC;AAA0C,GAF7D;;AAIA,MAAG1C,KAAK,CAAC2C,gBAAT,EAA2B;AACvB,QAAIC,WAAW,GAAG5C,KAAK,CAACc,SAAD,CAAvB;;AACA,QAAI+B,GAAG,GAAG,UAASC,CAAT,EAAY;AAAE,aAAOjC,OAAO,CAACgC,GAAR,CAAY,CAAC7C,KAAK,CAAC8C,CAAD,CAAL,IAAY,EAAb,EAAiBnC,CAAjB,CAAZ,CAAP;AAA0C,KAAlE;;AACA,QAAIoC,MAAM,GAAGC,QAAb;AACA,QAAIC,MAAM,GAAG,CAACD,QAAd;;AAEA,SAAIrC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGX,KAAK,CAACkD,OAArB,EAA8BvC,CAAC,EAA/B,EAAmC;AAC/B,UAAIwC,IAAI,GAAG5B,QAAQ,CAACZ,CAAD,CAAnB;AACA,UAAG,CAACtB,SAAS,CAAC8D,IAAD,CAAb,EAAqB;AAErBpB,MAAAA,GAAG,GAAG,EAAN;AACAA,MAAAA,GAAG,CAACqB,GAAJ,GAAUrB,GAAG,CAACf,SAAD,CAAH,GAAiBmC,IAA3B;;AACA,UAAGlC,SAAS,IAAIO,OAAhB,EAAyB;AACrBO,QAAAA,GAAG,CAACsB,MAAJ,GAAa7B,OAAO,CAACb,CAAD,CAApB,CADqB,CACI;AAC5B;;AAEDoB,MAAAA,GAAG,CAACuB,EAAJ,GAAST,GAAG,CAAC,IAAD,CAAZ;AACAd,MAAAA,GAAG,CAACwB,GAAJ,GAAUV,GAAG,CAAC,QAAD,CAAb;AACAd,MAAAA,GAAG,CAACyB,EAAJ,GAASX,GAAG,CAAC,IAAD,CAAZ;AAEAb,MAAAA,GAAG,GAAG,EAAN;;AACA,UAAGY,WAAW,IAAInD,GAAG,CAACgE,mBAAJ,CAAwBb,WAAW,CAACjC,CAAD,CAAnC,CAAlB,EAA2D;AACvD,aAAIC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGgC,WAAW,CAACjC,CAAD,CAAX,CAAe+C,MAA9B,EAAsC9C,CAAC,EAAvC,EAA2C;AACvCwB,UAAAA,CAAC,GAAGvB,OAAO,CAACgC,GAAR,CAAYD,WAAW,CAACjC,CAAD,CAAX,CAAeC,CAAf,CAAZ,CAAJ;;AACA,cAAGwB,CAAC,KAAK1C,MAAT,EAAiB;AACbyC,YAAAA,EAAE,GAAG;AAACC,cAAAA,CAAC,EAAEA,CAAJ;AAAOzB,cAAAA,CAAC,EAAE,CAACA,CAAD,EAAIC,CAAJ;AAAV,aAAL;AACA+C,YAAAA,gBAAgB,CAACxB,EAAD,EAAKnC,KAAL,EAAY,CAACW,CAAD,EAAIC,CAAJ,CAAZ,CAAhB;AACAoB,YAAAA,GAAG,CAAC4B,IAAJ,CAASzB,EAAT;AACH;AACJ;AACJ;;AACDJ,MAAAA,GAAG,CAACC,GAAJ,GAAUA,GAAG,CAAC6B,IAAJ,CAASC,SAAT,CAAV;AACA7B,MAAAA,OAAO,GAAGF,GAAG,CAACjB,SAAD,CAAH,GAAiBkB,GAAG,CAAC+B,GAAJ,CAAQC,UAAR,CAA3B;AACA9B,MAAAA,CAAC,GAAGD,OAAO,CAACyB,MAAZ;;AAEA,UAAG3B,GAAG,CAACwB,GAAJ,KAAY7D,MAAZ,IAAsBqC,GAAG,CAACuB,EAAJ,KAAW5D,MAAjC,IAA2CqC,GAAG,CAACyB,EAAJ,KAAW9D,MAAtD,IACCqC,GAAG,CAACwB,GAAJ,IAAWxB,GAAG,CAACuB,EADhB,IACsBvB,GAAG,CAACyB,EAAJ,IAAUzB,GAAG,CAACwB,GADvC,EAEE;AACE,YAAId,EAAE,GAAGI,GAAG,CAAC,YAAD,CAAZ;AACAd,QAAAA,GAAG,CAACU,EAAJ,GAAUA,EAAE,KAAK/C,MAAP,IAAiB+C,EAAE,IAAIV,GAAG,CAACuB,EAA5B,GACLb,EADK,GAELwB,iBAAiB,CAAClC,GAAD,EAAME,OAAN,EAAeC,CAAf,CAFrB;AAIA,YAAIQ,EAAE,GAAGG,GAAG,CAAC,YAAD,CAAZ;AACAd,QAAAA,GAAG,CAACW,EAAJ,GAAUA,EAAE,KAAKhD,MAAP,IAAiBgD,EAAE,IAAIX,GAAG,CAACyB,EAA5B,GACLd,EADK,GAELwB,iBAAiB,CAACnC,GAAD,EAAME,OAAN,EAAeC,CAAf,CAFrB;AAIA,YAAIiC,IAAI,GAAGtB,GAAG,CAAC,MAAD,CAAd;AACAd,QAAAA,GAAG,CAACoC,IAAJ,GAAYA,IAAI,KAAKzE,MAAV,GACPyE,IADO,GAENjC,CAAC,GAAGzC,GAAG,CAAC0E,IAAJ,CAASlC,OAAT,EAAkBC,CAAlB,CAAH,GAA0B,CAACH,GAAG,CAACuB,EAAJ,GAASvB,GAAG,CAACyB,EAAd,IAAoB,CAFpD;AAIA,YAAIY,EAAE,GAAGvB,GAAG,CAAC,IAAD,CAAZ;AACAd,QAAAA,GAAG,CAACqC,EAAJ,GAAUD,IAAI,KAAKzE,MAAT,IAAmB0E,EAAE,IAAI,CAA1B,GACLA,EADK,GAEJlC,CAAC,GAAGzC,GAAG,CAAC4E,KAAJ,CAAUpC,OAAV,EAAmBC,CAAnB,EAAsBH,GAAG,CAACoC,IAA1B,CAAH,GAAsCpC,GAAG,CAACyB,EAAJ,GAASzB,GAAG,CAACuB,EAFzD;AAIAvB,QAAAA,GAAG,CAACuC,EAAJ,GAASC,wBAAwB,CAACxC,GAAD,CAAjC;AACAA,QAAAA,GAAG,CAACyC,EAAJ,GAASC,wBAAwB,CAAC1C,GAAD,CAAjC;AAEA,YAAI2C,EAAE,GAAG7B,GAAG,CAAC,WAAD,CAAZ;AACA6B,QAAAA,EAAE,GAAIA,EAAE,KAAKhF,MAAP,IAAiBgF,EAAE,GAAG,CAAvB,GAA4BA,EAA5B,GAAiCC,gBAAgB,CAAC5C,GAAD,EAAMG,CAAN,CAAtD;AACAH,QAAAA,GAAG,CAAC6C,EAAJ,GAAS7C,GAAG,CAACwB,GAAJ,GAAUmB,EAAnB;AACA3C,QAAAA,GAAG,CAAC8C,EAAJ,GAAS9C,GAAG,CAACwB,GAAJ,GAAUmB,EAAnB;AAEA,YAAII,IAAI,GAAG/C,GAAG,CAACU,EAAf;AACA,YAAIsC,IAAI,GAAGhD,GAAG,CAACW,EAAf;;AACA,YAAG1C,KAAK,CAACsC,SAAN,IAAmBL,OAAO,CAACyB,MAA9B,EAAsC;AAClCoB,UAAAA,IAAI,GAAGE,IAAI,CAACC,GAAL,CAASH,IAAT,EAAe7C,OAAO,CAAC,CAAD,CAAtB,CAAP;AACA8C,UAAAA,IAAI,GAAGC,IAAI,CAACE,GAAL,CAASH,IAAT,EAAe9C,OAAO,CAACC,CAAC,GAAG,CAAL,CAAtB,CAAP;AACH;;AACD,YAAGlC,KAAK,CAACmF,OAAT,EAAkB;AACdL,UAAAA,IAAI,GAAGE,IAAI,CAACC,GAAL,CAASH,IAAT,EAAe/C,GAAG,CAAC6C,EAAnB,CAAP;AACAG,UAAAA,IAAI,GAAGC,IAAI,CAACE,GAAL,CAASH,IAAT,EAAehD,GAAG,CAAC8C,EAAnB,CAAP;AACH;;AACD9C,QAAAA,GAAG,CAACkD,GAAJ,GAAUH,IAAV;AACA/C,QAAAA,GAAG,CAACmD,GAAJ,GAAUH,IAAV;AACH,OA3CD,MA2CO;AACHtF,QAAAA,GAAG,CAAC2F,IAAJ,CAAS,CACL,mDADK,EAEL,UAAUrD,GAAG,CAACuB,EAFT,EAGL,cAAcvB,GAAG,CAACwB,GAHb,EAIL,UAAUxB,GAAG,CAACyB,EAJT,EAKP6B,IALO,CAKF,IALE,CAAT;AAOA,YAAIC,EAAJ;;AACA,YAAGvD,GAAG,CAACwB,GAAJ,KAAY7D,MAAf,EAAuB;AACnB4F,UAAAA,EAAE,GAAGvD,GAAG,CAACwB,GAAT;AACH,SAFD,MAEO,IAAGxB,GAAG,CAACuB,EAAJ,KAAW5D,MAAd,EAAsB;AACzB,cAAGqC,GAAG,CAACyB,EAAJ,KAAW9D,MAAd,EAAsB4F,EAAE,GAAG,CAACvD,GAAG,CAACuB,EAAJ,GAASvB,GAAG,CAACyB,EAAd,IAAoB,CAAzB,CAAtB,KACK8B,EAAE,GAAGvD,GAAG,CAACuB,EAAT;AACR,SAHM,MAGA,IAAGvB,GAAG,CAACyB,EAAJ,KAAW9D,MAAd,EAAsB;AACzB4F,UAAAA,EAAE,GAAGvD,GAAG,CAACyB,EAAT;AACH,SAFM,MAEA;AACH8B,UAAAA,EAAE,GAAG,CAAL;AACH,SAlBE,CAoBH;;;AACAvD,QAAAA,GAAG,CAACwB,GAAJ,GAAU+B,EAAV;AACAvD,QAAAA,GAAG,CAACuB,EAAJ,GAASvB,GAAG,CAACyB,EAAJ,GAAS8B,EAAlB;AACAvD,QAAAA,GAAG,CAACU,EAAJ,GAASV,GAAG,CAACW,EAAJ,GAAS4C,EAAlB;AACAvD,QAAAA,GAAG,CAACoC,IAAJ,GAAWpC,GAAG,CAACqC,EAAJ,GAASkB,EAApB;AACAvD,QAAAA,GAAG,CAAC6C,EAAJ,GAAS7C,GAAG,CAAC8C,EAAJ,GAASS,EAAlB;AACAvD,QAAAA,GAAG,CAACkD,GAAJ,GAAUlD,GAAG,CAACmD,GAAJ,GAAUI,EAApB;AACH;;AAEDvC,MAAAA,MAAM,GAAGiC,IAAI,CAACC,GAAL,CAASlC,MAAT,EAAiBhB,GAAG,CAACkD,GAArB,CAAT;AACAhC,MAAAA,MAAM,GAAG+B,IAAI,CAACE,GAAL,CAASjC,MAAT,EAAiBlB,GAAG,CAACmD,GAArB,CAAT;AAEAnD,MAAAA,GAAG,CAACwD,IAAJ,GAAWvD,GAAG,CAACwD,MAAJ,CAAWnD,UAAX,CAAX;AAEA7B,MAAAA,EAAE,CAACoD,IAAH,CAAQ7B,GAAR;AACH;;AAED/B,IAAAA,KAAK,CAACyF,SAAN,CAAgB5E,OAAO,CAAC6E,GAAxB,IAA+BnG,IAAI,CAACoG,YAAL,CAAkB9E,OAAlB,EAC3B,CAACkC,MAAD,EAASE,MAAT,CAD2B,EAE3B;AAAC2C,MAAAA,MAAM,EAAE;AAAT,KAF2B,CAA/B;AAIH,GAvHD,MAuHO;AACH,QAAIC,QAAQ,GAAGhF,OAAO,CAACiF,YAAR,CAAqB9F,KAArB,EAA4Bc,SAA5B,CAAf;AACA,QAAIiF,OAAO,GAAGC,QAAQ,CAACrE,WAAD,EAAcE,IAAd,CAAtB;AACA,QAAIoE,IAAI,GAAGtE,WAAW,CAAC+B,MAAvB;AACA,QAAIwC,SAAS,GAAGC,eAAe,CAACF,IAAD,CAA/B,CAJG,CAMH;;AACA,SAAItF,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGX,KAAK,CAACkD,OAArB,EAA8BvC,CAAC,EAA/B,EAAmC;AAC/ByB,MAAAA,CAAC,GAAGyD,QAAQ,CAAClF,CAAD,CAAZ;AACA,UAAG,CAACtB,SAAS,CAAC+C,CAAD,CAAb,EAAkB;AAElB,UAAIgE,CAAC,GAAG3G,GAAG,CAAC4G,OAAJ,CAAY9E,QAAQ,CAACZ,CAAD,CAApB,EAAyBoF,OAAzB,CAAR;;AACA,UAAGK,CAAC,IAAI,CAAL,IAAUA,CAAC,GAAGH,IAAjB,EAAuB;AACnB9D,QAAAA,EAAE,GAAG;AAACC,UAAAA,CAAC,EAAEA,CAAJ;AAAOzB,UAAAA,CAAC,EAAEA;AAAV,SAAL;AACAgD,QAAAA,gBAAgB,CAACxB,EAAD,EAAKnC,KAAL,EAAYW,CAAZ,CAAhB;AACAuF,QAAAA,SAAS,CAACE,CAAD,CAAT,CAAaxC,IAAb,CAAkBzB,EAAlB;AACH;AACJ;;AAED,QAAImE,aAAa,GAAGtD,QAApB;AACA,QAAIuD,aAAa,GAAG,CAACvD,QAArB;AAEA,QAAIwD,cAAc,GAAGxG,KAAK,CAACwG,cAA3B;AACA,QAAIC,aAAa,GAAGD,cAAc,KAAK,WAAvC;AACA,QAAIE,aAAa,GAAGF,cAAc,KAAK,WAAvC,CAxBG,CA0BH;;AACA,SAAI7F,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsF,IAAf,EAAqBtF,CAAC,EAAtB,EAA0B;AACtB,UAAGuF,SAAS,CAACvF,CAAD,CAAT,CAAa+C,MAAb,GAAsB,CAAzB,EAA4B;AACxB3B,QAAAA,GAAG,GAAG,EAAN;AACAA,QAAAA,GAAG,CAACqB,GAAJ,GAAUrB,GAAG,CAACf,SAAD,CAAH,GAAiBW,WAAW,CAAChB,CAAD,CAAtC;AAEAqB,QAAAA,GAAG,GAAGD,GAAG,CAACC,GAAJ,GAAUkE,SAAS,CAACvF,CAAD,CAAT,CAAakD,IAAb,CAAkBC,SAAlB,CAAhB;AACA7B,QAAAA,OAAO,GAAGF,GAAG,CAACjB,SAAD,CAAH,GAAiBkB,GAAG,CAAC+B,GAAJ,CAAQC,UAAR,CAA3B;AACA9B,QAAAA,CAAC,GAAGD,OAAO,CAACyB,MAAZ;AAEA3B,QAAAA,GAAG,CAACkD,GAAJ,GAAUhD,OAAO,CAAC,CAAD,CAAjB;AACAF,QAAAA,GAAG,CAACmD,GAAJ,GAAUjD,OAAO,CAACC,CAAC,GAAG,CAAL,CAAjB;AACAH,QAAAA,GAAG,CAACoC,IAAJ,GAAW1E,GAAG,CAAC0E,IAAJ,CAASlC,OAAT,EAAkBC,CAAlB,CAAX;AACAH,QAAAA,GAAG,CAACqC,EAAJ,GAAS3E,GAAG,CAAC4E,KAAJ,CAAUpC,OAAV,EAAmBC,CAAnB,EAAsBH,GAAG,CAACoC,IAA1B,CAAT;AACApC,QAAAA,GAAG,CAACwB,GAAJ,GAAU9D,GAAG,CAACkH,MAAJ,CAAW1E,OAAX,EAAoB,GAApB,CAAV;;AAEA,YAAIC,CAAC,GAAG,CAAL,KAAYuE,aAAa,IAAIC,aAA7B,CAAH,EAAgD;AAC5C,cAAIE,KAAJ;AACA,cAAIC,KAAJ;;AAEA,cAAGJ,aAAH,EAAkB;AACd;AACAG,YAAAA,KAAK,GAAG3E,OAAO,CAAC6E,KAAR,CAAc,CAAd,EAAiB5E,CAAC,GAAG,CAArB,CAAR;AACA2E,YAAAA,KAAK,GAAG5E,OAAO,CAAC6E,KAAR,CAAc5E,CAAC,GAAG,CAAJ,GAAQ,CAAtB,CAAR;AACH,WAJD,MAIO,IAAGwE,aAAH,EAAkB;AACrB;AACAE,YAAAA,KAAK,GAAG3E,OAAO,CAAC6E,KAAR,CAAc,CAAd,EAAiB5E,CAAC,GAAG,CAAJ,GAAQ,CAAzB,CAAR;AACA2E,YAAAA,KAAK,GAAG5E,OAAO,CAAC6E,KAAR,CAAc5E,CAAC,GAAG,CAAlB,CAAR;AACH;;AAEDH,UAAAA,GAAG,CAACuB,EAAJ,GAAS7D,GAAG,CAACkH,MAAJ,CAAWC,KAAX,EAAkB,GAAlB,CAAT;AACA7E,UAAAA,GAAG,CAACyB,EAAJ,GAAS/D,GAAG,CAACkH,MAAJ,CAAWE,KAAX,EAAkB,GAAlB,CAAT;AACH,SAhBD,MAgBO;AACH9E,UAAAA,GAAG,CAACuB,EAAJ,GAAS7D,GAAG,CAACkH,MAAJ,CAAW1E,OAAX,EAAoB,IAApB,CAAT;AACAF,UAAAA,GAAG,CAACyB,EAAJ,GAAS/D,GAAG,CAACkH,MAAJ,CAAW1E,OAAX,EAAoB,IAApB,CAAT;AACH,SAjCuB,CAmCxB;;;AACAF,QAAAA,GAAG,CAACU,EAAJ,GAASwB,iBAAiB,CAAClC,GAAD,EAAME,OAAN,EAAeC,CAAf,CAA1B;AACAH,QAAAA,GAAG,CAACW,EAAJ,GAASwB,iBAAiB,CAACnC,GAAD,EAAME,OAAN,EAAeC,CAAf,CAA1B,CArCwB,CAuCxB;;AACAH,QAAAA,GAAG,CAACuC,EAAJ,GAASC,wBAAwB,CAACxC,GAAD,CAAjC;AACAA,QAAAA,GAAG,CAACyC,EAAJ,GAASC,wBAAwB,CAAC1C,GAAD,CAAjC,CAzCwB,CA2CxB;;AACA,YAAIgF,GAAG,GAAGpC,gBAAgB,CAAC5C,GAAD,EAAMG,CAAN,CAA1B;AACAH,QAAAA,GAAG,CAAC6C,EAAJ,GAAS7C,GAAG,CAACwB,GAAJ,GAAUwD,GAAnB;AACAhF,QAAAA,GAAG,CAAC8C,EAAJ,GAAS9C,GAAG,CAACwB,GAAJ,GAAUwD,GAAnB;AACAT,QAAAA,aAAa,GAAGtB,IAAI,CAACC,GAAL,CAASqB,aAAT,EAAwBvE,GAAG,CAAC6C,EAA5B,CAAhB;AACA2B,QAAAA,aAAa,GAAGvB,IAAI,CAACE,GAAL,CAASqB,aAAT,EAAwBxE,GAAG,CAAC8C,EAA5B,CAAhB;AAEA9C,QAAAA,GAAG,CAACwD,IAAJ,GAAWvD,GAAG,CAACwD,MAAJ,CAAWnD,UAAX,CAAX;AAEA7B,QAAAA,EAAE,CAACoD,IAAH,CAAQ7B,GAAR;AACH;AACJ;;AAED/B,IAAAA,KAAK,CAACyF,SAAN,CAAgB5E,OAAO,CAAC6E,GAAxB,IAA+BnG,IAAI,CAACoG,YAAL,CAAkB9E,OAAlB,EAC3Bb,KAAK,CAACmF,OAAN,GAAgBU,QAAQ,CAACmB,MAAT,CAAgB,CAACV,aAAD,EAAgBC,aAAhB,CAAhB,CAAhB,GAAkEV,QADvC,EAE3B;AAACD,MAAAA,MAAM,EAAE;AAAT,KAF2B,CAA/B;AAIH;;AAEDqB,EAAAA,aAAa,CAACzG,EAAD,EAAKR,KAAL,CAAb;;AAEA,MAAGQ,EAAE,CAACkD,MAAH,GAAY,CAAf,EAAkB;AACdlD,IAAAA,EAAE,CAAC,CAAD,CAAF,CAAM0G,CAAN,GAAU;AACNC,MAAAA,GAAG,EAAElH,UAAU,CAACQ,MAAD,CADT;AAENoB,MAAAA,IAAI,EAAEA,IAFA;AAGNb,MAAAA,SAAS,EAAEA,SAHL;AAINF,MAAAA,SAAS,EAAEA,SAJL;AAKNsG,MAAAA,MAAM,EAAE;AACJ7D,QAAAA,GAAG,EAAE5D,CAAC,CAACI,EAAD,EAAK,SAAL,CADF;AAEJkF,QAAAA,GAAG,EAAEtF,CAAC,CAACI,EAAD,EAAK,MAAL,CAFF;AAGJuD,QAAAA,EAAE,EAAE3D,CAAC,CAACI,EAAD,EAAK,KAAL,CAHD;AAIJyD,QAAAA,EAAE,EAAE7D,CAAC,CAACI,EAAD,EAAK,KAAL,CAJD;AAKJmF,QAAAA,GAAG,EAAEvF,CAAC,CAACI,EAAD,EAAK,MAAL,CALF;AAMJoE,QAAAA,IAAI,EAAEnE,KAAK,CAACqH,OAAN,KAAkB,IAAlB,GAAyB1H,CAAC,CAACI,EAAD,EAAK,WAAL,CAA1B,GAA8CJ,CAAC,CAACI,EAAD,EAAK,OAAL,CANjD;AAOJ0C,QAAAA,EAAE,EAAE9C,CAAC,CAACI,EAAD,EAAK,cAAL,CAPD;AAQJ2C,QAAAA,EAAE,EAAE/C,CAAC,CAACI,EAAD,EAAK,cAAL;AARD;AALF,KAAV;AAiBAE,IAAAA,UAAU,CAACQ,MAAD,CAAV;AACA,WAAOD,EAAP;AACH,GApBD,MAoBO;AACH,WAAO,CAAC;AAAC0G,MAAAA,CAAC,EAAE;AAACI,QAAAA,KAAK,EAAE;AAAR;AAAJ,KAAD,CAAP;AACH;AACJ,CAhSD,C,CAkSA;AACA;AACA;AACA;AACA;;;AACA,SAAShG,YAAT,CAAsBtB,KAAtB,EAA6BgB,SAA7B,EAAwCD,OAAxC,EAAiDoG,GAAjD,EAAsD;AAClD,MAAII,WAAW,IAAGvG,SAAS,IAAIhB,KAAhB,CAAf;AACA,MAAIwH,OAAO,IAAGxG,SAAS,GAAG,GAAZ,IAAmBhB,KAAtB,CAAX;AACA,MAAIyH,UAAU,IAAG,MAAMzG,SAAN,IAAmBhB,KAAtB,CAAd;;AAEA,MAAGuH,WAAW,IAAKC,OAAO,IAAIC,UAA9B,EAA2C;AACvC,QAAIjG,OAAO,GAAGT,OAAO,CAAC+E,YAAR,CAAqB9F,KAArB,EAA4BgB,SAA5B,CAAd;AACA,QAAIoC,GAAG,GAAG5D,WAAW,CAACQ,KAAD,EAAQe,OAAR,EAAiBC,SAAjB,EAA4BQ,OAA5B,CAAX,CAAgDI,IAA1D;AACA,WAAO,CAACwB,GAAD,EAAM5B,OAAN,CAAP;AACH;;AAED,MAAIkG,IAAJ;;AACA,MAAGF,OAAH,EAAY;AACRE,IAAAA,IAAI,GAAG1H,KAAK,CAACgB,SAAS,GAAG,GAAb,CAAZ;AACH,GAFD,MAEO,IAAG,UAAUhB,KAAV,KACNe,OAAO,CAACL,IAAR,KAAiB,UAAjB,IACIrB,SAAS,CAACW,KAAK,CAAC2H,IAAP,CAAT,IACA,CAAC,QAAD,EAAW,KAAX,EAAkBC,OAAlB,CAA0B7G,OAAO,CAACL,IAAlC,MAA4C,CAAC,CAFjD,IAIIjB,GAAG,CAACoI,UAAJ,CAAe7H,KAAK,CAAC2H,IAArB,KACA5G,OAAO,CAACL,IAAR,KAAiB,MANf,CAAH,EAQJ;AACCgH,IAAAA,IAAI,GAAG1H,KAAK,CAAC2H,IAAb;AACH,GAVM,MAUA;AACHD,IAAAA,IAAI,GAAGP,GAAP;AACH;;AAED,MAAIW,KAAK,GAAG/G,OAAO,CAACL,IAAR,KAAiB,eAAjB,GACRK,OAAO,CAACgH,gBAAR,CAAyBL,IAAzB,CADQ,GAER3G,OAAO,CAAC8B,GAAR,CAAY6E,IAAZ,EAAkB,CAAlB,EAAqB1H,KAAK,CAACgB,SAAS,GAAG,UAAb,CAA1B,CAFJ;AAIA,MAAIgH,GAAG,GAAGhI,KAAK,CAACkD,OAAhB;AACA,MAAI+E,GAAG,GAAG,IAAIC,KAAJ,CAAUF,GAAV,CAAV;;AACA,OAAI,IAAIrH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqH,GAAnB,EAAwBrH,CAAC,EAAzB,EAA6BsH,GAAG,CAACtH,CAAD,CAAH,GAASmH,KAAT;;AAE7B,SAAO,CAACG,GAAD,CAAP;AACH;;AAED,SAASjC,QAAT,CAAkBmC,CAAlB,EAAqBC,EAArB,EAAyB;AACrB,MAAIJ,GAAG,GAAGG,CAAC,CAACzE,MAAZ;AACA,MAAI2E,IAAI,GAAG,IAAIH,KAAJ,CAAUF,GAAG,GAAG,CAAhB,CAAX;;AAEA,OAAI,IAAIrH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqH,GAAnB,EAAwBrH,CAAC,EAAzB,EAA6B;AACzB0H,IAAAA,IAAI,CAAC1H,CAAD,CAAJ,GAAUwH,CAAC,CAACxH,CAAD,CAAD,GAAOyH,EAAjB;AACH;;AACDC,EAAAA,IAAI,CAACL,GAAD,CAAJ,GAAYG,CAAC,CAACH,GAAG,GAAG,CAAP,CAAD,GAAaI,EAAzB;AAEA,SAAOC,IAAP;AACH;;AAED,SAASlC,eAAT,CAAyB6B,GAAzB,EAA8B;AAC1B,MAAIM,GAAG,GAAG,IAAIJ,KAAJ,CAAUF,GAAV,CAAV;;AACA,OAAI,IAAIrH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGqH,GAAnB,EAAwBrH,CAAC,EAAzB,EAA6B;AACzB2H,IAAAA,GAAG,CAAC3H,CAAD,CAAH,GAAS,EAAT;AACH;;AACD,SAAO2H,GAAP;AACH;;AAED,IAAIC,aAAa,GAAG;AAChBC,EAAAA,IAAI,EAAE,IADU;AAEhBC,EAAAA,SAAS,EAAE;AAFK,CAApB;;AAKA,SAAS9E,gBAAT,CAA0BxB,EAA1B,EAA8BnC,KAA9B,EAAqC0I,QAArC,EAA+C;AAC3C,OAAI,IAAI5F,CAAR,IAAayF,aAAb,EAA4B;AACxB,QAAG9I,GAAG,CAACgE,mBAAJ,CAAwBzD,KAAK,CAAC8C,CAAD,CAA7B,CAAH,EAAsC;AAClC,UAAGoF,KAAK,CAACS,OAAN,CAAcD,QAAd,CAAH,EAA4B;AACxB,YAAGjJ,GAAG,CAACgE,mBAAJ,CAAwBzD,KAAK,CAAC8C,CAAD,CAAL,CAAS4F,QAAQ,CAAC,CAAD,CAAjB,CAAxB,CAAH,EAAmD;AAC/CvG,UAAAA,EAAE,CAACoG,aAAa,CAACzF,CAAD,CAAd,CAAF,GAAuB9C,KAAK,CAAC8C,CAAD,CAAL,CAAS4F,QAAQ,CAAC,CAAD,CAAjB,EAAsBA,QAAQ,CAAC,CAAD,CAA9B,CAAvB;AACH;AACJ,OAJD,MAIO;AACHvG,QAAAA,EAAE,CAACoG,aAAa,CAACzF,CAAD,CAAd,CAAF,GAAuB9C,KAAK,CAAC8C,CAAD,CAAL,CAAS4F,QAAT,CAAvB;AACH;AACJ;AACJ;AACJ;;AAED,SAASzB,aAAT,CAAuBzG,EAAvB,EAA2BR,KAA3B,EAAkC;AAC9B,MAAGP,GAAG,CAACgE,mBAAJ,CAAwBzD,KAAK,CAAC4I,cAA9B,CAAH,EAAkD;AAC9C,SAAI,IAAIjI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,EAAE,CAACkD,MAAtB,EAA8B/C,CAAC,EAA/B,EAAmC;AAC/B,UAAIqB,GAAG,GAAGxB,EAAE,CAACG,CAAD,CAAF,CAAMqB,GAAN,IAAa,EAAvB;AACA,UAAI6G,gBAAgB,GAAG,EAAvB;;AAEA,WAAI,IAAIjI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoB,GAAG,CAAC0B,MAAvB,EAA+B9C,CAAC,EAAhC,EAAoC;AAChCiI,QAAAA,gBAAgB,CAAC7G,GAAG,CAACpB,CAAD,CAAH,CAAOD,CAAR,CAAhB,GAA6BC,CAA7B;AACH;;AAEDnB,MAAAA,GAAG,CAACqJ,WAAJ,CAAgB9G,GAAhB,EAAqBhC,KAArB,EAA4B6I,gBAA5B;AACH;AACJ;AACJ;;AAED,SAAS/E,SAAT,CAAmBiF,CAAnB,EAAsBC,CAAtB,EAAyB;AAAE,SAAOD,CAAC,CAAC3G,CAAF,GAAM4G,CAAC,CAAC5G,CAAf;AAAmB;;AAE9C,SAAS4B,UAAT,CAAoBiF,CAApB,EAAuB;AAAE,SAAOA,CAAC,CAAC7G,CAAT;AAAa,C,CAEtC;;;AACA,SAAS6B,iBAAT,CAA2BlC,GAA3B,EAAgCE,OAAhC,EAAyCC,CAAzC,EAA4C;AACxC,MAAGA,CAAC,KAAK,CAAT,EAAY,OAAOH,GAAG,CAACuB,EAAX;AACZ,SAAO0B,IAAI,CAACC,GAAL,CACHlD,GAAG,CAACuB,EADD,EAEHrB,OAAO,CAAC+C,IAAI,CAACC,GAAL,CACJxF,GAAG,CAAC4G,OAAJ,CAAY,MAAMtE,GAAG,CAACuB,EAAV,GAAe,MAAMvB,GAAG,CAACyB,EAArC,EAAyCvB,OAAzC,EAAkD,IAAlD,IAA0D,CADtD,EAEJC,CAAC,GAAG,CAFA,CAAD,CAFJ,CAAP;AAOH,C,CAED;;;AACA,SAASgC,iBAAT,CAA2BnC,GAA3B,EAAgCE,OAAhC,EAAyCC,CAAzC,EAA4C;AACxC,MAAGA,CAAC,KAAK,CAAT,EAAY,OAAOH,GAAG,CAACyB,EAAX;AACZ,SAAOwB,IAAI,CAACE,GAAL,CACHnD,GAAG,CAACyB,EADD,EAEHvB,OAAO,CAAC+C,IAAI,CAACE,GAAL,CACJzF,GAAG,CAAC4G,OAAJ,CAAY,MAAMtE,GAAG,CAACyB,EAAV,GAAe,MAAMzB,GAAG,CAACuB,EAArC,EAAyCrB,OAAzC,CADI,EAEJ,CAFI,CAAD,CAFJ,CAAP;AAOH,C,CAED;AACA;;;AACA,SAASsC,wBAAT,CAAkCxC,GAAlC,EAAuC;AACnC,SAAO,IAAIA,GAAG,CAACuB,EAAR,GAAa,IAAIvB,GAAG,CAACyB,EAA5B;AACH,C,CAED;AACA;;;AACA,SAASiB,wBAAT,CAAkC1C,GAAlC,EAAuC;AACnC,SAAO,IAAIA,GAAG,CAACyB,EAAR,GAAa,IAAIzB,GAAG,CAACuB,EAA5B;AACH,C,CAED;;;AACA,SAASqB,gBAAT,CAA0B5C,GAA1B,EAA+BG,CAA/B,EAAkC;AAC9B,MAAGA,CAAC,KAAK,CAAT,EAAY,OAAO,CAAP;AACZ,SAAO,QAAQH,GAAG,CAACyB,EAAJ,GAASzB,GAAG,CAACuB,EAArB,IAA2B0B,IAAI,CAACkE,IAAL,CAAUhH,CAAV,CAAlC;AACH","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Axes = require('../../plots/cartesian/axes');\nvar alignPeriod = require('../../plots/cartesian/align_period');\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar _ = Lib._;\n\nmodule.exports = function calc(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n    var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n    var cd = [];\n\n    // N.B. violin reuses same Box.calc\n    var numKey = trace.type === 'violin' ? '_numViolins' : '_numBoxes';\n\n    var i, j;\n    var valAxis, valLetter;\n    var posAxis, posLetter;\n\n    var hasPeriod;\n    if(trace.orientation === 'h') {\n        valAxis = xa;\n        valLetter = 'x';\n        posAxis = ya;\n        posLetter = 'y';\n        hasPeriod = !!trace.yperiodalignment;\n    } else {\n        valAxis = ya;\n        valLetter = 'y';\n        posAxis = xa;\n        posLetter = 'x';\n        hasPeriod = !!trace.xperiodalignment;\n    }\n\n    var allPosArrays = getPosArrays(trace, posLetter, posAxis, fullLayout[numKey]);\n    var posArray = allPosArrays[0];\n    var origPos = allPosArrays[1];\n    var dv = Lib.distinctVals(posArray, posAxis);\n    var posDistinct = dv.vals;\n    var dPos = dv.minDiff / 2;\n\n    // item in trace calcdata\n    var cdi;\n    // array of {v: v, i, i} sample pts\n    var pts;\n    // values of the `pts` array of objects\n    var boxVals;\n    // length of sample\n    var N;\n    // single sample point\n    var pt;\n    // single sample value\n    var v;\n\n    // filter function for outlier pts\n    // outlier definition based on http://www.physics.csbsju.edu/stats/box2.html\n    var ptFilterFn = (trace.boxpoints || trace.points) === 'all' ?\n        Lib.identity :\n        function(pt) { return (pt.v < cdi.lf || pt.v > cdi.uf); };\n\n    if(trace._hasPreCompStats) {\n        var valArrayRaw = trace[valLetter];\n        var d2c = function(k) { return valAxis.d2c((trace[k] || [])[i]); };\n        var minVal = Infinity;\n        var maxVal = -Infinity;\n\n        for(i = 0; i < trace._length; i++) {\n            var posi = posArray[i];\n            if(!isNumeric(posi)) continue;\n\n            cdi = {};\n            cdi.pos = cdi[posLetter] = posi;\n            if(hasPeriod && origPos) {\n                cdi.orig_p = origPos[i]; // used by hover\n            }\n\n            cdi.q1 = d2c('q1');\n            cdi.med = d2c('median');\n            cdi.q3 = d2c('q3');\n\n            pts = [];\n            if(valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {\n                for(j = 0; j < valArrayRaw[i].length; j++) {\n                    v = valAxis.d2c(valArrayRaw[i][j]);\n                    if(v !== BADNUM) {\n                        pt = {v: v, i: [i, j]};\n                        arraysToCalcdata(pt, trace, [i, j]);\n                        pts.push(pt);\n                    }\n                }\n            }\n            cdi.pts = pts.sort(sortByVal);\n            boxVals = cdi[valLetter] = pts.map(extractVal);\n            N = boxVals.length;\n\n            if(cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM &&\n                cdi.med >= cdi.q1 && cdi.q3 >= cdi.med\n            ) {\n                var lf = d2c('lowerfence');\n                cdi.lf = (lf !== BADNUM && lf <= cdi.q1) ?\n                    lf :\n                    computeLowerFence(cdi, boxVals, N);\n\n                var uf = d2c('upperfence');\n                cdi.uf = (uf !== BADNUM && uf >= cdi.q3) ?\n                    uf :\n                    computeUpperFence(cdi, boxVals, N);\n\n                var mean = d2c('mean');\n                cdi.mean = (mean !== BADNUM) ?\n                    mean :\n                    (N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2);\n\n                var sd = d2c('sd');\n                cdi.sd = (mean !== BADNUM && sd >= 0) ?\n                    sd :\n                    (N ? Lib.stdev(boxVals, N, cdi.mean) : (cdi.q3 - cdi.q1));\n\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                var ns = d2c('notchspan');\n                ns = (ns !== BADNUM && ns > 0) ? ns : computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - ns;\n                cdi.un = cdi.med + ns;\n\n                var imin = cdi.lf;\n                var imax = cdi.uf;\n                if(trace.boxpoints && boxVals.length) {\n                    imin = Math.min(imin, boxVals[0]);\n                    imax = Math.max(imax, boxVals[N - 1]);\n                }\n                if(trace.notched) {\n                    imin = Math.min(imin, cdi.ln);\n                    imax = Math.max(imax, cdi.un);\n                }\n                cdi.min = imin;\n                cdi.max = imax;\n            } else {\n                Lib.warn([\n                    'Invalid input - make sure that q1 <= median <= q3',\n                    'q1 = ' + cdi.q1,\n                    'median = ' + cdi.med,\n                    'q3 = ' + cdi.q3\n                ].join('\\n'));\n\n                var v0;\n                if(cdi.med !== BADNUM) {\n                    v0 = cdi.med;\n                } else if(cdi.q1 !== BADNUM) {\n                    if(cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;\n                    else v0 = cdi.q1;\n                } else if(cdi.q3 !== BADNUM) {\n                    v0 = cdi.q3;\n                } else {\n                    v0 = 0;\n                }\n\n                // draw box as line segment\n                cdi.med = v0;\n                cdi.q1 = cdi.q3 = v0;\n                cdi.lf = cdi.uf = v0;\n                cdi.mean = cdi.sd = v0;\n                cdi.ln = cdi.un = v0;\n                cdi.min = cdi.max = v0;\n            }\n\n            minVal = Math.min(minVal, cdi.min);\n            maxVal = Math.max(maxVal, cdi.max);\n\n            cdi.pts2 = pts.filter(ptFilterFn);\n\n            cd.push(cdi);\n        }\n\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            [minVal, maxVal],\n            {padded: true}\n        );\n    } else {\n        var valArray = valAxis.makeCalcdata(trace, valLetter);\n        var posBins = makeBins(posDistinct, dPos);\n        var pLen = posDistinct.length;\n        var ptsPerBin = initNestedArray(pLen);\n\n        // bin pts info per position bins\n        for(i = 0; i < trace._length; i++) {\n            v = valArray[i];\n            if(!isNumeric(v)) continue;\n\n            var n = Lib.findBin(posArray[i], posBins);\n            if(n >= 0 && n < pLen) {\n                pt = {v: v, i: i};\n                arraysToCalcdata(pt, trace, i);\n                ptsPerBin[n].push(pt);\n            }\n        }\n\n        var minLowerNotch = Infinity;\n        var maxUpperNotch = -Infinity;\n\n        var quartilemethod = trace.quartilemethod;\n        var usesExclusive = quartilemethod === 'exclusive';\n        var usesInclusive = quartilemethod === 'inclusive';\n\n        // build calcdata trace items, one item per distinct position\n        for(i = 0; i < pLen; i++) {\n            if(ptsPerBin[i].length > 0) {\n                cdi = {};\n                cdi.pos = cdi[posLetter] = posDistinct[i];\n\n                pts = cdi.pts = ptsPerBin[i].sort(sortByVal);\n                boxVals = cdi[valLetter] = pts.map(extractVal);\n                N = boxVals.length;\n\n                cdi.min = boxVals[0];\n                cdi.max = boxVals[N - 1];\n                cdi.mean = Lib.mean(boxVals, N);\n                cdi.sd = Lib.stdev(boxVals, N, cdi.mean);\n                cdi.med = Lib.interp(boxVals, 0.5);\n\n                if((N % 2) && (usesExclusive || usesInclusive)) {\n                    var lower;\n                    var upper;\n\n                    if(usesExclusive) {\n                        // do NOT include the median in either half\n                        lower = boxVals.slice(0, N / 2);\n                        upper = boxVals.slice(N / 2 + 1);\n                    } else if(usesInclusive) {\n                        // include the median in either half\n                        lower = boxVals.slice(0, N / 2 + 1);\n                        upper = boxVals.slice(N / 2);\n                    }\n\n                    cdi.q1 = Lib.interp(lower, 0.5);\n                    cdi.q3 = Lib.interp(upper, 0.5);\n                } else {\n                    cdi.q1 = Lib.interp(boxVals, 0.25);\n                    cdi.q3 = Lib.interp(boxVals, 0.75);\n                }\n\n                // lower and upper fences\n                cdi.lf = computeLowerFence(cdi, boxVals, N);\n                cdi.uf = computeUpperFence(cdi, boxVals, N);\n\n                // lower and upper outliers bounds\n                cdi.lo = computeLowerOutlierBound(cdi);\n                cdi.uo = computeUpperOutlierBound(cdi);\n\n                // lower and upper notches\n                var mci = computeNotchSpan(cdi, N);\n                cdi.ln = cdi.med - mci;\n                cdi.un = cdi.med + mci;\n                minLowerNotch = Math.min(minLowerNotch, cdi.ln);\n                maxUpperNotch = Math.max(maxUpperNotch, cdi.un);\n\n                cdi.pts2 = pts.filter(ptFilterFn);\n\n                cd.push(cdi);\n            }\n        }\n\n        trace._extremes[valAxis._id] = Axes.findExtremes(valAxis,\n            trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray,\n            {padded: true}\n        );\n    }\n\n    calcSelection(cd, trace);\n\n    if(cd.length > 0) {\n        cd[0].t = {\n            num: fullLayout[numKey],\n            dPos: dPos,\n            posLetter: posLetter,\n            valLetter: valLetter,\n            labels: {\n                med: _(gd, 'median:'),\n                min: _(gd, 'min:'),\n                q1: _(gd, 'q1:'),\n                q3: _(gd, 'q3:'),\n                max: _(gd, 'max:'),\n                mean: trace.boxmean === 'sd' ? _(gd, 'mean ± σ:') : _(gd, 'mean:'),\n                lf: _(gd, 'lower fence:'),\n                uf: _(gd, 'upper fence:')\n            }\n        };\n\n        fullLayout[numKey]++;\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n};\n\n// In vertical (horizontal) box plots:\n// if no x (y) data, use x0 (y0), or name\n// so if you want one box\n// per trace, set x0 (y0) to the x (y) value or category for this trace\n// (or set x (y) to a constant array matching y (x))\nfunction getPosArrays(trace, posLetter, posAxis, num) {\n    var hasPosArray = posLetter in trace;\n    var hasPos0 = posLetter + '0' in trace;\n    var hasPosStep = 'd' + posLetter in trace;\n\n    if(hasPosArray || (hasPos0 && hasPosStep)) {\n        var origPos = posAxis.makeCalcdata(trace, posLetter);\n        var pos = alignPeriod(trace, posAxis, posLetter, origPos).vals;\n        return [pos, origPos];\n    }\n\n    var pos0;\n    if(hasPos0) {\n        pos0 = trace[posLetter + '0'];\n    } else if('name' in trace && (\n        posAxis.type === 'category' || (\n            isNumeric(trace.name) &&\n            ['linear', 'log'].indexOf(posAxis.type) !== -1\n        ) || (\n            Lib.isDateTime(trace.name) &&\n            posAxis.type === 'date'\n        )\n    )) {\n        pos0 = trace.name;\n    } else {\n        pos0 = num;\n    }\n\n    var pos0c = posAxis.type === 'multicategory' ?\n        posAxis.r2c_just_indices(pos0) :\n        posAxis.d2c(pos0, 0, trace[posLetter + 'calendar']);\n\n    var len = trace._length;\n    var out = new Array(len);\n    for(var i = 0; i < len; i++) out[i] = pos0c;\n\n    return [out];\n}\n\nfunction makeBins(x, dx) {\n    var len = x.length;\n    var bins = new Array(len + 1);\n\n    for(var i = 0; i < len; i++) {\n        bins[i] = x[i] - dx;\n    }\n    bins[len] = x[len - 1] + dx;\n\n    return bins;\n}\n\nfunction initNestedArray(len) {\n    var arr = new Array(len);\n    for(var i = 0; i < len; i++) {\n        arr[i] = [];\n    }\n    return arr;\n}\n\nvar TRACE_TO_CALC = {\n    text: 'tx',\n    hovertext: 'htx'\n};\n\nfunction arraysToCalcdata(pt, trace, ptNumber) {\n    for(var k in TRACE_TO_CALC) {\n        if(Lib.isArrayOrTypedArray(trace[k])) {\n            if(Array.isArray(ptNumber)) {\n                if(Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {\n                    pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];\n                }\n            } else {\n                pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];\n            }\n        }\n    }\n}\n\nfunction calcSelection(cd, trace) {\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        for(var i = 0; i < cd.length; i++) {\n            var pts = cd[i].pts || [];\n            var ptNumber2cdIndex = {};\n\n            for(var j = 0; j < pts.length; j++) {\n                ptNumber2cdIndex[pts[j].i] = j;\n            }\n\n            Lib.tagSelected(pts, trace, ptNumber2cdIndex);\n        }\n    }\n}\n\nfunction sortByVal(a, b) { return a.v - b.v; }\n\nfunction extractVal(o) { return o.v; }\n\n// last point below 1.5 * IQR\nfunction computeLowerFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q1;\n    return Math.min(\n        cdi.q1,\n        boxVals[Math.min(\n            Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1,\n            N - 1\n        )]\n    );\n}\n\n// last point above 1.5 * IQR\nfunction computeUpperFence(cdi, boxVals, N) {\n    if(N === 0) return cdi.q3;\n    return Math.max(\n        cdi.q3,\n        boxVals[Math.max(\n            Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals),\n            0\n        )]\n    );\n}\n\n// 3 IQR below (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeLowerOutlierBound(cdi) {\n    return 4 * cdi.q1 - 3 * cdi.q3;\n}\n\n// 3 IQR above (don't clip to max/min,\n// this is only for discriminating suspected & far outliers)\nfunction computeUpperOutlierBound(cdi) {\n    return 4 * cdi.q3 - 3 * cdi.q1;\n}\n\n// 95% confidence intervals for median\nfunction computeNotchSpan(cdi, N) {\n    if(N === 0) return 0;\n    return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);\n}\n"]},"metadata":{},"sourceType":"script"}