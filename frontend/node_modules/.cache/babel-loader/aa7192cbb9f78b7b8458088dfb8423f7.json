{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar Fx = require('../fx');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar dragElement = require('../dragelement');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head'); // Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  drawRaw: drawRaw\n};\n/*\n * draw: draw all annotations without any new modifications\n */\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  fullLayout._infolayer.selectAll('.annotation').remove();\n\n  for (var i = 0; i < fullLayout.annotations.length; i++) {\n    if (fullLayout.annotations[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n\n  return Plots.previousPromises(gd);\n}\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\n\n\nfunction drawOne(gd, index) {\n  var fullLayout = gd._fullLayout;\n  var options = fullLayout.annotations[index] || {};\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  if (xa) xa.setScale();\n  if (ya) ya.setScale();\n  drawRaw(gd, options, index, false, xa, ya);\n} // Convert pixels to the coordinates relevant for the axis referred to. For\n// example, for paper it would convert to a value normalized by the dimension of\n// the plot.\n// axDomainRef: if true and axa defined, draws relative to axis domain,\n// otherwise draws relative to data (if axa defined) or paper (if not).\n\n\nfunction shiftPosition(axa, dAx, axLetter, gs, options) {\n  var optAx = options[axLetter];\n  var axRef = options[axLetter + 'ref'];\n  var vertical = axLetter.indexOf('y') !== -1;\n  var axDomainRef = Axes.getRefType(axRef) === 'domain';\n  var gsDim = vertical ? gs.h : gs.w;\n\n  if (axa) {\n    if (axDomainRef) {\n      // here optAx normalized to length of axis (e.g., normally in range\n      // 0 to 1). But dAx is in pixels. So we normalize dAx to length of\n      // axis before doing the math.\n      return optAx + (vertical ? -dAx : dAx) / axa._length;\n    } else {\n      return axa.p2r(axa.r2p(optAx) + dAx);\n    }\n  } else {\n    return optAx + (vertical ? -dAx : dAx) / gsDim;\n  }\n}\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\n\n\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n  var fullLayout = gd._fullLayout;\n  var gs = gd._fullLayout._size;\n  var edits = gd._context.edits;\n  var className, containerStr;\n\n  if (subplotId) {\n    className = 'annotation-' + subplotId;\n    containerStr = subplotId + '.annotations';\n  } else {\n    className = 'annotation';\n    containerStr = 'annotations';\n  }\n\n  var editHelpers = arrayEditor(gd.layout, containerStr, options);\n  var modifyBase = editHelpers.modifyBase;\n  var modifyItem = editHelpers.modifyItem;\n  var getUpdateObj = editHelpers.getUpdateObj; // remove the existing annotation if there is one\n\n  fullLayout._infolayer.selectAll('.' + className + '[data-index=\"' + index + '\"]').remove();\n\n  var annClipID = 'clip' + fullLayout._uid + '_ann' + index; // this annotation is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input || options.visible === false) {\n    d3.selectAll('#' + annClipID).remove();\n    return;\n  } // calculated pixel positions\n  // x & y each will get text, head, and tail as appropriate\n\n\n  var annPosPx = {\n    x: {},\n    y: {}\n  };\n  var textangle = +options.textangle || 0; // create the components\n  // made a single group to contain all, so opacity can work right\n  // with border/arrow together this could handle a whole bunch of\n  // cleanup at this point, but works for now\n\n  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity); // another group for text+background so that they can rotate together\n\n\n  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);\n  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n  var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n  function makeEventData(initialEvent) {\n    var eventData = {\n      index: index,\n      annotation: options._input,\n      fullAnnotation: options,\n      event: initialEvent\n    };\n\n    if (subplotId) {\n      eventData.subplotId = subplotId;\n    }\n\n    return eventData;\n  }\n\n  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {\n    gd._dragging = false;\n    gd.emit('plotly_clickannotation', makeEventData(d3.event));\n  });\n\n  if (options.hovertext) {\n    annTextGroupInner.on('mouseover', function () {\n      var hoverOptions = options.hoverlabel;\n      var hoverFont = hoverOptions.font;\n      var bBox = this.getBoundingClientRect();\n      var bBoxRef = gd.getBoundingClientRect();\n      Fx.loneHover({\n        x0: bBox.left - bBoxRef.left,\n        x1: bBox.right - bBoxRef.left,\n        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n        text: options.hovertext,\n        color: hoverOptions.bgcolor,\n        borderColor: hoverOptions.bordercolor,\n        fontFamily: hoverFont.family,\n        fontSize: hoverFont.size,\n        fontColor: hoverFont.color\n      }, {\n        container: fullLayout._hoverlayer.node(),\n        outerContainer: fullLayout._paper.node(),\n        gd: gd\n      });\n    }).on('mouseout', function () {\n      Fx.loneUnhover(fullLayout._hoverlayer.node());\n    });\n  }\n\n  var borderwidth = options.borderwidth;\n  var borderpad = options.borderpad;\n  var borderfull = borderwidth + borderpad;\n  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);\n  var isSizeConstrained = options.width || options.height;\n\n  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);\n\n  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');\n  annTextClip.exit().remove();\n  var font = options.font;\n  var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;\n  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);\n\n  function textLayout(s) {\n    s.call(Drawing.font, font).attr({\n      'text-anchor': {\n        left: 'start',\n        right: 'end'\n      }[options.align] || 'middle'\n    });\n    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n    return s;\n  }\n\n  function drawGraphicalElements() {\n    // if the text has *only* a link, make the whole box into a link\n    var anchor3 = annText.selectAll('a');\n\n    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {\n      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n        'xlink:xlink:href': anchor3.attr('xlink:href'),\n        'xlink:xlink:show': anchor3.attr('xlink:show')\n      }).style({\n        cursor: 'pointer'\n      });\n      wholeLink.node().appendChild(annTextBG.node());\n    }\n\n    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n    var hasMathjax = !mathjaxGroup.empty();\n    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());\n    var textWidth = anntextBB.width;\n    var textHeight = anntextBB.height;\n    var annWidth = options.width || textWidth;\n    var annHeight = options.height || textHeight;\n    var outerWidth = Math.round(annWidth + 2 * borderfull);\n    var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n    function shiftFraction(v, anchor) {\n      if (anchor === 'auto') {\n        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';\n      }\n\n      return {\n        center: 0,\n        middle: 0,\n        left: 0.5,\n        bottom: -0.5,\n        right: -0.5,\n        top: 0.5\n      }[anchor];\n    }\n\n    var annotationIsOffscreen = false;\n    var letters = ['x', 'y'];\n\n    for (var i = 0; i < letters.length; i++) {\n      var axLetter = letters[i];\n      var axRef = options[axLetter + 'ref'] || axLetter;\n      var tailRef = options['a' + axLetter + 'ref'];\n      var ax = {\n        x: xa,\n        y: ya\n      }[axLetter];\n      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180; // note that these two can be either positive or negative\n\n      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n      var annSizeFromHeight = outerHeight * Math.sin(dimAngle); // but this one is the positive total size\n\n      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n      var anchor = options[axLetter + 'anchor'];\n      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n      var posPx = annPosPx[axLetter];\n      var basePx;\n      var textPadShift;\n      var alignPosition;\n      var autoAlignFraction;\n      var textShift;\n      var axRefType = Axes.getRefType(axRef);\n      /*\n       * calculate the *primary* pixel position\n       * which is the arrowhead if there is one,\n       * otherwise the text anchor point\n       */\n\n      if (ax && axRefType !== 'domain') {\n        // check if annotation is off screen, to bypass DOM manipulations\n        var posFraction = ax.r2fraction(options[axLetter]);\n\n        if (posFraction < 0 || posFraction > 1) {\n          if (tailRef === axRef) {\n            posFraction = ax.r2fraction(options['a' + axLetter]);\n\n            if (posFraction < 0 || posFraction > 1) {\n              annotationIsOffscreen = true;\n            }\n          } else {\n            annotationIsOffscreen = true;\n          }\n        }\n\n        basePx = ax._offset + ax.r2p(options[axLetter]);\n        autoAlignFraction = 0.5;\n      } else {\n        var axRefTypeEqDomain = axRefType === 'domain';\n\n        if (axLetter === 'x') {\n          alignPosition = options[axLetter];\n          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;\n        } else {\n          alignPosition = 1 - options[axLetter];\n          basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;\n        }\n\n        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n      } // now translate this into pixel positions of head, tail, and text\n      // as well as paddings for autorange\n\n\n      if (options.showarrow) {\n        posPx.head = basePx;\n        var arrowLength = options['a' + axLetter]; // with an arrow, the text rotates around the anchor point\n\n        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n        if (tailRef === axRef) {\n          // In the case tailRefType is 'domain' or 'paper', the arrow's\n          // position is set absolutely, which is consistent with how\n          // it behaves when its position is set in data ('range')\n          // coordinates.\n          var tailRefType = Axes.getRefType(tailRef);\n\n          if (tailRefType === 'domain') {\n            if (axLetter === 'y') {\n              arrowLength = 1 - arrowLength;\n            }\n\n            posPx.tail = ax._offset + ax._length * arrowLength;\n          } else if (tailRefType === 'paper') {\n            if (axLetter === 'y') {\n              arrowLength = 1 - arrowLength;\n              posPx.tail = gs.t + gs.h * arrowLength;\n            } else {\n              posPx.tail = gs.l + gs.w * arrowLength;\n            }\n          } else {\n            // assumed tailRef is range or paper referenced\n            posPx.tail = ax._offset + ax.r2p(arrowLength);\n          } // tail is range- or domain-referenced: autorange pads the\n          // text in px from the tail\n\n\n          textPadShift = textShift;\n        } else {\n          posPx.tail = basePx + arrowLength; // tail is specified in px from head, so autorange also pads vs head\n\n          textPadShift = textShift + arrowLength;\n        }\n\n        posPx.text = posPx.tail + textShift; // constrain pixel/paper referenced so the draggers are at least\n        // partially visible\n\n        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];\n\n        if (axRef === 'paper') {\n          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n        }\n\n        if (tailRef === 'pixel') {\n          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n\n          if (shiftPlus > 0) {\n            posPx.tail += shiftPlus;\n            posPx.text += shiftPlus;\n          } else if (shiftMinus > 0) {\n            posPx.tail -= shiftMinus;\n            posPx.text -= shiftMinus;\n          }\n        }\n\n        posPx.tail += overallShift;\n        posPx.head += overallShift;\n      } else {\n        // with no arrow, the text rotates and *then* we put the anchor\n        // relative to the new bounding box\n        textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n        textPadShift = textShift;\n        posPx.text = basePx + textShift;\n      }\n\n      posPx.text += overallShift;\n      textShift += overallShift;\n      textPadShift += overallShift; // padplus/minus are used by autorange\n\n      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;\n      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift; // size/shift are used during dragging\n\n      options['_' + axLetter + 'size'] = annSize;\n      options['_' + axLetter + 'shift'] = textShift;\n    }\n\n    if (annotationIsOffscreen) {\n      annTextGroupInner.remove();\n      return;\n    }\n\n    var xShift = 0;\n    var yShift = 0;\n\n    if (options.align !== 'left') {\n      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n    }\n\n    if (options.valign !== 'top') {\n      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n    }\n\n    if (hasMathjax) {\n      mathjaxGroup.select('svg').attr({\n        x: borderfull + xShift - 1,\n        y: borderfull + yShift\n      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    } else {\n      var texty = borderfull + yShift - anntextBB.top;\n      var textx = borderfull + xShift - anntextBB.left;\n      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    }\n\n    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);\n    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);\n    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));\n    /*\n     * rotate text and background\n     * we already calculated the text center position *as rotated*\n     * because we needed that for autoranging anyway, so now whether\n     * we have an arrow or not, we rotate about the text center.\n     */\n\n    annTextGroup.attr({\n      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'\n    });\n    /*\n     * add the arrow\n     * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n     * dx and dy are normally zero, but when you are dragging the textbox\n     * while the head stays put, dx and dy are the pixel offsets\n     */\n\n    var drawArrow = function (dx, dy) {\n      annGroup.selectAll('.annotation-arrow-g').remove();\n      var headX = annPosPx.x.head;\n      var headY = annPosPx.y.head;\n      var tailX = annPosPx.x.tail + dx;\n      var tailY = annPosPx.y.tail + dy;\n      var textX = annPosPx.x.text + dx;\n      var textY = annPosPx.y.text + dy; // find the edge of the text box, where we'll start the arrow:\n      // create transform matrix to rotate the text box corners\n\n      var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n      var applyTransform = Lib.apply2DTransform(transform);\n      var applyTransform2 = Lib.apply2DTransform2(transform); // calculate and transform bounding box\n\n      var width = +annTextBG.attr('width');\n      var height = +annTextBG.attr('height');\n      var xLeft = textX - 0.5 * width;\n      var xRight = xLeft + width;\n      var yTop = textY - 0.5 * height;\n      var yBottom = yTop + height;\n      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2); // Remove the line if it ends inside the box.  Use ray\n      // casting for rotated boxes: see which edges intersect a\n      // line from the arrowhead to far away and reduce with xor\n      // to get the parity of the number of intersections.\n\n      if (edges.reduce(function (a, x) {\n        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);\n      }, false)) {\n        // no line or arrow - so quit drawArrow now\n        return;\n      }\n\n      edges.forEach(function (x) {\n        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);\n\n        if (p) {\n          tailX = p.x;\n          tailY = p.y;\n        }\n      });\n      var strokewidth = options.arrowwidth;\n      var arrowColor = options.arrowcolor;\n      var arrowSide = options.arrowside;\n      var arrowGroup = annGroup.append('g').style({\n        opacity: Color.opacity(arrowColor)\n      }).classed('annotation-arrow-g', true);\n      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));\n      drawArrowHead(arrow, arrowSide, options); // the arrow dragger is a small square right at the head, then a line to the tail,\n      // all expanded by a stroke width of 6px plus the arrow line width\n\n      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n        var arrowDragHeadX = headX;\n        var arrowDragHeadY = headY;\n\n        if (options.standoff) {\n          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n        }\n\n        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({\n          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n          transform: strTranslate(arrowDragHeadX, arrowDragHeadY)\n        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');\n        var annx0, anny0; // dragger for the arrow & head: translates the whole thing\n        // (head/tail/text) all together\n\n        dragElement.init({\n          element: arrowDrag.node(),\n          gd: gd,\n          prepFn: function () {\n            var pos = Drawing.getTranslate(annTextGroupInner);\n            annx0 = pos.x;\n            anny0 = pos.y;\n\n            if (xa && xa.autorange) {\n              modifyBase(xa._name + '.autorange', true);\n            }\n\n            if (ya && ya.autorange) {\n              modifyBase(ya._name + '.autorange', true);\n            }\n          },\n          moveFn: function (dx, dy) {\n            var annxy0 = applyTransform(annx0, anny0);\n            var xcenter = annxy0[0] + dx;\n            var ycenter = annxy0[1] + dy;\n            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n            modifyItem('x', shiftPosition(xa, dx, 'x', gs, options));\n            modifyItem('y', shiftPosition(ya, dy, 'y', gs, options)); // for these 2 calls to shiftPosition, it is assumed xa, ya are\n            // defined, so gsDim will not be used, but we put it in\n            // anyways for consistency\n\n            if (options.axref === options.xref) {\n              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs, options));\n            }\n\n            arrowGroup.attr('transform', strTranslate(dx, dy));\n            annTextGroup.attr({\n              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'\n            });\n          },\n          doneFn: function () {\n            Registry.call('_guiRelayout', gd, getUpdateObj());\n            var notesBox = document.querySelector('.js-notes-box-panel');\n            if (notesBox) notesBox.redraw(notesBox.selectedObj);\n          }\n        });\n      }\n    };\n\n    if (options.showarrow) drawArrow(0, 0); // user dragging the annotation (text, not arrow)\n\n    if (editTextPosition) {\n      var baseTextTransform; // dragger for the textbox: if there's an arrow, just drag the\n      // textbox and tail, leave the head untouched\n\n      dragElement.init({\n        element: annTextGroupInner.node(),\n        gd: gd,\n        prepFn: function () {\n          baseTextTransform = annTextGroup.attr('transform');\n        },\n        moveFn: function (dx, dy) {\n          var csr = 'pointer';\n\n          if (options.showarrow) {\n            // for these 2 calls to shiftPosition, it is assumed xa, ya are\n            // defined, so gsDim will not be used, but we put it in\n            // anyways for consistency\n            if (options.axref === options.xref) {\n              modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n            } else {\n              modifyItem('ax', options.ax + dx);\n            }\n\n            if (options.ayref === options.yref) {\n              modifyItem('ay', shiftPosition(ya, dy, 'ay', gs.w, options));\n            } else {\n              modifyItem('ay', options.ay + dy);\n            }\n\n            drawArrow(dx, dy);\n          } else if (!subplotId) {\n            var xUpdate, yUpdate;\n\n            if (xa) {\n              // shiftPosition will not execute code where xa was\n              // undefined, so we use to calculate xUpdate too\n              xUpdate = shiftPosition(xa, dx, 'x', gs, options);\n            } else {\n              var widthFraction = options._xsize / gs.w;\n              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);\n            }\n\n            if (ya) {\n              // shiftPosition will not execute code where ya was\n              // undefined, so we use to calculate yUpdate too\n              yUpdate = shiftPosition(ya, dy, 'y', gs, options);\n            } else {\n              var heightFraction = options._ysize / gs.h;\n              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);\n            }\n\n            modifyItem('x', xUpdate);\n            modifyItem('y', yUpdate);\n\n            if (!xa || !ya) {\n              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);\n            }\n          } else return;\n\n          annTextGroup.attr({\n            transform: strTranslate(dx, dy) + baseTextTransform\n          });\n          setCursor(annTextGroupInner, csr);\n        },\n        clickFn: function (_, initialEvent) {\n          if (options.captureevents) {\n            gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n          }\n        },\n        doneFn: function () {\n          setCursor(annTextGroupInner);\n          Registry.call('_guiRelayout', gd, getUpdateObj());\n          var notesBox = document.querySelector('.js-notes-box-panel');\n          if (notesBox) notesBox.redraw(notesBox.selectedObj);\n        }\n      });\n    }\n  }\n\n  if (edits.annotationText) {\n    annText.call(svgTextUtils.makeEditable, {\n      delegate: annTextGroupInner,\n      gd: gd\n    }).call(textLayout).on('edit', function (_text) {\n      options.text = _text;\n      this.call(textLayout);\n      modifyItem('text', _text);\n\n      if (xa && xa.autorange) {\n        modifyBase(xa._name + '.autorange', true);\n      }\n\n      if (ya && ya.autorange) {\n        modifyBase(ya._name + '.autorange', true);\n      }\n\n      Registry.call('_guiRelayout', gd, getUpdateObj());\n    });\n  } else annText.call(textLayout);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/components/annotations/draw.js"],"names":["d3","require","Registry","Plots","Lib","strTranslate","Axes","Color","Drawing","Fx","svgTextUtils","setCursor","dragElement","arrayEditor","drawArrowHead","module","exports","draw","drawOne","drawRaw","gd","fullLayout","_fullLayout","_infolayer","selectAll","remove","i","annotations","length","visible","previousPromises","index","options","xa","getFromId","xref","ya","yref","setScale","shiftPosition","axa","dAx","axLetter","gs","optAx","axRef","vertical","indexOf","axDomainRef","getRefType","gsDim","h","w","_length","p2r","r2p","subplotId","_size","edits","_context","className","containerStr","editHelpers","layout","modifyBase","modifyItem","getUpdateObj","annClipID","_uid","_input","annPosPx","x","y","textangle","annGroup","append","classed","attr","String","style","opacity","annTextGroup","editTextPosition","showarrow","textEvents","captureevents","annotationText","makeEventData","initialEvent","eventData","annotation","fullAnnotation","event","annTextGroupInner","call","on","_dragging","emit","hovertext","hoverOptions","hoverlabel","hoverFont","font","bBox","getBoundingClientRect","bBoxRef","loneHover","x0","left","x1","right","top","bottom","text","color","bgcolor","borderColor","bordercolor","fontFamily","family","fontSize","size","fontColor","container","_hoverlayer","node","outerContainer","_paper","loneUnhover","borderwidth","borderpad","borderfull","annTextBG","stroke","fill","isSizeConstrained","width","height","annTextClip","_topclips","data","enter","exit","_meta","templateString","annText","textLayout","s","align","convertToTspans","drawGraphicalElements","anchor3","wholeLink","insert","cursor","appendChild","mathjaxGroup","select","hasMathjax","empty","anntextBB","textWidth","textHeight","annWidth","annHeight","outerWidth","Math","round","outerHeight","shiftFraction","v","anchor","center","middle","annotationIsOffscreen","letters","tailRef","ax","dimAngle","PI","annSizeFromWidth","cos","annSizeFromHeight","sin","annSize","abs","overallShift","posPx","basePx","textPadShift","alignPosition","autoAlignFraction","textShift","axRefType","posFraction","r2fraction","_offset","axRefTypeEqDomain","l","t","head","arrowLength","xanchor","yanchor","tailRefType","tail","maxPx","constrain","shiftPlus","max","shiftMinus","min","xShift","yShift","valign","setClipUrl","texty","textx","positionText","setRect","setTranslate","transform","drawArrow","dx","dy","headX","headY","tailX","tailY","textX","textY","rotationXYMatrix","applyTransform","apply2DTransform","applyTransform2","apply2DTransform2","xLeft","xRight","yTop","yBottom","edges","map","reduce","a","segmentsIntersect","forEach","p","strokewidth","arrowwidth","arrowColor","arrowcolor","arrowSide","arrowside","arrowGroup","arrow","rgb","annotationPosition","parentNode","arrowDragHeadX","arrowDragHeadY","standoff","sqrt","pow","arrowDrag","d","annx0","anny0","init","element","prepFn","pos","getTranslate","autorange","_name","moveFn","annxy0","xcenter","ycenter","axref","ayref","doneFn","notesBox","document","querySelector","redraw","selectedObj","baseTextTransform","csr","ay","xUpdate","yUpdate","widthFraction","_xsize","_xshift","xshift","heightFraction","_ysize","_yshift","yshift","getCursor","clickFn","_","makeEditable","delegate","_text"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._infolayer.selectAll('.annotation').remove();\n\n    for(var i = 0; i < fullLayout.annotations.length; i++) {\n        if(fullLayout.annotations[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n    var fullLayout = gd._fullLayout;\n    var options = fullLayout.annotations[index] || {};\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n\n    if(xa) xa.setScale();\n    if(ya) ya.setScale();\n\n    drawRaw(gd, options, index, false, xa, ya);\n}\n\n// Convert pixels to the coordinates relevant for the axis referred to. For\n// example, for paper it would convert to a value normalized by the dimension of\n// the plot.\n// axDomainRef: if true and axa defined, draws relative to axis domain,\n// otherwise draws relative to data (if axa defined) or paper (if not).\nfunction shiftPosition(axa, dAx, axLetter, gs, options) {\n    var optAx = options[axLetter];\n    var axRef = options[axLetter + 'ref'];\n    var vertical = axLetter.indexOf('y') !== -1;\n    var axDomainRef = Axes.getRefType(axRef) === 'domain';\n    var gsDim = vertical ? gs.h : gs.w;\n    if(axa) {\n        if(axDomainRef) {\n            // here optAx normalized to length of axis (e.g., normally in range\n            // 0 to 1). But dAx is in pixels. So we normalize dAx to length of\n            // axis before doing the math.\n            return optAx + (vertical ? -dAx : dAx) / axa._length;\n        } else {\n            return axa.p2r(axa.r2p(optAx) + dAx);\n        }\n    } else {\n        return optAx + (vertical ? -dAx : dAx) / gsDim;\n    }\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n    var fullLayout = gd._fullLayout;\n    var gs = gd._fullLayout._size;\n    var edits = gd._context.edits;\n\n    var className, containerStr;\n\n    if(subplotId) {\n        className = 'annotation-' + subplotId;\n        containerStr = subplotId + '.annotations';\n    } else {\n        className = 'annotation';\n        containerStr = 'annotations';\n    }\n\n    var editHelpers = arrayEditor(gd.layout, containerStr, options);\n    var modifyBase = editHelpers.modifyBase;\n    var modifyItem = editHelpers.modifyItem;\n    var getUpdateObj = editHelpers.getUpdateObj;\n\n    // remove the existing annotation if there is one\n    fullLayout._infolayer\n        .selectAll('.' + className + '[data-index=\"' + index + '\"]')\n        .remove();\n\n    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n    // this annotation is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) {\n        d3.selectAll('#' + annClipID).remove();\n        return;\n    }\n\n    // calculated pixel positions\n    // x & y each will get text, head, and tail as appropriate\n    var annPosPx = {x: {}, y: {}};\n    var textangle = +options.textangle || 0;\n\n    // create the components\n    // made a single group to contain all, so opacity can work right\n    // with border/arrow together this could handle a whole bunch of\n    // cleanup at this point, but works for now\n    var annGroup = fullLayout._infolayer.append('g')\n        .classed(className, true)\n        .attr('data-index', String(index))\n        .style('opacity', options.opacity);\n\n    // another group for text+background so that they can rotate together\n    var annTextGroup = annGroup.append('g')\n        .classed('annotation-text-g', true);\n\n    var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n    var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n    function makeEventData(initialEvent) {\n        var eventData = {\n            index: index,\n            annotation: options._input,\n            fullAnnotation: options,\n            event: initialEvent\n        };\n        if(subplotId) {\n            eventData.subplotId = subplotId;\n        }\n        return eventData;\n    }\n\n    var annTextGroupInner = annTextGroup.append('g')\n        .style('pointer-events', textEvents ? 'all' : null)\n        .call(setCursor, 'pointer')\n        .on('click', function() {\n            gd._dragging = false;\n            gd.emit('plotly_clickannotation', makeEventData(d3.event));\n        });\n\n    if(options.hovertext) {\n        annTextGroupInner\n        .on('mouseover', function() {\n            var hoverOptions = options.hoverlabel;\n            var hoverFont = hoverOptions.font;\n            var bBox = this.getBoundingClientRect();\n            var bBoxRef = gd.getBoundingClientRect();\n\n            Fx.loneHover({\n                x0: bBox.left - bBoxRef.left,\n                x1: bBox.right - bBoxRef.left,\n                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n                text: options.hovertext,\n                color: hoverOptions.bgcolor,\n                borderColor: hoverOptions.bordercolor,\n                fontFamily: hoverFont.family,\n                fontSize: hoverFont.size,\n                fontColor: hoverFont.color\n            }, {\n                container: fullLayout._hoverlayer.node(),\n                outerContainer: fullLayout._paper.node(),\n                gd: gd\n            });\n        })\n        .on('mouseout', function() {\n            Fx.loneUnhover(fullLayout._hoverlayer.node());\n        });\n    }\n\n    var borderwidth = options.borderwidth;\n    var borderpad = options.borderpad;\n    var borderfull = borderwidth + borderpad;\n\n    var annTextBG = annTextGroupInner.append('rect')\n        .attr('class', 'bg')\n        .style('stroke-width', borderwidth + 'px')\n        .call(Color.stroke, options.bordercolor)\n        .call(Color.fill, options.bgcolor);\n\n    var isSizeConstrained = options.width || options.height;\n\n    var annTextClip = fullLayout._topclips\n        .selectAll('#' + annClipID)\n        .data(isSizeConstrained ? [0] : []);\n\n    annTextClip.enter().append('clipPath')\n        .classed('annclip', true)\n        .attr('id', annClipID)\n      .append('rect');\n    annTextClip.exit().remove();\n\n    var font = options.font;\n\n    var text = fullLayout._meta ?\n        Lib.templateString(options.text, fullLayout._meta) :\n        options.text;\n\n    var annText = annTextGroupInner.append('text')\n        .classed('annotation-text', true)\n        .text(text);\n\n    function textLayout(s) {\n        s.call(Drawing.font, font)\n        .attr({\n            'text-anchor': {\n                left: 'start',\n                right: 'end'\n            }[options.align] || 'middle'\n        });\n\n        svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n        return s;\n    }\n\n    function drawGraphicalElements() {\n        // if the text has *only* a link, make the whole box into a link\n        var anchor3 = annText.selectAll('a');\n        if(anchor3.size() === 1 && anchor3.text() === annText.text()) {\n            var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n                'xlink:xlink:href': anchor3.attr('xlink:href'),\n                'xlink:xlink:show': anchor3.attr('xlink:show')\n            })\n            .style({cursor: 'pointer'});\n\n            wholeLink.node().appendChild(annTextBG.node());\n        }\n\n        var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n        var hasMathjax = !mathjaxGroup.empty();\n        var anntextBB = Drawing.bBox(\n                (hasMathjax ? mathjaxGroup : annText).node());\n        var textWidth = anntextBB.width;\n        var textHeight = anntextBB.height;\n        var annWidth = options.width || textWidth;\n        var annHeight = options.height || textHeight;\n        var outerWidth = Math.round(annWidth + 2 * borderfull);\n        var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n        function shiftFraction(v, anchor) {\n            if(anchor === 'auto') {\n                if(v < 1 / 3) anchor = 'left';\n                else if(v > 2 / 3) anchor = 'right';\n                else anchor = 'center';\n            }\n            return {\n                center: 0,\n                middle: 0,\n                left: 0.5,\n                bottom: -0.5,\n                right: -0.5,\n                top: 0.5\n            }[anchor];\n        }\n\n        var annotationIsOffscreen = false;\n        var letters = ['x', 'y'];\n\n        for(var i = 0; i < letters.length; i++) {\n            var axLetter = letters[i];\n            var axRef = options[axLetter + 'ref'] || axLetter;\n            var tailRef = options['a' + axLetter + 'ref'];\n            var ax = {x: xa, y: ya}[axLetter];\n            var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n            // note that these two can be either positive or negative\n            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n            // but this one is the positive total size\n            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n            var anchor = options[axLetter + 'anchor'];\n            var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n            var posPx = annPosPx[axLetter];\n            var basePx;\n            var textPadShift;\n            var alignPosition;\n            var autoAlignFraction;\n            var textShift;\n            var axRefType = Axes.getRefType(axRef);\n\n            /*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */\n            if(ax && (axRefType !== 'domain')) {\n                // check if annotation is off screen, to bypass DOM manipulations\n                var posFraction = ax.r2fraction(options[axLetter]);\n                if(posFraction < 0 || posFraction > 1) {\n                    if(tailRef === axRef) {\n                        posFraction = ax.r2fraction(options['a' + axLetter]);\n                        if(posFraction < 0 || posFraction > 1) {\n                            annotationIsOffscreen = true;\n                        }\n                    } else {\n                        annotationIsOffscreen = true;\n                    }\n                }\n                basePx = ax._offset + ax.r2p(options[axLetter]);\n                autoAlignFraction = 0.5;\n            } else {\n                var axRefTypeEqDomain = axRefType === 'domain';\n                if(axLetter === 'x') {\n                    alignPosition = options[axLetter];\n                    basePx = axRefTypeEqDomain ?\n                        ax._offset + ax._length * alignPosition :\n                        basePx = gs.l + gs.w * alignPosition;\n                } else {\n                    alignPosition = 1 - options[axLetter];\n                    basePx = axRefTypeEqDomain ?\n                        ax._offset + ax._length * alignPosition :\n                        basePx = gs.t + gs.h * alignPosition;\n                }\n                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n            }\n\n            // now translate this into pixel positions of head, tail, and text\n            // as well as paddings for autorange\n            if(options.showarrow) {\n                posPx.head = basePx;\n\n                var arrowLength = options['a' + axLetter];\n\n                // with an arrow, the text rotates around the anchor point\n                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -\n                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n                if(tailRef === axRef) {\n                    // In the case tailRefType is 'domain' or 'paper', the arrow's\n                    // position is set absolutely, which is consistent with how\n                    // it behaves when its position is set in data ('range')\n                    // coordinates.\n                    var tailRefType = Axes.getRefType(tailRef);\n                    if(tailRefType === 'domain') {\n                        if(axLetter === 'y') {\n                            arrowLength = 1 - arrowLength;\n                        }\n                        posPx.tail = ax._offset + ax._length * arrowLength;\n                    } else if(tailRefType === 'paper') {\n                        if(axLetter === 'y') {\n                            arrowLength = 1 - arrowLength;\n                            posPx.tail = gs.t + gs.h * arrowLength;\n                        } else {\n                            posPx.tail = gs.l + gs.w * arrowLength;\n                        }\n                    } else {\n                        // assumed tailRef is range or paper referenced\n                        posPx.tail = ax._offset + ax.r2p(arrowLength);\n                    }\n                    // tail is range- or domain-referenced: autorange pads the\n                    // text in px from the tail\n                    textPadShift = textShift;\n                } else {\n                    posPx.tail = basePx + arrowLength;\n                    // tail is specified in px from head, so autorange also pads vs head\n                    textPadShift = textShift + arrowLength;\n                }\n\n                posPx.text = posPx.tail + textShift;\n\n                // constrain pixel/paper referenced so the draggers are at least\n                // partially visible\n                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];\n                if(axRef === 'paper') {\n                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n                }\n                if(tailRef === 'pixel') {\n                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n                    var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n                    if(shiftPlus > 0) {\n                        posPx.tail += shiftPlus;\n                        posPx.text += shiftPlus;\n                    } else if(shiftMinus > 0) {\n                        posPx.tail -= shiftMinus;\n                        posPx.text -= shiftMinus;\n                    }\n                }\n\n                posPx.tail += overallShift;\n                posPx.head += overallShift;\n            } else {\n                // with no arrow, the text rotates and *then* we put the anchor\n                // relative to the new bounding box\n                textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n                textPadShift = textShift;\n                posPx.text = basePx + textShift;\n            }\n\n            posPx.text += overallShift;\n            textShift += overallShift;\n            textPadShift += overallShift;\n\n            // padplus/minus are used by autorange\n            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;\n            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;\n\n            // size/shift are used during dragging\n            options['_' + axLetter + 'size'] = annSize;\n            options['_' + axLetter + 'shift'] = textShift;\n        }\n\n        if(annotationIsOffscreen) {\n            annTextGroupInner.remove();\n            return;\n        }\n\n        var xShift = 0;\n        var yShift = 0;\n\n        if(options.align !== 'left') {\n            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n        }\n        if(options.valign !== 'top') {\n            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n        }\n\n        if(hasMathjax) {\n            mathjaxGroup.select('svg').attr({\n                x: borderfull + xShift - 1,\n                y: borderfull + yShift\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        } else {\n            var texty = borderfull + yShift - anntextBB.top;\n            var textx = borderfull + xShift - anntextBB.left;\n\n            annText.call(svgTextUtils.positionText, textx, texty)\n                .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        }\n\n        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,\n            annWidth, annHeight);\n\n        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,\n            outerWidth - borderwidth, outerHeight - borderwidth);\n\n        annTextGroupInner.call(Drawing.setTranslate,\n            Math.round(annPosPx.x.text - outerWidth / 2),\n            Math.round(annPosPx.y.text - outerHeight / 2));\n\n        /*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */\n        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +\n                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});\n\n        /*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */\n        var drawArrow = function(dx, dy) {\n            annGroup\n                .selectAll('.annotation-arrow-g')\n                .remove();\n\n            var headX = annPosPx.x.head;\n            var headY = annPosPx.y.head;\n            var tailX = annPosPx.x.tail + dx;\n            var tailY = annPosPx.y.tail + dy;\n            var textX = annPosPx.x.text + dx;\n            var textY = annPosPx.y.text + dy;\n\n            // find the edge of the text box, where we'll start the arrow:\n            // create transform matrix to rotate the text box corners\n            var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n            var applyTransform = Lib.apply2DTransform(transform);\n            var applyTransform2 = Lib.apply2DTransform2(transform);\n\n            // calculate and transform bounding box\n            var width = +annTextBG.attr('width');\n            var height = +annTextBG.attr('height');\n            var xLeft = textX - 0.5 * width;\n            var xRight = xLeft + width;\n            var yTop = textY - 0.5 * height;\n            var yBottom = yTop + height;\n            var edges = [\n                [xLeft, yTop, xLeft, yBottom],\n                [xLeft, yBottom, xRight, yBottom],\n                [xRight, yBottom, xRight, yTop],\n                [xRight, yTop, xLeft, yTop]\n            ].map(applyTransform2);\n\n            // Remove the line if it ends inside the box.  Use ray\n            // casting for rotated boxes: see which edges intersect a\n            // line from the arrowhead to far away and reduce with xor\n            // to get the parity of the number of intersections.\n            if(edges.reduce(function(a, x) {\n                return a ^\n                    !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6,\n                            x[0], x[1], x[2], x[3]);\n            }, false)) {\n                // no line or arrow - so quit drawArrow now\n                return;\n            }\n\n            edges.forEach(function(x) {\n                var p = Lib.segmentsIntersect(tailX, tailY, headX, headY,\n                            x[0], x[1], x[2], x[3]);\n                if(p) {\n                    tailX = p.x;\n                    tailY = p.y;\n                }\n            });\n\n            var strokewidth = options.arrowwidth;\n            var arrowColor = options.arrowcolor;\n            var arrowSide = options.arrowside;\n\n            var arrowGroup = annGroup.append('g')\n                .style({opacity: Color.opacity(arrowColor)})\n                .classed('annotation-arrow-g', true);\n\n            var arrow = arrowGroup.append('path')\n                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)\n                .style('stroke-width', strokewidth + 'px')\n                .call(Color.stroke, Color.rgb(arrowColor));\n\n            drawArrowHead(arrow, arrowSide, options);\n\n            // the arrow dragger is a small square right at the head, then a line to the tail,\n            // all expanded by a stroke width of 6px plus the arrow line width\n            if(edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n                var arrowDragHeadX = headX;\n                var arrowDragHeadY = headY;\n                if(options.standoff) {\n                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n                }\n                var arrowDrag = arrowGroup.append('path')\n                    .classed('annotation-arrow', true)\n                    .classed('anndrag', true)\n                    .classed('cursor-move', true)\n                    .attr({\n                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n                        transform: strTranslate(arrowDragHeadX, arrowDragHeadY)\n                    })\n                    .style('stroke-width', (strokewidth + 6) + 'px')\n                    .call(Color.stroke, 'rgba(0,0,0,0)')\n                    .call(Color.fill, 'rgba(0,0,0,0)');\n\n                var annx0, anny0;\n\n                // dragger for the arrow & head: translates the whole thing\n                // (head/tail/text) all together\n                dragElement.init({\n                    element: arrowDrag.node(),\n                    gd: gd,\n                    prepFn: function() {\n                        var pos = Drawing.getTranslate(annTextGroupInner);\n\n                        annx0 = pos.x;\n                        anny0 = pos.y;\n                        if(xa && xa.autorange) {\n                            modifyBase(xa._name + '.autorange', true);\n                        }\n                        if(ya && ya.autorange) {\n                            modifyBase(ya._name + '.autorange', true);\n                        }\n                    },\n                    moveFn: function(dx, dy) {\n                        var annxy0 = applyTransform(annx0, anny0);\n                        var xcenter = annxy0[0] + dx;\n                        var ycenter = annxy0[1] + dy;\n                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n\n                        modifyItem('x',\n                            shiftPosition(xa, dx, 'x', gs, options));\n                        modifyItem('y',\n                            shiftPosition(ya, dy, 'y', gs, options));\n\n                        // for these 2 calls to shiftPosition, it is assumed xa, ya are\n                        // defined, so gsDim will not be used, but we put it in\n                        // anyways for consistency\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', shiftPosition(ya, dy, 'ay', gs, options));\n                        }\n\n                        arrowGroup.attr('transform', strTranslate(dx, dy));\n                        annTextGroup.attr({\n                            transform: 'rotate(' + textangle + ',' +\n                                   xcenter + ',' + ycenter + ')'\n                        });\n                    },\n                    doneFn: function() {\n                        Registry.call('_guiRelayout', gd, getUpdateObj());\n                        var notesBox = document.querySelector('.js-notes-box-panel');\n                        if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                    }\n                });\n            }\n        };\n\n        if(options.showarrow) drawArrow(0, 0);\n\n        // user dragging the annotation (text, not arrow)\n        if(editTextPosition) {\n            var baseTextTransform;\n\n            // dragger for the textbox: if there's an arrow, just drag the\n            // textbox and tail, leave the head untouched\n            dragElement.init({\n                element: annTextGroupInner.node(),\n                gd: gd,\n                prepFn: function() {\n                    baseTextTransform = annTextGroup.attr('transform');\n                },\n                moveFn: function(dx, dy) {\n                    var csr = 'pointer';\n                    if(options.showarrow) {\n                        // for these 2 calls to shiftPosition, it is assumed xa, ya are\n                        // defined, so gsDim will not be used, but we put it in\n                        // anyways for consistency\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', shiftPosition(xa, dx, 'ax', gs, options));\n                        } else {\n                            modifyItem('ax', options.ax + dx);\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', shiftPosition(ya, dy, 'ay', gs.w, options));\n                        } else {\n                            modifyItem('ay', options.ay + dy);\n                        }\n\n                        drawArrow(dx, dy);\n                    } else if(!subplotId) {\n                        var xUpdate, yUpdate;\n                        if(xa) {\n                            // shiftPosition will not execute code where xa was\n                            // undefined, so we use to calculate xUpdate too\n                            xUpdate = shiftPosition(xa, dx, 'x', gs, options);\n                        } else {\n                            var widthFraction = options._xsize / gs.w;\n                            var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n\n                            xUpdate = dragElement.align(xLeft + dx / gs.w,\n                                widthFraction, 0, 1, options.xanchor);\n                        }\n\n                        if(ya) {\n                            // shiftPosition will not execute code where ya was\n                            // undefined, so we use to calculate yUpdate too\n                            yUpdate = shiftPosition(ya, dy, 'y', gs, options);\n                        } else {\n                            var heightFraction = options._ysize / gs.h;\n                            var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n\n                            yUpdate = dragElement.align(yBottom - dy / gs.h,\n                                heightFraction, 0, 1, options.yanchor);\n                        }\n                        modifyItem('x', xUpdate);\n                        modifyItem('y', yUpdate);\n                        if(!xa || !ya) {\n                            csr = dragElement.getCursor(\n                                xa ? 0.5 : xUpdate,\n                                ya ? 0.5 : yUpdate,\n                                options.xanchor, options.yanchor\n                            );\n                        }\n                    } else return;\n\n                    annTextGroup.attr({\n                        transform: strTranslate(dx, dy) + baseTextTransform\n                    });\n\n                    setCursor(annTextGroupInner, csr);\n                },\n                clickFn: function(_, initialEvent) {\n                    if(options.captureevents) {\n                        gd.emit('plotly_clickannotation', makeEventData(initialEvent));\n                    }\n                },\n                doneFn: function() {\n                    setCursor(annTextGroupInner);\n                    Registry.call('_guiRelayout', gd, getUpdateObj());\n                    var notesBox = document.querySelector('.js-notes-box-panel');\n                    if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                }\n            });\n        }\n    }\n\n    if(edits.annotationText) {\n        annText.call(svgTextUtils.makeEditable, {delegate: annTextGroupInner, gd: gd})\n            .call(textLayout)\n            .on('edit', function(_text) {\n                options.text = _text;\n\n                this.call(textLayout);\n\n                modifyItem('text', _text);\n\n                if(xa && xa.autorange) {\n                    modifyBase(xa._name + '.autorange', true);\n                }\n                if(ya && ya.autorange) {\n                    modifyBase(ya._name + '.autorange', true);\n                }\n\n                Registry.call('_guiRelayout', gd, getUpdateObj());\n            });\n    } else annText.call(textLayout);\n}\n"]},"metadata":{},"sourceType":"script"}