{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar piePlot = require('../pie/plot');\n\nvar getRotationAngle = require('../pie/helpers').getRotationAngle;\n\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\n\nvar styleOne = require('./style').styleOne;\n\nvar resizeText = require('../bar/style').resizeText;\n\nvar attachFxHandlers = require('./fx');\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nexports.plot = function (gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var layer = fullLayout._sunburstlayer;\n  var join, onComplete; // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  clearMinTextSize('sunburst', fullLayout);\n  join = layer.selectAll('g.trace.sunburst').data(cdmodule, function (cd) {\n    return cd[0].trace.uid;\n  }); // using same 'stroke-linejoin' as pie traces\n\n  join.enter().append('g').classed('trace', true).classed('sunburst', true).attr('stroke-linejoin', 'round');\n  join.order();\n\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      layer.selectAll('g.trace').each(function (cd) {\n        plotOne(gd, cd, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (cd) {\n      plotOne(gd, cd, this, transitionOpts);\n    });\n\n    if (fullLayout.uniformtext.mode) {\n      resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n    }\n  }\n\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n  var fullLayout = gd._fullLayout;\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var gTrace = d3.select(element);\n  var slices = gTrace.selectAll('g.slice');\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var maxDepth = helpers.getMaxDepth(trace);\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var rMax = 0.5 * Math.min(vpw, vph);\n  var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n  if (!entry) {\n    return slices.remove();\n  } // previous root 'pt' (can be empty)\n\n\n  var prevEntry = null; // stash of 'previous' position data used by tweening functions\n\n  var prevLookup = {};\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    slices.each(function (pt) {\n      prevLookup[helpers.getPtId(pt)] = {\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1,\n        x0: pt.x0,\n        x1: pt.x1,\n        transform: pt.transform\n      };\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  } // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n\n\n  var sliceData = partition(entry).descendants();\n  var maxHeight = entry.height + 1;\n  var yOffset = 0;\n  var cutoff = maxDepth; // N.B. handle multiple-root special case\n\n  if (cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n    sliceData = sliceData.slice(1);\n    maxHeight -= 1;\n    yOffset = 1;\n    cutoff += 1;\n  } // filter out slices that won't show up on graph\n\n\n  sliceData = sliceData.filter(function (pt) {\n    return pt.y1 <= cutoff;\n  });\n  var baseX = getRotationAngle(trace.rotation);\n\n  if (baseX) {\n    sliceData.forEach(function (pt) {\n      pt.x0 += baseX;\n      pt.x1 += baseX;\n    });\n  } // partition span ('y') to sector radial px value\n\n\n  var maxY = Math.min(maxHeight, maxDepth);\n\n  var y2rpx = function (y) {\n    return (y - yOffset) / maxY * rMax;\n  }; // (radial px value, partition angle ('x'))  to px [x,y]\n\n\n  var rx2px = function (r, x) {\n    return [r * Math.cos(x), -r * Math.sin(x)];\n  }; // slice path generation fn\n\n\n  var pathSlice = function (d) {\n    return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy);\n  }; // slice text translate x/y\n\n\n  var getTargetX = function (d) {\n    return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0);\n  };\n\n  var getTargetY = function (d) {\n    return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0);\n  };\n\n  slices = slices.data(sliceData, helpers.getPtId);\n  slices.enter().append('g').classed('slice', true);\n\n  if (hasTransition) {\n    slices.exit().transition().each(function () {\n      var sliceTop = d3.select(this);\n      var slicePath = sliceTop.select('path.surface');\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeExitSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n      var sliceTextGroup = sliceTop.select('g.slicetext');\n      sliceTextGroup.attr('opacity', 0);\n    }).remove();\n  } else {\n    slices.exit().remove();\n  }\n\n  slices.order(); // next x1 (i.e. sector end angle) of previous entry\n\n  var nextX1ofPrevEntry = null;\n\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextX1ofPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextX1ofPrevEntry = pt.x1;\n      }\n    });\n  }\n\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: true,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', 'all');\n    });\n    pt.rpx0 = y2rpx(pt.y0);\n    pt.rpx1 = y2rpx(pt.y1);\n    pt.xmid = (pt.x0 + pt.x1) / 2;\n    pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n    pt.midangle = -(pt.xmid - Math.PI / 2);\n    pt.startangle = -(pt.x0 - Math.PI / 2);\n    pt.stopangle = -(pt.x1 - Math.PI / 2);\n    pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n    pt.ring = 1 - pt.rpx0 / pt.rpx1;\n    pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      hideOnRoot: true,\n      hideOnLeaves: true,\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace);\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout)).classed('slicetext', true).attr('text-anchor', 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n    var textBB = Drawing.bBox(sliceText.node());\n    pt.transform = transformInsideText(textBB, pt, cd0);\n    pt.transform.targetX = getTargetX(pt);\n    pt.transform.targetY = getTargetY(pt);\n\n    var strTransform = function (d, textBB) {\n      var transform = d.transform;\n      computeTransform(transform, textBB);\n      transform.fontSize = font.size;\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return Lib.getTextTransform(transform);\n    };\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2);\n        return function (t) {\n          return strTransform(interp(t), textBB);\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt, textBB));\n    }\n  });\n\n  function makeExitSliceInterpolator(pt) {\n    var id = helpers.getPtId(pt);\n    var prev = prevLookup[id];\n    var entryPrev = prevLookup[helpers.getPtId(entry)];\n    var next;\n\n    if (entryPrev) {\n      var a = (pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0) + baseX; // if pt to remove:\n      // - if 'below' where the root-node used to be: shrink it radially inward\n      // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n\n      next = pt.rpx1 < entryPrev.rpx1 ? {\n        x0: pt.x0,\n        x1: pt.x1,\n        rpx0: 0,\n        rpx1: 0\n      } : {\n        x0: a,\n        x1: a,\n        rpx0: pt.rpx0,\n        rpx1: pt.rpx1\n      };\n    } else {\n      // this happens when maxdepth is set, when leaves must\n      // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n      var parent;\n      var parentId = helpers.getPtId(pt.parent);\n      slices.each(function (pt2) {\n        if (helpers.getPtId(pt2) === parentId) {\n          return parent = pt2;\n        }\n      });\n      var parentChildren = parent.children;\n      var ci;\n      parentChildren.forEach(function (pt2, i) {\n        if (helpers.getPtId(pt2) === id) {\n          return ci = i;\n        }\n      });\n      var n = parentChildren.length;\n      var interp = interpolate(parent.x0, parent.x1);\n      next = {\n        rpx0: rMax,\n        rpx1: rMax,\n        x0: interp(ci / n),\n        x1: interp((ci + 1) / n)\n      };\n    }\n\n    return interpolate(prev, next);\n  }\n\n  function makeUpdateSliceInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var next = {\n      x0: pt.x0,\n      x1: pt.x1,\n      rpx0: pt.rpx0,\n      rpx1: pt.rpx1\n    };\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = (pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0) + baseX;\n            prev = {\n              x0: a,\n              x1: a\n            };\n          } else {\n            // if new leaf (when maxdepth is set),\n            // grow it radially and angularly from\n            // its parent node\n            prev = {\n              rpx0: rMax,\n              rpx1: rMax\n            };\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node, grow it radially\n          prev = {\n            rpx0: 0,\n            rpx1: 0\n          };\n        }\n      } else {\n        // start sector of new traces from theta=0\n        prev = {\n          x0: baseX,\n          x1: baseX\n        };\n      }\n    }\n\n    return interpolate(prev, next);\n  }\n\n  function makeUpdateTextInterpolator(pt) {\n    var prev0 = prevLookup[helpers.getPtId(pt)];\n    var prev;\n    var transform = pt.transform;\n\n    if (prev0) {\n      prev = prev0;\n    } else {\n      prev = {\n        rpx1: pt.rpx1,\n        transform: {\n          textPosAngle: transform.textPosAngle,\n          scale: 0,\n          rotate: transform.rotate,\n          rCenter: transform.rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      }; // for new pts:\n\n      if (prevEntry) {\n        // if trace was visible before\n        if (pt.parent) {\n          if (nextX1ofPrevEntry) {\n            // if new branch, twist it in clockwise or\n            // counterclockwise which ever is shorter to\n            // its final angle\n            var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n            prev.x0 = prev.x1 = a;\n          } else {\n            // if leaf\n            Lib.extendFlat(prev, interpX0X1FromParent(pt));\n          }\n        } else {\n          // if new root-node\n          prev.x0 = prev.x1 = baseX;\n        }\n      } else {\n        // on new traces\n        prev.x0 = prev.x1 = baseX;\n      }\n    }\n\n    var textPosAngleFn = interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n    var rpx1Fn = interpolate(prev.rpx1, pt.rpx1);\n    var x0Fn = interpolate(prev.x0, pt.x0);\n    var x1Fn = interpolate(prev.x1, pt.x1);\n    var scaleFn = interpolate(prev.transform.scale, transform.scale);\n    var rotateFn = interpolate(prev.transform.rotate, transform.rotate); // smooth out start/end from entry, to try to keep text inside sector\n    // while keeping transition smooth\n\n    var pow = transform.rCenter === 0 ? 3 : prev.transform.rCenter === 0 ? 1 / 3 : 1;\n\n    var _rCenterFn = interpolate(prev.transform.rCenter, transform.rCenter);\n\n    var rCenterFn = function (t) {\n      return _rCenterFn(Math.pow(t, pow));\n    };\n\n    return function (t) {\n      var rpx1 = rpx1Fn(t);\n      var x0 = x0Fn(t);\n      var x1 = x1Fn(t);\n      var rCenter = rCenterFn(t);\n      var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n      var textPosAngle = textPosAngleFn(t);\n      var d = {\n        pxmid: pxmid,\n        rpx1: rpx1,\n        transform: {\n          textPosAngle: textPosAngle,\n          rCenter: rCenter,\n          x: transform.x,\n          y: transform.y\n        }\n      };\n      recordMinTextSize(trace.type, transform, fullLayout);\n      return {\n        transform: {\n          targetX: getTargetX(d),\n          targetY: getTargetY(d),\n          scale: scaleFn(t),\n          rotate: rotateFn(t),\n          rCenter: rCenter\n        }\n      };\n    };\n  }\n\n  function interpX0X1FromParent(pt) {\n    var parent = pt.parent;\n    var parentPrev = prevLookup[helpers.getPtId(parent)];\n    var out = {};\n\n    if (parentPrev) {\n      // if parent is visible\n      var parentChildren = parent.children;\n      var ci = parentChildren.indexOf(pt);\n      var n = parentChildren.length;\n      var interp = interpolate(parentPrev.x0, parentPrev.x1);\n      out.x0 = interp(ci / n);\n      out.x1 = interp(ci / n);\n    } else {\n      // w/o visible parent\n      // TODO !!! HOW ???\n      out.x0 = out.x1 = 0;\n    }\n\n    return out;\n  }\n} // x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\n\n\nfunction partition(entry) {\n  return d3Hierarchy.partition().size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function (pt, entry, trace, cd, fullLayout) {\n  var texttemplate = trace.texttemplate;\n  var textinfo = trace.textinfo;\n\n  if (!texttemplate && (!textinfo || textinfo === 'none')) {\n    return '';\n  }\n\n  var separators = fullLayout.separators;\n  var cd0 = cd[0];\n  var cdi = pt.data.data;\n  var hierarchy = cd0.hierarchy;\n  var isRoot = helpers.isHierarchyRoot(pt);\n  var parent = helpers.getParent(hierarchy, pt);\n  var val = helpers.getValue(pt);\n\n  if (!texttemplate) {\n    var parts = textinfo.split('+');\n\n    var hasFlag = function (flag) {\n      return parts.indexOf(flag) !== -1;\n    };\n\n    var thisText = [];\n    var tx;\n\n    if (hasFlag('label') && cdi.label) {\n      thisText.push(cdi.label);\n    }\n\n    if (cdi.hasOwnProperty('v') && hasFlag('value')) {\n      thisText.push(helpers.formatValue(cdi.v, separators));\n    }\n\n    if (!isRoot) {\n      if (hasFlag('current path')) {\n        thisText.push(helpers.getPath(pt.data));\n      }\n\n      var nPercent = 0;\n      if (hasFlag('percent parent')) nPercent++;\n      if (hasFlag('percent entry')) nPercent++;\n      if (hasFlag('percent root')) nPercent++;\n      var hasMultiplePercents = nPercent > 1;\n\n      if (nPercent) {\n        var percent;\n\n        var addPercent = function (key) {\n          tx = helpers.formatPercent(percent, separators);\n          if (hasMultiplePercents) tx += ' of ' + key;\n          thisText.push(tx);\n        };\n\n        if (hasFlag('percent parent') && !isRoot) {\n          percent = val / helpers.getValue(parent);\n          addPercent('parent');\n        }\n\n        if (hasFlag('percent entry')) {\n          percent = val / helpers.getValue(entry);\n          addPercent('entry');\n        }\n\n        if (hasFlag('percent root')) {\n          percent = val / helpers.getValue(hierarchy);\n          addPercent('root');\n        }\n      }\n    }\n\n    if (hasFlag('text')) {\n      tx = Lib.castOption(trace, cdi.i, 'text');\n      if (Lib.isValidTextValue(tx)) thisText.push(tx);\n    }\n\n    return thisText.join('<br>');\n  }\n\n  var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n  if (!txt) return '';\n  var obj = {};\n  if (cdi.label) obj.label = cdi.label;\n\n  if (cdi.hasOwnProperty('v')) {\n    obj.value = cdi.v;\n    obj.valueLabel = helpers.formatValue(cdi.v, separators);\n  }\n\n  obj.currentPath = helpers.getPath(pt.data);\n\n  if (!isRoot) {\n    obj.percentParent = val / helpers.getValue(parent);\n    obj.percentParentLabel = helpers.formatPercent(obj.percentParent, separators);\n    obj.parent = helpers.getPtLabel(parent);\n  }\n\n  obj.percentEntry = val / helpers.getValue(entry);\n  obj.percentEntryLabel = helpers.formatPercent(obj.percentEntry, separators);\n  obj.entry = helpers.getPtLabel(entry);\n  obj.percentRoot = val / helpers.getValue(hierarchy);\n  obj.percentRootLabel = helpers.formatPercent(obj.percentRoot, separators);\n  obj.root = helpers.getPtLabel(hierarchy);\n\n  if (cdi.hasOwnProperty('color')) {\n    obj.color = cdi.color;\n  }\n\n  var ptTx = Lib.castOption(trace, cdi.i, 'text');\n  if (Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n  obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n  if (pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n    // special case of 100% with no hole\n    return 1;\n  } else {\n    return Math.max(0, Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2));\n  }\n}\n\nfunction getTextXY(d) {\n  return getCoords(d.rpx1, d.transform.textPosAngle);\n}\n\nfunction getCoords(r, angle) {\n  return [r * Math.sin(angle), -r * Math.cos(angle)];\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/sunburst/plot.js"],"names":["d3","require","d3Hierarchy","interpolate","Drawing","Lib","svgTextUtils","uniformText","recordMinTextSize","clearMinTextSize","piePlot","getRotationAngle","computeTransform","transformInsideText","styleOne","resizeText","attachFxHandlers","constants","helpers","exports","plot","gd","cdmodule","transitionOpts","makeOnCompleteCallback","fullLayout","_fullLayout","layer","_sunburstlayer","join","onComplete","isFullReplot","hasTransition","uniformtext","mode","selectAll","data","cd","trace","uid","enter","append","classed","attr","order","transition","duration","ease","easing","each","plotOne","exit","remove","element","gTrace","select","slices","cd0","hierarchy","entry","findEntryWithLevel","level","maxDepth","getMaxDepth","gs","_size","domain","vpw","w","x","vph","h","y","rMax","Math","min","cx","l","cy","t","prevEntry","prevLookup","pt","getPtId","rpx0","rpx1","x0","x1","transform","isEntry","sliceData","partition","descendants","maxHeight","height","yOffset","cutoff","hasMultipleRoots","isHierarchyRoot","slice","filter","y1","baseX","rotation","forEach","maxY","y2rpx","rx2px","r","cos","sin","pathSlice","d","pathAnnulus","getTargetX","getTextXY","rCenter","getTargetY","sliceTop","slicePath","attrTween","pt2","interp","makeExitSliceInterpolator","sliceTextGroup","nextX1ofPrevEntry","prevEntryId","updateSlices","setSliceCursor","hideOnRoot","hideOnLeaves","isTransitioning","ensureSingle","s","style","y0","xmid","pxmid","midangle","PI","startangle","stopangle","halfangle","angleDelta","ring","rInscribed","getInscribedRadiusFraction","makeUpdateSliceInterpolator","call","eventDataKeys","transitionTime","CLICK_TRANSITION_TIME","transitionEasing","CLICK_TRANSITION_EASING","_transitioning","sliceText","font","ensureUniformFontSize","determineTextFont","text","formatSliceLabel","convertToTspans","textBB","bBox","node","targetX","targetY","strTransform","fontSize","size","type","getTextTransform","makeUpdateTextInterpolator","id","prev","entryPrev","next","a","parent","parentId","parentChildren","children","ci","i","n","length","prev0","extendFlat","interpX0X1FromParent","textPosAngle","scale","rotate","textPosAngleFn","rpx1Fn","x0Fn","x1Fn","scaleFn","rotateFn","pow","_rCenterFn","rCenterFn","parentPrev","out","indexOf","texttemplate","textinfo","separators","cdi","isRoot","getParent","val","getValue","parts","split","hasFlag","flag","thisText","tx","label","push","hasOwnProperty","formatValue","v","getPath","nPercent","hasMultiplePercents","percent","addPercent","key","formatPercent","castOption","isValidTextValue","txt","obj","value","valueLabel","currentPath","percentParent","percentParentLabel","getPtLabel","percentEntry","percentEntryLabel","percentRoot","percentRootLabel","root","color","ptTx","customdata","texttemplateString","_d3locale","_meta","isFullCircle","max","getCoords","angle"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar d3Hierarchy = require('d3-hierarchy');\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar uniformText = require('../bar/uniform_text');\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\nvar piePlot = require('../pie/plot');\nvar getRotationAngle = require('../pie/helpers').getRotationAngle;\nvar computeTransform = piePlot.computeTransform;\nvar transformInsideText = piePlot.transformInsideText;\nvar styleOne = require('./style').styleOne;\nvar resizeText = require('../bar/style').resizeText;\nvar attachFxHandlers = require('./fx');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nexports.plot = function(gd, cdmodule, transitionOpts, makeOnCompleteCallback) {\n    var fullLayout = gd._fullLayout;\n    var layer = fullLayout._sunburstlayer;\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    clearMinTextSize('sunburst', fullLayout);\n\n    join = layer.selectAll('g.trace.sunburst')\n        .data(cdmodule, function(cd) { return cd[0].trace.uid; });\n\n    // using same 'stroke-linejoin' as pie traces\n    join.enter().append('g')\n        .classed('trace', true)\n        .classed('sunburst', true)\n        .attr('stroke-linejoin', 'round');\n\n    join.order();\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() { onComplete && onComplete(); })\n            .each('interrupt', function() { onComplete && onComplete(); });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            layer.selectAll('g.trace').each(function(cd) {\n                plotOne(gd, cd, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(cd) {\n            plotOne(gd, cd, this, transitionOpts);\n        });\n\n        if(fullLayout.uniformtext.mode) {\n            resizeText(gd, fullLayout._sunburstlayer.selectAll('.trace'), 'sunburst');\n        }\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n};\n\nfunction plotOne(gd, cd, element, transitionOpts) {\n    var fullLayout = gd._fullLayout;\n    var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n\n    var gTrace = d3.select(element);\n    var slices = gTrace.selectAll('g.slice');\n\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var hierarchy = cd0.hierarchy;\n    var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n    var maxDepth = helpers.getMaxDepth(trace);\n\n    var gs = fullLayout._size;\n    var domain = trace.domain;\n    var vpw = gs.w * (domain.x[1] - domain.x[0]);\n    var vph = gs.h * (domain.y[1] - domain.y[0]);\n    var rMax = 0.5 * Math.min(vpw, vph);\n    var cx = cd0.cx = gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n    var cy = cd0.cy = gs.t + gs.h * (1 - domain.y[0]) - vph / 2;\n\n    if(!entry) {\n        return slices.remove();\n    }\n\n    // previous root 'pt' (can be empty)\n    var prevEntry = null;\n    // stash of 'previous' position data used by tweening functions\n    var prevLookup = {};\n\n    if(hasTransition) {\n        // Important: do this before binding new sliceData!\n        slices.each(function(pt) {\n            prevLookup[helpers.getPtId(pt)] = {\n                rpx0: pt.rpx0,\n                rpx1: pt.rpx1,\n                x0: pt.x0,\n                x1: pt.x1,\n                transform: pt.transform\n            };\n\n            if(!prevEntry && helpers.isEntry(pt)) {\n                prevEntry = pt;\n            }\n        });\n    }\n\n    // N.B. slice data isn't the calcdata,\n    // grab corresponding calcdata item in sliceData[i].data.data\n    var sliceData = partition(entry).descendants();\n\n    var maxHeight = entry.height + 1;\n    var yOffset = 0;\n    var cutoff = maxDepth;\n    // N.B. handle multiple-root special case\n    if(cd0.hasMultipleRoots && helpers.isHierarchyRoot(entry)) {\n        sliceData = sliceData.slice(1);\n        maxHeight -= 1;\n        yOffset = 1;\n        cutoff += 1;\n    }\n\n    // filter out slices that won't show up on graph\n    sliceData = sliceData.filter(function(pt) { return pt.y1 <= cutoff; });\n\n    var baseX = getRotationAngle(trace.rotation);\n    if(baseX) {\n        sliceData.forEach(function(pt) {\n            pt.x0 += baseX;\n            pt.x1 += baseX;\n        });\n    }\n\n    // partition span ('y') to sector radial px value\n    var maxY = Math.min(maxHeight, maxDepth);\n    var y2rpx = function(y) { return (y - yOffset) / maxY * rMax; };\n    // (radial px value, partition angle ('x'))  to px [x,y]\n    var rx2px = function(r, x) { return [r * Math.cos(x), -r * Math.sin(x)]; };\n    // slice path generation fn\n    var pathSlice = function(d) { return Lib.pathAnnulus(d.rpx0, d.rpx1, d.x0, d.x1, cx, cy); };\n    // slice text translate x/y\n\n    var getTargetX = function(d) { return cx + getTextXY(d)[0] * (d.transform.rCenter || 0) + (d.transform.x || 0); };\n    var getTargetY = function(d) { return cy + getTextXY(d)[1] * (d.transform.rCenter || 0) + (d.transform.y || 0); };\n\n    slices = slices.data(sliceData, helpers.getPtId);\n\n    slices.enter().append('g')\n        .classed('slice', true);\n\n    if(hasTransition) {\n        slices.exit().transition()\n            .each(function() {\n                var sliceTop = d3.select(this);\n\n                var slicePath = sliceTop.select('path.surface');\n                slicePath.transition().attrTween('d', function(pt2) {\n                    var interp = makeExitSliceInterpolator(pt2);\n                    return function(t) { return pathSlice(interp(t)); };\n                });\n\n                var sliceTextGroup = sliceTop.select('g.slicetext');\n                sliceTextGroup.attr('opacity', 0);\n            })\n            .remove();\n    } else {\n        slices.exit().remove();\n    }\n\n    slices.order();\n\n    // next x1 (i.e. sector end angle) of previous entry\n    var nextX1ofPrevEntry = null;\n    if(hasTransition && prevEntry) {\n        var prevEntryId = helpers.getPtId(prevEntry);\n        slices.each(function(pt) {\n            if(nextX1ofPrevEntry === null && (helpers.getPtId(pt) === prevEntryId)) {\n                nextX1ofPrevEntry = pt.x1;\n            }\n        });\n    }\n\n    var updateSlices = slices;\n    if(hasTransition) {\n        updateSlices = updateSlices.transition().each('end', function() {\n            // N.B. gd._transitioning is (still) *true* by the time\n            // transition updates get here\n            var sliceTop = d3.select(this);\n            helpers.setSliceCursor(sliceTop, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: false\n            });\n        });\n    }\n\n    updateSlices.each(function(pt) {\n        var sliceTop = d3.select(this);\n\n        var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function(s) {\n            s.style('pointer-events', 'all');\n        });\n\n        pt.rpx0 = y2rpx(pt.y0);\n        pt.rpx1 = y2rpx(pt.y1);\n        pt.xmid = (pt.x0 + pt.x1) / 2;\n        pt.pxmid = rx2px(pt.rpx1, pt.xmid);\n        pt.midangle = -(pt.xmid - Math.PI / 2);\n        pt.startangle = -(pt.x0 - Math.PI / 2);\n        pt.stopangle = -(pt.x1 - Math.PI / 2);\n        pt.halfangle = 0.5 * Math.min(Lib.angleDelta(pt.x0, pt.x1) || Math.PI, Math.PI);\n        pt.ring = 1 - (pt.rpx0 / pt.rpx1);\n        pt.rInscribed = getInscribedRadiusFraction(pt, trace);\n\n        if(hasTransition) {\n            slicePath.transition().attrTween('d', function(pt2) {\n                var interp = makeUpdateSliceInterpolator(pt2);\n                return function(t) { return pathSlice(interp(t)); };\n            });\n        } else {\n            slicePath.attr('d', pathSlice);\n        }\n\n        sliceTop\n            .call(attachFxHandlers, entry, gd, cd, {\n                eventDataKeys: constants.eventDataKeys,\n                transitionTime: constants.CLICK_TRANSITION_TIME,\n                transitionEasing: constants.CLICK_TRANSITION_EASING\n            })\n            .call(helpers.setSliceCursor, gd, {\n                hideOnRoot: true,\n                hideOnLeaves: true,\n                isTransitioning: gd._transitioning\n            });\n\n        slicePath.call(styleOne, pt, trace);\n\n        var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n        var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n\n        sliceText.text(exports.formatSliceLabel(pt, entry, trace, cd, fullLayout))\n            .classed('slicetext', true)\n            .attr('text-anchor', 'middle')\n            .call(Drawing.font, font)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        // position the text relative to the slice\n        var textBB = Drawing.bBox(sliceText.node());\n        pt.transform = transformInsideText(textBB, pt, cd0);\n        pt.transform.targetX = getTargetX(pt);\n        pt.transform.targetY = getTargetY(pt);\n\n        var strTransform = function(d, textBB) {\n            var transform = d.transform;\n            computeTransform(transform, textBB);\n\n            transform.fontSize = font.size;\n            recordMinTextSize(trace.type, transform, fullLayout);\n\n            return Lib.getTextTransform(transform);\n        };\n\n        if(hasTransition) {\n            sliceText.transition().attrTween('transform', function(pt2) {\n                var interp = makeUpdateTextInterpolator(pt2);\n                return function(t) { return strTransform(interp(t), textBB); };\n            });\n        } else {\n            sliceText.attr('transform', strTransform(pt, textBB));\n        }\n    });\n\n    function makeExitSliceInterpolator(pt) {\n        var id = helpers.getPtId(pt);\n        var prev = prevLookup[id];\n        var entryPrev = prevLookup[helpers.getPtId(entry)];\n        var next;\n\n        if(entryPrev) {\n            var a = (pt.x1 > entryPrev.x1 ? 2 * Math.PI : 0) + baseX;\n            // if pt to remove:\n            // - if 'below' where the root-node used to be: shrink it radially inward\n            // - otherwise, collapse it clockwise or counterclockwise which ever is shortest to theta=0\n            next = pt.rpx1 < entryPrev.rpx1 ?\n                {x0: pt.x0, x1: pt.x1, rpx0: 0, rpx1: 0} :\n                {x0: a, x1: a, rpx0: pt.rpx0, rpx1: pt.rpx1};\n        } else {\n            // this happens when maxdepth is set, when leaves must\n            // be removed and the rootPt is new (i.e. does not have a 'prev' object)\n            var parent;\n            var parentId = helpers.getPtId(pt.parent);\n            slices.each(function(pt2) {\n                if(helpers.getPtId(pt2) === parentId) {\n                    return parent = pt2;\n                }\n            });\n            var parentChildren = parent.children;\n            var ci;\n            parentChildren.forEach(function(pt2, i) {\n                if(helpers.getPtId(pt2) === id) {\n                    return ci = i;\n                }\n            });\n            var n = parentChildren.length;\n            var interp = interpolate(parent.x0, parent.x1);\n            next = {\n                rpx0: rMax, rpx1: rMax,\n                x0: interp(ci / n), x1: interp((ci + 1) / n)\n            };\n        }\n\n        return interpolate(prev, next);\n    }\n\n    function makeUpdateSliceInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var next = {x0: pt.x0, x1: pt.x1, rpx0: pt.rpx0, rpx1: pt.rpx1};\n\n        if(prev0) {\n            // if pt already on graph, this is easy\n            prev = prev0;\n        } else {\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = (pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0) + baseX;\n                        prev = {x0: a, x1: a};\n                    } else {\n                        // if new leaf (when maxdepth is set),\n                        // grow it radially and angularly from\n                        // its parent node\n                        prev = {rpx0: rMax, rpx1: rMax};\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node, grow it radially\n                    prev = {rpx0: 0, rpx1: 0};\n                }\n            } else {\n                // start sector of new traces from theta=0\n                prev = {x0: baseX, x1: baseX};\n            }\n        }\n\n        return interpolate(prev, next);\n    }\n\n    function makeUpdateTextInterpolator(pt) {\n        var prev0 = prevLookup[helpers.getPtId(pt)];\n        var prev;\n        var transform = pt.transform;\n\n        if(prev0) {\n            prev = prev0;\n        } else {\n            prev = {\n                rpx1: pt.rpx1,\n                transform: {\n                    textPosAngle: transform.textPosAngle,\n                    scale: 0,\n                    rotate: transform.rotate,\n                    rCenter: transform.rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            // for new pts:\n            if(prevEntry) {\n                // if trace was visible before\n                if(pt.parent) {\n                    if(nextX1ofPrevEntry) {\n                        // if new branch, twist it in clockwise or\n                        // counterclockwise which ever is shorter to\n                        // its final angle\n                        var a = pt.x1 > nextX1ofPrevEntry ? 2 * Math.PI : 0;\n                        prev.x0 = prev.x1 = a;\n                    } else {\n                        // if leaf\n                        Lib.extendFlat(prev, interpX0X1FromParent(pt));\n                    }\n                } else {\n                    // if new root-node\n                    prev.x0 = prev.x1 = baseX;\n                }\n            } else {\n                // on new traces\n                prev.x0 = prev.x1 = baseX;\n            }\n        }\n\n        var textPosAngleFn = interpolate(prev.transform.textPosAngle, pt.transform.textPosAngle);\n        var rpx1Fn = interpolate(prev.rpx1, pt.rpx1);\n        var x0Fn = interpolate(prev.x0, pt.x0);\n        var x1Fn = interpolate(prev.x1, pt.x1);\n        var scaleFn = interpolate(prev.transform.scale, transform.scale);\n        var rotateFn = interpolate(prev.transform.rotate, transform.rotate);\n\n        // smooth out start/end from entry, to try to keep text inside sector\n        // while keeping transition smooth\n        var pow = transform.rCenter === 0 ? 3 :\n            prev.transform.rCenter === 0 ? 1 / 3 :\n            1;\n        var _rCenterFn = interpolate(prev.transform.rCenter, transform.rCenter);\n        var rCenterFn = function(t) { return _rCenterFn(Math.pow(t, pow)); };\n\n        return function(t) {\n            var rpx1 = rpx1Fn(t);\n            var x0 = x0Fn(t);\n            var x1 = x1Fn(t);\n            var rCenter = rCenterFn(t);\n            var pxmid = rx2px(rpx1, (x0 + x1) / 2);\n            var textPosAngle = textPosAngleFn(t);\n\n            var d = {\n                pxmid: pxmid,\n                rpx1: rpx1,\n                transform: {\n                    textPosAngle: textPosAngle,\n                    rCenter: rCenter,\n                    x: transform.x,\n                    y: transform.y\n                }\n            };\n\n            recordMinTextSize(trace.type, transform, fullLayout);\n            return {\n                transform: {\n                    targetX: getTargetX(d),\n                    targetY: getTargetY(d),\n                    scale: scaleFn(t),\n                    rotate: rotateFn(t),\n                    rCenter: rCenter\n                }\n            };\n        };\n    }\n\n    function interpX0X1FromParent(pt) {\n        var parent = pt.parent;\n        var parentPrev = prevLookup[helpers.getPtId(parent)];\n        var out = {};\n\n        if(parentPrev) {\n            // if parent is visible\n            var parentChildren = parent.children;\n            var ci = parentChildren.indexOf(pt);\n            var n = parentChildren.length;\n            var interp = interpolate(parentPrev.x0, parentPrev.x1);\n            out.x0 = interp(ci / n);\n            out.x1 = interp(ci / n);\n        } else {\n            // w/o visible parent\n            // TODO !!! HOW ???\n            out.x0 = out.x1 = 0;\n        }\n\n        return out;\n    }\n}\n\n// x[0-1] keys are angles [radians]\n// y[0-1] keys are hierarchy heights [integers]\nfunction partition(entry) {\n    return d3Hierarchy.partition()\n        .size([2 * Math.PI, entry.height + 1])(entry);\n}\n\nexports.formatSliceLabel = function(pt, entry, trace, cd, fullLayout) {\n    var texttemplate = trace.texttemplate;\n    var textinfo = trace.textinfo;\n\n    if(!texttemplate && (!textinfo || textinfo === 'none')) {\n        return '';\n    }\n\n    var separators = fullLayout.separators;\n    var cd0 = cd[0];\n    var cdi = pt.data.data;\n    var hierarchy = cd0.hierarchy;\n    var isRoot = helpers.isHierarchyRoot(pt);\n    var parent = helpers.getParent(hierarchy, pt);\n    var val = helpers.getValue(pt);\n\n    if(!texttemplate) {\n        var parts = textinfo.split('+');\n        var hasFlag = function(flag) { return parts.indexOf(flag) !== -1; };\n        var thisText = [];\n        var tx;\n\n        if(hasFlag('label') && cdi.label) {\n            thisText.push(cdi.label);\n        }\n\n        if(cdi.hasOwnProperty('v') && hasFlag('value')) {\n            thisText.push(helpers.formatValue(cdi.v, separators));\n        }\n\n        if(!isRoot) {\n            if(hasFlag('current path')) {\n                thisText.push(helpers.getPath(pt.data));\n            }\n\n            var nPercent = 0;\n            if(hasFlag('percent parent')) nPercent++;\n            if(hasFlag('percent entry')) nPercent++;\n            if(hasFlag('percent root')) nPercent++;\n            var hasMultiplePercents = nPercent > 1;\n\n            if(nPercent) {\n                var percent;\n                var addPercent = function(key) {\n                    tx = helpers.formatPercent(percent, separators);\n\n                    if(hasMultiplePercents) tx += ' of ' + key;\n                    thisText.push(tx);\n                };\n\n                if(hasFlag('percent parent') && !isRoot) {\n                    percent = val / helpers.getValue(parent);\n                    addPercent('parent');\n                }\n                if(hasFlag('percent entry')) {\n                    percent = val / helpers.getValue(entry);\n                    addPercent('entry');\n                }\n                if(hasFlag('percent root')) {\n                    percent = val / helpers.getValue(hierarchy);\n                    addPercent('root');\n                }\n            }\n        }\n\n        if(hasFlag('text')) {\n            tx = Lib.castOption(trace, cdi.i, 'text');\n            if(Lib.isValidTextValue(tx)) thisText.push(tx);\n        }\n\n        return thisText.join('<br>');\n    }\n\n    var txt = Lib.castOption(trace, cdi.i, 'texttemplate');\n    if(!txt) return '';\n    var obj = {};\n    if(cdi.label) obj.label = cdi.label;\n    if(cdi.hasOwnProperty('v')) {\n        obj.value = cdi.v;\n        obj.valueLabel = helpers.formatValue(cdi.v, separators);\n    }\n\n    obj.currentPath = helpers.getPath(pt.data);\n\n    if(!isRoot) {\n        obj.percentParent = val / helpers.getValue(parent);\n        obj.percentParentLabel = helpers.formatPercent(\n            obj.percentParent, separators\n        );\n        obj.parent = helpers.getPtLabel(parent);\n    }\n\n    obj.percentEntry = val / helpers.getValue(entry);\n    obj.percentEntryLabel = helpers.formatPercent(\n        obj.percentEntry, separators\n    );\n    obj.entry = helpers.getPtLabel(entry);\n\n    obj.percentRoot = val / helpers.getValue(hierarchy);\n    obj.percentRootLabel = helpers.formatPercent(\n        obj.percentRoot, separators\n    );\n    obj.root = helpers.getPtLabel(hierarchy);\n\n    if(cdi.hasOwnProperty('color')) {\n        obj.color = cdi.color;\n    }\n    var ptTx = Lib.castOption(trace, cdi.i, 'text');\n    if(Lib.isValidTextValue(ptTx) || ptTx === '') obj.text = ptTx;\n    obj.customdata = Lib.castOption(trace, cdi.i, 'customdata');\n    return Lib.texttemplateString(txt, obj, fullLayout._d3locale, obj, trace._meta || {});\n};\n\nfunction getInscribedRadiusFraction(pt) {\n    if(pt.rpx0 === 0 && Lib.isFullCircle([pt.x0, pt.x1])) {\n        // special case of 100% with no hole\n        return 1;\n    } else {\n        return Math.max(0, Math.min(\n            1 / (1 + 1 / Math.sin(pt.halfangle)),\n            pt.ring / 2\n        ));\n    }\n}\n\nfunction getTextXY(d) {\n    return getCoords(d.rpx1, d.transform.textPosAngle);\n}\n\nfunction getCoords(r, angle) {\n    return [r * Math.sin(angle), -r * Math.cos(angle)];\n}\n"]},"metadata":{},"sourceType":"script"}