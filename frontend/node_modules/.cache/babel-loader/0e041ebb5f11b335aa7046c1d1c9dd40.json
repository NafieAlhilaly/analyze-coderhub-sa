{"ast":null,"code":"'use strict';\n\nvar boxAttrs = require('../box/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar axisHoverFormat = require('../../plots/cartesian/axis_format_attributes').axisHoverFormat;\n\nmodule.exports = {\n  y: boxAttrs.y,\n  x: boxAttrs.x,\n  x0: boxAttrs.x0,\n  y0: boxAttrs.y0,\n  xhoverformat: axisHoverFormat('x'),\n  yhoverformat: axisHoverFormat('y'),\n  name: extendFlat({}, boxAttrs.name, {\n    description: ['Sets the trace name.', 'The trace name appear as the legend item and on hover.', 'For violin traces, the name will also be used for the position', 'coordinate, if `x` and `x0` (`y` and `y0` if horizontal) are', 'missing and the position axis is categorical.', 'Note that the trace name is also used as a default value', 'for attribute `scalegroup` (please see its description for details).'].join(' ')\n  }),\n  orientation: extendFlat({}, boxAttrs.orientation, {\n    description: ['Sets the orientation of the violin(s).', 'If *v* (*h*), the distribution is visualized along', 'the vertical (horizontal).'].join(' ')\n  }),\n  bandwidth: {\n    valType: 'number',\n    min: 0,\n    editType: 'calc',\n    description: ['Sets the bandwidth used to compute the kernel density estimate.', 'By default, the bandwidth is determined by Silverman\\'s rule of thumb.'].join(' ')\n  },\n  scalegroup: {\n    valType: 'string',\n    dflt: '',\n    editType: 'calc',\n    description: ['If there are multiple violins that should be sized according to', 'to some metric (see `scalemode`), link them by providing a non-empty group id here', 'shared by every trace in the same group.', 'If a violin\\'s `width` is undefined, `scalegroup` will default to the trace\\'s name.', 'In this case, violins with the same names will be linked together'].join(' ')\n  },\n  scalemode: {\n    valType: 'enumerated',\n    values: ['width', 'count'],\n    dflt: 'width',\n    editType: 'calc',\n    description: ['Sets the metric by which the width of each violin is determined.', '*width* means each violin has the same (max) width', '*count* means the violins are scaled by the number of sample points making', 'up each violin.'].join('')\n  },\n  spanmode: {\n    valType: 'enumerated',\n    values: ['soft', 'hard', 'manual'],\n    dflt: 'soft',\n    editType: 'calc',\n    description: ['Sets the method by which the span in data space where the density function will be computed.', '*soft* means the span goes from the sample\\'s minimum value minus two bandwidths', 'to the sample\\'s maximum value plus two bandwidths.', '*hard* means the span goes from the sample\\'s minimum to its maximum value.', 'For custom span settings, use mode *manual* and fill in the `span` attribute.'].join(' ')\n  },\n  span: {\n    valType: 'info_array',\n    items: [{\n      valType: 'any',\n      editType: 'calc'\n    }, {\n      valType: 'any',\n      editType: 'calc'\n    }],\n    editType: 'calc',\n    description: ['Sets the span in data space for which the density function will be computed.', 'Has an effect only when `spanmode` is set to *manual*.'].join(' ')\n  },\n  line: {\n    color: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the color of line bounding the violin(s).'\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      dflt: 2,\n      editType: 'style',\n      description: 'Sets the width (in px) of line bounding the violin(s).'\n    },\n    editType: 'plot'\n  },\n  fillcolor: boxAttrs.fillcolor,\n  points: extendFlat({}, boxAttrs.boxpoints, {\n    description: ['If *outliers*, only the sample points lying outside the whiskers', 'are shown', 'If *suspectedoutliers*, the outlier points are shown and', 'points either less than 4*Q1-3*Q3 or greater than 4*Q3-3*Q1', 'are highlighted (see `outliercolor`)', 'If *all*, all sample points are shown', 'If *false*, only the violins are shown with no sample points.', 'Defaults to *suspectedoutliers* when `marker.outliercolor` or', '`marker.line.outliercolor` is set,', 'otherwise defaults to *outliers*.'].join(' ')\n  }),\n  jitter: extendFlat({}, boxAttrs.jitter, {\n    description: ['Sets the amount of jitter in the sample points drawn.', 'If *0*, the sample points align along the distribution axis.', 'If *1*, the sample points are drawn in a random jitter of width', 'equal to the width of the violins.'].join(' ')\n  }),\n  pointpos: extendFlat({}, boxAttrs.pointpos, {\n    description: ['Sets the position of the sample points in relation to the violins.', 'If *0*, the sample points are places over the center of the violins.', 'Positive (negative) values correspond to positions to the', 'right (left) for vertical violins and above (below) for horizontal violins.'].join(' ')\n  }),\n  width: extendFlat({}, boxAttrs.width, {\n    description: ['Sets the width of the violin in data coordinates.', 'If *0* (default value) the width is automatically selected based on the positions', 'of other violin traces in the same subplot.'].join(' ')\n  }),\n  marker: boxAttrs.marker,\n  text: boxAttrs.text,\n  hovertext: boxAttrs.hovertext,\n  hovertemplate: boxAttrs.hovertemplate,\n  box: {\n    visible: {\n      valType: 'boolean',\n      dflt: false,\n      editType: 'plot',\n      description: ['Determines if an miniature box plot is drawn inside the violins. '].join(' ')\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      max: 1,\n      dflt: 0.25,\n      editType: 'plot',\n      description: ['Sets the width of the inner box plots relative to', 'the violins\\' width.', 'For example, with 1, the inner box plots are as wide as the violins.'].join(' ')\n    },\n    fillcolor: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the inner box plot fill color.'\n    },\n    line: {\n      color: {\n        valType: 'color',\n        editType: 'style',\n        description: 'Sets the inner box plot bounding line color.'\n      },\n      width: {\n        valType: 'number',\n        min: 0,\n        editType: 'style',\n        description: 'Sets the inner box plot bounding line width.'\n      },\n      editType: 'style'\n    },\n    editType: 'plot'\n  },\n  meanline: {\n    visible: {\n      valType: 'boolean',\n      dflt: false,\n      editType: 'plot',\n      description: ['Determines if a line corresponding to the sample\\'s mean is shown', 'inside the violins.', 'If `box.visible` is turned on, the mean line is drawn inside the inner box.', 'Otherwise, the mean line is drawn from one side of the violin to other.'].join(' ')\n    },\n    color: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the mean line color.'\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      editType: 'style',\n      description: 'Sets the mean line width.'\n    },\n    editType: 'plot'\n  },\n  side: {\n    valType: 'enumerated',\n    values: ['both', 'positive', 'negative'],\n    dflt: 'both',\n    editType: 'calc',\n    description: ['Determines on which side of the position value the density function making up', 'one half of a violin is plotted.', 'Useful when comparing two violin traces under *overlay* mode, where one trace', 'has `side` set to *positive* and the other to *negative*.'].join(' ')\n  },\n  offsetgroup: boxAttrs.offsetgroup,\n  alignmentgroup: boxAttrs.alignmentgroup,\n  selected: boxAttrs.selected,\n  unselected: boxAttrs.unselected,\n  hoveron: {\n    valType: 'flaglist',\n    flags: ['violins', 'points', 'kde'],\n    dflt: 'violins+points+kde',\n    extras: ['all'],\n    editType: 'style',\n    description: ['Do the hover effects highlight individual violins', 'or sample points or the kernel density estimate or any combination of them?'].join(' ')\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/violin/attributes.js"],"names":["boxAttrs","require","extendFlat","axisHoverFormat","module","exports","y","x","x0","y0","xhoverformat","yhoverformat","name","description","join","orientation","bandwidth","valType","min","editType","scalegroup","dflt","scalemode","values","spanmode","span","items","line","color","width","fillcolor","points","boxpoints","jitter","pointpos","marker","text","hovertext","hovertemplate","box","visible","max","meanline","side","offsetgroup","alignmentgroup","selected","unselected","hoveron","flags","extras"],"mappings":"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","sourcesContent":["'use strict';\n\nvar boxAttrs = require('../box/attributes');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar axisHoverFormat = require('../../plots/cartesian/axis_format_attributes').axisHoverFormat;\n\nmodule.exports = {\n    y: boxAttrs.y,\n    x: boxAttrs.x,\n    x0: boxAttrs.x0,\n    y0: boxAttrs.y0,\n\n    xhoverformat: axisHoverFormat('x'),\n    yhoverformat: axisHoverFormat('y'),\n\n    name: extendFlat({}, boxAttrs.name, {\n        description: [\n            'Sets the trace name.',\n            'The trace name appear as the legend item and on hover.',\n            'For violin traces, the name will also be used for the position',\n            'coordinate, if `x` and `x0` (`y` and `y0` if horizontal) are',\n            'missing and the position axis is categorical.',\n            'Note that the trace name is also used as a default value',\n            'for attribute `scalegroup` (please see its description for details).'\n        ].join(' ')\n    }),\n    orientation: extendFlat({}, boxAttrs.orientation, {\n        description: [\n            'Sets the orientation of the violin(s).',\n            'If *v* (*h*), the distribution is visualized along',\n            'the vertical (horizontal).'\n        ].join(' ')\n    }),\n\n    bandwidth: {\n        valType: 'number',\n        min: 0,\n        editType: 'calc',\n        description: [\n            'Sets the bandwidth used to compute the kernel density estimate.',\n            'By default, the bandwidth is determined by Silverman\\'s rule of thumb.'\n        ].join(' ')\n    },\n\n    scalegroup: {\n        valType: 'string',\n        dflt: '',\n        editType: 'calc',\n        description: [\n            'If there are multiple violins that should be sized according to',\n            'to some metric (see `scalemode`), link them by providing a non-empty group id here',\n            'shared by every trace in the same group.',\n            'If a violin\\'s `width` is undefined, `scalegroup` will default to the trace\\'s name.',\n            'In this case, violins with the same names will be linked together'\n        ].join(' ')\n    },\n    scalemode: {\n        valType: 'enumerated',\n        values: ['width', 'count'],\n        dflt: 'width',\n        editType: 'calc',\n        description: [\n            'Sets the metric by which the width of each violin is determined.',\n            '*width* means each violin has the same (max) width',\n            '*count* means the violins are scaled by the number of sample points making',\n            'up each violin.'\n        ].join('')\n    },\n\n    spanmode: {\n        valType: 'enumerated',\n        values: ['soft', 'hard', 'manual'],\n        dflt: 'soft',\n        editType: 'calc',\n        description: [\n            'Sets the method by which the span in data space where the density function will be computed.',\n            '*soft* means the span goes from the sample\\'s minimum value minus two bandwidths',\n            'to the sample\\'s maximum value plus two bandwidths.',\n            '*hard* means the span goes from the sample\\'s minimum to its maximum value.',\n            'For custom span settings, use mode *manual* and fill in the `span` attribute.'\n        ].join(' ')\n    },\n    span: {\n        valType: 'info_array',\n        items: [\n            {valType: 'any', editType: 'calc'},\n            {valType: 'any', editType: 'calc'}\n        ],\n        editType: 'calc',\n        description: [\n            'Sets the span in data space for which the density function will be computed.',\n            'Has an effect only when `spanmode` is set to *manual*.'\n        ].join(' ')\n    },\n\n    line: {\n        color: {\n            valType: 'color',\n            editType: 'style',\n            description: 'Sets the color of line bounding the violin(s).'\n        },\n        width: {\n            valType: 'number',\n            min: 0,\n            dflt: 2,\n            editType: 'style',\n            description: 'Sets the width (in px) of line bounding the violin(s).'\n        },\n        editType: 'plot'\n    },\n    fillcolor: boxAttrs.fillcolor,\n\n    points: extendFlat({}, boxAttrs.boxpoints, {\n        description: [\n            'If *outliers*, only the sample points lying outside the whiskers',\n            'are shown',\n            'If *suspectedoutliers*, the outlier points are shown and',\n            'points either less than 4*Q1-3*Q3 or greater than 4*Q3-3*Q1',\n            'are highlighted (see `outliercolor`)',\n            'If *all*, all sample points are shown',\n            'If *false*, only the violins are shown with no sample points.',\n            'Defaults to *suspectedoutliers* when `marker.outliercolor` or',\n            '`marker.line.outliercolor` is set,',\n            'otherwise defaults to *outliers*.'\n        ].join(' ')\n    }),\n    jitter: extendFlat({}, boxAttrs.jitter, {\n        description: [\n            'Sets the amount of jitter in the sample points drawn.',\n            'If *0*, the sample points align along the distribution axis.',\n            'If *1*, the sample points are drawn in a random jitter of width',\n            'equal to the width of the violins.'\n        ].join(' ')\n    }),\n    pointpos: extendFlat({}, boxAttrs.pointpos, {\n        description: [\n            'Sets the position of the sample points in relation to the violins.',\n            'If *0*, the sample points are places over the center of the violins.',\n            'Positive (negative) values correspond to positions to the',\n            'right (left) for vertical violins and above (below) for horizontal violins.'\n        ].join(' ')\n    }),\n\n    width: extendFlat({}, boxAttrs.width, {\n        description: [\n            'Sets the width of the violin in data coordinates.',\n            'If *0* (default value) the width is automatically selected based on the positions',\n            'of other violin traces in the same subplot.',\n        ].join(' ')\n    }),\n\n    marker: boxAttrs.marker,\n    text: boxAttrs.text,\n    hovertext: boxAttrs.hovertext,\n    hovertemplate: boxAttrs.hovertemplate,\n\n    box: {\n        visible: {\n            valType: 'boolean',\n            dflt: false,\n            editType: 'plot',\n            description: [\n                'Determines if an miniature box plot is drawn inside the violins. '\n            ].join(' ')\n        },\n        width: {\n            valType: 'number',\n            min: 0,\n            max: 1,\n            dflt: 0.25,\n            editType: 'plot',\n            description: [\n                'Sets the width of the inner box plots relative to',\n                'the violins\\' width.',\n                'For example, with 1, the inner box plots are as wide as the violins.'\n            ].join(' ')\n        },\n        fillcolor: {\n            valType: 'color',\n            editType: 'style',\n            description: 'Sets the inner box plot fill color.'\n        },\n        line: {\n            color: {\n                valType: 'color',\n                editType: 'style',\n                description: 'Sets the inner box plot bounding line color.'\n            },\n            width: {\n                valType: 'number',\n                min: 0,\n                editType: 'style',\n                description: 'Sets the inner box plot bounding line width.'\n            },\n            editType: 'style'\n        },\n        editType: 'plot'\n    },\n\n    meanline: {\n        visible: {\n            valType: 'boolean',\n            dflt: false,\n            editType: 'plot',\n            description: [\n                'Determines if a line corresponding to the sample\\'s mean is shown',\n                'inside the violins.',\n                'If `box.visible` is turned on, the mean line is drawn inside the inner box.',\n                'Otherwise, the mean line is drawn from one side of the violin to other.'\n            ].join(' ')\n        },\n        color: {\n            valType: 'color',\n            editType: 'style',\n            description: 'Sets the mean line color.'\n        },\n        width: {\n            valType: 'number',\n            min: 0,\n            editType: 'style',\n            description: 'Sets the mean line width.'\n        },\n        editType: 'plot'\n    },\n\n    side: {\n        valType: 'enumerated',\n        values: ['both', 'positive', 'negative'],\n        dflt: 'both',\n        editType: 'calc',\n        description: [\n            'Determines on which side of the position value the density function making up',\n            'one half of a violin is plotted.',\n            'Useful when comparing two violin traces under *overlay* mode, where one trace',\n            'has `side` set to *positive* and the other to *negative*.'\n        ].join(' ')\n    },\n\n    offsetgroup: boxAttrs.offsetgroup,\n    alignmentgroup: boxAttrs.alignmentgroup,\n\n    selected: boxAttrs.selected,\n    unselected: boxAttrs.unselected,\n\n    hoveron: {\n        valType: 'flaglist',\n        flags: ['violins', 'points', 'kde'],\n        dflt: 'violins+points+kde',\n        extras: ['all'],\n        editType: 'style',\n        description: [\n            'Do the hover effects highlight individual violins',\n            'or sample points or the kernel density estimate or any combination of them?'\n        ].join(' ')\n    }\n};\n"]},"metadata":{},"sourceType":"script"}