{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar utcFormat = require('d3-time-format').utcFormat;\n\nvar Lib = require('../../lib');\n\nvar numberFormat = Lib.numberFormat;\n\nvar isNumeric = require('fast-isnumeric');\n\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\nvar numConstants = require('../../constants/numerical');\n\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar ONEWEEK = numConstants.ONEWEEK;\nvar ONEDAY = numConstants.ONEDAY;\nvar ONEHOUR = numConstants.ONEHOUR;\nvar ONEMIN = numConstants.ONEMIN;\nvar ONESEC = numConstants.ONESEC;\n\nvar axisIds = require('./axis_ids');\n\nvar constants = require('./constants');\n\nvar HOUR_PATTERN = constants.HOUR_PATTERN;\nvar WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;\n\nfunction fromLog(v) {\n  return Math.pow(10, v);\n}\n\nfunction isValidCategory(v) {\n  return v !== null && v !== undefined;\n}\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v3.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\n\n\nmodule.exports = function setConvert(ax, fullLayout) {\n  fullLayout = fullLayout || {};\n  var axId = ax._id || 'x';\n  var axLetter = axId.charAt(0);\n\n  function toLog(v, clip) {\n    if (v > 0) return Math.log(v) / Math.LN10;else if (v <= 0 && clip && ax.range && ax.range.length === 2) {\n      // clip NaN (ie past negative infinity) to LOG_CLIP axis\n      // length past the negative edge\n      var r0 = ax.range[0];\n      var r1 = ax.range[1];\n      return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n    } else return BADNUM;\n  }\n  /*\n   * wrapped dateTime2ms that:\n   * - accepts ms numbers for backward compatibility\n   * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n   * - defaults to ax.calendar\n   */\n\n\n  function dt2ms(v, _, calendar, opts) {\n    if ((opts || {}).msUTC && isNumeric(v)) {\n      // For now it is only used\n      // to fix bar length in milliseconds & gl3d ticks\n      // It could be applied in other places in v3\n      return +v;\n    } // NOTE: Changed this behavior: previously we took any numeric value\n    // to be a ms, even if it was a string that could be a bare year.\n    // Now we convert it as a date if at all possible, and only try\n    // as (local) ms if that fails.\n\n\n    var ms = dateTime2ms(v, calendar || ax.calendar);\n\n    if (ms === BADNUM) {\n      if (isNumeric(v)) {\n        v = +v; // keep track of tenths of ms, that `new Date` will drop\n        // same logic as in Lib.ms2DateTime\n\n        var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n        var msRounded = Math.round(v - msecTenths / 10);\n        ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n      } else return BADNUM;\n    }\n\n    return ms;\n  } // wrapped ms2DateTime to insert default ax.calendar\n\n\n  function ms2dt(v, r, calendar) {\n    return ms2DateTime(v, r, calendar || ax.calendar);\n  }\n\n  function getCategoryName(v) {\n    return ax._categories[Math.round(v)];\n  }\n  /*\n   * setCategoryIndex: return the index of category v,\n   * inserting it in the list if it's not already there\n   *\n   * this will enter the categories in the order it\n   * encounters them, ie all the categories from the\n   * first data set, then all the ones from the second\n   * that aren't in the first etc.\n   *\n   * it is assumed that this function is being invoked in the\n   * already sorted category order; otherwise there would be\n   * a disconnect between the array and the index returned\n   */\n\n\n  function setCategoryIndex(v) {\n    if (isValidCategory(v)) {\n      if (ax._categoriesMap === undefined) {\n        ax._categoriesMap = {};\n      }\n\n      if (ax._categoriesMap[v] !== undefined) {\n        return ax._categoriesMap[v];\n      } else {\n        ax._categories.push(typeof v === 'number' ? String(v) : v);\n\n        var curLength = ax._categories.length - 1;\n        ax._categoriesMap[v] = curLength;\n        return curLength;\n      }\n    }\n\n    return BADNUM;\n  }\n\n  function setMultiCategoryIndex(arrayIn, len) {\n    var arrayOut = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var v0 = (arrayIn[0] || [])[i];\n      var v1 = (arrayIn[1] || [])[i];\n      arrayOut[i] = getCategoryIndex([v0, v1]);\n    }\n\n    return arrayOut;\n  }\n\n  function getCategoryIndex(v) {\n    if (ax._categoriesMap) {\n      return ax._categoriesMap[v];\n    }\n  }\n\n  function getCategoryPosition(v) {\n    // d2l/d2c variant that that won't add categories but will also\n    // allow numbers to be mapped to the linearized axis positions\n    var index = getCategoryIndex(v);\n    if (index !== undefined) return index;\n    if (isNumeric(v)) return +v;\n  }\n\n  function getRangePosition(v) {\n    return isNumeric(v) ? +v : getCategoryIndex(v);\n  } // include 2 fractional digits on pixel, for PDF zooming etc\n\n\n  function _l2p(v, m, b) {\n    return d3.round(b + m * v, 2);\n  }\n\n  function _p2l(px, m, b) {\n    return (px - b) / m;\n  }\n\n  var l2p = function l2p(v) {\n    if (!isNumeric(v)) return BADNUM;\n    return _l2p(v, ax._m, ax._b);\n  };\n\n  var p2l = function p2l(px) {\n    return _p2l(px, ax._m, ax._b);\n  };\n\n  if (ax.rangebreaks) {\n    var isY = axLetter === 'y';\n\n    l2p = function l2p(v) {\n      if (!isNumeric(v)) return BADNUM;\n      var len = ax._rangebreaks.length;\n      if (!len) return _l2p(v, ax._m, ax._b);\n      var flip = isY;\n      if (ax.range[0] > ax.range[1]) flip = !flip;\n      var signAx = flip ? -1 : 1;\n      var pos = signAx * v;\n      var q = 0;\n\n      for (var i = 0; i < len; i++) {\n        var min = signAx * ax._rangebreaks[i].min;\n        var max = signAx * ax._rangebreaks[i].max;\n        if (pos < min) break;\n        if (pos > max) q = i + 1;else {\n          // when falls into break, pick 'closest' offset\n          q = pos < (min + max) / 2 ? i : i + 1;\n          break;\n        }\n      }\n\n      var b2 = ax._B[q] || 0;\n      if (!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break\n\n      return _l2p(v, ax._m2, b2);\n    };\n\n    p2l = function p2l(px) {\n      var len = ax._rangebreaks.length;\n      if (!len) return _p2l(px, ax._m, ax._b);\n      var q = 0;\n\n      for (var i = 0; i < len; i++) {\n        if (px < ax._rangebreaks[i].pmin) break;\n        if (px > ax._rangebreaks[i].pmax) q = i + 1;\n      }\n\n      return _p2l(px, ax._m2, ax._B[q]);\n    };\n  } // conversions among c/l/p are fairly simple - do them together for all axis types\n\n\n  ax.c2l = ax.type === 'log' ? toLog : ensureNumber;\n  ax.l2c = ax.type === 'log' ? fromLog : ensureNumber;\n  ax.l2p = l2p;\n  ax.p2l = p2l;\n  ax.c2p = ax.type === 'log' ? function (v, clip) {\n    return l2p(toLog(v, clip));\n  } : l2p;\n  ax.p2c = ax.type === 'log' ? function (px) {\n    return fromLog(p2l(px));\n  } : p2l;\n  /*\n   * now type-specific conversions for **ALL** other combinations\n   * they're all written out, instead of being combinations of each other, for\n   * both clarity and speed.\n   */\n\n  if (['linear', '-'].indexOf(ax.type) !== -1) {\n    // all are data vals, but d and r need cleaning\n    ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n\n    ax.d2p = ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n\n    ax.p2d = ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'log') {\n    // d and c are data vals, r and l are logged (but d and r need cleaning)\n    ax.d2r = ax.d2l = function (v, clip) {\n      return toLog(cleanNumber(v), clip);\n    };\n\n    ax.r2d = ax.r2c = function (v) {\n      return fromLog(cleanNumber(v));\n    };\n\n    ax.d2c = ax.r2l = cleanNumber;\n    ax.c2d = ax.l2r = ensureNumber;\n    ax.c2r = toLog;\n    ax.l2d = fromLog;\n\n    ax.d2p = function (v, clip) {\n      return ax.l2p(ax.d2r(v, clip));\n    };\n\n    ax.p2d = function (px) {\n      return fromLog(p2l(px));\n    };\n\n    ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n\n    ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'date') {\n    // r and d are date strings, l and c are ms\n\n    /*\n     * Any of these functions with r and d on either side, calendar is the\n     * **3rd** argument. log has reserved the second argument.\n     *\n     * Unless you need the special behavior of the second arg (ms2DateTime\n     * uses this to limit precision, toLog uses true to clip negatives\n     * to offscreen low rather than undefined), it's safe to pass 0.\n     */\n    ax.d2r = ax.r2d = Lib.identity;\n    ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n    ax.d2p = ax.r2p = function (v, _, calendar) {\n      return ax.l2p(dt2ms(v, 0, calendar));\n    };\n\n    ax.p2d = ax.p2r = function (px, r, calendar) {\n      return ms2dt(p2l(px), r, calendar);\n    };\n\n    ax.cleanPos = function (v) {\n      return Lib.cleanDate(v, BADNUM, ax.calendar);\n    };\n  } else if (ax.type === 'category') {\n    // d is categories (string)\n    // c and l are indices (numbers)\n    // r is categories or numbers\n    ax.d2c = ax.d2l = setCategoryIndex;\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n    ax.r2c = function (v) {\n      var index = getRangePosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getRangePosition;\n\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n\n    ax.cleanPos = function (v) {\n      if (typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n  } else if (ax.type === 'multicategory') {\n    // N.B. multicategory axes don't define d2c and d2l,\n    // as 'data-to-calcdata' conversion needs to take into\n    // account all data array items as in ax.makeCalcdata.\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n    ax.r2c = function (v) {\n      var index = getCategoryPosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n\n    ax.r2c_just_indices = getCategoryIndex;\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getCategoryPosition;\n\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n\n    ax.cleanPos = function (v) {\n      if (Array.isArray(v) || typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n\n    ax.setupMultiCategory = function (fullData) {\n      var traceIndices = ax._traceIndices;\n      var i, j;\n      var group = ax._matchGroup;\n\n      if (group && ax._categories.length === 0) {\n        for (var axId2 in group) {\n          if (axId2 !== axId) {\n            var ax2 = fullLayout[axisIds.id2name(axId2)];\n            traceIndices = traceIndices.concat(ax2._traceIndices);\n          }\n        }\n      } // [ [cnt, {$cat: index}], for 1,2 ]\n\n\n      var seen = [[0, {}], [0, {}]]; // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n\n      var list = [];\n\n      for (i = 0; i < traceIndices.length; i++) {\n        var trace = fullData[traceIndices[i]];\n\n        if (axLetter in trace) {\n          var arrayIn = trace[axLetter];\n          var len = trace._length || Lib.minRowLength(arrayIn);\n\n          if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n            for (j = 0; j < len; j++) {\n              var v0 = arrayIn[0][j];\n              var v1 = arrayIn[1][j];\n\n              if (isValidCategory(v0) && isValidCategory(v1)) {\n                list.push([v0, v1]);\n\n                if (!(v0 in seen[0][1])) {\n                  seen[0][1][v0] = seen[0][0]++;\n                }\n\n                if (!(v1 in seen[1][1])) {\n                  seen[1][1][v1] = seen[1][0]++;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      list.sort(function (a, b) {\n        var ind0 = seen[0][1];\n        var d = ind0[a[0]] - ind0[b[0]];\n        if (d) return d;\n        var ind1 = seen[1][1];\n        return ind1[a[1]] - ind1[b[1]];\n      });\n\n      for (i = 0; i < list.length; i++) {\n        setCategoryIndex(list[i]);\n      }\n    };\n  } // find the range value at the specified (linear) fraction of the axis\n\n\n  ax.fraction2r = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return ax.l2r(rl0 + v * (rl1 - rl0));\n  }; // find the fraction of the range at the specified range value\n\n\n  ax.r2fraction = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return (ax.r2l(v) - rl0) / (rl1 - rl0);\n  };\n  /*\n   * cleanRange: make sure range is a couplet of valid & distinct values\n   * keep numbers away from the limits of floating point numbers,\n   * and dates away from the ends of our date system (+/- 9999 years)\n   *\n   * optional param rangeAttr: operate on a different attribute, like\n   * ax._r, rather than ax.range\n   */\n\n\n  ax.cleanRange = function (rangeAttr, opts) {\n    if (!opts) opts = {};\n    if (!rangeAttr) rangeAttr = 'range';\n    var range = Lib.nestedProperty(ax, rangeAttr).get();\n    var i, dflt;\n    if (ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);else if (axLetter === 'y') dflt = constants.DFLTRANGEY;else dflt = opts.dfltRange || constants.DFLTRANGEX; // make sure we don't later mutate the defaults\n\n    dflt = dflt.slice();\n\n    if (ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {\n      dflt[0] = 0;\n    }\n\n    if (!range || range.length !== 2) {\n      Lib.nestedProperty(ax, rangeAttr).set(dflt);\n      return;\n    }\n\n    if (ax.type === 'date' && !ax.autorange) {\n      // check if milliseconds or js date objects are provided for range\n      // and convert to date strings\n      range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n      range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n    }\n\n    for (i = 0; i < 2; i++) {\n      if (ax.type === 'date') {\n        if (!Lib.isDateTime(range[i], ax.calendar)) {\n          ax[rangeAttr] = dflt;\n          break;\n        }\n\n        if (ax.r2l(range[0]) === ax.r2l(range[1])) {\n          // split by +/- 1 second\n          var linCenter = Lib.constrain(ax.r2l(range[0]), Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n          range[0] = ax.l2r(linCenter - 1000);\n          range[1] = ax.l2r(linCenter + 1000);\n          break;\n        }\n      } else {\n        if (!isNumeric(range[i])) {\n          if (isNumeric(range[1 - i])) {\n            range[i] = range[1 - i] * (i ? 10 : 0.1);\n          } else {\n            ax[rangeAttr] = dflt;\n            break;\n          }\n        }\n\n        if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;else if (range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n        if (range[0] === range[1]) {\n          // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n          var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n          range[0] -= inc;\n          range[1] += inc;\n        }\n      }\n    }\n  }; // set scaling to pixels\n\n\n  ax.setScale = function (usePrivateRange) {\n    var gs = fullLayout._size; // make sure we have a domain (pull it in from the axis\n    // this one is overlaying if necessary)\n\n    if (ax.overlaying) {\n      var ax2 = axisIds.getFromId({\n        _fullLayout: fullLayout\n      }, ax.overlaying);\n      ax.domain = ax2.domain;\n    } // While transitions are occurring, we get a double-transform\n    // issue if we transform the drawn layer *and* use the new axis range to\n    // draw the data. This allows us to construct setConvert using the pre-\n    // interaction values of the range:\n\n\n    var rangeAttr = usePrivateRange && ax._r ? '_r' : 'range';\n    var calendar = ax.calendar;\n    ax.cleanRange(rangeAttr);\n    var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n    var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n    var isY = axLetter === 'y';\n\n    if (isY) {\n      ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n      ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl0 - rl1);\n      ax._b = -ax._m * rl1;\n    } else {\n      ax._offset = gs.l + ax.domain[0] * gs.w;\n      ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl1 - rl0);\n      ax._b = -ax._m * rl0;\n    } // set of \"N\" disjoint rangebreaks inside the range\n\n\n    ax._rangebreaks = []; // length of these rangebreaks in value space - negative on reversed axes\n\n    ax._lBreaks = 0; // l2p slope (same for all intervals)\n\n    ax._m2 = 0; // set of l2p offsets (one for each of the (N+1) piecewise intervals)\n\n    ax._B = [];\n\n    if (ax.rangebreaks) {\n      var i, brk;\n      ax._rangebreaks = ax.locateBreaks(Math.min(rl0, rl1), Math.max(rl0, rl1));\n\n      if (ax._rangebreaks.length) {\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          ax._lBreaks += Math.abs(brk.max - brk.min);\n        }\n\n        var flip = isY;\n        if (rl0 > rl1) flip = !flip;\n        if (flip) ax._rangebreaks.reverse();\n        var sign = flip ? -1 : 1;\n        ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);\n\n        ax._B.push(-ax._m2 * (isY ? rl1 : rl0));\n\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n\n          ax._B.push(ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min));\n        } // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2l`\n\n\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          brk.pmin = l2p(brk.min);\n          brk.pmax = l2p(brk.max);\n        }\n      }\n    }\n\n    if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {\n      fullLayout._replotting = false;\n      throw new Error('Something went wrong with axis scaling');\n    }\n  };\n\n  ax.maskBreaks = function (v) {\n    var rangebreaksIn = ax.rangebreaks || [];\n    var bnds, b0, b1, vb, vDate;\n\n    if (!rangebreaksIn._cachedPatterns) {\n      rangebreaksIn._cachedPatterns = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.d2c // case of pattern: ''\n        ) : null;\n      });\n    }\n\n    if (!rangebreaksIn._cachedValues) {\n      rangebreaksIn._cachedValues = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;\n      });\n    }\n\n    for (var i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var pattern = brk.pattern;\n          bnds = rangebreaksIn._cachedPatterns[i];\n          b0 = bnds[0];\n          b1 = bnds[1];\n\n          switch (pattern) {\n            case WEEKDAY_PATTERN:\n              vDate = new Date(v);\n              vb = vDate.getUTCDay();\n\n              if (b0 > b1) {\n                b1 += 7;\n                if (vb < b0) vb += 7;\n              }\n\n              break;\n\n            case HOUR_PATTERN:\n              vDate = new Date(v);\n              var hours = vDate.getUTCHours();\n              var minutes = vDate.getUTCMinutes();\n              var seconds = vDate.getUTCSeconds();\n              var milliseconds = vDate.getUTCMilliseconds();\n              vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 3600000);\n\n              if (b0 > b1) {\n                b1 += 24;\n                if (vb < b0) vb += 24;\n              }\n\n              break;\n\n            case '':\n              // N.B. should work on date axes as well!\n              // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }\n              // TODO should work with reversed-range axes\n              vb = v;\n              break;\n          }\n\n          if (vb >= b0 && vb < b1) return BADNUM;\n        } else {\n          var vals = rangebreaksIn._cachedValues[i];\n\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            if (v >= b0 && v < b1) return BADNUM;\n          }\n        }\n      }\n    }\n\n    return v;\n  };\n\n  ax.locateBreaks = function (r0, r1) {\n    var i, bnds, b0, b1;\n    var rangebreaksOut = [];\n    if (!ax.rangebreaks) return rangebreaksOut;\n    var rangebreaksIn = ax.rangebreaks.slice().sort(function (a, b) {\n      if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;\n      if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;\n      return 0;\n    });\n\n    var addBreak = function addBreak(min, max) {\n      min = Lib.constrain(min, r0, r1);\n      max = Lib.constrain(max, r0, r1);\n      if (min === max) return;\n      var isNewBreak = true;\n\n      for (var j = 0; j < rangebreaksOut.length; j++) {\n        var brkj = rangebreaksOut[j];\n\n        if (min < brkj.max && max >= brkj.min) {\n          if (min < brkj.min) {\n            brkj.min = min;\n          }\n\n          if (max > brkj.max) {\n            brkj.max = max;\n          }\n\n          isNewBreak = false;\n        }\n      }\n\n      if (isNewBreak) {\n        rangebreaksOut.push({\n          min: min,\n          max: max\n        });\n      }\n    };\n\n    for (i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var t0 = r0;\n          var t1 = r1;\n\n          if (brk.pattern) {\n            // to remove decimal (most often found in auto ranges)\n            t0 = Math.floor(t0);\n          }\n\n          bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);\n          b0 = bnds[0];\n          b1 = bnds[1]; // r0 value as date\n\n          var t0Date = new Date(t0); // r0 value for break pattern\n\n          var bndDelta; // step in ms between rangebreaks\n\n          var step;\n\n          switch (brk.pattern) {\n            case WEEKDAY_PATTERN:\n              step = ONEWEEK;\n              bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;\n              t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n\n            case HOUR_PATTERN:\n              step = ONEDAY;\n              bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;\n              t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n\n            default:\n              t0 = Math.min(bnds[0], bnds[1]);\n              t1 = Math.max(bnds[0], bnds[1]);\n              step = t1 - t0;\n              bndDelta = step;\n          }\n\n          for (var t = t0; t < t1; t += step) {\n            addBreak(t, t + bndDelta);\n          }\n        } else {\n          var vals = Lib.simpleMap(brk.values, ax.d2c);\n\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            addBreak(b0, b1);\n          }\n        }\n      }\n    }\n\n    rangebreaksOut.sort(function (a, b) {\n      return a.min - b.min;\n    });\n    return rangebreaksOut;\n  }; // makeCalcdata: takes an x or y array and converts it\n  // to a position on the axis object \"ax\"\n  // inputs:\n  //      trace - a data object from gd.data\n  //      axLetter - a string, either 'x' or 'y', for which item\n  //          to convert (TODO: is this now always the same as\n  //          the first letter of ax._id?)\n  // in case the expected data isn't there, make a list of\n  // integers based on the opposite data\n\n\n  ax.makeCalcdata = function (trace, axLetter, opts) {\n    var arrayIn, arrayOut, i, len;\n    var axType = ax.type;\n    var cal = axType === 'date' && trace[axLetter + 'calendar'];\n\n    if (axLetter in trace) {\n      arrayIn = trace[axLetter];\n      len = trace._length || Lib.minRowLength(arrayIn);\n\n      if (Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n\n      if (axType === 'multicategory') {\n        return setMultiCategoryIndex(arrayIn, len);\n      }\n\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);\n      }\n    } else {\n      var v0 = axLetter + '0' in trace ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n      var dv = trace['d' + axLetter] ? Number(trace['d' + axLetter]) : 1; // the opposing data, for size if we have x and dx etc\n\n      arrayIn = trace[{\n        x: 'y',\n        y: 'x'\n      }[axLetter]];\n      len = trace._length || arrayIn.length;\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    } // mask (i.e. set to BADNUM) coords that fall inside rangebreaks\n\n\n    if (ax.rangebreaks) {\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.maskBreaks(arrayOut[i]);\n      }\n    }\n\n    return arrayOut;\n  };\n\n  ax.isValidRange = function (range) {\n    return Array.isArray(range) && range.length === 2 && isNumeric(ax.r2l(range[0])) && isNumeric(ax.r2l(range[1]));\n  };\n\n  ax.isPtWithinRange = function (d, calendar) {\n    var coord = ax.c2l(d[axLetter], null, calendar);\n    var r0 = ax.r2l(ax.range[0]);\n    var r1 = ax.r2l(ax.range[1]);\n\n    if (r0 < r1) {\n      return r0 <= coord && coord <= r1;\n    } else {\n      // Reversed axis case.\n      return r1 <= coord && coord <= r0;\n    }\n  };\n\n  ax._emptyCategories = function () {\n    ax._categories = [];\n    ax._categoriesMap = {};\n  }; // should skip if not category nor multicategory\n\n\n  ax.clearCalc = function () {\n    var group = ax._matchGroup;\n\n    if (group) {\n      var categories = null;\n      var categoriesMap = null;\n\n      for (var axId2 in group) {\n        var ax2 = fullLayout[axisIds.id2name(axId2)];\n\n        if (ax2._categories) {\n          categories = ax2._categories;\n          categoriesMap = ax2._categoriesMap;\n          break;\n        }\n      }\n\n      if (categories && categoriesMap) {\n        ax._categories = categories;\n        ax._categoriesMap = categoriesMap;\n      } else {\n        ax._emptyCategories();\n      }\n    } else {\n      ax._emptyCategories();\n    }\n\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n  }; // sort the axis (and all the matching ones) by _initialCategories\n  // returns the indices of the traces affected by the reordering\n\n\n  ax.sortByInitialCategories = function () {\n    var affectedTraces = [];\n\n    ax._emptyCategories();\n\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n\n    affectedTraces = affectedTraces.concat(ax._traceIndices); // Propagate to matching axes\n\n    var group = ax._matchGroup;\n\n    for (var axId2 in group) {\n      if (axId === axId2) continue;\n      var ax2 = fullLayout[axisIds.id2name(axId2)];\n      ax2._categories = ax._categories;\n      ax2._categoriesMap = ax._categoriesMap;\n      affectedTraces = affectedTraces.concat(ax2._traceIndices);\n    }\n\n    return affectedTraces;\n  }; // Propagate localization into the axis so that\n  // methods in Axes can use it w/o having to pass fullLayout\n  // Default (non-d3) number formatting uses separators directly\n  // dates and d3-formatted numbers use the d3 locale\n  // Fall back on default format for dummy axes that don't care about formatting\n\n\n  var locale = fullLayout._d3locale;\n\n  if (ax.type === 'date') {\n    ax._dateFormat = locale ? locale.timeFormat : utcFormat;\n    ax._extraFormat = fullLayout._extraFormat;\n  } // occasionally we need _numFormat to pass through\n  // even though it won't be needed by this axis\n\n\n  ax._separators = fullLayout.separators;\n  ax._numFormat = locale ? locale.numberFormat : numberFormat; // and for bar charts and box plots: reset forced minimum tick spacing\n\n  delete ax._minDtick;\n  delete ax._forceTick0;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/cartesian/set_convert.js"],"names":["d3","require","utcFormat","Lib","numberFormat","isNumeric","cleanNumber","ms2DateTime","dateTime2ms","ensureNumber","isArrayOrTypedArray","numConstants","FP_SAFE","BADNUM","LOG_CLIP","ONEWEEK","ONEDAY","ONEHOUR","ONEMIN","ONESEC","axisIds","constants","HOUR_PATTERN","WEEKDAY_PATTERN","fromLog","v","Math","pow","isValidCategory","undefined","module","exports","setConvert","ax","fullLayout","axId","_id","axLetter","charAt","toLog","clip","log","LN10","range","length","r0","r1","abs","dt2ms","_","calendar","opts","msUTC","ms","msecTenths","floor","mod","msRounded","round","Date","ms2dt","r","getCategoryName","_categories","setCategoryIndex","_categoriesMap","push","String","curLength","setMultiCategoryIndex","arrayIn","len","arrayOut","Array","i","v0","v1","getCategoryIndex","getCategoryPosition","index","getRangePosition","_l2p","m","b","_p2l","px","l2p","_m","_b","p2l","rangebreaks","isY","_rangebreaks","flip","signAx","pos","q","min","max","b2","_B","isFinite","_m2","pmin","pmax","c2l","type","l2c","c2p","p2c","indexOf","d2r","r2d","d2c","r2c","d2l","r2l","c2d","c2r","l2d","l2r","d2p","r2p","p2d","p2r","cleanPos","identity","cleanDate","d2l_noadd","fraction2r","r2c_just_indices","isArray","setupMultiCategory","fullData","traceIndices","_traceIndices","j","group","_matchGroup","axId2","ax2","id2name","concat","seen","list","trace","_length","minRowLength","sort","a","ind0","d","ind1","rl0","rl1","r2fraction","cleanRange","rangeAttr","nestedProperty","get","dflt","dfltRange","DFLTRANGEY","DFLTRANGEX","slice","rangemode","set","autorange","isDateTime","linCenter","constrain","MIN_MS","MAX_MS","inc","setScale","usePrivateRange","gs","_size","overlaying","getFromId","_fullLayout","domain","_r","_offset","t","h","l","w","_lBreaks","brk","locateBreaks","reverse","sign","_replotting","Error","maskBreaks","rangebreaksIn","bnds","b0","b1","vb","vDate","_cachedPatterns","map","enabled","bounds","simpleMap","pattern","_cachedValues","values","sorterAsc","getUTCDay","hours","getUTCHours","minutes","getUTCMinutes","seconds","getUTCSeconds","milliseconds","getUTCMilliseconds","vals","dvalue","rangebreaksOut","addBreak","isNewBreak","brkj","t0","t1","t0Date","bndDelta","step","makeCalcdata","axType","cal","isTypedArray","subarray","dv","Number","x","y","isValidRange","isPtWithinRange","coord","_emptyCategories","clearCalc","categories","categoriesMap","_initialCategories","sortByInitialCategories","affectedTraces","locale","_d3locale","_dateFormat","timeFormat","_extraFormat","_separators","separators","_numFormat","_minDtick","_forceTick0"],"mappings":"AAAA;;AAEA,IAAIA,EAAE,GAAGC,OAAO,CAAC,YAAD,CAAhB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAD,CAAP,CAA0BC,SAA1C;;AACA,IAAIC,GAAG,GAAGF,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIG,YAAY,GAAGD,GAAG,CAACC,YAAvB;;AACA,IAAIC,SAAS,GAAGJ,OAAO,CAAC,gBAAD,CAAvB;;AAEA,IAAIK,WAAW,GAAGH,GAAG,CAACG,WAAtB;AACA,IAAIC,WAAW,GAAGJ,GAAG,CAACI,WAAtB;AACA,IAAIC,WAAW,GAAGL,GAAG,CAACK,WAAtB;AACA,IAAIC,YAAY,GAAGN,GAAG,CAACM,YAAvB;AACA,IAAIC,mBAAmB,GAAGP,GAAG,CAACO,mBAA9B;;AAEA,IAAIC,YAAY,GAAGV,OAAO,CAAC,2BAAD,CAA1B;;AACA,IAAIW,OAAO,GAAGD,YAAY,CAACC,OAA3B;AACA,IAAIC,MAAM,GAAGF,YAAY,CAACE,MAA1B;AACA,IAAIC,QAAQ,GAAGH,YAAY,CAACG,QAA5B;AACA,IAAIC,OAAO,GAAGJ,YAAY,CAACI,OAA3B;AACA,IAAIC,MAAM,GAAGL,YAAY,CAACK,MAA1B;AACA,IAAIC,OAAO,GAAGN,YAAY,CAACM,OAA3B;AACA,IAAIC,MAAM,GAAGP,YAAY,CAACO,MAA1B;AACA,IAAIC,MAAM,GAAGR,YAAY,CAACQ,MAA1B;;AAEA,IAAIC,OAAO,GAAGnB,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIoB,SAAS,GAAGpB,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIqB,YAAY,GAAGD,SAAS,CAACC,YAA7B;AACA,IAAIC,eAAe,GAAGF,SAAS,CAACE,eAAhC;;AAEA,SAASC,OAAT,CAAiBC,CAAjB,EAAoB;AAChB,SAAOC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaF,CAAb,CAAP;AACH;;AAED,SAASG,eAAT,CAAyBH,CAAzB,EAA4B;AACxB,SAAOA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAKI,SAA3B;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBC,EAApB,EAAwBC,UAAxB,EAAoC;AACjDA,EAAAA,UAAU,GAAGA,UAAU,IAAI,EAA3B;AAEA,MAAIC,IAAI,GAAIF,EAAE,CAACG,GAAH,IAAU,GAAtB;AACA,MAAIC,QAAQ,GAAGF,IAAI,CAACG,MAAL,CAAY,CAAZ,CAAf;;AAEA,WAASC,KAAT,CAAed,CAAf,EAAkBe,IAAlB,EAAwB;AACpB,QAAGf,CAAC,GAAG,CAAP,EAAU,OAAOC,IAAI,CAACe,GAAL,CAAShB,CAAT,IAAcC,IAAI,CAACgB,IAA1B,CAAV,KAEK,IAAGjB,CAAC,IAAI,CAAL,IAAUe,IAAV,IAAkBP,EAAE,CAACU,KAArB,IAA8BV,EAAE,CAACU,KAAH,CAASC,MAAT,KAAoB,CAArD,EAAwD;AACzD;AACA;AACA,UAAIC,EAAE,GAAGZ,EAAE,CAACU,KAAH,CAAS,CAAT,CAAT;AACA,UAAIG,EAAE,GAAGb,EAAE,CAACU,KAAH,CAAS,CAAT,CAAT;AACA,aAAO,OAAOE,EAAE,GAAGC,EAAL,GAAU,IAAIhC,QAAJ,GAAeY,IAAI,CAACqB,GAAL,CAASF,EAAE,GAAGC,EAAd,CAAhC,CAAP;AACH,KANI,MAME,OAAOjC,MAAP;AACV;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI,WAASmC,KAAT,CAAevB,CAAf,EAAkBwB,CAAlB,EAAqBC,QAArB,EAA+BC,IAA/B,EAAqC;AACjC,QAAG,CAACA,IAAI,IAAI,EAAT,EAAaC,KAAb,IAAsB/C,SAAS,CAACoB,CAAD,CAAlC,EAAuC;AACnC;AACA;AACA;AACA,aAAO,CAACA,CAAR;AACH,KANgC,CAQjC;AACA;AACA;AACA;;;AACA,QAAI4B,EAAE,GAAG7C,WAAW,CAACiB,CAAD,EAAIyB,QAAQ,IAAIjB,EAAE,CAACiB,QAAnB,CAApB;;AACA,QAAGG,EAAE,KAAKxC,MAAV,EAAkB;AACd,UAAGR,SAAS,CAACoB,CAAD,CAAZ,EAAiB;AACbA,QAAAA,CAAC,GAAG,CAACA,CAAL,CADa,CAEb;AACA;;AACA,YAAI6B,UAAU,GAAG5B,IAAI,CAAC6B,KAAL,CAAWpD,GAAG,CAACqD,GAAJ,CAAQ/B,CAAC,GAAG,IAAZ,EAAkB,CAAlB,IAAuB,EAAlC,CAAjB;AACA,YAAIgC,SAAS,GAAG/B,IAAI,CAACgC,KAAL,CAAWjC,CAAC,GAAG6B,UAAU,GAAG,EAA5B,CAAhB;AACAD,QAAAA,EAAE,GAAG7C,WAAW,CAAC,IAAImD,IAAJ,CAASF,SAAT,CAAD,CAAX,GAAmCH,UAAU,GAAG,EAArD;AACH,OAPD,MAOO,OAAOzC,MAAP;AACV;;AACD,WAAOwC,EAAP;AACH,GAhDgD,CAkDjD;;;AACA,WAASO,KAAT,CAAenC,CAAf,EAAkBoC,CAAlB,EAAqBX,QAArB,EAA+B;AAC3B,WAAO3C,WAAW,CAACkB,CAAD,EAAIoC,CAAJ,EAAOX,QAAQ,IAAIjB,EAAE,CAACiB,QAAtB,CAAlB;AACH;;AAED,WAASY,eAAT,CAAyBrC,CAAzB,EAA4B;AACxB,WAAOQ,EAAE,CAAC8B,WAAH,CAAerC,IAAI,CAACgC,KAAL,CAAWjC,CAAX,CAAf,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,WAASuC,gBAAT,CAA0BvC,CAA1B,EAA6B;AACzB,QAAGG,eAAe,CAACH,CAAD,CAAlB,EAAuB;AACnB,UAAGQ,EAAE,CAACgC,cAAH,KAAsBpC,SAAzB,EAAoC;AAChCI,QAAAA,EAAE,CAACgC,cAAH,GAAoB,EAApB;AACH;;AAED,UAAGhC,EAAE,CAACgC,cAAH,CAAkBxC,CAAlB,MAAyBI,SAA5B,EAAuC;AACnC,eAAOI,EAAE,CAACgC,cAAH,CAAkBxC,CAAlB,CAAP;AACH,OAFD,MAEO;AACHQ,QAAAA,EAAE,CAAC8B,WAAH,CAAeG,IAAf,CAAoB,OAAOzC,CAAP,KAAa,QAAb,GAAwB0C,MAAM,CAAC1C,CAAD,CAA9B,GAAoCA,CAAxD;;AAEA,YAAI2C,SAAS,GAAGnC,EAAE,CAAC8B,WAAH,CAAenB,MAAf,GAAwB,CAAxC;AACAX,QAAAA,EAAE,CAACgC,cAAH,CAAkBxC,CAAlB,IAAuB2C,SAAvB;AAEA,eAAOA,SAAP;AACH;AACJ;;AACD,WAAOvD,MAAP;AACH;;AAED,WAASwD,qBAAT,CAA+BC,OAA/B,EAAwCC,GAAxC,EAA6C;AACzC,QAAIC,QAAQ,GAAG,IAAIC,KAAJ,CAAUF,GAAV,CAAf;;AAEA,SAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,GAAnB,EAAwBG,CAAC,EAAzB,EAA6B;AACzB,UAAIC,EAAE,GAAG,CAACL,OAAO,CAAC,CAAD,CAAP,IAAc,EAAf,EAAmBI,CAAnB,CAAT;AACA,UAAIE,EAAE,GAAG,CAACN,OAAO,CAAC,CAAD,CAAP,IAAc,EAAf,EAAmBI,CAAnB,CAAT;AACAF,MAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcG,gBAAgB,CAAC,CAACF,EAAD,EAAKC,EAAL,CAAD,CAA9B;AACH;;AAED,WAAOJ,QAAP;AACH;;AAED,WAASK,gBAAT,CAA0BpD,CAA1B,EAA6B;AACzB,QAAGQ,EAAE,CAACgC,cAAN,EAAsB;AAClB,aAAOhC,EAAE,CAACgC,cAAH,CAAkBxC,CAAlB,CAAP;AACH;AACJ;;AAED,WAASqD,mBAAT,CAA6BrD,CAA7B,EAAgC;AAC5B;AACA;AACA,QAAIsD,KAAK,GAAGF,gBAAgB,CAACpD,CAAD,CAA5B;AACA,QAAGsD,KAAK,KAAKlD,SAAb,EAAwB,OAAOkD,KAAP;AACxB,QAAG1E,SAAS,CAACoB,CAAD,CAAZ,EAAiB,OAAO,CAACA,CAAR;AACpB;;AAED,WAASuD,gBAAT,CAA0BvD,CAA1B,EAA6B;AACzB,WAAOpB,SAAS,CAACoB,CAAD,CAAT,GAAe,CAACA,CAAhB,GAAoBoD,gBAAgB,CAACpD,CAAD,CAA3C;AACH,GAxHgD,CA0HjD;;;AACA,WAASwD,IAAT,CAAcxD,CAAd,EAAiByD,CAAjB,EAAoBC,CAApB,EAAuB;AAAE,WAAOnF,EAAE,CAAC0D,KAAH,CAASyB,CAAC,GAAGD,CAAC,GAAGzD,CAAjB,EAAoB,CAApB,CAAP;AAAgC;;AAEzD,WAAS2D,IAAT,CAAcC,EAAd,EAAkBH,CAAlB,EAAqBC,CAArB,EAAwB;AAAE,WAAO,CAACE,EAAE,GAAGF,CAAN,IAAWD,CAAlB;AAAsB;;AAEhD,MAAII,GAAG,GAAG,SAASA,GAAT,CAAa7D,CAAb,EAAgB;AACtB,QAAG,CAACpB,SAAS,CAACoB,CAAD,CAAb,EAAkB,OAAOZ,MAAP;AAClB,WAAOoE,IAAI,CAACxD,CAAD,EAAIQ,EAAE,CAACsD,EAAP,EAAWtD,EAAE,CAACuD,EAAd,CAAX;AACH,GAHD;;AAKA,MAAIC,GAAG,GAAG,aAASJ,EAAT,EAAa;AACnB,WAAOD,IAAI,CAACC,EAAD,EAAKpD,EAAE,CAACsD,EAAR,EAAYtD,EAAE,CAACuD,EAAf,CAAX;AACH,GAFD;;AAIA,MAAGvD,EAAE,CAACyD,WAAN,EAAmB;AACf,QAAIC,GAAG,GAAGtD,QAAQ,KAAK,GAAvB;;AAEAiD,IAAAA,GAAG,GAAG,aAAS7D,CAAT,EAAY;AACd,UAAG,CAACpB,SAAS,CAACoB,CAAD,CAAb,EAAkB,OAAOZ,MAAP;AAClB,UAAI0D,GAAG,GAAGtC,EAAE,CAAC2D,YAAH,CAAgBhD,MAA1B;AACA,UAAG,CAAC2B,GAAJ,EAAS,OAAOU,IAAI,CAACxD,CAAD,EAAIQ,EAAE,CAACsD,EAAP,EAAWtD,EAAE,CAACuD,EAAd,CAAX;AAET,UAAIK,IAAI,GAAGF,GAAX;AACA,UAAG1D,EAAE,CAACU,KAAH,CAAS,CAAT,IAAcV,EAAE,CAACU,KAAH,CAAS,CAAT,CAAjB,EAA8BkD,IAAI,GAAG,CAACA,IAAR;AAC9B,UAAIC,MAAM,GAAGD,IAAI,GAAG,CAAC,CAAJ,GAAQ,CAAzB;AACA,UAAIE,GAAG,GAAGD,MAAM,GAAGrE,CAAnB;AAEA,UAAIuE,CAAC,GAAG,CAAR;;AACA,WAAI,IAAItB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,GAAnB,EAAwBG,CAAC,EAAzB,EAA6B;AACzB,YAAIuB,GAAG,GAAGH,MAAM,GAAG7D,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,EAAmBuB,GAAtC;AACA,YAAIC,GAAG,GAAGJ,MAAM,GAAG7D,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,EAAmBwB,GAAtC;AAEA,YAAGH,GAAG,GAAGE,GAAT,EAAc;AACd,YAAGF,GAAG,GAAGG,GAAT,EAAcF,CAAC,GAAGtB,CAAC,GAAG,CAAR,CAAd,KACK;AACD;AACAsB,UAAAA,CAAC,GAAGD,GAAG,GAAG,CAACE,GAAG,GAAGC,GAAP,IAAc,CAApB,GAAwBxB,CAAxB,GAA4BA,CAAC,GAAG,CAApC;AACA;AACH;AACJ;;AACD,UAAIyB,EAAE,GAAGlE,EAAE,CAACmE,EAAH,CAAMJ,CAAN,KAAY,CAArB;AACA,UAAG,CAACK,QAAQ,CAACF,EAAD,CAAZ,EAAkB,OAAO,CAAP,CAxBJ,CAwBc;;AAC5B,aAAOlB,IAAI,CAACxD,CAAD,EAAIQ,EAAE,CAACqE,GAAP,EAAYH,EAAZ,CAAX;AACH,KA1BD;;AA4BAV,IAAAA,GAAG,GAAG,aAASJ,EAAT,EAAa;AACf,UAAId,GAAG,GAAGtC,EAAE,CAAC2D,YAAH,CAAgBhD,MAA1B;AACA,UAAG,CAAC2B,GAAJ,EAAS,OAAOa,IAAI,CAACC,EAAD,EAAKpD,EAAE,CAACsD,EAAR,EAAYtD,EAAE,CAACuD,EAAf,CAAX;AAET,UAAIQ,CAAC,GAAG,CAAR;;AACA,WAAI,IAAItB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,GAAnB,EAAwBG,CAAC,EAAzB,EAA6B;AACzB,YAAGW,EAAE,GAAGpD,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,EAAmB6B,IAA3B,EAAiC;AACjC,YAAGlB,EAAE,GAAGpD,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,EAAmB8B,IAA3B,EAAiCR,CAAC,GAAGtB,CAAC,GAAG,CAAR;AACpC;;AACD,aAAOU,IAAI,CAACC,EAAD,EAAKpD,EAAE,CAACqE,GAAR,EAAarE,EAAE,CAACmE,EAAH,CAAMJ,CAAN,CAAb,CAAX;AACH,KAVD;AAWH,GAlLgD,CAoLjD;;;AACA/D,EAAAA,EAAE,CAACwE,GAAH,GAAUxE,EAAE,CAACyE,IAAH,KAAY,KAAb,GAAsBnE,KAAtB,GAA8B9B,YAAvC;AACAwB,EAAAA,EAAE,CAAC0E,GAAH,GAAU1E,EAAE,CAACyE,IAAH,KAAY,KAAb,GAAsBlF,OAAtB,GAAgCf,YAAzC;AAEAwB,EAAAA,EAAE,CAACqD,GAAH,GAASA,GAAT;AACArD,EAAAA,EAAE,CAACwD,GAAH,GAASA,GAAT;AAEAxD,EAAAA,EAAE,CAAC2E,GAAH,GAAU3E,EAAE,CAACyE,IAAH,KAAY,KAAb,GAAsB,UAASjF,CAAT,EAAYe,IAAZ,EAAkB;AAAE,WAAO8C,GAAG,CAAC/C,KAAK,CAACd,CAAD,EAAIe,IAAJ,CAAN,CAAV;AAA6B,GAAvE,GAA0E8C,GAAnF;AACArD,EAAAA,EAAE,CAAC4E,GAAH,GAAU5E,EAAE,CAACyE,IAAH,KAAY,KAAb,GAAsB,UAASrB,EAAT,EAAa;AAAE,WAAO7D,OAAO,CAACiE,GAAG,CAACJ,EAAD,CAAJ,CAAd;AAA0B,GAA/D,GAAkEI,GAA3E;AAEA;AACJ;AACA;AACA;AACA;;AACI,MAAG,CAAC,QAAD,EAAW,GAAX,EAAgBqB,OAAhB,CAAwB7E,EAAE,CAACyE,IAA3B,MAAqC,CAAC,CAAzC,EAA4C;AACxC;AACAzE,IAAAA,EAAE,CAAC8E,GAAH,GAAS9E,EAAE,CAAC+E,GAAH,GAAS/E,EAAE,CAACgF,GAAH,GAAShF,EAAE,CAACiF,GAAH,GAASjF,EAAE,CAACkF,GAAH,GAASlF,EAAE,CAACmF,GAAH,GAAS9G,WAAtD;AACA2B,IAAAA,EAAE,CAACoF,GAAH,GAASpF,EAAE,CAACqF,GAAH,GAASrF,EAAE,CAACsF,GAAH,GAAStF,EAAE,CAACuF,GAAH,GAAS/G,YAApC;;AAEAwB,IAAAA,EAAE,CAACwF,GAAH,GAASxF,EAAE,CAACyF,GAAH,GAAS,UAASjG,CAAT,EAAY;AAAE,aAAOQ,EAAE,CAACqD,GAAH,CAAOhF,WAAW,CAACmB,CAAD,CAAlB,CAAP;AAAgC,KAAhE;;AACAQ,IAAAA,EAAE,CAAC0F,GAAH,GAAS1F,EAAE,CAAC2F,GAAH,GAASnC,GAAlB;AAEAxD,IAAAA,EAAE,CAAC4F,QAAH,GAAcpH,YAAd;AACH,GATD,MASO,IAAGwB,EAAE,CAACyE,IAAH,KAAY,KAAf,EAAsB;AACzB;AACAzE,IAAAA,EAAE,CAAC8E,GAAH,GAAS9E,EAAE,CAACkF,GAAH,GAAS,UAAS1F,CAAT,EAAYe,IAAZ,EAAkB;AAAE,aAAOD,KAAK,CAACjC,WAAW,CAACmB,CAAD,CAAZ,EAAiBe,IAAjB,CAAZ;AAAqC,KAA3E;;AACAP,IAAAA,EAAE,CAAC+E,GAAH,GAAS/E,EAAE,CAACiF,GAAH,GAAS,UAASzF,CAAT,EAAY;AAAE,aAAOD,OAAO,CAAClB,WAAW,CAACmB,CAAD,CAAZ,CAAd;AAAiC,KAAjE;;AAEAQ,IAAAA,EAAE,CAACgF,GAAH,GAAShF,EAAE,CAACmF,GAAH,GAAS9G,WAAlB;AACA2B,IAAAA,EAAE,CAACoF,GAAH,GAASpF,EAAE,CAACuF,GAAH,GAAS/G,YAAlB;AAEAwB,IAAAA,EAAE,CAACqF,GAAH,GAAS/E,KAAT;AACAN,IAAAA,EAAE,CAACsF,GAAH,GAAS/F,OAAT;;AAEAS,IAAAA,EAAE,CAACwF,GAAH,GAAS,UAAShG,CAAT,EAAYe,IAAZ,EAAkB;AAAE,aAAOP,EAAE,CAACqD,GAAH,CAAOrD,EAAE,CAAC8E,GAAH,CAAOtF,CAAP,EAAUe,IAAV,CAAP,CAAP;AAAiC,KAA9D;;AACAP,IAAAA,EAAE,CAAC0F,GAAH,GAAS,UAAStC,EAAT,EAAa;AAAE,aAAO7D,OAAO,CAACiE,GAAG,CAACJ,EAAD,CAAJ,CAAd;AAA0B,KAAlD;;AAEApD,IAAAA,EAAE,CAACyF,GAAH,GAAS,UAASjG,CAAT,EAAY;AAAE,aAAOQ,EAAE,CAACqD,GAAH,CAAOhF,WAAW,CAACmB,CAAD,CAAlB,CAAP;AAAgC,KAAvD;;AACAQ,IAAAA,EAAE,CAAC2F,GAAH,GAASnC,GAAT;AAEAxD,IAAAA,EAAE,CAAC4F,QAAH,GAAcpH,YAAd;AACH,GAlBM,MAkBA,IAAGwB,EAAE,CAACyE,IAAH,KAAY,MAAf,EAAuB;AAC1B;;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQzE,IAAAA,EAAE,CAAC8E,GAAH,GAAS9E,EAAE,CAAC+E,GAAH,GAAS7G,GAAG,CAAC2H,QAAtB;AAEA7F,IAAAA,EAAE,CAACgF,GAAH,GAAShF,EAAE,CAACiF,GAAH,GAASjF,EAAE,CAACkF,GAAH,GAASlF,EAAE,CAACmF,GAAH,GAASpE,KAApC;AACAf,IAAAA,EAAE,CAACoF,GAAH,GAASpF,EAAE,CAACqF,GAAH,GAASrF,EAAE,CAACsF,GAAH,GAAStF,EAAE,CAACuF,GAAH,GAAS5D,KAApC;;AAEA3B,IAAAA,EAAE,CAACwF,GAAH,GAASxF,EAAE,CAACyF,GAAH,GAAS,UAASjG,CAAT,EAAYwB,CAAZ,EAAeC,QAAf,EAAyB;AAAE,aAAOjB,EAAE,CAACqD,GAAH,CAAOtC,KAAK,CAACvB,CAAD,EAAI,CAAJ,EAAOyB,QAAP,CAAZ,CAAP;AAAuC,KAApF;;AACAjB,IAAAA,EAAE,CAAC0F,GAAH,GAAS1F,EAAE,CAAC2F,GAAH,GAAS,UAASvC,EAAT,EAAaxB,CAAb,EAAgBX,QAAhB,EAA0B;AAAE,aAAOU,KAAK,CAAC6B,GAAG,CAACJ,EAAD,CAAJ,EAAUxB,CAAV,EAAaX,QAAb,CAAZ;AAAqC,KAAnF;;AAEAjB,IAAAA,EAAE,CAAC4F,QAAH,GAAc,UAASpG,CAAT,EAAY;AAAE,aAAOtB,GAAG,CAAC4H,SAAJ,CAActG,CAAd,EAAiBZ,MAAjB,EAAyBoB,EAAE,CAACiB,QAA5B,CAAP;AAA+C,KAA3E;AACH,GApBM,MAoBA,IAAGjB,EAAE,CAACyE,IAAH,KAAY,UAAf,EAA2B;AAC9B;AACA;AACA;AAEAzE,IAAAA,EAAE,CAACgF,GAAH,GAAShF,EAAE,CAACkF,GAAH,GAASnD,gBAAlB;AACA/B,IAAAA,EAAE,CAAC+E,GAAH,GAAS/E,EAAE,CAACoF,GAAH,GAASpF,EAAE,CAACsF,GAAH,GAASzD,eAA3B;AAEA7B,IAAAA,EAAE,CAAC8E,GAAH,GAAS9E,EAAE,CAAC+F,SAAH,GAAelD,mBAAxB;;AAEA7C,IAAAA,EAAE,CAACiF,GAAH,GAAS,UAASzF,CAAT,EAAY;AACjB,UAAIsD,KAAK,GAAGC,gBAAgB,CAACvD,CAAD,CAA5B;AACA,aAAOsD,KAAK,KAAKlD,SAAV,GAAsBkD,KAAtB,GAA8B9C,EAAE,CAACgG,UAAH,CAAc,GAAd,CAArC;AACH,KAHD;;AAKAhG,IAAAA,EAAE,CAACuF,GAAH,GAASvF,EAAE,CAACqF,GAAH,GAAS7G,YAAlB;AACAwB,IAAAA,EAAE,CAACmF,GAAH,GAASpC,gBAAT;;AAEA/C,IAAAA,EAAE,CAACwF,GAAH,GAAS,UAAShG,CAAT,EAAY;AAAE,aAAOQ,EAAE,CAACqD,GAAH,CAAOrD,EAAE,CAACiF,GAAH,CAAOzF,CAAP,CAAP,CAAP;AAA2B,KAAlD;;AACAQ,IAAAA,EAAE,CAAC0F,GAAH,GAAS,UAAStC,EAAT,EAAa;AAAE,aAAOvB,eAAe,CAAC2B,GAAG,CAACJ,EAAD,CAAJ,CAAtB;AAAkC,KAA1D;;AACApD,IAAAA,EAAE,CAACyF,GAAH,GAASzF,EAAE,CAACwF,GAAZ;AACAxF,IAAAA,EAAE,CAAC2F,GAAH,GAASnC,GAAT;;AAEAxD,IAAAA,EAAE,CAAC4F,QAAH,GAAc,UAASpG,CAAT,EAAY;AACtB,UAAG,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,EAAlC,EAAsC,OAAOA,CAAP;AACtC,aAAOhB,YAAY,CAACgB,CAAD,CAAnB;AACH,KAHD;AAIH,GA3BM,MA2BA,IAAGQ,EAAE,CAACyE,IAAH,KAAY,eAAf,EAAgC;AACnC;AACA;AACA;AAEAzE,IAAAA,EAAE,CAAC+E,GAAH,GAAS/E,EAAE,CAACoF,GAAH,GAASpF,EAAE,CAACsF,GAAH,GAASzD,eAA3B;AACA7B,IAAAA,EAAE,CAAC8E,GAAH,GAAS9E,EAAE,CAAC+F,SAAH,GAAelD,mBAAxB;;AAEA7C,IAAAA,EAAE,CAACiF,GAAH,GAAS,UAASzF,CAAT,EAAY;AACjB,UAAIsD,KAAK,GAAGD,mBAAmB,CAACrD,CAAD,CAA/B;AACA,aAAOsD,KAAK,KAAKlD,SAAV,GAAsBkD,KAAtB,GAA8B9C,EAAE,CAACgG,UAAH,CAAc,GAAd,CAArC;AACH,KAHD;;AAKAhG,IAAAA,EAAE,CAACiG,gBAAH,GAAsBrD,gBAAtB;AAEA5C,IAAAA,EAAE,CAACuF,GAAH,GAASvF,EAAE,CAACqF,GAAH,GAAS7G,YAAlB;AACAwB,IAAAA,EAAE,CAACmF,GAAH,GAAStC,mBAAT;;AAEA7C,IAAAA,EAAE,CAACwF,GAAH,GAAS,UAAShG,CAAT,EAAY;AAAE,aAAOQ,EAAE,CAACqD,GAAH,CAAOrD,EAAE,CAACiF,GAAH,CAAOzF,CAAP,CAAP,CAAP;AAA2B,KAAlD;;AACAQ,IAAAA,EAAE,CAAC0F,GAAH,GAAS,UAAStC,EAAT,EAAa;AAAE,aAAOvB,eAAe,CAAC2B,GAAG,CAACJ,EAAD,CAAJ,CAAtB;AAAkC,KAA1D;;AACApD,IAAAA,EAAE,CAACyF,GAAH,GAASzF,EAAE,CAACwF,GAAZ;AACAxF,IAAAA,EAAE,CAAC2F,GAAH,GAASnC,GAAT;;AAEAxD,IAAAA,EAAE,CAAC4F,QAAH,GAAc,UAASpG,CAAT,EAAY;AACtB,UAAGgD,KAAK,CAAC0D,OAAN,CAAc1G,CAAd,KAAqB,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,EAAvD,EAA4D,OAAOA,CAAP;AAC5D,aAAOhB,YAAY,CAACgB,CAAD,CAAnB;AACH,KAHD;;AAKAQ,IAAAA,EAAE,CAACmG,kBAAH,GAAwB,UAASC,QAAT,EAAmB;AACvC,UAAIC,YAAY,GAAGrG,EAAE,CAACsG,aAAtB;AACA,UAAI7D,CAAJ,EAAO8D,CAAP;AAEA,UAAIC,KAAK,GAAGxG,EAAE,CAACyG,WAAf;;AACA,UAAGD,KAAK,IAAIxG,EAAE,CAAC8B,WAAH,CAAenB,MAAf,KAA0B,CAAtC,EAAyC;AACrC,aAAI,IAAI+F,KAAR,IAAiBF,KAAjB,EAAwB;AACpB,cAAGE,KAAK,KAAKxG,IAAb,EAAmB;AACf,gBAAIyG,GAAG,GAAG1G,UAAU,CAACd,OAAO,CAACyH,OAAR,CAAgBF,KAAhB,CAAD,CAApB;AACAL,YAAAA,YAAY,GAAGA,YAAY,CAACQ,MAAb,CAAoBF,GAAG,CAACL,aAAxB,CAAf;AACH;AACJ;AACJ,OAZsC,CAcvC;;;AACA,UAAIQ,IAAI,GAAG,CAAC,CAAC,CAAD,EAAI,EAAJ,CAAD,EAAU,CAAC,CAAD,EAAI,EAAJ,CAAV,CAAX,CAfuC,CAgBvC;;AACA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAItE,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG4D,YAAY,CAAC1F,MAA5B,EAAoC8B,CAAC,EAArC,EAAyC;AACrC,YAAIuE,KAAK,GAAGZ,QAAQ,CAACC,YAAY,CAAC5D,CAAD,CAAb,CAApB;;AAEA,YAAGrC,QAAQ,IAAI4G,KAAf,EAAsB;AAClB,cAAI3E,OAAO,GAAG2E,KAAK,CAAC5G,QAAD,CAAnB;AACA,cAAIkC,GAAG,GAAG0E,KAAK,CAACC,OAAN,IAAiB/I,GAAG,CAACgJ,YAAJ,CAAiB7E,OAAjB,CAA3B;;AAEA,cAAG5D,mBAAmB,CAAC4D,OAAO,CAAC,CAAD,CAAR,CAAnB,IAAmC5D,mBAAmB,CAAC4D,OAAO,CAAC,CAAD,CAAR,CAAzD,EAAuE;AACnE,iBAAIkE,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGjE,GAAf,EAAoBiE,CAAC,EAArB,EAAyB;AACrB,kBAAI7D,EAAE,GAAGL,OAAO,CAAC,CAAD,CAAP,CAAWkE,CAAX,CAAT;AACA,kBAAI5D,EAAE,GAAGN,OAAO,CAAC,CAAD,CAAP,CAAWkE,CAAX,CAAT;;AAEA,kBAAG5G,eAAe,CAAC+C,EAAD,CAAf,IAAuB/C,eAAe,CAACgD,EAAD,CAAzC,EAA+C;AAC3CoE,gBAAAA,IAAI,CAAC9E,IAAL,CAAU,CAACS,EAAD,EAAKC,EAAL,CAAV;;AAEA,oBAAG,EAAED,EAAE,IAAIoE,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAR,CAAH,EAAwB;AACpBA,kBAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAWpE,EAAX,IAAiBoE,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,GAAjB;AACH;;AACD,oBAAG,EAAEnE,EAAE,IAAImE,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAR,CAAH,EAAwB;AACpBA,kBAAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,EAAWnE,EAAX,IAAiBmE,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,GAAjB;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;;AAEDC,MAAAA,IAAI,CAACI,IAAL,CAAU,UAASC,CAAT,EAAYlE,CAAZ,EAAe;AACrB,YAAImE,IAAI,GAAGP,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAX;AACA,YAAIQ,CAAC,GAAGD,IAAI,CAACD,CAAC,CAAC,CAAD,CAAF,CAAJ,GAAaC,IAAI,CAACnE,CAAC,CAAC,CAAD,CAAF,CAAzB;AACA,YAAGoE,CAAH,EAAM,OAAOA,CAAP;AAEN,YAAIC,IAAI,GAAGT,IAAI,CAAC,CAAD,CAAJ,CAAQ,CAAR,CAAX;AACA,eAAOS,IAAI,CAACH,CAAC,CAAC,CAAD,CAAF,CAAJ,GAAaG,IAAI,CAACrE,CAAC,CAAC,CAAD,CAAF,CAAxB;AACH,OAPD;;AASA,WAAIT,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGsE,IAAI,CAACpG,MAApB,EAA4B8B,CAAC,EAA7B,EAAiC;AAC7BV,QAAAA,gBAAgB,CAACgF,IAAI,CAACtE,CAAD,CAAL,CAAhB;AACH;AACJ,KA1DD;AA2DH,GApWgD,CAsWjD;;;AACAzC,EAAAA,EAAE,CAACgG,UAAH,GAAgB,UAASxG,CAAT,EAAY;AACxB,QAAIgI,GAAG,GAAGxH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAV;AACA,QAAI+G,GAAG,GAAGzH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAV;AACA,WAAOV,EAAE,CAACuF,GAAH,CAAOiC,GAAG,GAAGhI,CAAC,IAAIiI,GAAG,GAAGD,GAAV,CAAd,CAAP;AACH,GAJD,CAvWiD,CA6WjD;;;AACAxH,EAAAA,EAAE,CAAC0H,UAAH,GAAgB,UAASlI,CAAT,EAAY;AACxB,QAAIgI,GAAG,GAAGxH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAV;AACA,QAAI+G,GAAG,GAAGzH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAV;AACA,WAAO,CAACV,EAAE,CAACmF,GAAH,CAAO3F,CAAP,IAAYgI,GAAb,KAAqBC,GAAG,GAAGD,GAA3B,CAAP;AACH,GAJD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxH,EAAAA,EAAE,CAAC2H,UAAH,GAAgB,UAASC,SAAT,EAAoB1G,IAApB,EAA0B;AACtC,QAAG,CAACA,IAAJ,EAAUA,IAAI,GAAG,EAAP;AACV,QAAG,CAAC0G,SAAJ,EAAeA,SAAS,GAAG,OAAZ;AAEf,QAAIlH,KAAK,GAAGxC,GAAG,CAAC2J,cAAJ,CAAmB7H,EAAnB,EAAuB4H,SAAvB,EAAkCE,GAAlC,EAAZ;AACA,QAAIrF,CAAJ,EAAOsF,IAAP;AAEA,QAAG/H,EAAE,CAACyE,IAAH,KAAY,MAAf,EAAuBsD,IAAI,GAAG7J,GAAG,CAAC8J,SAAJ,CAAchI,EAAE,CAACiB,QAAjB,CAAP,CAAvB,KACK,IAAGb,QAAQ,KAAK,GAAhB,EAAqB2H,IAAI,GAAG3I,SAAS,CAAC6I,UAAjB,CAArB,KACAF,IAAI,GAAG7G,IAAI,CAAC8G,SAAL,IAAkB5I,SAAS,CAAC8I,UAAnC,CATiC,CAWtC;;AACAH,IAAAA,IAAI,GAAGA,IAAI,CAACI,KAAL,EAAP;;AAEA,QAAGnI,EAAE,CAACoI,SAAH,KAAiB,QAAjB,IAA6BpI,EAAE,CAACoI,SAAH,KAAiB,aAAjD,EAAgE;AAC5DL,MAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AACH;;AAED,QAAG,CAACrH,KAAD,IAAUA,KAAK,CAACC,MAAN,KAAiB,CAA9B,EAAiC;AAC7BzC,MAAAA,GAAG,CAAC2J,cAAJ,CAAmB7H,EAAnB,EAAuB4H,SAAvB,EAAkCS,GAAlC,CAAsCN,IAAtC;AACA;AACH;;AAED,QAAG/H,EAAE,CAACyE,IAAH,KAAY,MAAZ,IAAsB,CAACzE,EAAE,CAACsI,SAA7B,EAAwC;AACpC;AACA;AACA5H,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWxC,GAAG,CAAC4H,SAAJ,CAAcpF,KAAK,CAAC,CAAD,CAAnB,EAAwB9B,MAAxB,EAAgCoB,EAAE,CAACiB,QAAnC,CAAX;AACAP,MAAAA,KAAK,CAAC,CAAD,CAAL,GAAWxC,GAAG,CAAC4H,SAAJ,CAAcpF,KAAK,CAAC,CAAD,CAAnB,EAAwB9B,MAAxB,EAAgCoB,EAAE,CAACiB,QAAnC,CAAX;AACH;;AAED,SAAIwB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAf,EAAkBA,CAAC,EAAnB,EAAuB;AACnB,UAAGzC,EAAE,CAACyE,IAAH,KAAY,MAAf,EAAuB;AACnB,YAAG,CAACvG,GAAG,CAACqK,UAAJ,CAAe7H,KAAK,CAAC+B,CAAD,CAApB,EAAyBzC,EAAE,CAACiB,QAA5B,CAAJ,EAA2C;AACvCjB,UAAAA,EAAE,CAAC4H,SAAD,CAAF,GAAgBG,IAAhB;AACA;AACH;;AAED,YAAG/H,EAAE,CAACmF,GAAH,CAAOzE,KAAK,CAAC,CAAD,CAAZ,MAAqBV,EAAE,CAACmF,GAAH,CAAOzE,KAAK,CAAC,CAAD,CAAZ,CAAxB,EAA0C;AACtC;AACA,cAAI8H,SAAS,GAAGtK,GAAG,CAACuK,SAAJ,CAAczI,EAAE,CAACmF,GAAH,CAAOzE,KAAK,CAAC,CAAD,CAAZ,CAAd,EACZxC,GAAG,CAACwK,MAAJ,GAAa,IADD,EACOxK,GAAG,CAACyK,MAAJ,GAAa,IADpB,CAAhB;AAEAjI,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWV,EAAE,CAACuF,GAAH,CAAOiD,SAAS,GAAG,IAAnB,CAAX;AACA9H,UAAAA,KAAK,CAAC,CAAD,CAAL,GAAWV,EAAE,CAACuF,GAAH,CAAOiD,SAAS,GAAG,IAAnB,CAAX;AACA;AACH;AACJ,OAdD,MAcO;AACH,YAAG,CAACpK,SAAS,CAACsC,KAAK,CAAC+B,CAAD,CAAN,CAAb,EAAyB;AACrB,cAAGrE,SAAS,CAACsC,KAAK,CAAC,IAAI+B,CAAL,CAAN,CAAZ,EAA4B;AACxB/B,YAAAA,KAAK,CAAC+B,CAAD,CAAL,GAAW/B,KAAK,CAAC,IAAI+B,CAAL,CAAL,IAAgBA,CAAC,GAAG,EAAH,GAAQ,GAAzB,CAAX;AACH,WAFD,MAEO;AACHzC,YAAAA,EAAE,CAAC4H,SAAD,CAAF,GAAgBG,IAAhB;AACA;AACH;AACJ;;AAED,YAAGrH,KAAK,CAAC+B,CAAD,CAAL,GAAW,CAAC9D,OAAf,EAAwB+B,KAAK,CAAC+B,CAAD,CAAL,GAAW,CAAC9D,OAAZ,CAAxB,KACK,IAAG+B,KAAK,CAAC+B,CAAD,CAAL,GAAW9D,OAAd,EAAuB+B,KAAK,CAAC+B,CAAD,CAAL,GAAW9D,OAAX;;AAE5B,YAAG+B,KAAK,CAAC,CAAD,CAAL,KAAaA,KAAK,CAAC,CAAD,CAArB,EAA0B;AACtB;AACA,cAAIkI,GAAG,GAAGnJ,IAAI,CAACwE,GAAL,CAAS,CAAT,EAAYxE,IAAI,CAACqB,GAAL,CAASJ,KAAK,CAAC,CAAD,CAAL,GAAW,IAApB,CAAZ,CAAV;AACAA,UAAAA,KAAK,CAAC,CAAD,CAAL,IAAYkI,GAAZ;AACAlI,UAAAA,KAAK,CAAC,CAAD,CAAL,IAAYkI,GAAZ;AACH;AACJ;AACJ;AACJ,GAlED,CA5XiD,CAgcjD;;;AACA5I,EAAAA,EAAE,CAAC6I,QAAH,GAAc,UAASC,eAAT,EAA0B;AACpC,QAAIC,EAAE,GAAG9I,UAAU,CAAC+I,KAApB,CADoC,CAGpC;AACA;;AACA,QAAGhJ,EAAE,CAACiJ,UAAN,EAAkB;AACd,UAAItC,GAAG,GAAGxH,OAAO,CAAC+J,SAAR,CAAkB;AAAEC,QAAAA,WAAW,EAAElJ;AAAf,OAAlB,EAA+CD,EAAE,CAACiJ,UAAlD,CAAV;AACAjJ,MAAAA,EAAE,CAACoJ,MAAH,GAAYzC,GAAG,CAACyC,MAAhB;AACH,KARmC,CAUpC;AACA;AACA;AACA;;;AACA,QAAIxB,SAAS,GAAIkB,eAAe,IAAI9I,EAAE,CAACqJ,EAAvB,GAA6B,IAA7B,GAAoC,OAApD;AACA,QAAIpI,QAAQ,GAAGjB,EAAE,CAACiB,QAAlB;AACAjB,IAAAA,EAAE,CAAC2H,UAAH,CAAcC,SAAd;AAEA,QAAIJ,GAAG,GAAGxH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAAC4H,SAAD,CAAF,CAAc,CAAd,CAAP,EAAyB3G,QAAzB,CAAV;AACA,QAAIwG,GAAG,GAAGzH,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAAC4H,SAAD,CAAF,CAAc,CAAd,CAAP,EAAyB3G,QAAzB,CAAV;AAEA,QAAIyC,GAAG,GAAGtD,QAAQ,KAAK,GAAvB;;AACA,QAAGsD,GAAH,EAAQ;AACJ1D,MAAAA,EAAE,CAACsJ,OAAH,GAAaP,EAAE,CAACQ,CAAH,GAAO,CAAC,IAAIvJ,EAAE,CAACoJ,MAAH,CAAU,CAAV,CAAL,IAAqBL,EAAE,CAACS,CAA5C;AACAxJ,MAAAA,EAAE,CAACiH,OAAH,GAAa8B,EAAE,CAACS,CAAH,IAAQxJ,EAAE,CAACoJ,MAAH,CAAU,CAAV,IAAepJ,EAAE,CAACoJ,MAAH,CAAU,CAAV,CAAvB,CAAb;AACApJ,MAAAA,EAAE,CAACsD,EAAH,GAAQtD,EAAE,CAACiH,OAAH,IAAcO,GAAG,GAAGC,GAApB,CAAR;AACAzH,MAAAA,EAAE,CAACuD,EAAH,GAAQ,CAACvD,EAAE,CAACsD,EAAJ,GAASmE,GAAjB;AACH,KALD,MAKO;AACHzH,MAAAA,EAAE,CAACsJ,OAAH,GAAaP,EAAE,CAACU,CAAH,GAAOzJ,EAAE,CAACoJ,MAAH,CAAU,CAAV,IAAeL,EAAE,CAACW,CAAtC;AACA1J,MAAAA,EAAE,CAACiH,OAAH,GAAa8B,EAAE,CAACW,CAAH,IAAQ1J,EAAE,CAACoJ,MAAH,CAAU,CAAV,IAAepJ,EAAE,CAACoJ,MAAH,CAAU,CAAV,CAAvB,CAAb;AACApJ,MAAAA,EAAE,CAACsD,EAAH,GAAQtD,EAAE,CAACiH,OAAH,IAAcQ,GAAG,GAAGD,GAApB,CAAR;AACAxH,MAAAA,EAAE,CAACuD,EAAH,GAAQ,CAACvD,EAAE,CAACsD,EAAJ,GAASkE,GAAjB;AACH,KAhCmC,CAkCpC;;;AACAxH,IAAAA,EAAE,CAAC2D,YAAH,GAAkB,EAAlB,CAnCoC,CAoCpC;;AACA3D,IAAAA,EAAE,CAAC2J,QAAH,GAAc,CAAd,CArCoC,CAsCpC;;AACA3J,IAAAA,EAAE,CAACqE,GAAH,GAAS,CAAT,CAvCoC,CAwCpC;;AACArE,IAAAA,EAAE,CAACmE,EAAH,GAAQ,EAAR;;AAEA,QAAGnE,EAAE,CAACyD,WAAN,EAAmB;AACf,UAAIhB,CAAJ,EAAOmH,GAAP;AAEA5J,MAAAA,EAAE,CAAC2D,YAAH,GAAkB3D,EAAE,CAAC6J,YAAH,CACdpK,IAAI,CAACuE,GAAL,CAASwD,GAAT,EAAcC,GAAd,CADc,EAEdhI,IAAI,CAACwE,GAAL,CAASuD,GAAT,EAAcC,GAAd,CAFc,CAAlB;;AAKA,UAAGzH,EAAE,CAAC2D,YAAH,CAAgBhD,MAAnB,EAA2B;AACvB,aAAI8B,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGzC,EAAE,CAAC2D,YAAH,CAAgBhD,MAA/B,EAAuC8B,CAAC,EAAxC,EAA4C;AACxCmH,UAAAA,GAAG,GAAG5J,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,CAAN;AACAzC,UAAAA,EAAE,CAAC2J,QAAH,IAAelK,IAAI,CAACqB,GAAL,CAAS8I,GAAG,CAAC3F,GAAJ,GAAU2F,GAAG,CAAC5F,GAAvB,CAAf;AACH;;AAED,YAAIJ,IAAI,GAAGF,GAAX;AACA,YAAG8D,GAAG,GAAGC,GAAT,EAAc7D,IAAI,GAAG,CAACA,IAAR;AACd,YAAGA,IAAH,EAAS5D,EAAE,CAAC2D,YAAH,CAAgBmG,OAAhB;AACT,YAAIC,IAAI,GAAGnG,IAAI,GAAG,CAAC,CAAJ,GAAQ,CAAvB;AAEA5D,QAAAA,EAAE,CAACqE,GAAH,GAAS0F,IAAI,GAAG/J,EAAE,CAACiH,OAAV,IAAqBxH,IAAI,CAACqB,GAAL,CAAS2G,GAAG,GAAGD,GAAf,IAAsBxH,EAAE,CAAC2J,QAA9C,CAAT;;AACA3J,QAAAA,EAAE,CAACmE,EAAH,CAAMlC,IAAN,CAAW,CAACjC,EAAE,CAACqE,GAAJ,IAAWX,GAAG,GAAG+D,GAAH,GAASD,GAAvB,CAAX;;AACA,aAAI/E,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGzC,EAAE,CAAC2D,YAAH,CAAgBhD,MAA/B,EAAuC8B,CAAC,EAAxC,EAA4C;AACxCmH,UAAAA,GAAG,GAAG5J,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,CAAN;;AACAzC,UAAAA,EAAE,CAACmE,EAAH,CAAMlC,IAAN,CACIjC,EAAE,CAACmE,EAAH,CAAMnE,EAAE,CAACmE,EAAH,CAAMxD,MAAN,GAAe,CAArB,IACAoJ,IAAI,GAAG/J,EAAE,CAACqE,GAAV,IAAiBuF,GAAG,CAAC3F,GAAJ,GAAU2F,GAAG,CAAC5F,GAA/B,CAFJ;AAIH,SAnBsB,CAqBvB;AACA;;;AACA,aAAIvB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGzC,EAAE,CAAC2D,YAAH,CAAgBhD,MAA/B,EAAuC8B,CAAC,EAAxC,EAA4C;AACxCmH,UAAAA,GAAG,GAAG5J,EAAE,CAAC2D,YAAH,CAAgBlB,CAAhB,CAAN;AACAmH,UAAAA,GAAG,CAACtF,IAAJ,GAAWjB,GAAG,CAACuG,GAAG,CAAC5F,GAAL,CAAd;AACA4F,UAAAA,GAAG,CAACrF,IAAJ,GAAWlB,GAAG,CAACuG,GAAG,CAAC3F,GAAL,CAAd;AACH;AACJ;AACJ;;AAED,QAAG,CAACG,QAAQ,CAACpE,EAAE,CAACsD,EAAJ,CAAT,IAAoB,CAACc,QAAQ,CAACpE,EAAE,CAACuD,EAAJ,CAA7B,IAAwCvD,EAAE,CAACiH,OAAH,GAAa,CAAxD,EAA2D;AACvDhH,MAAAA,UAAU,CAAC+J,WAAX,GAAyB,KAAzB;AACA,YAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;AACH;AACJ,GAtFD;;AAwFAjK,EAAAA,EAAE,CAACkK,UAAH,GAAgB,UAAS1K,CAAT,EAAY;AACxB,QAAI2K,aAAa,GAAGnK,EAAE,CAACyD,WAAH,IAAkB,EAAtC;AACA,QAAI2G,IAAJ,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,KAAtB;;AAGA,QAAG,CAACL,aAAa,CAACM,eAAlB,EAAmC;AAC/BN,MAAAA,aAAa,CAACM,eAAd,GAAgCN,aAAa,CAACO,GAAd,CAAkB,UAASd,GAAT,EAAc;AAC5D,eAAOA,GAAG,CAACe,OAAJ,IAAef,GAAG,CAACgB,MAAnB,GAA4B1M,GAAG,CAAC2M,SAAJ,CAAcjB,GAAG,CAACgB,MAAlB,EAA0BhB,GAAG,CAACkB,OAAJ,GACzDzM,WADyD,GAEzD2B,EAAE,CAACgF,GAF4B,CAExB;AAFwB,SAA5B,GAGH,IAHJ;AAIH,OAL+B,CAAhC;AAMH;;AACD,QAAG,CAACmF,aAAa,CAACY,aAAlB,EAAiC;AAC7BZ,MAAAA,aAAa,CAACY,aAAd,GAA8BZ,aAAa,CAACO,GAAd,CAAkB,UAASd,GAAT,EAAc;AAC1D,eAAOA,GAAG,CAACe,OAAJ,IAAef,GAAG,CAACoB,MAAnB,GAA4B9M,GAAG,CAAC2M,SAAJ,CAAcjB,GAAG,CAACoB,MAAlB,EAA0BhL,EAAE,CAACgF,GAA7B,EAAkCmC,IAAlC,CAAuCjJ,GAAG,CAAC+M,SAA3C,CAA5B,GAAoF,IAA3F;AACH,OAF6B,CAA9B;AAGH;;AAGD,SAAI,IAAIxI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG0H,aAAa,CAACxJ,MAAjC,EAAyC8B,CAAC,EAA1C,EAA8C;AAC1C,UAAImH,GAAG,GAAGO,aAAa,CAAC1H,CAAD,CAAvB;;AAEA,UAAGmH,GAAG,CAACe,OAAP,EAAgB;AACZ,YAAGf,GAAG,CAACgB,MAAP,EAAe;AACX,cAAIE,OAAO,GAAGlB,GAAG,CAACkB,OAAlB;AACAV,UAAAA,IAAI,GAAGD,aAAa,CAACM,eAAd,CAA8BhI,CAA9B,CAAP;AACA4H,UAAAA,EAAE,GAAGD,IAAI,CAAC,CAAD,CAAT;AACAE,UAAAA,EAAE,GAAGF,IAAI,CAAC,CAAD,CAAT;;AAEA,kBAAOU,OAAP;AACI,iBAAKxL,eAAL;AACIkL,cAAAA,KAAK,GAAG,IAAI9I,IAAJ,CAASlC,CAAT,CAAR;AACA+K,cAAAA,EAAE,GAAGC,KAAK,CAACU,SAAN,EAAL;;AAEA,kBAAGb,EAAE,GAAGC,EAAR,EAAY;AACRA,gBAAAA,EAAE,IAAI,CAAN;AACA,oBAAGC,EAAE,GAAGF,EAAR,EAAYE,EAAE,IAAI,CAAN;AACf;;AAED;;AACJ,iBAAKlL,YAAL;AACImL,cAAAA,KAAK,GAAG,IAAI9I,IAAJ,CAASlC,CAAT,CAAR;AACA,kBAAI2L,KAAK,GAAGX,KAAK,CAACY,WAAN,EAAZ;AACA,kBAAIC,OAAO,GAAGb,KAAK,CAACc,aAAN,EAAd;AACA,kBAAIC,OAAO,GAAGf,KAAK,CAACgB,aAAN,EAAd;AACA,kBAAIC,YAAY,GAAGjB,KAAK,CAACkB,kBAAN,EAAnB;AAEAnB,cAAAA,EAAE,GAAGY,KAAK,IACNE,OAAO,GAAG,EAAV,GACAE,OAAO,GAAG,IADV,GAEAE,YAAY,GAAG,OAHT,CAAV;;AAMA,kBAAGpB,EAAE,GAAGC,EAAR,EAAY;AACRA,gBAAAA,EAAE,IAAI,EAAN;AACA,oBAAGC,EAAE,GAAGF,EAAR,EAAYE,EAAE,IAAI,EAAN;AACf;;AAED;;AACJ,iBAAK,EAAL;AACI;AACA;AACA;AACAA,cAAAA,EAAE,GAAG/K,CAAL;AACA;AAnCR;;AAsCA,cAAG+K,EAAE,IAAIF,EAAN,IAAYE,EAAE,GAAGD,EAApB,EAAwB,OAAO1L,MAAP;AAC3B,SA7CD,MA6CO;AACH,cAAI+M,IAAI,GAAGxB,aAAa,CAACY,aAAd,CAA4BtI,CAA5B,CAAX;;AACA,eAAI,IAAI8D,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoF,IAAI,CAAChL,MAAxB,EAAgC4F,CAAC,EAAjC,EAAqC;AACjC8D,YAAAA,EAAE,GAAGsB,IAAI,CAACpF,CAAD,CAAT;AACA+D,YAAAA,EAAE,GAAGD,EAAE,GAAGT,GAAG,CAACgC,MAAd;AACA,gBAAGpM,CAAC,IAAI6K,EAAL,IAAW7K,CAAC,GAAG8K,EAAlB,EAAsB,OAAO1L,MAAP;AACzB;AACJ;AACJ;AACJ;;AACD,WAAOY,CAAP;AACH,GAhFD;;AAkFAQ,EAAAA,EAAE,CAAC6J,YAAH,GAAkB,UAASjJ,EAAT,EAAaC,EAAb,EAAiB;AAC/B,QAAI4B,CAAJ,EAAO2H,IAAP,EAAaC,EAAb,EAAiBC,EAAjB;AAEA,QAAIuB,cAAc,GAAG,EAArB;AACA,QAAG,CAAC7L,EAAE,CAACyD,WAAP,EAAoB,OAAOoI,cAAP;AAEpB,QAAI1B,aAAa,GAAGnK,EAAE,CAACyD,WAAH,CAAe0E,KAAf,GAAuBhB,IAAvB,CAA4B,UAASC,CAAT,EAAYlE,CAAZ,EAAe;AAC3D,UAAGkE,CAAC,CAAC0D,OAAF,KAAcxL,eAAd,IAAiC4D,CAAC,CAAC4H,OAAF,KAAczL,YAAlD,EAAgE,OAAO,CAAC,CAAR;AAChE,UAAG6D,CAAC,CAAC4H,OAAF,KAAcxL,eAAd,IAAiC8H,CAAC,CAAC0D,OAAF,KAAczL,YAAlD,EAAgE,OAAO,CAAP;AAChE,aAAO,CAAP;AACH,KAJmB,CAApB;;AAMA,QAAIyM,QAAQ,GAAG,SAAXA,QAAW,CAAS9H,GAAT,EAAcC,GAAd,EAAmB;AAC9BD,MAAAA,GAAG,GAAG9F,GAAG,CAACuK,SAAJ,CAAczE,GAAd,EAAmBpD,EAAnB,EAAuBC,EAAvB,CAAN;AACAoD,MAAAA,GAAG,GAAG/F,GAAG,CAACuK,SAAJ,CAAcxE,GAAd,EAAmBrD,EAAnB,EAAuBC,EAAvB,CAAN;AACA,UAAGmD,GAAG,KAAKC,GAAX,EAAgB;AAEhB,UAAI8H,UAAU,GAAG,IAAjB;;AACA,WAAI,IAAIxF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGsF,cAAc,CAAClL,MAAlC,EAA0C4F,CAAC,EAA3C,EAA+C;AAC3C,YAAIyF,IAAI,GAAGH,cAAc,CAACtF,CAAD,CAAzB;;AACA,YAAGvC,GAAG,GAAGgI,IAAI,CAAC/H,GAAX,IAAkBA,GAAG,IAAI+H,IAAI,CAAChI,GAAjC,EAAsC;AAClC,cAAGA,GAAG,GAAGgI,IAAI,CAAChI,GAAd,EAAmB;AACfgI,YAAAA,IAAI,CAAChI,GAAL,GAAWA,GAAX;AACH;;AACD,cAAGC,GAAG,GAAG+H,IAAI,CAAC/H,GAAd,EAAmB;AACf+H,YAAAA,IAAI,CAAC/H,GAAL,GAAWA,GAAX;AACH;;AACD8H,UAAAA,UAAU,GAAG,KAAb;AACH;AACJ;;AACD,UAAGA,UAAH,EAAe;AACXF,QAAAA,cAAc,CAAC5J,IAAf,CAAoB;AAAC+B,UAAAA,GAAG,EAAEA,GAAN;AAAWC,UAAAA,GAAG,EAAEA;AAAhB,SAApB;AACH;AACJ,KArBD;;AAuBA,SAAIxB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG0H,aAAa,CAACxJ,MAA7B,EAAqC8B,CAAC,EAAtC,EAA0C;AACtC,UAAImH,GAAG,GAAGO,aAAa,CAAC1H,CAAD,CAAvB;;AAEA,UAAGmH,GAAG,CAACe,OAAP,EAAgB;AACZ,YAAGf,GAAG,CAACgB,MAAP,EAAe;AACX,cAAIqB,EAAE,GAAGrL,EAAT;AACA,cAAIsL,EAAE,GAAGrL,EAAT;;AACA,cAAG+I,GAAG,CAACkB,OAAP,EAAgB;AACZ;AACAmB,YAAAA,EAAE,GAAGxM,IAAI,CAAC6B,KAAL,CAAW2K,EAAX,CAAL;AACH;;AAED7B,UAAAA,IAAI,GAAGlM,GAAG,CAAC2M,SAAJ,CAAcjB,GAAG,CAACgB,MAAlB,EAA0BhB,GAAG,CAACkB,OAAJ,GAAczM,WAAd,GAA4B2B,EAAE,CAACmF,GAAzD,CAAP;AACAkF,UAAAA,EAAE,GAAGD,IAAI,CAAC,CAAD,CAAT;AACAE,UAAAA,EAAE,GAAGF,IAAI,CAAC,CAAD,CAAT,CAVW,CAYX;;AACA,cAAI+B,MAAM,GAAG,IAAIzK,IAAJ,CAASuK,EAAT,CAAb,CAbW,CAcX;;AACA,cAAIG,QAAJ,CAfW,CAgBX;;AACA,cAAIC,IAAJ;;AAEA,kBAAOzC,GAAG,CAACkB,OAAX;AACI,iBAAKxL,eAAL;AACI+M,cAAAA,IAAI,GAAGvN,OAAP;AAEAsN,cAAAA,QAAQ,GAAG,CACP,CAAC9B,EAAE,GAAGD,EAAL,GAAU,CAAV,GAAc,CAAf,KACCC,EAAE,GAAGD,EADN,CADO,IAGPtL,MAHJ;AAKAkN,cAAAA,EAAE,IAAI5B,EAAE,GAAGtL,MAAL,IACFoN,MAAM,CAACjB,SAAP,KAAqBnM,MAArB,GACAoN,MAAM,CAACf,WAAP,KAAuBpM,OADvB,GAEAmN,MAAM,CAACb,aAAP,KAAyBrM,MAFzB,GAGAkN,MAAM,CAACX,aAAP,KAAyBtM,MAHzB,GAIAiN,MAAM,CAACT,kBAAP,EALE,CAAN;AAOA;;AACJ,iBAAKrM,YAAL;AACIgN,cAAAA,IAAI,GAAGtN,MAAP;AAEAqN,cAAAA,QAAQ,GAAG,CACP,CAAC9B,EAAE,GAAGD,EAAL,GAAU,EAAV,GAAe,CAAhB,KACCC,EAAE,GAAGD,EADN,CADO,IAGPrL,OAHJ;AAKAiN,cAAAA,EAAE,IAAI5B,EAAE,GAAGrL,OAAL,IACFmN,MAAM,CAACf,WAAP,KAAuBpM,OAAvB,GACAmN,MAAM,CAACb,aAAP,KAAyBrM,MADzB,GAEAkN,MAAM,CAACX,aAAP,KAAyBtM,MAFzB,GAGAiN,MAAM,CAACT,kBAAP,EAJE,CAAN;AAMA;;AACJ;AACIO,cAAAA,EAAE,GAAGxM,IAAI,CAACuE,GAAL,CAASoG,IAAI,CAAC,CAAD,CAAb,EAAkBA,IAAI,CAAC,CAAD,CAAtB,CAAL;AACA8B,cAAAA,EAAE,GAAGzM,IAAI,CAACwE,GAAL,CAASmG,IAAI,CAAC,CAAD,CAAb,EAAkBA,IAAI,CAAC,CAAD,CAAtB,CAAL;AACAiC,cAAAA,IAAI,GAAGH,EAAE,GAAGD,EAAZ;AACAG,cAAAA,QAAQ,GAAGC,IAAX;AApCR;;AAuCA,eAAI,IAAI9C,CAAC,GAAG0C,EAAZ,EAAgB1C,CAAC,GAAG2C,EAApB,EAAwB3C,CAAC,IAAI8C,IAA7B,EAAmC;AAC/BP,YAAAA,QAAQ,CAACvC,CAAD,EAAIA,CAAC,GAAG6C,QAAR,CAAR;AACH;AACJ,SA7DD,MA6DO;AACH,cAAIT,IAAI,GAAGzN,GAAG,CAAC2M,SAAJ,CAAcjB,GAAG,CAACoB,MAAlB,EAA0BhL,EAAE,CAACgF,GAA7B,CAAX;;AACA,eAAI,IAAIuB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoF,IAAI,CAAChL,MAAxB,EAAgC4F,CAAC,EAAjC,EAAqC;AACjC8D,YAAAA,EAAE,GAAGsB,IAAI,CAACpF,CAAD,CAAT;AACA+D,YAAAA,EAAE,GAAGD,EAAE,GAAGT,GAAG,CAACgC,MAAd;AACAE,YAAAA,QAAQ,CAACzB,EAAD,EAAKC,EAAL,CAAR;AACH;AACJ;AACJ;AACJ;;AAEDuB,IAAAA,cAAc,CAAC1E,IAAf,CAAoB,UAASC,CAAT,EAAYlE,CAAZ,EAAe;AAAE,aAAOkE,CAAC,CAACpD,GAAF,GAAQd,CAAC,CAACc,GAAjB;AAAuB,KAA5D;AAEA,WAAO6H,cAAP;AACH,GAlHD,CA3mBiD,CA+tBjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA7L,EAAAA,EAAE,CAACsM,YAAH,GAAkB,UAAStF,KAAT,EAAgB5G,QAAhB,EAA0Bc,IAA1B,EAAgC;AAC9C,QAAImB,OAAJ,EAAaE,QAAb,EAAuBE,CAAvB,EAA0BH,GAA1B;AAEA,QAAIiK,MAAM,GAAGvM,EAAE,CAACyE,IAAhB;AACA,QAAI+H,GAAG,GAAGD,MAAM,KAAK,MAAX,IAAqBvF,KAAK,CAAC5G,QAAQ,GAAG,UAAZ,CAApC;;AAEA,QAAGA,QAAQ,IAAI4G,KAAf,EAAsB;AAClB3E,MAAAA,OAAO,GAAG2E,KAAK,CAAC5G,QAAD,CAAf;AACAkC,MAAAA,GAAG,GAAG0E,KAAK,CAACC,OAAN,IAAiB/I,GAAG,CAACgJ,YAAJ,CAAiB7E,OAAjB,CAAvB;;AAEA,UAAGnE,GAAG,CAACuO,YAAJ,CAAiBpK,OAAjB,MAA8BkK,MAAM,KAAK,QAAX,IAAuBA,MAAM,KAAK,KAAhE,CAAH,EAA2E;AACvE,YAAGjK,GAAG,KAAKD,OAAO,CAAC1B,MAAnB,EAA2B;AACvB,iBAAO0B,OAAP;AACH,SAFD,MAEO,IAAGA,OAAO,CAACqK,QAAX,EAAqB;AACxB,iBAAOrK,OAAO,CAACqK,QAAR,CAAiB,CAAjB,EAAoBpK,GAApB,CAAP;AACH;AACJ;;AAED,UAAGiK,MAAM,KAAK,eAAd,EAA+B;AAC3B,eAAOnK,qBAAqB,CAACC,OAAD,EAAUC,GAAV,CAA5B;AACH;;AAEDC,MAAAA,QAAQ,GAAG,IAAIC,KAAJ,CAAUF,GAAV,CAAX;;AACA,WAAIG,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGH,GAAf,EAAoBG,CAAC,EAArB,EAAyB;AACrBF,QAAAA,QAAQ,CAACE,CAAD,CAAR,GAAczC,EAAE,CAACgF,GAAH,CAAO3C,OAAO,CAACI,CAAD,CAAd,EAAmB,CAAnB,EAAsB+J,GAAtB,EAA2BtL,IAA3B,CAAd;AACH;AACJ,KApBD,MAoBO;AACH,UAAIwB,EAAE,GAAKtC,QAAQ,GAAG,GAAZ,IAAoB4G,KAArB,GAA8BhH,EAAE,CAACgF,GAAH,CAAOgC,KAAK,CAAC5G,QAAQ,GAAG,GAAZ,CAAZ,EAA8B,CAA9B,EAAiCoM,GAAjC,CAA9B,GAAsE,CAA/E;AACA,UAAIG,EAAE,GAAI3F,KAAK,CAAC,MAAM5G,QAAP,CAAN,GAA0BwM,MAAM,CAAC5F,KAAK,CAAC,MAAM5G,QAAP,CAAN,CAAhC,GAA0D,CAAnE,CAFG,CAIH;;AACAiC,MAAAA,OAAO,GAAG2E,KAAK,CAAC;AAAC6F,QAAAA,CAAC,EAAE,GAAJ;AAASC,QAAAA,CAAC,EAAE;AAAZ,QAAiB1M,QAAjB,CAAD,CAAf;AACAkC,MAAAA,GAAG,GAAG0E,KAAK,CAACC,OAAN,IAAiB5E,OAAO,CAAC1B,MAA/B;AACA4B,MAAAA,QAAQ,GAAG,IAAIC,KAAJ,CAAUF,GAAV,CAAX;;AAEA,WAAIG,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGH,GAAf,EAAoBG,CAAC,EAArB,EAAyB;AACrBF,QAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcC,EAAE,GAAGD,CAAC,GAAGkK,EAAvB;AACH;AACJ,KAtC6C,CAwC9C;;;AACA,QAAG3M,EAAE,CAACyD,WAAN,EAAmB;AACf,WAAIhB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGH,GAAf,EAAoBG,CAAC,EAArB,EAAyB;AACrBF,QAAAA,QAAQ,CAACE,CAAD,CAAR,GAAczC,EAAE,CAACkK,UAAH,CAAc3H,QAAQ,CAACE,CAAD,CAAtB,CAAd;AACH;AACJ;;AAED,WAAOF,QAAP;AACH,GAhDD;;AAkDAvC,EAAAA,EAAE,CAAC+M,YAAH,GAAkB,UAASrM,KAAT,EAAgB;AAC9B,WACI8B,KAAK,CAAC0D,OAAN,CAAcxF,KAAd,KACAA,KAAK,CAACC,MAAN,KAAiB,CADjB,IAEAvC,SAAS,CAAC4B,EAAE,CAACmF,GAAH,CAAOzE,KAAK,CAAC,CAAD,CAAZ,CAAD,CAFT,IAGAtC,SAAS,CAAC4B,EAAE,CAACmF,GAAH,CAAOzE,KAAK,CAAC,CAAD,CAAZ,CAAD,CAJb;AAMH,GAPD;;AASAV,EAAAA,EAAE,CAACgN,eAAH,GAAqB,UAAS1F,CAAT,EAAYrG,QAAZ,EAAsB;AACvC,QAAIgM,KAAK,GAAGjN,EAAE,CAACwE,GAAH,CAAO8C,CAAC,CAAClH,QAAD,CAAR,EAAoB,IAApB,EAA0Ba,QAA1B,CAAZ;AACA,QAAIL,EAAE,GAAGZ,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAT;AACA,QAAIG,EAAE,GAAGb,EAAE,CAACmF,GAAH,CAAOnF,EAAE,CAACU,KAAH,CAAS,CAAT,CAAP,CAAT;;AAEA,QAAGE,EAAE,GAAGC,EAAR,EAAY;AACR,aAAOD,EAAE,IAAIqM,KAAN,IAAeA,KAAK,IAAIpM,EAA/B;AACH,KAFD,MAEO;AACH;AACA,aAAOA,EAAE,IAAIoM,KAAN,IAAeA,KAAK,IAAIrM,EAA/B;AACH;AACJ,GAXD;;AAaAZ,EAAAA,EAAE,CAACkN,gBAAH,GAAsB,YAAW;AAC7BlN,IAAAA,EAAE,CAAC8B,WAAH,GAAiB,EAAjB;AACA9B,IAAAA,EAAE,CAACgC,cAAH,GAAoB,EAApB;AACH,GAHD,CAhzBiD,CAqzBjD;;;AACAhC,EAAAA,EAAE,CAACmN,SAAH,GAAe,YAAW;AACtB,QAAI3G,KAAK,GAAGxG,EAAE,CAACyG,WAAf;;AACA,QAAGD,KAAH,EAAU;AACN,UAAI4G,UAAU,GAAG,IAAjB;AACA,UAAIC,aAAa,GAAG,IAApB;;AAEA,WAAI,IAAI3G,KAAR,IAAiBF,KAAjB,EAAwB;AACpB,YAAIG,GAAG,GAAG1G,UAAU,CAACd,OAAO,CAACyH,OAAR,CAAgBF,KAAhB,CAAD,CAApB;;AACA,YAAGC,GAAG,CAAC7E,WAAP,EAAoB;AAChBsL,UAAAA,UAAU,GAAGzG,GAAG,CAAC7E,WAAjB;AACAuL,UAAAA,aAAa,GAAG1G,GAAG,CAAC3E,cAApB;AACA;AACH;AACJ;;AAED,UAAGoL,UAAU,IAAIC,aAAjB,EAAgC;AAC5BrN,QAAAA,EAAE,CAAC8B,WAAH,GAAiBsL,UAAjB;AACApN,QAAAA,EAAE,CAACgC,cAAH,GAAoBqL,aAApB;AACH,OAHD,MAGO;AACHrN,QAAAA,EAAE,CAACkN,gBAAH;AACH;AACJ,KAnBD,MAmBO;AACHlN,MAAAA,EAAE,CAACkN,gBAAH;AACH;;AAED,QAAGlN,EAAE,CAACsN,kBAAN,EAA0B;AACtB,WAAI,IAAI/G,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGvG,EAAE,CAACsN,kBAAH,CAAsB3M,MAAzC,EAAiD4F,CAAC,EAAlD,EAAsD;AAClDxE,QAAAA,gBAAgB,CAAC/B,EAAE,CAACsN,kBAAH,CAAsB/G,CAAtB,CAAD,CAAhB;AACH;AACJ;AACJ,GA9BD,CAtzBiD,CAs1BjD;AACA;;;AACAvG,EAAAA,EAAE,CAACuN,uBAAH,GAA6B,YAAW;AACpC,QAAIC,cAAc,GAAG,EAArB;;AAEAxN,IAAAA,EAAE,CAACkN,gBAAH;;AAEA,QAAGlN,EAAE,CAACsN,kBAAN,EAA0B;AACtB,WAAI,IAAI/G,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGvG,EAAE,CAACsN,kBAAH,CAAsB3M,MAAzC,EAAiD4F,CAAC,EAAlD,EAAsD;AAClDxE,QAAAA,gBAAgB,CAAC/B,EAAE,CAACsN,kBAAH,CAAsB/G,CAAtB,CAAD,CAAhB;AACH;AACJ;;AAEDiH,IAAAA,cAAc,GAAGA,cAAc,CAAC3G,MAAf,CAAsB7G,EAAE,CAACsG,aAAzB,CAAjB,CAXoC,CAapC;;AACA,QAAIE,KAAK,GAAGxG,EAAE,CAACyG,WAAf;;AACA,SAAI,IAAIC,KAAR,IAAiBF,KAAjB,EAAwB;AACpB,UAAGtG,IAAI,KAAKwG,KAAZ,EAAmB;AACnB,UAAIC,GAAG,GAAG1G,UAAU,CAACd,OAAO,CAACyH,OAAR,CAAgBF,KAAhB,CAAD,CAApB;AACAC,MAAAA,GAAG,CAAC7E,WAAJ,GAAkB9B,EAAE,CAAC8B,WAArB;AACA6E,MAAAA,GAAG,CAAC3E,cAAJ,GAAqBhC,EAAE,CAACgC,cAAxB;AACAwL,MAAAA,cAAc,GAAGA,cAAc,CAAC3G,MAAf,CAAsBF,GAAG,CAACL,aAA1B,CAAjB;AACH;;AACD,WAAOkH,cAAP;AACH,GAvBD,CAx1BiD,CAi3BjD;AACA;AACA;AACA;AACA;;;AACA,MAAIC,MAAM,GAAGxN,UAAU,CAACyN,SAAxB;;AACA,MAAG1N,EAAE,CAACyE,IAAH,KAAY,MAAf,EAAuB;AACnBzE,IAAAA,EAAE,CAAC2N,WAAH,GAAiBF,MAAM,GAAGA,MAAM,CAACG,UAAV,GAAuB3P,SAA9C;AACA+B,IAAAA,EAAE,CAAC6N,YAAH,GAAkB5N,UAAU,CAAC4N,YAA7B;AACH,GA13BgD,CA23BjD;AACA;;;AACA7N,EAAAA,EAAE,CAAC8N,WAAH,GAAiB7N,UAAU,CAAC8N,UAA5B;AACA/N,EAAAA,EAAE,CAACgO,UAAH,GAAgBP,MAAM,GAAGA,MAAM,CAACtP,YAAV,GAAyBA,YAA/C,CA93BiD,CAg4BjD;;AACA,SAAO6B,EAAE,CAACiO,SAAV;AACA,SAAOjO,EAAE,CAACkO,WAAV;AACH,CAn4BD","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar utcFormat = require('d3-time-format').utcFormat;\nvar Lib = require('../../lib');\nvar numberFormat = Lib.numberFormat;\nvar isNumeric = require('fast-isnumeric');\n\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar ONEWEEK = numConstants.ONEWEEK;\nvar ONEDAY = numConstants.ONEDAY;\nvar ONEHOUR = numConstants.ONEHOUR;\nvar ONEMIN = numConstants.ONEMIN;\nvar ONESEC = numConstants.ONESEC;\n\nvar axisIds = require('./axis_ids');\nvar constants = require('./constants');\nvar HOUR_PATTERN = constants.HOUR_PATTERN;\nvar WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;\n\nfunction fromLog(v) {\n    return Math.pow(10, v);\n}\n\nfunction isValidCategory(v) {\n    return v !== null && v !== undefined;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v3.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n    fullLayout = fullLayout || {};\n\n    var axId = (ax._id || 'x');\n    var axLetter = axId.charAt(0);\n\n    function toLog(v, clip) {\n        if(v > 0) return Math.log(v) / Math.LN10;\n\n        else if(v <= 0 && clip && ax.range && ax.range.length === 2) {\n            // clip NaN (ie past negative infinity) to LOG_CLIP axis\n            // length past the negative edge\n            var r0 = ax.range[0];\n            var r1 = ax.range[1];\n            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n        } else return BADNUM;\n    }\n\n    /*\n     * wrapped dateTime2ms that:\n     * - accepts ms numbers for backward compatibility\n     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n     * - defaults to ax.calendar\n     */\n    function dt2ms(v, _, calendar, opts) {\n        if((opts || {}).msUTC && isNumeric(v)) {\n            // For now it is only used\n            // to fix bar length in milliseconds & gl3d ticks\n            // It could be applied in other places in v3\n            return +v;\n        }\n\n        // NOTE: Changed this behavior: previously we took any numeric value\n        // to be a ms, even if it was a string that could be a bare year.\n        // Now we convert it as a date if at all possible, and only try\n        // as (local) ms if that fails.\n        var ms = dateTime2ms(v, calendar || ax.calendar);\n        if(ms === BADNUM) {\n            if(isNumeric(v)) {\n                v = +v;\n                // keep track of tenths of ms, that `new Date` will drop\n                // same logic as in Lib.ms2DateTime\n                var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n                var msRounded = Math.round(v - msecTenths / 10);\n                ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n            } else return BADNUM;\n        }\n        return ms;\n    }\n\n    // wrapped ms2DateTime to insert default ax.calendar\n    function ms2dt(v, r, calendar) {\n        return ms2DateTime(v, r, calendar || ax.calendar);\n    }\n\n    function getCategoryName(v) {\n        return ax._categories[Math.round(v)];\n    }\n\n    /*\n     * setCategoryIndex: return the index of category v,\n     * inserting it in the list if it's not already there\n     *\n     * this will enter the categories in the order it\n     * encounters them, ie all the categories from the\n     * first data set, then all the ones from the second\n     * that aren't in the first etc.\n     *\n     * it is assumed that this function is being invoked in the\n     * already sorted category order; otherwise there would be\n     * a disconnect between the array and the index returned\n     */\n    function setCategoryIndex(v) {\n        if(isValidCategory(v)) {\n            if(ax._categoriesMap === undefined) {\n                ax._categoriesMap = {};\n            }\n\n            if(ax._categoriesMap[v] !== undefined) {\n                return ax._categoriesMap[v];\n            } else {\n                ax._categories.push(typeof v === 'number' ? String(v) : v);\n\n                var curLength = ax._categories.length - 1;\n                ax._categoriesMap[v] = curLength;\n\n                return curLength;\n            }\n        }\n        return BADNUM;\n    }\n\n    function setMultiCategoryIndex(arrayIn, len) {\n        var arrayOut = new Array(len);\n\n        for(var i = 0; i < len; i++) {\n            var v0 = (arrayIn[0] || [])[i];\n            var v1 = (arrayIn[1] || [])[i];\n            arrayOut[i] = getCategoryIndex([v0, v1]);\n        }\n\n        return arrayOut;\n    }\n\n    function getCategoryIndex(v) {\n        if(ax._categoriesMap) {\n            return ax._categoriesMap[v];\n        }\n    }\n\n    function getCategoryPosition(v) {\n        // d2l/d2c variant that that won't add categories but will also\n        // allow numbers to be mapped to the linearized axis positions\n        var index = getCategoryIndex(v);\n        if(index !== undefined) return index;\n        if(isNumeric(v)) return +v;\n    }\n\n    function getRangePosition(v) {\n        return isNumeric(v) ? +v : getCategoryIndex(v);\n    }\n\n    // include 2 fractional digits on pixel, for PDF zooming etc\n    function _l2p(v, m, b) { return d3.round(b + m * v, 2); }\n\n    function _p2l(px, m, b) { return (px - b) / m; }\n\n    var l2p = function l2p(v) {\n        if(!isNumeric(v)) return BADNUM;\n        return _l2p(v, ax._m, ax._b);\n    };\n\n    var p2l = function(px) {\n        return _p2l(px, ax._m, ax._b);\n    };\n\n    if(ax.rangebreaks) {\n        var isY = axLetter === 'y';\n\n        l2p = function(v) {\n            if(!isNumeric(v)) return BADNUM;\n            var len = ax._rangebreaks.length;\n            if(!len) return _l2p(v, ax._m, ax._b);\n\n            var flip = isY;\n            if(ax.range[0] > ax.range[1]) flip = !flip;\n            var signAx = flip ? -1 : 1;\n            var pos = signAx * v;\n\n            var q = 0;\n            for(var i = 0; i < len; i++) {\n                var min = signAx * ax._rangebreaks[i].min;\n                var max = signAx * ax._rangebreaks[i].max;\n\n                if(pos < min) break;\n                if(pos > max) q = i + 1;\n                else {\n                    // when falls into break, pick 'closest' offset\n                    q = pos < (min + max) / 2 ? i : i + 1;\n                    break;\n                }\n            }\n            var b2 = ax._B[q] || 0;\n            if(!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break\n            return _l2p(v, ax._m2, b2);\n        };\n\n        p2l = function(px) {\n            var len = ax._rangebreaks.length;\n            if(!len) return _p2l(px, ax._m, ax._b);\n\n            var q = 0;\n            for(var i = 0; i < len; i++) {\n                if(px < ax._rangebreaks[i].pmin) break;\n                if(px > ax._rangebreaks[i].pmax) q = i + 1;\n            }\n            return _p2l(px, ax._m2, ax._B[q]);\n        };\n    }\n\n    // conversions among c/l/p are fairly simple - do them together for all axis types\n    ax.c2l = (ax.type === 'log') ? toLog : ensureNumber;\n    ax.l2c = (ax.type === 'log') ? fromLog : ensureNumber;\n\n    ax.l2p = l2p;\n    ax.p2l = p2l;\n\n    ax.c2p = (ax.type === 'log') ? function(v, clip) { return l2p(toLog(v, clip)); } : l2p;\n    ax.p2c = (ax.type === 'log') ? function(px) { return fromLog(p2l(px)); } : p2l;\n\n    /*\n     * now type-specific conversions for **ALL** other combinations\n     * they're all written out, instead of being combinations of each other, for\n     * both clarity and speed.\n     */\n    if(['linear', '-'].indexOf(ax.type) !== -1) {\n        // all are data vals, but d and r need cleaning\n        ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n\n        ax.d2p = ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2d = ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    } else if(ax.type === 'log') {\n        // d and c are data vals, r and l are logged (but d and r need cleaning)\n        ax.d2r = ax.d2l = function(v, clip) { return toLog(cleanNumber(v), clip); };\n        ax.r2d = ax.r2c = function(v) { return fromLog(cleanNumber(v)); };\n\n        ax.d2c = ax.r2l = cleanNumber;\n        ax.c2d = ax.l2r = ensureNumber;\n\n        ax.c2r = toLog;\n        ax.l2d = fromLog;\n\n        ax.d2p = function(v, clip) { return ax.l2p(ax.d2r(v, clip)); };\n        ax.p2d = function(px) { return fromLog(p2l(px)); };\n\n        ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    } else if(ax.type === 'date') {\n        // r and d are date strings, l and c are ms\n\n        /*\n         * Any of these functions with r and d on either side, calendar is the\n         * **3rd** argument. log has reserved the second argument.\n         *\n         * Unless you need the special behavior of the second arg (ms2DateTime\n         * uses this to limit precision, toLog uses true to clip negatives\n         * to offscreen low rather than undefined), it's safe to pass 0.\n         */\n        ax.d2r = ax.r2d = Lib.identity;\n\n        ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n        ax.d2p = ax.r2p = function(v, _, calendar) { return ax.l2p(dt2ms(v, 0, calendar)); };\n        ax.p2d = ax.p2r = function(px, r, calendar) { return ms2dt(p2l(px), r, calendar); };\n\n        ax.cleanPos = function(v) { return Lib.cleanDate(v, BADNUM, ax.calendar); };\n    } else if(ax.type === 'category') {\n        // d is categories (string)\n        // c and l are indices (numbers)\n        // r is categories or numbers\n\n        ax.d2c = ax.d2l = setCategoryIndex;\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getRangePosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getRangePosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(typeof v === 'string' && v !== '') return v;\n            return ensureNumber(v);\n        };\n    } else if(ax.type === 'multicategory') {\n        // N.B. multicategory axes don't define d2c and d2l,\n        // as 'data-to-calcdata' conversion needs to take into\n        // account all data array items as in ax.makeCalcdata.\n\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getCategoryPosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.r2c_just_indices = getCategoryIndex;\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getCategoryPosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(Array.isArray(v) || (typeof v === 'string' && v !== '')) return v;\n            return ensureNumber(v);\n        };\n\n        ax.setupMultiCategory = function(fullData) {\n            var traceIndices = ax._traceIndices;\n            var i, j;\n\n            var group = ax._matchGroup;\n            if(group && ax._categories.length === 0) {\n                for(var axId2 in group) {\n                    if(axId2 !== axId) {\n                        var ax2 = fullLayout[axisIds.id2name(axId2)];\n                        traceIndices = traceIndices.concat(ax2._traceIndices);\n                    }\n                }\n            }\n\n            // [ [cnt, {$cat: index}], for 1,2 ]\n            var seen = [[0, {}], [0, {}]];\n            // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n            var list = [];\n\n            for(i = 0; i < traceIndices.length; i++) {\n                var trace = fullData[traceIndices[i]];\n\n                if(axLetter in trace) {\n                    var arrayIn = trace[axLetter];\n                    var len = trace._length || Lib.minRowLength(arrayIn);\n\n                    if(isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n                        for(j = 0; j < len; j++) {\n                            var v0 = arrayIn[0][j];\n                            var v1 = arrayIn[1][j];\n\n                            if(isValidCategory(v0) && isValidCategory(v1)) {\n                                list.push([v0, v1]);\n\n                                if(!(v0 in seen[0][1])) {\n                                    seen[0][1][v0] = seen[0][0]++;\n                                }\n                                if(!(v1 in seen[1][1])) {\n                                    seen[1][1][v1] = seen[1][0]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            list.sort(function(a, b) {\n                var ind0 = seen[0][1];\n                var d = ind0[a[0]] - ind0[b[0]];\n                if(d) return d;\n\n                var ind1 = seen[1][1];\n                return ind1[a[1]] - ind1[b[1]];\n            });\n\n            for(i = 0; i < list.length; i++) {\n                setCategoryIndex(list[i]);\n            }\n        };\n    }\n\n    // find the range value at the specified (linear) fraction of the axis\n    ax.fraction2r = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return ax.l2r(rl0 + v * (rl1 - rl0));\n    };\n\n    // find the fraction of the range at the specified range value\n    ax.r2fraction = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return (ax.r2l(v) - rl0) / (rl1 - rl0);\n    };\n\n    /*\n     * cleanRange: make sure range is a couplet of valid & distinct values\n     * keep numbers away from the limits of floating point numbers,\n     * and dates away from the ends of our date system (+/- 9999 years)\n     *\n     * optional param rangeAttr: operate on a different attribute, like\n     * ax._r, rather than ax.range\n     */\n    ax.cleanRange = function(rangeAttr, opts) {\n        if(!opts) opts = {};\n        if(!rangeAttr) rangeAttr = 'range';\n\n        var range = Lib.nestedProperty(ax, rangeAttr).get();\n        var i, dflt;\n\n        if(ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);\n        else if(axLetter === 'y') dflt = constants.DFLTRANGEY;\n        else dflt = opts.dfltRange || constants.DFLTRANGEX;\n\n        // make sure we don't later mutate the defaults\n        dflt = dflt.slice();\n\n        if(ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {\n            dflt[0] = 0;\n        }\n\n        if(!range || range.length !== 2) {\n            Lib.nestedProperty(ax, rangeAttr).set(dflt);\n            return;\n        }\n\n        if(ax.type === 'date' && !ax.autorange) {\n            // check if milliseconds or js date objects are provided for range\n            // and convert to date strings\n            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n        }\n\n        for(i = 0; i < 2; i++) {\n            if(ax.type === 'date') {\n                if(!Lib.isDateTime(range[i], ax.calendar)) {\n                    ax[rangeAttr] = dflt;\n                    break;\n                }\n\n                if(ax.r2l(range[0]) === ax.r2l(range[1])) {\n                    // split by +/- 1 second\n                    var linCenter = Lib.constrain(ax.r2l(range[0]),\n                        Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n                    range[0] = ax.l2r(linCenter - 1000);\n                    range[1] = ax.l2r(linCenter + 1000);\n                    break;\n                }\n            } else {\n                if(!isNumeric(range[i])) {\n                    if(isNumeric(range[1 - i])) {\n                        range[i] = range[1 - i] * (i ? 10 : 0.1);\n                    } else {\n                        ax[rangeAttr] = dflt;\n                        break;\n                    }\n                }\n\n                if(range[i] < -FP_SAFE) range[i] = -FP_SAFE;\n                else if(range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n                if(range[0] === range[1]) {\n                    // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n                    var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n                    range[0] -= inc;\n                    range[1] += inc;\n                }\n            }\n        }\n    };\n\n    // set scaling to pixels\n    ax.setScale = function(usePrivateRange) {\n        var gs = fullLayout._size;\n\n        // make sure we have a domain (pull it in from the axis\n        // this one is overlaying if necessary)\n        if(ax.overlaying) {\n            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);\n            ax.domain = ax2.domain;\n        }\n\n        // While transitions are occurring, we get a double-transform\n        // issue if we transform the drawn layer *and* use the new axis range to\n        // draw the data. This allows us to construct setConvert using the pre-\n        // interaction values of the range:\n        var rangeAttr = (usePrivateRange && ax._r) ? '_r' : 'range';\n        var calendar = ax.calendar;\n        ax.cleanRange(rangeAttr);\n\n        var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n        var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n\n        var isY = axLetter === 'y';\n        if(isY) {\n            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl0 - rl1);\n            ax._b = -ax._m * rl1;\n        } else {\n            ax._offset = gs.l + ax.domain[0] * gs.w;\n            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl1 - rl0);\n            ax._b = -ax._m * rl0;\n        }\n\n        // set of \"N\" disjoint rangebreaks inside the range\n        ax._rangebreaks = [];\n        // length of these rangebreaks in value space - negative on reversed axes\n        ax._lBreaks = 0;\n        // l2p slope (same for all intervals)\n        ax._m2 = 0;\n        // set of l2p offsets (one for each of the (N+1) piecewise intervals)\n        ax._B = [];\n\n        if(ax.rangebreaks) {\n            var i, brk;\n\n            ax._rangebreaks = ax.locateBreaks(\n                Math.min(rl0, rl1),\n                Math.max(rl0, rl1)\n            );\n\n            if(ax._rangebreaks.length) {\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    ax._lBreaks += Math.abs(brk.max - brk.min);\n                }\n\n                var flip = isY;\n                if(rl0 > rl1) flip = !flip;\n                if(flip) ax._rangebreaks.reverse();\n                var sign = flip ? -1 : 1;\n\n                ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);\n                ax._B.push(-ax._m2 * (isY ? rl1 : rl0));\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    ax._B.push(\n                        ax._B[ax._B.length - 1] -\n                        sign * ax._m2 * (brk.max - brk.min)\n                    );\n                }\n\n                // fill pixel (i.e. 'p') min/max here,\n                // to not have to loop through the _rangebreaks twice during `p2l`\n                for(i = 0; i < ax._rangebreaks.length; i++) {\n                    brk = ax._rangebreaks[i];\n                    brk.pmin = l2p(brk.min);\n                    brk.pmax = l2p(brk.max);\n                }\n            }\n        }\n\n        if(!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {\n            fullLayout._replotting = false;\n            throw new Error('Something went wrong with axis scaling');\n        }\n    };\n\n    ax.maskBreaks = function(v) {\n        var rangebreaksIn = ax.rangebreaks || [];\n        var bnds, b0, b1, vb, vDate;\n\n\n        if(!rangebreaksIn._cachedPatterns) {\n            rangebreaksIn._cachedPatterns = rangebreaksIn.map(function(brk) {\n                return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ?\n                    cleanNumber :\n                    ax.d2c // case of pattern: ''\n                ) : null;\n            });\n        }\n        if(!rangebreaksIn._cachedValues) {\n            rangebreaksIn._cachedValues = rangebreaksIn.map(function(brk) {\n                return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;\n            });\n        }\n\n\n        for(var i = 0; i < rangebreaksIn.length; i++) {\n            var brk = rangebreaksIn[i];\n\n            if(brk.enabled) {\n                if(brk.bounds) {\n                    var pattern = brk.pattern;\n                    bnds = rangebreaksIn._cachedPatterns[i];\n                    b0 = bnds[0];\n                    b1 = bnds[1];\n\n                    switch(pattern) {\n                        case WEEKDAY_PATTERN:\n                            vDate = new Date(v);\n                            vb = vDate.getUTCDay();\n\n                            if(b0 > b1) {\n                                b1 += 7;\n                                if(vb < b0) vb += 7;\n                            }\n\n                            break;\n                        case HOUR_PATTERN:\n                            vDate = new Date(v);\n                            var hours = vDate.getUTCHours();\n                            var minutes = vDate.getUTCMinutes();\n                            var seconds = vDate.getUTCSeconds();\n                            var milliseconds = vDate.getUTCMilliseconds();\n\n                            vb = hours + (\n                                minutes / 60 +\n                                seconds / 3600 +\n                                milliseconds / 3600000\n                            );\n\n                            if(b0 > b1) {\n                                b1 += 24;\n                                if(vb < b0) vb += 24;\n                            }\n\n                            break;\n                        case '':\n                            // N.B. should work on date axes as well!\n                            // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }\n                            // TODO should work with reversed-range axes\n                            vb = v;\n                            break;\n                    }\n\n                    if(vb >= b0 && vb < b1) return BADNUM;\n                } else {\n                    var vals = rangebreaksIn._cachedValues[i];\n                    for(var j = 0; j < vals.length; j++) {\n                        b0 = vals[j];\n                        b1 = b0 + brk.dvalue;\n                        if(v >= b0 && v < b1) return BADNUM;\n                    }\n                }\n            }\n        }\n        return v;\n    };\n\n    ax.locateBreaks = function(r0, r1) {\n        var i, bnds, b0, b1;\n\n        var rangebreaksOut = [];\n        if(!ax.rangebreaks) return rangebreaksOut;\n\n        var rangebreaksIn = ax.rangebreaks.slice().sort(function(a, b) {\n            if(a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;\n            if(b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;\n            return 0;\n        });\n\n        var addBreak = function(min, max) {\n            min = Lib.constrain(min, r0, r1);\n            max = Lib.constrain(max, r0, r1);\n            if(min === max) return;\n\n            var isNewBreak = true;\n            for(var j = 0; j < rangebreaksOut.length; j++) {\n                var brkj = rangebreaksOut[j];\n                if(min < brkj.max && max >= brkj.min) {\n                    if(min < brkj.min) {\n                        brkj.min = min;\n                    }\n                    if(max > brkj.max) {\n                        brkj.max = max;\n                    }\n                    isNewBreak = false;\n                }\n            }\n            if(isNewBreak) {\n                rangebreaksOut.push({min: min, max: max});\n            }\n        };\n\n        for(i = 0; i < rangebreaksIn.length; i++) {\n            var brk = rangebreaksIn[i];\n\n            if(brk.enabled) {\n                if(brk.bounds) {\n                    var t0 = r0;\n                    var t1 = r1;\n                    if(brk.pattern) {\n                        // to remove decimal (most often found in auto ranges)\n                        t0 = Math.floor(t0);\n                    }\n\n                    bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);\n                    b0 = bnds[0];\n                    b1 = bnds[1];\n\n                    // r0 value as date\n                    var t0Date = new Date(t0);\n                    // r0 value for break pattern\n                    var bndDelta;\n                    // step in ms between rangebreaks\n                    var step;\n\n                    switch(brk.pattern) {\n                        case WEEKDAY_PATTERN:\n                            step = ONEWEEK;\n\n                            bndDelta = (\n                                (b1 < b0 ? 7 : 0) +\n                                (b1 - b0)\n                            ) * ONEDAY;\n\n                            t0 += b0 * ONEDAY - (\n                                t0Date.getUTCDay() * ONEDAY +\n                                t0Date.getUTCHours() * ONEHOUR +\n                                t0Date.getUTCMinutes() * ONEMIN +\n                                t0Date.getUTCSeconds() * ONESEC +\n                                t0Date.getUTCMilliseconds()\n                            );\n                            break;\n                        case HOUR_PATTERN:\n                            step = ONEDAY;\n\n                            bndDelta = (\n                                (b1 < b0 ? 24 : 0) +\n                                (b1 - b0)\n                            ) * ONEHOUR;\n\n                            t0 += b0 * ONEHOUR - (\n                                t0Date.getUTCHours() * ONEHOUR +\n                                t0Date.getUTCMinutes() * ONEMIN +\n                                t0Date.getUTCSeconds() * ONESEC +\n                                t0Date.getUTCMilliseconds()\n                            );\n                            break;\n                        default:\n                            t0 = Math.min(bnds[0], bnds[1]);\n                            t1 = Math.max(bnds[0], bnds[1]);\n                            step = t1 - t0;\n                            bndDelta = step;\n                    }\n\n                    for(var t = t0; t < t1; t += step) {\n                        addBreak(t, t + bndDelta);\n                    }\n                } else {\n                    var vals = Lib.simpleMap(brk.values, ax.d2c);\n                    for(var j = 0; j < vals.length; j++) {\n                        b0 = vals[j];\n                        b1 = b0 + brk.dvalue;\n                        addBreak(b0, b1);\n                    }\n                }\n            }\n        }\n\n        rangebreaksOut.sort(function(a, b) { return a.min - b.min; });\n\n        return rangebreaksOut;\n    };\n\n    // makeCalcdata: takes an x or y array and converts it\n    // to a position on the axis object \"ax\"\n    // inputs:\n    //      trace - a data object from gd.data\n    //      axLetter - a string, either 'x' or 'y', for which item\n    //          to convert (TODO: is this now always the same as\n    //          the first letter of ax._id?)\n    // in case the expected data isn't there, make a list of\n    // integers based on the opposite data\n    ax.makeCalcdata = function(trace, axLetter, opts) {\n        var arrayIn, arrayOut, i, len;\n\n        var axType = ax.type;\n        var cal = axType === 'date' && trace[axLetter + 'calendar'];\n\n        if(axLetter in trace) {\n            arrayIn = trace[axLetter];\n            len = trace._length || Lib.minRowLength(arrayIn);\n\n            if(Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n                if(len === arrayIn.length) {\n                    return arrayIn;\n                } else if(arrayIn.subarray) {\n                    return arrayIn.subarray(0, len);\n                }\n            }\n\n            if(axType === 'multicategory') {\n                return setMultiCategoryIndex(arrayIn, len);\n            }\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);\n            }\n        } else {\n            var v0 = ((axLetter + '0') in trace) ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n            var dv = (trace['d' + axLetter]) ? Number(trace['d' + axLetter]) : 1;\n\n            // the opposing data, for size if we have x and dx etc\n            arrayIn = trace[{x: 'y', y: 'x'}[axLetter]];\n            len = trace._length || arrayIn.length;\n            arrayOut = new Array(len);\n\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = v0 + i * dv;\n            }\n        }\n\n        // mask (i.e. set to BADNUM) coords that fall inside rangebreaks\n        if(ax.rangebreaks) {\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = ax.maskBreaks(arrayOut[i]);\n            }\n        }\n\n        return arrayOut;\n    };\n\n    ax.isValidRange = function(range) {\n        return (\n            Array.isArray(range) &&\n            range.length === 2 &&\n            isNumeric(ax.r2l(range[0])) &&\n            isNumeric(ax.r2l(range[1]))\n        );\n    };\n\n    ax.isPtWithinRange = function(d, calendar) {\n        var coord = ax.c2l(d[axLetter], null, calendar);\n        var r0 = ax.r2l(ax.range[0]);\n        var r1 = ax.r2l(ax.range[1]);\n\n        if(r0 < r1) {\n            return r0 <= coord && coord <= r1;\n        } else {\n            // Reversed axis case.\n            return r1 <= coord && coord <= r0;\n        }\n    };\n\n    ax._emptyCategories = function() {\n        ax._categories = [];\n        ax._categoriesMap = {};\n    };\n\n    // should skip if not category nor multicategory\n    ax.clearCalc = function() {\n        var group = ax._matchGroup;\n        if(group) {\n            var categories = null;\n            var categoriesMap = null;\n\n            for(var axId2 in group) {\n                var ax2 = fullLayout[axisIds.id2name(axId2)];\n                if(ax2._categories) {\n                    categories = ax2._categories;\n                    categoriesMap = ax2._categoriesMap;\n                    break;\n                }\n            }\n\n            if(categories && categoriesMap) {\n                ax._categories = categories;\n                ax._categoriesMap = categoriesMap;\n            } else {\n                ax._emptyCategories();\n            }\n        } else {\n            ax._emptyCategories();\n        }\n\n        if(ax._initialCategories) {\n            for(var j = 0; j < ax._initialCategories.length; j++) {\n                setCategoryIndex(ax._initialCategories[j]);\n            }\n        }\n    };\n\n    // sort the axis (and all the matching ones) by _initialCategories\n    // returns the indices of the traces affected by the reordering\n    ax.sortByInitialCategories = function() {\n        var affectedTraces = [];\n\n        ax._emptyCategories();\n\n        if(ax._initialCategories) {\n            for(var j = 0; j < ax._initialCategories.length; j++) {\n                setCategoryIndex(ax._initialCategories[j]);\n            }\n        }\n\n        affectedTraces = affectedTraces.concat(ax._traceIndices);\n\n        // Propagate to matching axes\n        var group = ax._matchGroup;\n        for(var axId2 in group) {\n            if(axId === axId2) continue;\n            var ax2 = fullLayout[axisIds.id2name(axId2)];\n            ax2._categories = ax._categories;\n            ax2._categoriesMap = ax._categoriesMap;\n            affectedTraces = affectedTraces.concat(ax2._traceIndices);\n        }\n        return affectedTraces;\n    };\n\n    // Propagate localization into the axis so that\n    // methods in Axes can use it w/o having to pass fullLayout\n    // Default (non-d3) number formatting uses separators directly\n    // dates and d3-formatted numbers use the d3 locale\n    // Fall back on default format for dummy axes that don't care about formatting\n    var locale = fullLayout._d3locale;\n    if(ax.type === 'date') {\n        ax._dateFormat = locale ? locale.timeFormat : utcFormat;\n        ax._extraFormat = fullLayout._extraFormat;\n    }\n    // occasionally we need _numFormat to pass through\n    // even though it won't be needed by this axis\n    ax._separators = fullLayout.separators;\n    ax._numFormat = locale ? locale.numberFormat : numberFormat;\n\n    // and for bar charts and box plots: reset forced minimum tick spacing\n    delete ax._minDtick;\n    delete ax._forceTick0;\n};\n"]},"metadata":{},"sourceType":"script"}