{"ast":null,"code":"\"use strict\"; //High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull;\n\nvar orient = require(\"robust-orientation\");\n\nvar compareCell = require(\"simplicial-complex\").compareCells;\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices;\n  this.adjacent = adjacent;\n  this.boundary = boundary;\n  this.lastVisited = -1;\n}\n\nSimplex.prototype.flip = function () {\n  var t = this.vertices[0];\n  this.vertices[0] = this.vertices[1];\n  this.vertices[1] = t;\n  var u = this.adjacent[0];\n  this.adjacent[0] = this.adjacent[1];\n  this.adjacent[1] = u;\n};\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices;\n  this.cell = cell;\n  this.index = index;\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices);\n}\n\nfunction wrapper(test) {\n  return function () {\n    var tuple = this.tuple;\n    return test.apply(this, tuple);\n  };\n}\n\nfunction bakeOrient(d) {\n  var test = orient[d + 1];\n\n  if (!test) {\n    test = orient;\n  }\n\n  return wrapper(test);\n}\n\nvar BAKED = [];\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension;\n  this.vertices = vertices;\n  this.simplices = simplices;\n  this.interior = simplices.filter(function (c) {\n    return !c.boundary;\n  });\n  this.tuple = new Array(dimension + 1);\n\n  for (var i = 0; i <= dimension; ++i) {\n    this.tuple[i] = this.vertices[i];\n  }\n\n  var o = BAKED[dimension];\n\n  if (!o) {\n    o = BAKED[dimension] = bakeOrient(dimension);\n  }\n\n  this.orient = o;\n}\n\nvar proto = Triangulation.prototype; //Degenerate situation where we are on boundary, but coplanar to face\n\nproto.handleBoundaryDegeneracy = function (cell, point) {\n  var d = this.dimension;\n  var n = this.vertices.length - 1;\n  var tuple = this.tuple;\n  var verts = this.vertices; //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n\n  var toVisit = [cell];\n  cell.lastVisited = -n;\n\n  while (toVisit.length > 0) {\n    cell = toVisit.pop();\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices;\n\n      for (var j = 0; j <= d; ++j) {\n        var vv = nv[j];\n\n        if (vv < 0) {\n          tuple[j] = point;\n        } else {\n          tuple[j] = verts[vv];\n        }\n      }\n\n      var o = this.orient();\n\n      if (o > 0) {\n        return neighbor;\n      }\n\n      neighbor.lastVisited = -n;\n\n      if (o === 0) {\n        toVisit.push(neighbor);\n      }\n    }\n  }\n\n  return null;\n};\n\nproto.walk = function (point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple; //Compute initial jump cell\n\n  var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;\n  var cell = this.interior[initIndex]; //Start walking\n\n  outerLoop: while (!cell.boundary) {\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      tuple[i] = verts[cellVerts[i]];\n    }\n\n    cell.lastVisited = n; //Find farthest adjacent cell\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var prev = tuple[i];\n      tuple[i] = point;\n      var o = this.orient();\n      tuple[i] = prev;\n\n      if (o < 0) {\n        cell = neighbor;\n        continue outerLoop;\n      } else {\n        if (!neighbor.boundary) {\n          neighbor.lastVisited = n;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n    }\n\n    return;\n  }\n\n  return cell;\n};\n\nproto.addPeaks = function (point, cell) {\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple;\n  var interior = this.interior;\n  var simplices = this.simplices; //Walking finished at boundary, time to add peaks\n\n  var tovisit = [cell]; //Stretch initial boundary cell into a peak\n\n  cell.lastVisited = n;\n  cell.vertices[cell.vertices.indexOf(-1)] = n;\n  cell.boundary = false;\n  interior.push(cell); //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n\n  var glueFacets = []; //Do a traversal of the boundary walking outward from starting peak\n\n  while (tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    var indexOfN = cellVerts.indexOf(n);\n\n    if (indexOfN < 0) {\n      continue;\n    }\n\n    for (var i = 0; i <= d; ++i) {\n      if (i === indexOfN) {\n        continue;\n      } //For each boundary neighbor of the cell\n\n\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices; //Test if neighbor is a peak\n\n      if (neighbor.lastVisited !== -n) {\n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0;\n\n        for (var j = 0; j <= d; ++j) {\n          if (nv[j] < 0) {\n            indexOfNeg1 = j;\n            tuple[j] = point;\n          } else {\n            tuple[j] = verts[nv[j]];\n          }\n        }\n\n        var o = this.orient(); //Test if neighbor cell is also a peak\n\n        if (o > 0) {\n          nv[indexOfNeg1] = n;\n          neighbor.boundary = false;\n          interior.push(neighbor);\n          tovisit.push(neighbor);\n          neighbor.lastVisited = n;\n          continue;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n\n      var na = neighbor.adjacent; //Otherwise, replace neighbor with new face\n\n      var vverts = cellVerts.slice();\n      var vadj = cellAdj.slice();\n      var ncell = new Simplex(vverts, vadj, true);\n      simplices.push(ncell); //Connect to neighbor\n\n      var opposite = na.indexOf(cell);\n\n      if (opposite < 0) {\n        continue;\n      }\n\n      na[opposite] = ncell;\n      vadj[indexOfN] = neighbor; //Connect to cell\n\n      vverts[i] = -1;\n      vadj[i] = cell;\n      cellAdj[i] = ncell; //Flip facet\n\n      ncell.flip(); //Add to glue list\n\n      for (var j = 0; j <= d; ++j) {\n        var uu = vverts[j];\n\n        if (uu < 0 || uu === n) {\n          continue;\n        }\n\n        var nface = new Array(d - 1);\n        var nptr = 0;\n\n        for (var k = 0; k <= d; ++k) {\n          var vv = vverts[k];\n\n          if (vv < 0 || k === j) {\n            continue;\n          }\n\n          nface[nptr++] = vv;\n        }\n\n        glueFacets.push(new GlueFacet(nface, ncell, j));\n      }\n    }\n  } //Glue boundary facets together\n\n\n  glueFacets.sort(compareGlue);\n\n  for (var i = 0; i + 1 < glueFacets.length; i += 2) {\n    var a = glueFacets[i];\n    var b = glueFacets[i + 1];\n    var ai = a.index;\n    var bi = b.index;\n\n    if (ai < 0 || bi < 0) {\n      continue;\n    }\n\n    a.cell.adjacent[a.index] = b.cell;\n    b.cell.adjacent[b.index] = a.cell;\n  }\n};\n\nproto.insert = function (point, random) {\n  //Add point\n  var verts = this.vertices;\n  verts.push(point);\n  var cell = this.walk(point, random);\n\n  if (!cell) {\n    return;\n  } //Alias local properties\n\n\n  var d = this.dimension;\n  var tuple = this.tuple; //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n\n  for (var i = 0; i <= d; ++i) {\n    var vv = cell.vertices[i];\n\n    if (vv < 0) {\n      tuple[i] = point;\n    } else {\n      tuple[i] = verts[vv];\n    }\n  }\n\n  var o = this.orient(tuple);\n\n  if (o < 0) {\n    return;\n  } else if (o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point);\n\n    if (!cell) {\n      return;\n    }\n  } //Add peaks\n\n\n  this.addPeaks(point, cell);\n}; //Extract all boundary cells\n\n\nproto.boundary = function () {\n  var d = this.dimension;\n  var boundary = [];\n  var cells = this.simplices;\n  var nc = cells.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    if (c.boundary) {\n      var bcell = new Array(d);\n      var cv = c.vertices;\n      var ptr = 0;\n      var parity = 0;\n\n      for (var j = 0; j <= d; ++j) {\n        if (cv[j] >= 0) {\n          bcell[ptr++] = cv[j];\n        } else {\n          parity = j & 1;\n        }\n      }\n\n      if (parity === (d & 1)) {\n        var t = bcell[0];\n        bcell[0] = bcell[1];\n        bcell[1] = t;\n      }\n\n      boundary.push(bcell);\n    }\n  }\n\n  return boundary;\n};\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length;\n\n  if (n === 0) {\n    throw new Error(\"Must have at least d+1 points\");\n  }\n\n  var d = points[0].length;\n\n  if (n <= d) {\n    throw new Error(\"Must input at least d+1 points\");\n  } //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n\n\n  var initialSimplex = points.slice(0, d + 1); //Make sure initial simplex is positively oriented\n\n  var o = orient.apply(void 0, initialSimplex);\n\n  if (o === 0) {\n    throw new Error(\"Input not in general position\");\n  }\n\n  var initialCoords = new Array(d + 1);\n\n  for (var i = 0; i <= d; ++i) {\n    initialCoords[i] = i;\n  }\n\n  if (o < 0) {\n    initialCoords[0] = 1;\n    initialCoords[1] = 0;\n  } //Create initial topological index, glue pointers together (kind of messy)\n\n\n  var initialCell = new Simplex(initialCoords, new Array(d + 1), false);\n  var boundary = initialCell.adjacent;\n  var list = new Array(d + 2);\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = initialCoords.slice();\n\n    for (var j = 0; j <= d; ++j) {\n      if (j === i) {\n        verts[j] = -1;\n      }\n    }\n\n    var t = verts[0];\n    verts[0] = verts[1];\n    verts[1] = t;\n    var cell = new Simplex(verts, new Array(d + 1), true);\n    boundary[i] = cell;\n    list[i] = cell;\n  }\n\n  list[d + 1] = initialCell;\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = boundary[i].vertices;\n    var adj = boundary[i].adjacent;\n\n    for (var j = 0; j <= d; ++j) {\n      var v = verts[j];\n\n      if (v < 0) {\n        adj[j] = initialCell;\n        continue;\n      }\n\n      for (var k = 0; k <= d; ++k) {\n        if (boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k];\n        }\n      }\n    }\n  } //Initialize triangles\n\n\n  var triangles = new Triangulation(d, initialSimplex, list); //Insert remaining points\n\n  var useRandom = !!randomSearch;\n\n  for (var i = d + 1; i < n; ++i) {\n    triangles.insert(points[i], useRandom);\n  } //Extract boundary cells\n\n\n  return triangles.boundary();\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/incremental-convex-hull/ich.js"],"names":["module","exports","incrementalConvexHull","orient","require","compareCell","compareCells","Simplex","vertices","adjacent","boundary","lastVisited","prototype","flip","t","u","GlueFacet","cell","index","compareGlue","a","b","wrapper","test","tuple","apply","bakeOrient","d","BAKED","Triangulation","dimension","simplices","interior","filter","c","Array","i","o","proto","handleBoundaryDegeneracy","point","n","length","verts","toVisit","pop","cellAdj","neighbor","nv","j","vv","push","walk","random","initIndex","Math","outerLoop","cellVerts","prev","addPeaks","tovisit","indexOf","glueFacets","indexOfN","indexOfNeg1","na","vverts","slice","vadj","ncell","opposite","uu","nface","nptr","k","sort","ai","bi","insert","cells","nc","bcell","cv","ptr","parity","points","randomSearch","Error","initialSimplex","initialCoords","initialCell","list","adj","v","triangles","useRandom"],"mappings":"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","sourcesContent":["\"use strict\"\r\n\r\n//High level idea:\r\n// 1. Use Clarkson's incremental construction to find convex hull\r\n// 2. Point location in triangulation by jump and walk\r\n\r\nmodule.exports = incrementalConvexHull\r\n\r\nvar orient = require(\"robust-orientation\")\r\nvar compareCell = require(\"simplicial-complex\").compareCells\r\n\r\nfunction Simplex(vertices, adjacent, boundary) {\r\n  this.vertices = vertices\r\n  this.adjacent = adjacent\r\n  this.boundary = boundary\r\n  this.lastVisited = -1\r\n}\r\n\r\nSimplex.prototype.flip = function() {\r\n  var t = this.vertices[0]\r\n  this.vertices[0] = this.vertices[1]\r\n  this.vertices[1] = t\r\n  var u = this.adjacent[0]\r\n  this.adjacent[0] = this.adjacent[1]\r\n  this.adjacent[1] = u\r\n}\r\n\r\nfunction GlueFacet(vertices, cell, index) {\r\n  this.vertices = vertices\r\n  this.cell = cell\r\n  this.index = index\r\n}\r\n\r\nfunction compareGlue(a, b) {\r\n  return compareCell(a.vertices, b.vertices)\r\n}\r\n\r\nfunction wrapper(test) {\r\n  return function() {\r\n    var tuple = this.tuple\r\n    return test.apply(this, tuple)\r\n  }\r\n}\r\n\r\nfunction bakeOrient(d) {\r\n  var test = orient[d+1]\r\n  if(!test) {\r\n    test = orient\r\n  }\r\n  return wrapper(test)\r\n}\r\n\r\nvar BAKED = []\r\n\r\nfunction Triangulation(dimension, vertices, simplices) {\r\n  this.dimension = dimension\r\n  this.vertices = vertices\r\n  this.simplices = simplices\r\n  this.interior = simplices.filter(function(c) {\r\n    return !c.boundary\r\n  })\r\n\r\n  this.tuple = new Array(dimension+1)\r\n  for(var i=0; i<=dimension; ++i) {\r\n    this.tuple[i] = this.vertices[i]\r\n  }\r\n\r\n  var o = BAKED[dimension]\r\n  if(!o) {\r\n    o = BAKED[dimension] = bakeOrient(dimension)\r\n  }\r\n  this.orient = o\r\n}\r\n\r\nvar proto = Triangulation.prototype\r\n\r\n//Degenerate situation where we are on boundary, but coplanar to face\r\nproto.handleBoundaryDegeneracy = function(cell, point) {\r\n  var d = this.dimension\r\n  var n = this.vertices.length - 1\r\n  var tuple = this.tuple\r\n  var verts = this.vertices\r\n\r\n  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\r\n  var toVisit = [ cell ]\r\n  cell.lastVisited = -n\r\n  while(toVisit.length > 0) {\r\n    cell = toVisit.pop()\r\n    var cellAdj = cell.adjacent\r\n    for(var i=0; i<=d; ++i) {\r\n      var neighbor = cellAdj[i]\r\n      if(!neighbor.boundary || neighbor.lastVisited <= -n) {\r\n        continue\r\n      }\r\n      var nv = neighbor.vertices\r\n      for(var j=0; j<=d; ++j) {\r\n        var vv = nv[j]\r\n        if(vv < 0) {\r\n          tuple[j] = point\r\n        } else {\r\n          tuple[j] = verts[vv]\r\n        }\r\n      }\r\n      var o = this.orient()\r\n      if(o > 0) {\r\n        return neighbor\r\n      }\r\n      neighbor.lastVisited = -n\r\n      if(o === 0) {\r\n        toVisit.push(neighbor)\r\n      }\r\n    }\r\n  }\r\n  return null\r\n}\r\n\r\nproto.walk = function(point, random) {\r\n  //Alias local properties\r\n  var n = this.vertices.length - 1\r\n  var d = this.dimension\r\n  var verts = this.vertices\r\n  var tuple = this.tuple\r\n\r\n  //Compute initial jump cell\r\n  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)\r\n  var cell = this.interior[ initIndex ]\r\n\r\n  //Start walking\r\nouterLoop:\r\n  while(!cell.boundary) {\r\n    var cellVerts = cell.vertices\r\n    var cellAdj = cell.adjacent\r\n\r\n    for(var i=0; i<=d; ++i) {\r\n      tuple[i] = verts[cellVerts[i]]\r\n    }\r\n    cell.lastVisited = n\r\n\r\n    //Find farthest adjacent cell\r\n    for(var i=0; i<=d; ++i) {\r\n      var neighbor = cellAdj[i]\r\n      if(neighbor.lastVisited >= n) {\r\n        continue\r\n      }\r\n      var prev = tuple[i]\r\n      tuple[i] = point\r\n      var o = this.orient()\r\n      tuple[i] = prev\r\n      if(o < 0) {\r\n        cell = neighbor\r\n        continue outerLoop\r\n      } else {\r\n        if(!neighbor.boundary) {\r\n          neighbor.lastVisited = n\r\n        } else {\r\n          neighbor.lastVisited = -n\r\n        }\r\n      }\r\n    }\r\n    return\r\n  }\r\n\r\n  return cell\r\n}\r\n\r\nproto.addPeaks = function(point, cell) {\r\n  var n = this.vertices.length - 1\r\n  var d = this.dimension\r\n  var verts = this.vertices\r\n  var tuple = this.tuple\r\n  var interior = this.interior\r\n  var simplices = this.simplices\r\n\r\n  //Walking finished at boundary, time to add peaks\r\n  var tovisit = [ cell ]\r\n\r\n  //Stretch initial boundary cell into a peak\r\n  cell.lastVisited = n\r\n  cell.vertices[cell.vertices.indexOf(-1)] = n\r\n  cell.boundary = false\r\n  interior.push(cell)\r\n\r\n  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\r\n  var glueFacets = []\r\n\r\n  //Do a traversal of the boundary walking outward from starting peak\r\n  while(tovisit.length > 0) {\r\n    //Pop off peak and walk over adjacent cells\r\n    var cell = tovisit.pop()\r\n    var cellVerts = cell.vertices\r\n    var cellAdj = cell.adjacent\r\n    var indexOfN = cellVerts.indexOf(n)\r\n    if(indexOfN < 0) {\r\n      continue\r\n    }\r\n\r\n    for(var i=0; i<=d; ++i) {\r\n      if(i === indexOfN) {\r\n        continue\r\n      }\r\n\r\n      //For each boundary neighbor of the cell\r\n      var neighbor = cellAdj[i]\r\n      if(!neighbor.boundary || neighbor.lastVisited >= n) {\r\n        continue\r\n      }\r\n\r\n      var nv = neighbor.vertices\r\n\r\n      //Test if neighbor is a peak\r\n      if(neighbor.lastVisited !== -n) {\r\n        //Compute orientation of p relative to each boundary peak\r\n        var indexOfNeg1 = 0\r\n        for(var j=0; j<=d; ++j) {\r\n          if(nv[j] < 0) {\r\n            indexOfNeg1 = j\r\n            tuple[j] = point\r\n          } else {\r\n            tuple[j] = verts[nv[j]]\r\n          }\r\n        }\r\n        var o = this.orient()\r\n\r\n        //Test if neighbor cell is also a peak\r\n        if(o > 0) {\r\n          nv[indexOfNeg1] = n\r\n          neighbor.boundary = false\r\n          interior.push(neighbor)\r\n          tovisit.push(neighbor)\r\n          neighbor.lastVisited = n\r\n          continue\r\n        } else {\r\n          neighbor.lastVisited = -n\r\n        }\r\n      }\r\n\r\n      var na = neighbor.adjacent\r\n\r\n      //Otherwise, replace neighbor with new face\r\n      var vverts = cellVerts.slice()\r\n      var vadj = cellAdj.slice()\r\n      var ncell = new Simplex(vverts, vadj, true)\r\n      simplices.push(ncell)\r\n\r\n      //Connect to neighbor\r\n      var opposite = na.indexOf(cell)\r\n      if(opposite < 0) {\r\n        continue\r\n      }\r\n      na[opposite] = ncell\r\n      vadj[indexOfN] = neighbor\r\n\r\n      //Connect to cell\r\n      vverts[i] = -1\r\n      vadj[i] = cell\r\n      cellAdj[i] = ncell\r\n\r\n      //Flip facet\r\n      ncell.flip()\r\n\r\n      //Add to glue list\r\n      for(var j=0; j<=d; ++j) {\r\n        var uu = vverts[j]\r\n        if(uu < 0 || uu === n) {\r\n          continue\r\n        }\r\n        var nface = new Array(d-1)\r\n        var nptr = 0\r\n        for(var k=0; k<=d; ++k) {\r\n          var vv = vverts[k]\r\n          if(vv < 0 || k === j) {\r\n            continue\r\n          }\r\n          nface[nptr++] = vv\r\n        }\r\n        glueFacets.push(new GlueFacet(nface, ncell, j))\r\n      }\r\n    }\r\n  }\r\n\r\n  //Glue boundary facets together\r\n  glueFacets.sort(compareGlue)\r\n\r\n  for(var i=0; i+1<glueFacets.length; i+=2) {\r\n    var a = glueFacets[i]\r\n    var b = glueFacets[i+1]\r\n    var ai = a.index\r\n    var bi = b.index\r\n    if(ai < 0 || bi < 0) {\r\n      continue\r\n    }\r\n    a.cell.adjacent[a.index] = b.cell\r\n    b.cell.adjacent[b.index] = a.cell\r\n  }\r\n}\r\n\r\nproto.insert = function(point, random) {\r\n  //Add point\r\n  var verts = this.vertices\r\n  verts.push(point)\r\n\r\n  var cell = this.walk(point, random)\r\n  if(!cell) {\r\n    return\r\n  }\r\n\r\n  //Alias local properties\r\n  var d = this.dimension\r\n  var tuple = this.tuple\r\n\r\n  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\r\n  for(var i=0; i<=d; ++i) {\r\n    var vv = cell.vertices[i]\r\n    if(vv < 0) {\r\n      tuple[i] = point\r\n    } else {\r\n      tuple[i] = verts[vv]\r\n    }\r\n  }\r\n  var o = this.orient(tuple)\r\n  if(o < 0) {\r\n    return\r\n  } else if(o === 0) {\r\n    cell = this.handleBoundaryDegeneracy(cell, point)\r\n    if(!cell) {\r\n      return\r\n    }\r\n  }\r\n\r\n  //Add peaks\r\n  this.addPeaks(point, cell)\r\n}\r\n\r\n//Extract all boundary cells\r\nproto.boundary = function() {\r\n  var d = this.dimension\r\n  var boundary = []\r\n  var cells = this.simplices\r\n  var nc = cells.length\r\n  for(var i=0; i<nc; ++i) {\r\n    var c = cells[i]\r\n    if(c.boundary) {\r\n      var bcell = new Array(d)\r\n      var cv = c.vertices\r\n      var ptr = 0\r\n      var parity = 0\r\n      for(var j=0; j<=d; ++j) {\r\n        if(cv[j] >= 0) {\r\n          bcell[ptr++] = cv[j]\r\n        } else {\r\n          parity = j&1\r\n        }\r\n      }\r\n      if(parity === (d&1)) {\r\n        var t = bcell[0]\r\n        bcell[0] = bcell[1]\r\n        bcell[1] = t\r\n      }\r\n      boundary.push(bcell)\r\n    }\r\n  }\r\n  return boundary\r\n}\r\n\r\nfunction incrementalConvexHull(points, randomSearch) {\r\n  var n = points.length\r\n  if(n === 0) {\r\n    throw new Error(\"Must have at least d+1 points\")\r\n  }\r\n  var d = points[0].length\r\n  if(n <= d) {\r\n    throw new Error(\"Must input at least d+1 points\")\r\n  }\r\n\r\n  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\r\n  var initialSimplex = points.slice(0, d+1)\r\n\r\n  //Make sure initial simplex is positively oriented\r\n  var o = orient.apply(void 0, initialSimplex)\r\n  if(o === 0) {\r\n    throw new Error(\"Input not in general position\")\r\n  }\r\n  var initialCoords = new Array(d+1)\r\n  for(var i=0; i<=d; ++i) {\r\n    initialCoords[i] = i\r\n  }\r\n  if(o < 0) {\r\n    initialCoords[0] = 1\r\n    initialCoords[1] = 0\r\n  }\r\n\r\n  //Create initial topological index, glue pointers together (kind of messy)\r\n  var initialCell = new Simplex(initialCoords, new Array(d+1), false)\r\n  var boundary = initialCell.adjacent\r\n  var list = new Array(d+2)\r\n  for(var i=0; i<=d; ++i) {\r\n    var verts = initialCoords.slice()\r\n    for(var j=0; j<=d; ++j) {\r\n      if(j === i) {\r\n        verts[j] = -1\r\n      }\r\n    }\r\n    var t = verts[0]\r\n    verts[0] = verts[1]\r\n    verts[1] = t\r\n    var cell = new Simplex(verts, new Array(d+1), true)\r\n    boundary[i] = cell\r\n    list[i] = cell\r\n  }\r\n  list[d+1] = initialCell\r\n  for(var i=0; i<=d; ++i) {\r\n    var verts = boundary[i].vertices\r\n    var adj = boundary[i].adjacent\r\n    for(var j=0; j<=d; ++j) {\r\n      var v = verts[j]\r\n      if(v < 0) {\r\n        adj[j] = initialCell\r\n        continue\r\n      }\r\n      for(var k=0; k<=d; ++k) {\r\n        if(boundary[k].vertices.indexOf(v) < 0) {\r\n          adj[j] = boundary[k]\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  //Initialize triangles\r\n  var triangles = new Triangulation(d, initialSimplex, list)\r\n\r\n  //Insert remaining points\r\n  var useRandom = !!randomSearch\r\n  for(var i=d+1; i<n; ++i) {\r\n    triangles.insert(points[i], useRandom)\r\n  }\r\n\r\n  //Extract boundary cells\r\n  return triangles.boundary()\r\n}"]},"metadata":{},"sourceType":"script"}