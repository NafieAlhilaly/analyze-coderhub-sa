{"ast":null,"code":"'use strict';\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n  init: function (plotObj) {\n    /*\n     * If we have already instantiated an emitter for this plot\n     * return early.\n     */\n    if (plotObj._ev instanceof EventEmitter) return plotObj;\n    var ev = new EventEmitter();\n    var internalEv = new EventEmitter();\n    /*\n     * Assign to plot._ev while we still live in a land\n     * where plot is a DOM element with stuff attached to it.\n     * In the future we can make plot the event emitter itself.\n     */\n\n    plotObj._ev = ev;\n    /*\n     * Create a second event handler that will manage events *internally*.\n     * This allows parts of plotly to respond to thing like relayout without\n     * having to use the user-facing event handler. They cannot peacefully\n     * coexist on the same handler because a user invoking\n     * plotObj.removeAllListeners() would detach internal events, breaking\n     * plotly.\n     */\n\n    plotObj._internalEv = internalEv;\n    /*\n     * Assign bound methods from the ev to the plot object. These methods\n     * will reference the 'this' of plot._ev even though they are methods\n     * of plot. This will keep the event machinery away from the plot object\n     * which currently is often a DOM element but presents an API that will\n     * continue to function when plot becomes an emitter. Not all EventEmitter\n     * methods have been bound to `plot` as some do not currently add value to\n     * the Plotly event API.\n     */\n\n    plotObj.on = ev.on.bind(ev);\n    plotObj.once = ev.once.bind(ev);\n    plotObj.removeListener = ev.removeListener.bind(ev);\n    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n    /*\n     * Create functions for managing internal events. These are *only* triggered\n     * by the mirroring of external events via the emit function.\n     */\n\n    plotObj._internalOn = internalEv.on.bind(internalEv);\n    plotObj._internalOnce = internalEv.once.bind(internalEv);\n    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n    /*\n     * We must wrap emit to continue to support JQuery events. The idea\n     * is to check to see if the user is using JQuery events, if they are\n     * we emit JQuery events to trigger user handlers as well as the EventEmitter\n     * events.\n     */\n\n    plotObj.emit = function (event, data) {\n      if (typeof jQuery !== 'undefined') {\n        jQuery(plotObj).trigger(event, data);\n      }\n\n      ev.emit(event, data);\n      internalEv.emit(event, data);\n    };\n\n    return plotObj;\n  },\n\n  /*\n   * This function behaves like jQuery's triggerHandler. It calls\n   * all handlers for a particular event and returns the return value\n   * of the LAST handler. This function also triggers jQuery's\n   * triggerHandler for backwards compatibility.\n   */\n  triggerHandler: function (plotObj, event, data) {\n    var jQueryHandlerValue;\n    var nodeEventHandlerValue;\n    /*\n     * If jQuery exists run all its handlers for this event and\n     * collect the return value of the LAST handler function\n     */\n\n    if (typeof jQuery !== 'undefined') {\n      jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n    }\n    /*\n     * Now run all the node style event handlers\n     */\n\n\n    var ev = plotObj._ev;\n    if (!ev) return jQueryHandlerValue;\n    var handlers = ev._events[event];\n    if (!handlers) return jQueryHandlerValue; // making sure 'this' is the EventEmitter instance\n\n    function apply(handler) {\n      // The 'once' case, we can't just call handler() as we need\n      // the return value here. So,\n      // - remove handler\n      // - call listener and grab return value!\n      // - stash 'fired' key to not call handler twice\n      if (handler.listener) {\n        ev.removeListener(event, handler.listener);\n\n        if (!handler.fired) {\n          handler.fired = true;\n          return handler.listener.apply(ev, [data]);\n        }\n      } else {\n        return handler.apply(ev, [data]);\n      }\n    } // handlers can be function or an array of functions\n\n\n    handlers = Array.isArray(handlers) ? handlers : [handlers];\n    var i;\n\n    for (i = 0; i < handlers.length - 1; i++) {\n      apply(handlers[i]);\n    } // now call the final handler and collect its value\n\n\n    nodeEventHandlerValue = apply(handlers[i]);\n    /*\n     * Return either the jQuery handler value if it exists or the\n     * nodeEventHandler value. jQuery event value supersedes nodejs\n     * events for backwards compatibility reasons.\n     */\n\n    return jQueryHandlerValue !== undefined ? jQueryHandlerValue : nodeEventHandlerValue;\n  },\n  purge: function (plotObj) {\n    delete plotObj._ev;\n    delete plotObj.on;\n    delete plotObj.once;\n    delete plotObj.removeListener;\n    delete plotObj.removeAllListeners;\n    delete plotObj.emit;\n    delete plotObj._ev;\n    delete plotObj._internalEv;\n    delete plotObj._internalOn;\n    delete plotObj._internalOnce;\n    delete plotObj._removeInternalListener;\n    delete plotObj._removeAllInternalListeners;\n    return plotObj;\n  }\n};\nmodule.exports = Events;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/lib/events.js"],"names":["EventEmitter","require","Events","init","plotObj","_ev","ev","internalEv","_internalEv","on","bind","once","removeListener","removeAllListeners","_internalOn","_internalOnce","_removeInternalListener","_removeAllInternalListeners","emit","event","data","jQuery","trigger","triggerHandler","jQueryHandlerValue","nodeEventHandlerValue","handlers","_events","apply","handler","listener","fired","Array","isArray","i","length","undefined","purge","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n\n    init: function(plotObj) {\n        /*\n         * If we have already instantiated an emitter for this plot\n         * return early.\n         */\n        if(plotObj._ev instanceof EventEmitter) return plotObj;\n\n        var ev = new EventEmitter();\n        var internalEv = new EventEmitter();\n\n        /*\n         * Assign to plot._ev while we still live in a land\n         * where plot is a DOM element with stuff attached to it.\n         * In the future we can make plot the event emitter itself.\n         */\n        plotObj._ev = ev;\n\n        /*\n         * Create a second event handler that will manage events *internally*.\n         * This allows parts of plotly to respond to thing like relayout without\n         * having to use the user-facing event handler. They cannot peacefully\n         * coexist on the same handler because a user invoking\n         * plotObj.removeAllListeners() would detach internal events, breaking\n         * plotly.\n         */\n        plotObj._internalEv = internalEv;\n\n        /*\n         * Assign bound methods from the ev to the plot object. These methods\n         * will reference the 'this' of plot._ev even though they are methods\n         * of plot. This will keep the event machinery away from the plot object\n         * which currently is often a DOM element but presents an API that will\n         * continue to function when plot becomes an emitter. Not all EventEmitter\n         * methods have been bound to `plot` as some do not currently add value to\n         * the Plotly event API.\n         */\n        plotObj.on = ev.on.bind(ev);\n        plotObj.once = ev.once.bind(ev);\n        plotObj.removeListener = ev.removeListener.bind(ev);\n        plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n\n        /*\n         * Create functions for managing internal events. These are *only* triggered\n         * by the mirroring of external events via the emit function.\n         */\n        plotObj._internalOn = internalEv.on.bind(internalEv);\n        plotObj._internalOnce = internalEv.once.bind(internalEv);\n        plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n        plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n\n        /*\n         * We must wrap emit to continue to support JQuery events. The idea\n         * is to check to see if the user is using JQuery events, if they are\n         * we emit JQuery events to trigger user handlers as well as the EventEmitter\n         * events.\n         */\n        plotObj.emit = function(event, data) {\n            if(typeof jQuery !== 'undefined') {\n                jQuery(plotObj).trigger(event, data);\n            }\n\n            ev.emit(event, data);\n            internalEv.emit(event, data);\n        };\n\n        return plotObj;\n    },\n\n    /*\n     * This function behaves like jQuery's triggerHandler. It calls\n     * all handlers for a particular event and returns the return value\n     * of the LAST handler. This function also triggers jQuery's\n     * triggerHandler for backwards compatibility.\n     */\n    triggerHandler: function(plotObj, event, data) {\n        var jQueryHandlerValue;\n        var nodeEventHandlerValue;\n\n        /*\n         * If jQuery exists run all its handlers for this event and\n         * collect the return value of the LAST handler function\n         */\n        if(typeof jQuery !== 'undefined') {\n            jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n        }\n\n        /*\n         * Now run all the node style event handlers\n         */\n        var ev = plotObj._ev;\n        if(!ev) return jQueryHandlerValue;\n\n        var handlers = ev._events[event];\n        if(!handlers) return jQueryHandlerValue;\n\n        // making sure 'this' is the EventEmitter instance\n        function apply(handler) {\n            // The 'once' case, we can't just call handler() as we need\n            // the return value here. So,\n            // - remove handler\n            // - call listener and grab return value!\n            // - stash 'fired' key to not call handler twice\n            if(handler.listener) {\n                ev.removeListener(event, handler.listener);\n                if(!handler.fired) {\n                    handler.fired = true;\n                    return handler.listener.apply(ev, [data]);\n                }\n            } else {\n                return handler.apply(ev, [data]);\n            }\n        }\n\n        // handlers can be function or an array of functions\n        handlers = Array.isArray(handlers) ? handlers : [handlers];\n\n        var i;\n        for(i = 0; i < handlers.length - 1; i++) {\n            apply(handlers[i]);\n        }\n        // now call the final handler and collect its value\n        nodeEventHandlerValue = apply(handlers[i]);\n\n        /*\n         * Return either the jQuery handler value if it exists or the\n         * nodeEventHandler value. jQuery event value supersedes nodejs\n         * events for backwards compatibility reasons.\n         */\n        return jQueryHandlerValue !== undefined ?\n            jQueryHandlerValue :\n            nodeEventHandlerValue;\n    },\n\n    purge: function(plotObj) {\n        delete plotObj._ev;\n        delete plotObj.on;\n        delete plotObj.once;\n        delete plotObj.removeListener;\n        delete plotObj.removeAllListeners;\n        delete plotObj.emit;\n\n        delete plotObj._ev;\n        delete plotObj._internalEv;\n        delete plotObj._internalOn;\n        delete plotObj._internalOnce;\n        delete plotObj._removeInternalListener;\n        delete plotObj._removeAllInternalListeners;\n\n        return plotObj;\n    }\n\n};\n\nmodule.exports = Events;\n"]},"metadata":{},"sourceType":"script"}