{"ast":null,"code":"'use strict';\n\nvar coallesceUniforms = require('./reflect');\n\nvar GLError = require(\"./GLError\");\n\nmodule.exports = createUniformWrapper; //Binds a function and returns a value\n\nfunction identity(x) {\n  return function () {\n    return x;\n  };\n}\n\nfunction makeVector(length, fill) {\n  var result = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = fill;\n  }\n\n  return result;\n} //Create shims for uniforms\n\n\nfunction createUniformWrapper(gl, wrapper, uniforms, locations) {\n  function makeGetter(idx) {\n    return function (gl, wrapper, locations) {\n      return gl.getUniform(wrapper.program, locations[idx]);\n    };\n  }\n\n  function makeSetter(type) {\n    return function updateProperty(obj) {\n      var indices = enumerateIndices('', type);\n\n      for (var i = 0; i < indices.length; ++i) {\n        var item = indices[i];\n        var path = item[0];\n        var idx = item[1];\n\n        if (locations[idx]) {\n          var objPath = obj;\n\n          if (typeof path === 'string' && (path.indexOf('.') === 0 || path.indexOf('[') === 0)) {\n            var key = path;\n\n            if (path.indexOf('.') === 0) {\n              key = path.slice(1);\n            }\n\n            if (key.indexOf(']') === key.length - 1) {\n              var j = key.indexOf('[');\n              var k1 = key.slice(0, j);\n              var k2 = key.slice(j + 1, key.length - 1);\n              objPath = k1 ? obj[k1][k2] : obj[k2];\n            } else {\n              objPath = obj[key];\n            }\n          }\n\n          var t = uniforms[idx].type;\n          var d;\n\n          switch (t) {\n            case 'bool':\n            case 'int':\n            case 'sampler2D':\n            case 'samplerCube':\n              gl.uniform1i(locations[idx], objPath);\n              break;\n\n            case 'float':\n              gl.uniform1f(locations[idx], objPath);\n              break;\n\n            default:\n              var vidx = t.indexOf('vec');\n\n              if (0 <= vidx && vidx <= 1 && t.length === 4 + vidx) {\n                d = t.charCodeAt(t.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid data type');\n                }\n\n                switch (t.charAt(0)) {\n                  case 'b':\n                  case 'i':\n                    gl['uniform' + d + 'iv'](locations[idx], objPath);\n                    break;\n\n                  case 'v':\n                    gl['uniform' + d + 'fv'](locations[idx], objPath);\n                    break;\n\n                  default:\n                    throw new GLError('', 'Unrecognized data type for vector ' + name + ': ' + t);\n                }\n              } else if (t.indexOf('mat') === 0 && t.length === 4) {\n                d = t.charCodeAt(t.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + t);\n                }\n\n                gl['uniformMatrix' + d + 'fv'](locations[idx], false, objPath);\n                break;\n              } else {\n                throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + t);\n              }\n\n          }\n        }\n      }\n    };\n  }\n\n  function enumerateIndices(prefix, type) {\n    if (typeof type !== 'object') {\n      return [[prefix, type]];\n    }\n\n    var indices = [];\n\n    for (var id in type) {\n      var prop = type[id];\n      var tprefix = prefix;\n\n      if (parseInt(id) + '' === id) {\n        tprefix += '[' + id + ']';\n      } else {\n        tprefix += '.' + id;\n      }\n\n      if (typeof prop === 'object') {\n        indices.push.apply(indices, enumerateIndices(tprefix, prop));\n      } else {\n        indices.push([tprefix, prop]);\n      }\n    }\n\n    return indices;\n  }\n\n  function defaultValue(type) {\n    switch (type) {\n      case 'bool':\n        return false;\n\n      case 'int':\n      case 'sampler2D':\n      case 'samplerCube':\n        return 0;\n\n      case 'float':\n        return 0.0;\n\n      default:\n        var vidx = type.indexOf('vec');\n\n        if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type');\n          }\n\n          if (type.charAt(0) === 'b') {\n            return makeVector(d, false);\n          }\n\n          return makeVector(d, 0);\n        } else if (type.indexOf('mat') === 0 && type.length === 4) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + type);\n          }\n\n          return makeVector(d * d, 0);\n        } else {\n          throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + type);\n        }\n\n    }\n  }\n\n  function storeProperty(obj, prop, type) {\n    if (typeof type === 'object') {\n      var child = processObject(type);\n      Object.defineProperty(obj, prop, {\n        get: identity(child),\n        set: makeSetter(type),\n        enumerable: true,\n        configurable: false\n      });\n    } else {\n      if (locations[type]) {\n        Object.defineProperty(obj, prop, {\n          get: makeGetter(type),\n          set: makeSetter(type),\n          enumerable: true,\n          configurable: false\n        });\n      } else {\n        obj[prop] = defaultValue(uniforms[type].type);\n      }\n    }\n  }\n\n  function processObject(obj) {\n    var result;\n\n    if (Array.isArray(obj)) {\n      result = new Array(obj.length);\n\n      for (var i = 0; i < obj.length; ++i) {\n        storeProperty(result, i, obj[i]);\n      }\n    } else {\n      result = {};\n\n      for (var id in obj) {\n        storeProperty(result, id, obj[id]);\n      }\n    }\n\n    return result;\n  } //Return data\n\n\n  var coallesced = coallesceUniforms(uniforms, true);\n  return {\n    get: identity(processObject(coallesced)),\n    set: makeSetter(coallesced),\n    enumerable: true,\n    configurable: true\n  };\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/gl-shader/lib/create-uniforms.js"],"names":["coallesceUniforms","require","GLError","module","exports","createUniformWrapper","identity","x","makeVector","length","fill","result","Array","i","gl","wrapper","uniforms","locations","makeGetter","idx","getUniform","program","makeSetter","type","updateProperty","obj","indices","enumerateIndices","item","path","objPath","indexOf","key","slice","j","k1","k2","t","d","uniform1i","uniform1f","vidx","charCodeAt","charAt","name","prefix","id","prop","tprefix","parseInt","push","apply","defaultValue","storeProperty","child","processObject","Object","defineProperty","get","set","enumerable","configurable","isArray","coallesced"],"mappings":"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","sourcesContent":["'use strict'\n\nvar coallesceUniforms = require('./reflect')\nvar GLError = require(\"./GLError\")\n\nmodule.exports = createUniformWrapper\n\n//Binds a function and returns a value\nfunction identity(x) {\n  return function() {\n    return x\n  }\n}\n\nfunction makeVector(length, fill) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = fill\n  }\n  return result\n}\n\n//Create shims for uniforms\nfunction createUniformWrapper(gl, wrapper, uniforms, locations) {\n\n  function makeGetter(idx) {\n    return function(gl, wrapper, locations) {\n      return gl.getUniform(wrapper.program, locations[idx])\n    }\n  }\n\n  function makeSetter(type) {\n    return function updateProperty(obj){\n      var indices = enumerateIndices('', type)\n      for(var i=0; i<indices.length; ++i) {\n        var item = indices[i]\n        var path = item[0]\n        var idx  = item[1]\n        if(locations[idx]) {\n          var objPath =  obj\n          if(typeof path === 'string' && (\n            path.indexOf('.') === 0 ||\n            path.indexOf('[') === 0\n          )) {\n            var key = path\n            if(path.indexOf('.') === 0) {\n              key = path.slice(1)\n            }\n\n            if(key.indexOf(']') === key.length - 1) {\n              var j = key.indexOf('[')\n              var k1 = key.slice(0, j)\n              var k2 = key.slice(j + 1, key.length - 1)\n              objPath = k1? obj[k1][k2] : obj[k2]\n            } else {\n              objPath = obj[key]\n            }\n          }\n\n          var t = uniforms[idx].type\n          var d\n          switch(t) {\n            case 'bool':\n            case 'int':\n            case 'sampler2D':\n            case 'samplerCube':\n              gl.uniform1i(locations[idx], objPath)\n              break\n            case 'float':\n              gl.uniform1f(locations[idx], objPath)\n              break\n            default:\n              var vidx = t.indexOf('vec')\n              if(0 <= vidx && vidx <= 1 && t.length === 4 + vidx) {\n                d = t.charCodeAt(t.length-1) - 48\n                if(d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid data type')\n                }\n                switch(t.charAt(0)) {\n                  case 'b':\n                  case 'i':\n                    gl['uniform' + d + 'iv'](locations[idx], objPath)\n                    break\n                  case 'v':\n                    gl['uniform' + d + 'fv'](locations[idx], objPath)\n                    break\n                  default:\n                    throw new GLError('', 'Unrecognized data type for vector ' + name + ': ' + t)\n                }\n              } else if(t.indexOf('mat') === 0 && t.length === 4) {\n                d = t.charCodeAt(t.length-1) - 48\n                if(d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + t)\n                }\n                gl['uniformMatrix' + d + 'fv'](locations[idx], false, objPath)\n                break\n              } else {\n                throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + t)\n              }\n          }\n        }\n      }\n    }\n  }\n\n  function enumerateIndices(prefix, type) {\n    if(typeof type !== 'object') {\n      return [ [prefix, type] ]\n    }\n    var indices = []\n    for(var id in type) {\n      var prop = type[id]\n      var tprefix = prefix\n      if(parseInt(id) + '' === id) {\n        tprefix += '[' + id + ']'\n      } else {\n        tprefix += '.' + id\n      }\n      if(typeof prop === 'object') {\n        indices.push.apply(indices, enumerateIndices(tprefix, prop))\n      } else {\n        indices.push([tprefix, prop])\n      }\n    }\n    return indices\n  }\n\n\n  function defaultValue(type) {\n    switch(type) {\n      case 'bool':\n        return false\n      case 'int':\n      case 'sampler2D':\n      case 'samplerCube':\n        return 0\n      case 'float':\n        return 0.0\n      default:\n        var vidx = type.indexOf('vec')\n        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type')\n          }\n          if(type.charAt(0) === 'b') {\n            return makeVector(d, false)\n          }\n          return makeVector(d, 0)\n        } else if(type.indexOf('mat') === 0 && type.length === 4) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + type)\n          }\n          return makeVector(d*d, 0)\n        } else {\n          throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + type)\n        }\n    }\n  }\n\n  function storeProperty(obj, prop, type) {\n    if(typeof type === 'object') {\n      var child = processObject(type)\n      Object.defineProperty(obj, prop, {\n        get: identity(child),\n        set: makeSetter(type),\n        enumerable: true,\n        configurable: false\n      })\n    } else {\n      if(locations[type]) {\n        Object.defineProperty(obj, prop, {\n          get: makeGetter(type),\n          set: makeSetter(type),\n          enumerable: true,\n          configurable: false\n        })\n      } else {\n        obj[prop] = defaultValue(uniforms[type].type)\n      }\n    }\n  }\n\n  function processObject(obj) {\n    var result\n    if(Array.isArray(obj)) {\n      result = new Array(obj.length)\n      for(var i=0; i<obj.length; ++i) {\n        storeProperty(result, i, obj[i])\n      }\n    } else {\n      result = {}\n      for(var id in obj) {\n        storeProperty(result, id, obj[id])\n      }\n    }\n    return result\n  }\n\n  //Return data\n  var coallesced = coallesceUniforms(uniforms, true)\n  return {\n    get: identity(processObject(coallesced)),\n    set: makeSetter(coallesced),\n    enumerable: true,\n    configurable: true\n  }\n}\n"]},"metadata":{},"sourceType":"script"}