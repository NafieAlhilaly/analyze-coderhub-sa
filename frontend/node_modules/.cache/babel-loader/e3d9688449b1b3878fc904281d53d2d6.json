{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar rgba = require('color-normalize');\n\nvar getBounds = require('array-bounds');\n\nvar colorId = require('color-id');\n\nvar cluster = require('@plotly/point-cluster');\n\nvar extend = require('object-assign');\n\nvar glslify = require('glslify');\n\nvar pick = require('pick-by-alias');\n\nvar updateDiff = require('update-diff');\n\nvar flatten = require('flatten-vertex-data');\n\nvar ie = require('is-iexplorer');\n\nvar f32 = require('to-float32');\n\nvar parseRect = require('parse-rect');\n\nvar scatter = Scatter;\n\nfunction Scatter(regl, options) {\n  var _this = this;\n\n  if (!(this instanceof Scatter)) return new Scatter(regl, options);\n\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n    regl = null;\n  }\n\n  if (options && options.length) options.positions = options;\n  regl = options.regl; // persistent variables\n\n  var gl = regl._gl,\n      paletteTexture,\n      palette = [],\n      paletteIds = {},\n      // state\n  groups = [],\n      // textures for marker keys\n  markerTextures = [null],\n      markerCache = [null];\n  var maxColors = 255,\n      maxSize = 100; // direct color buffer mode\n  // IE does not support palette anyways\n\n  this.tooManyColors = ie; // texture with color palette\n\n  paletteTexture = regl.texture({\n    data: new Uint8Array(maxColors * 4),\n    width: maxColors,\n    height: 1,\n    type: 'uint8',\n    format: 'rgba',\n    wrapS: 'clamp',\n    wrapT: 'clamp',\n    mag: 'nearest',\n    min: 'nearest'\n  });\n  extend(this, {\n    regl: regl,\n    gl: gl,\n    groups: groups,\n    markerCache: markerCache,\n    markerTextures: markerTextures,\n    palette: palette,\n    paletteIds: paletteIds,\n    paletteTexture: paletteTexture,\n    maxColors: maxColors,\n    maxSize: maxSize,\n    canvas: gl.canvas\n  });\n  this.update(options); // common shader options\n\n  var shaderOptions = {\n    uniforms: {\n      constPointSize: !!options.constPointSize,\n      opacity: regl.prop('opacity'),\n      paletteSize: function paletteSize(ctx, prop) {\n        return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];\n      },\n      pixelRatio: regl.context('pixelRatio'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translate: regl.prop('translate'),\n      translateFract: regl.prop('translateFract'),\n      markerTexture: regl.prop('markerTexture'),\n      paletteTexture: paletteTexture\n    },\n    attributes: {\n      // FIXME: optimize these parts\n      x: function x(ctx, prop) {\n        return prop.xAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      y: function y(ctx, prop) {\n        return prop.yAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      xFract: function xFract(ctx, prop) {\n        return prop.xAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      yFract: function yFract(ctx, prop) {\n        return prop.yAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      size: function size(ctx, prop) {\n        return prop.size.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 0\n        } : {\n          constant: [Math.round(prop.size * 255 / _this.maxSize)]\n        };\n      },\n      borderSize: function borderSize(ctx, prop) {\n        return prop.borderSize.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 1\n        } : {\n          constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]\n        };\n      },\n      colorId: function colorId(ctx, prop) {\n        return prop.color.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: 0\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]\n        };\n      },\n      borderColorId: function borderColorId(ctx, prop) {\n        return prop.borderColor.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: _this.tooManyColors ? 4 : 2\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]\n        };\n      },\n      isActive: function isActive(ctx, prop) {\n        return prop.activation === true ? {\n          constant: [1]\n        } : prop.activation ? prop.activation : {\n          constant: [0]\n        };\n      }\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      // photoshop blending\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    elements: regl.prop('elements'),\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    primitive: 'points'\n  }; // draw sdf-marker\n\n  var markerOptions = extend({}, shaderOptions);\n  markerOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float opacity;\\nuniform sampler2D markerTexture;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat smoothStep(float x, float y) {\\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\\n}\\n\\nvoid main() {\\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\\n\\n  // max-distance alpha\\n  if (dist < 0.003) discard;\\n\\n  // null-border case\\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\\n  }\\n  else {\\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\\n\\n    vec4 color = fragBorderColor;\\n    color.a *= borderColorAmt;\\n    color = mix(color, fragColor, colorAmt);\\n    color.a *= opacity;\\n\\n    gl_FragColor = color;\\n  }\\n\\n}\\n\"]);\n  markerOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\nconst float borderLevel = .5;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = 2. * size * pointSizeScale;\\n  fragPointSize = size * pixelRatio;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragColor = color;\\n  fragBorderColor = borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n\\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\\n}\"]);\n  this.drawMarker = regl(markerOptions); // draw circle\n\n  var circleOptions = extend({}, shaderOptions);\n  circleOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nuniform float opacity;\\n\\nfloat smoothStep(float edge0, float edge1, float x) {\\n\\tfloat t;\\n\\tt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\treturn t * t * (3.0 - 2.0 * t);\\n}\\n\\nvoid main() {\\n\\tfloat radius, alpha = 1.0, delta = fragWidth;\\n\\n\\tradius = length(2.0 * gl_PointCoord.xy - 1.0);\\n\\n\\tif (radius > 1.0 + delta) {\\n\\t\\tdiscard;\\n\\t}\\n\\n\\talpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\\n\\n\\tfloat borderRadius = fragBorderRadius;\\n\\tfloat ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\\n\\tvec4 color = mix(fragColor, fragBorderColor, ratio);\\n\\tcolor.a *= alpha * opacity;\\n\\tgl_FragColor = color;\\n}\\n\"]);\n  circleOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = (size + borderSize) * pointSizeScale;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\\n  fragColor = color;\\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n}\\n\"]); // polyfill IE\n\n  if (ie) {\n    circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep');\n    markerOptions.frag = markerOptions.frag.replace('smoothstep', 'smoothStep');\n  }\n\n  this.drawCircle = regl(circleOptions);\n} // single pass defaults\n\n\nScatter.defaults = {\n  color: 'black',\n  borderColor: 'transparent',\n  borderSize: 0,\n  size: 12,\n  opacity: 1,\n  marker: undefined,\n  viewport: null,\n  range: null,\n  pixelSize: null,\n  count: 0,\n  offset: 0,\n  bounds: null,\n  positions: [],\n  snap: 1e4\n}; // update & redraw\n\nScatter.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  this.draw();\n  return this;\n}; // draw all groups or only indicated ones\n\n\nScatter.prototype.draw = function () {\n  var _this2 = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var groups = this.groups; // if directly array passed - treat as passes\n\n  if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {\n    args = args[0];\n  } // FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\n\n\n  this.regl._refresh();\n\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      this.drawItem(i, args[i]);\n    }\n  } // draw all passes\n  else {\n    groups.forEach(function (group, i) {\n      _this2.drawItem(i);\n    });\n  }\n\n  return this;\n}; // draw specific scatter group\n\n\nScatter.prototype.drawItem = function (id, els) {\n  var groups = this.groups;\n  var group = groups[id]; // debug viewport\n  // let { viewport } = group\n  // gl.enable(gl.SCISSOR_TEST);\n  // gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\n  // gl.clearColor(0, 0, 0, .5);\n  // gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (typeof els === 'number') {\n    id = els;\n    group = groups[els];\n    els = null;\n  }\n\n  if (!(group && group.count && group.opacity)) return; // draw circles\n\n  if (group.activation[0]) {\n    // TODO: optimize this performance by making groups and regl.this props\n    this.drawCircle(this.getMarkerDrawOptions(0, group, els));\n  } // draw all other available markers\n\n\n  var batch = [];\n\n  for (var i = 1; i < group.activation.length; i++) {\n    if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;\n    batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));\n  }\n\n  if (batch.length) {\n    this.drawMarker(batch);\n  }\n}; // get options for the marker ids\n\n\nScatter.prototype.getMarkerDrawOptions = function (markerId, group, elements) {\n  var range = group.range,\n      tree = group.tree,\n      viewport = group.viewport,\n      activation = group.activation,\n      selectionBuffer = group.selectionBuffer,\n      count = group.count;\n  var regl = this.regl; // direct points\n\n  if (!tree) {\n    // if elements array - draw unclustered points\n    if (elements) {\n      return [extend({}, group, {\n        markerTexture: this.markerTextures[markerId],\n        activation: activation[markerId],\n        count: elements.length,\n        elements: elements,\n        offset: 0\n      })];\n    }\n\n    return [extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: activation[markerId],\n      offset: 0\n    })];\n  } // clustered points\n\n\n  var batch = [];\n  var lod = tree.range(range, {\n    lod: true,\n    px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]\n  }); // enable elements by using selection buffer\n\n  if (elements) {\n    var markerActivation = activation[markerId];\n    var mask = markerActivation.data;\n    var data = new Uint8Array(count);\n\n    for (var i = 0; i < elements.length; i++) {\n      var id = elements[i];\n      data[id] = mask ? mask[id] : 1;\n    }\n\n    selectionBuffer.subdata(data);\n  }\n\n  for (var l = lod.length; l--;) {\n    var _lod$l = _slicedToArray(lod[l], 2),\n        from = _lod$l[0],\n        to = _lod$l[1];\n\n    batch.push(extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: elements ? selectionBuffer : activation[markerId],\n      offset: from,\n      count: to - from\n    }));\n  }\n\n  return batch;\n}; // update groups options\n\n\nScatter.prototype.update = function () {\n  var _this3 = this;\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (!args.length) return; // passes are as single array\n\n  if (args.length === 1 && Array.isArray(args[0])) args = args[0];\n  var groups = this.groups,\n      gl = this.gl,\n      regl = this.regl,\n      maxSize = this.maxSize,\n      maxColors = this.maxColors,\n      palette = this.palette;\n  this.groups = groups = args.map(function (options, i) {\n    var group = groups[i];\n    if (options === undefined) return group;\n    if (options === null) options = {\n      positions: null\n    };else if (typeof options === 'function') options = {\n      ondraw: options\n    };else if (typeof options[0] === 'number') options = {\n      positions: options\n    }; // copy options to avoid mutation & handle aliases\n\n    options = pick(options, {\n      positions: 'positions data points',\n      snap: 'snap cluster lod tree',\n      size: 'sizes size radius',\n      borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n      color: 'colors color fill fill-color fillColor',\n      borderColor: 'borderColors borderColor stroke stroke-color strokeColor',\n      marker: 'markers marker shape',\n      range: 'range dataBox databox',\n      viewport: 'viewport viewPort viewBox viewbox',\n      opacity: 'opacity alpha transparency',\n      bounds: 'bound bounds boundaries limits',\n      tooManyColors: 'tooManyColors palette paletteMode optimizePalette enablePalette'\n    });\n    if (options.positions === null) options.positions = [];\n    if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;\n\n    if (!group) {\n      groups[i] = group = {\n        id: i,\n        scale: null,\n        translate: null,\n        scaleFract: null,\n        translateFract: null,\n        // buffers for active markers\n        activation: [],\n        // buffer for filtered markers\n        selectionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'stream',\n          type: 'uint8'\n        }),\n        // buffers with data: it is faster to switch them per-pass\n        // than provide one congregate buffer\n        sizeBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        colorBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        positionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        }),\n        positionFractBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        })\n      };\n      options = extend({}, Scatter.defaults, options);\n    } // force update triggers\n\n\n    if (options.positions && !('marker' in options)) {\n      options.marker = group.marker;\n      delete group.marker;\n    } // updating markers cause recalculating snapping\n\n\n    if (options.marker && !('positions' in options)) {\n      options.positions = group.positions;\n      delete group.positions;\n    } // global count of points\n\n\n    var hasSize = 0,\n        hasColor = 0;\n    updateDiff(group, options, [{\n      snap: true,\n      size: function size(s, group) {\n        if (s == null) s = Scatter.defaults.size;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      borderSize: function borderSize(s, group) {\n        if (s == null) s = Scatter.defaults.borderSize;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      opacity: parseFloat,\n      // add colors to palette, save references\n      color: function color(c, group) {\n        if (c == null) c = Scatter.defaults.color;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      borderColor: function borderColor(c, group) {\n        if (c == null) c = Scatter.defaults.borderColor;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      bounds: function bounds(_bounds, group, options) {\n        if (!('range' in options)) options.range = null;\n        return _bounds;\n      },\n      positions: function positions(_positions, group, options) {\n        var snap = group.snap;\n        var positionBuffer = group.positionBuffer,\n            positionFractBuffer = group.positionFractBuffer,\n            selectionBuffer = group.selectionBuffer; // separate buffers for x/y coordinates\n\n        if (_positions.x || _positions.y) {\n          if (_positions.x.length) {\n            group.xAttr = {\n              buffer: regl.buffer(_positions.x),\n              offset: 0,\n              stride: 4,\n              count: _positions.x.length\n            };\n          } else {\n            group.xAttr = {\n              buffer: _positions.x.buffer,\n              offset: _positions.x.offset * 4 || 0,\n              stride: (_positions.x.stride || 1) * 4,\n              count: _positions.x.count\n            };\n          }\n\n          if (_positions.y.length) {\n            group.yAttr = {\n              buffer: regl.buffer(_positions.y),\n              offset: 0,\n              stride: 4,\n              count: _positions.y.length\n            };\n          } else {\n            group.yAttr = {\n              buffer: _positions.y.buffer,\n              offset: _positions.y.offset * 4 || 0,\n              stride: (_positions.y.stride || 1) * 4,\n              count: _positions.y.count\n            };\n          }\n\n          group.count = Math.max(group.xAttr.count, group.yAttr.count);\n          return _positions;\n        }\n\n        _positions = flatten(_positions, 'float64');\n        var count = group.count = Math.floor(_positions.length / 2);\n        var bounds = group.bounds = count ? getBounds(_positions, 2) : null; // if range is not provided updated - recalc it\n\n        if (!options.range && !group.range) {\n          delete group.range;\n          options.range = bounds;\n        } // reset marker\n\n\n        if (!options.marker && !group.marker) {\n          delete group.marker;\n          options.marker = null;\n        } // build cluster tree if required\n\n\n        if (snap && (snap === true || count > snap)) {\n          group.tree = cluster(_positions, {\n            bounds: bounds\n          });\n        } // existing tree instance\n        else if (snap && snap.length) {\n          group.tree = snap;\n        }\n\n        if (group.tree) {\n          var opts = {\n            primitive: 'points',\n            usage: 'static',\n            data: group.tree,\n            type: 'uint32'\n          };\n          if (group.elements) group.elements(opts);else group.elements = regl.elements(opts);\n        } // update position buffers\n\n\n        var float_data = f32.float32(_positions);\n        positionBuffer({\n          data: float_data,\n          usage: 'dynamic'\n        });\n        var frac_data = f32.fract32(_positions, float_data);\n        positionFractBuffer({\n          data: frac_data,\n          usage: 'dynamic'\n        }); // expand selectionBuffer\n\n        selectionBuffer({\n          data: new Uint8Array(count),\n          type: 'uint8',\n          usage: 'stream'\n        });\n        return _positions;\n      }\n    }, {\n      // create marker ids corresponding to known marker textures\n      marker: function marker(markers, group, options) {\n        var activation = group.activation; // reset marker elements\n\n        activation.forEach(function (buffer) {\n          return buffer && buffer.destroy && buffer.destroy();\n        });\n        activation.length = 0; // single sdf marker\n\n        if (!markers || typeof markers[0] === 'number') {\n          var id = _this3.addMarker(markers);\n\n          activation[id] = true;\n        } // per-point markers use mask buffers to enable markers in vert shader\n        else {\n          var markerMasks = [];\n\n          for (var _i = 0, l = Math.min(markers.length, group.count); _i < l; _i++) {\n            var _id = _this3.addMarker(markers[_i]);\n\n            if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group.count); // enable marker by default\n\n            markerMasks[_id][_i] = 1;\n          }\n\n          for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {\n            if (!markerMasks[_id2]) continue;\n            var opts = {\n              data: markerMasks[_id2],\n              type: 'uint8',\n              usage: 'static'\n            };\n\n            if (!activation[_id2]) {\n              activation[_id2] = regl.buffer(opts);\n            } else {\n              activation[_id2](opts);\n            }\n\n            activation[_id2].data = markerMasks[_id2];\n          }\n        }\n\n        return markers;\n      },\n      range: function range(_range, group, options) {\n        var bounds = group.bounds; // FIXME: why do we need this?\n\n        if (!bounds) return;\n        if (!_range) _range = bounds;\n        group.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n        group.translate = [-_range[0], -_range[1]];\n        group.scaleFract = f32.fract(group.scale);\n        group.translateFract = f32.fract(group.translate);\n        return _range;\n      },\n      viewport: function viewport(vp) {\n        var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]); // normalize viewport to the canvas coordinates\n        // rect.y = gl.drawingBufferHeight - rect.height - rect.y\n\n        return rect;\n      }\n    }]); // update size buffer, if needed\n\n    if (hasSize) {\n      var _group = group,\n          count = _group.count,\n          size = _group.size,\n          borderSize = _group.borderSize,\n          sizeBuffer = _group.sizeBuffer;\n      var sizes = new Uint8Array(count * 2);\n\n      if (size.length || borderSize.length) {\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          // we downscale size to allow for fractions\n          sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);\n          sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);\n        }\n      }\n\n      sizeBuffer({\n        data: sizes,\n        usage: 'dynamic'\n      });\n    } // update color buffer if needed\n\n\n    if (hasColor) {\n      var _group2 = group,\n          _count = _group2.count,\n          color = _group2.color,\n          borderColor = _group2.borderColor,\n          colorBuffer = _group2.colorBuffer;\n      var colors; // if too many colors - put colors to buffer directly\n\n      if (_this3.tooManyColors) {\n        if (color.length || borderColor.length) {\n          colors = new Uint8Array(_count * 8);\n\n          for (var _i3 = 0; _i3 < _count; _i3++) {\n            var _colorId = color[_i3];\n            colors[_i3 * 8] = palette[_colorId * 4];\n            colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];\n            colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];\n            colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];\n            var borderColorId = borderColor[_i3];\n            colors[_i3 * 8 + 4] = palette[borderColorId * 4];\n            colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];\n            colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];\n            colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];\n          }\n        }\n      } // if limited amount of colors - keep palette color picking\n      // that saves significant memory\n      else {\n        if (color.length || borderColor.length) {\n          // we need slight data increase by 2 due to vec4 borderId in shader\n          colors = new Uint8Array(_count * 4 + 2);\n\n          for (var _i4 = 0; _i4 < _count; _i4++) {\n            // put color coords in palette texture\n            if (color[_i4] != null) {\n              colors[_i4 * 4] = color[_i4] % maxColors;\n              colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);\n            }\n\n            if (borderColor[_i4] != null) {\n              colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;\n              colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);\n            }\n          }\n        }\n      }\n\n      colorBuffer({\n        data: colors || new Uint8Array(0),\n        type: 'uint8',\n        usage: 'dynamic'\n      });\n    }\n\n    return group;\n  });\n}; // get (and create) marker texture id\n\n\nScatter.prototype.addMarker = function (sdf) {\n  var markerTextures = this.markerTextures,\n      regl = this.regl,\n      markerCache = this.markerCache;\n  var pos = sdf == null ? 0 : markerCache.indexOf(sdf);\n  if (pos >= 0) return pos; // convert sdf to 0..255 range\n\n  var distArr;\n\n  if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\n    distArr = sdf;\n  } else {\n    distArr = new Uint8Array(sdf.length);\n\n    for (var i = 0, l = sdf.length; i < l; i++) {\n      distArr[i] = sdf[i] * 255;\n    }\n  }\n\n  var radius = Math.floor(Math.sqrt(distArr.length));\n  pos = markerTextures.length;\n  markerCache.push(sdf);\n  markerTextures.push(regl.texture({\n    channels: 1,\n    data: distArr,\n    radius: radius,\n    mag: 'linear',\n    min: 'linear'\n  }));\n  return pos;\n}; // register color to palette, return it's index or list of indexes\n\n\nScatter.prototype.updateColor = function (colors) {\n  var paletteIds = this.paletteIds,\n      palette = this.palette,\n      maxColors = this.maxColors;\n\n  if (!Array.isArray(colors)) {\n    colors = [colors];\n  }\n\n  var idx = []; // if color groups - flatten them\n\n  if (typeof colors[0] === 'number') {\n    var grouped = [];\n\n    if (Array.isArray(colors)) {\n      for (var i = 0; i < colors.length; i += 4) {\n        grouped.push(colors.slice(i, i + 4));\n      }\n    } else {\n      for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {\n        grouped.push(colors.subarray(_i5, _i5 + 4));\n      }\n    }\n\n    colors = grouped;\n  }\n\n  for (var _i6 = 0; _i6 < colors.length; _i6++) {\n    var color = colors[_i6];\n    color = rgba(color, 'uint8');\n    var id = colorId(color, false); // if new color - save it\n\n    if (paletteIds[id] == null) {\n      var pos = palette.length;\n      paletteIds[id] = Math.floor(pos / 4);\n      palette[pos] = color[0];\n      palette[pos + 1] = color[1];\n      palette[pos + 2] = color[2];\n      palette[pos + 3] = color[3];\n    }\n\n    idx[_i6] = paletteIds[id];\n  } // detect if too many colors in palette\n\n\n  if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true; // limit max color\n\n  this.updatePalette(palette); // keep static index for single-color property\n\n  return idx.length === 1 ? idx[0] : idx;\n};\n\nScatter.prototype.updatePalette = function (palette) {\n  if (this.tooManyColors) return;\n  var maxColors = this.maxColors,\n      paletteTexture = this.paletteTexture;\n  var requiredHeight = Math.ceil(palette.length * .25 / maxColors); // pad data\n\n  if (requiredHeight > 1) {\n    palette = palette.slice();\n\n    for (var i = palette.length * .25 % maxColors; i < requiredHeight * maxColors; i++) {\n      palette.push(0, 0, 0, 0);\n    }\n  } // ensure height\n\n\n  if (paletteTexture.height < requiredHeight) {\n    paletteTexture.resize(maxColors, requiredHeight);\n  } // update full data\n\n\n  paletteTexture.subimage({\n    width: Math.min(palette.length * .25, maxColors),\n    height: requiredHeight,\n    data: palette\n  }, 0, 0);\n}; // remove unused stuff\n\n\nScatter.prototype.destroy = function () {\n  this.groups.forEach(function (group) {\n    group.sizeBuffer.destroy();\n    group.positionBuffer.destroy();\n    group.positionFractBuffer.destroy();\n    group.colorBuffer.destroy();\n    group.activation.forEach(function (b) {\n      return b && b.destroy && b.destroy();\n    });\n    group.selectionBuffer.destroy();\n    if (group.elements) group.elements.destroy();\n  });\n  this.groups.length = 0;\n  this.paletteTexture.destroy();\n  this.markerTextures.forEach(function (txt) {\n    return txt && txt.destroy && txt.destroy();\n  });\n  return this;\n};\n\nvar extend$1 = require('object-assign');\n\nvar reglScatter2d = function reglScatter2d(regl, options) {\n  var scatter$1 = new scatter(regl, options);\n  var render = scatter$1.render.bind(scatter$1); // expose API\n\n  extend$1(render, {\n    render: render,\n    update: scatter$1.update.bind(scatter$1),\n    draw: scatter$1.draw.bind(scatter$1),\n    destroy: scatter$1.destroy.bind(scatter$1),\n    regl: scatter$1.regl,\n    gl: scatter$1.gl,\n    canvas: scatter$1.gl.canvas,\n    groups: scatter$1.groups,\n    markers: scatter$1.markerCache,\n    palette: scatter$1.palette\n  });\n  return render;\n};\n\nmodule.exports = reglScatter2d;","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/regl-scatter2d/bundle.js"],"names":["_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Symbol","iterator","from","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","o","minLen","n","Object","prototype","toString","slice","constructor","name","test","len","arr2","TypeError","rgba","require","getBounds","colorId","cluster","extend","glslify","pick","updateDiff","flatten","ie","f32","parseRect","scatter","Scatter","regl","options","_this","positions","gl","_gl","paletteTexture","palette","paletteIds","groups","markerTextures","markerCache","maxColors","maxSize","tooManyColors","texture","data","Uint8Array","width","height","type","format","wrapS","wrapT","mag","min","canvas","update","shaderOptions","uniforms","constPointSize","opacity","prop","paletteSize","ctx","pixelRatio","context","scale","scaleFract","translate","translateFract","markerTexture","attributes","x","xAttr","buffer","positionBuffer","stride","offset","y","yAttr","xFract","constant","positionFractBuffer","yFract","size","sizeBuffer","Math","round","borderSize","color","colorBuffer","borderColorId","borderColor","isActive","activation","blend","enable","func","srcRGB","dstRGB","srcAlpha","dstAlpha","scissor","box","viewport","stencil","depth","elements","count","primitive","markerOptions","frag","vert","drawMarker","circleOptions","replace","drawCircle","defaults","marker","undefined","range","pixelSize","bounds","snap","render","arguments","apply","draw","_this2","_len","args","_key","_refresh","drawItem","forEach","group","id","els","getMarkerDrawOptions","batch","markerId","tree","selectionBuffer","lod","px","markerActivation","mask","subdata","l","_lod$l","to","_this3","_len2","_key2","map","ondraw","usage","hasSize","hasColor","s","parseFloat","c","updateColor","_bounds","_positions","max","floor","opts","float_data","float32","frac_data","fract32","markers","destroy","addMarker","markerMasks","_id","_id2","_range","fract","vp","rect","drawingBufferWidth","drawingBufferHeight","_group","sizes","_i2","_group2","_count","colors","_i3","_colorId","_i4","sdf","pos","indexOf","distArr","Uint8ClampedArray","radius","sqrt","channels","idx","grouped","_i5","subarray","_i6","updatePalette","requiredHeight","ceil","resize","subimage","b","txt","extend$1","reglScatter2d","scatter$1","bind","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar rgba = require('color-normalize');\n\nvar getBounds = require('array-bounds');\n\nvar colorId = require('color-id');\n\nvar cluster = require('@plotly/point-cluster');\n\nvar extend = require('object-assign');\n\nvar glslify = require('glslify');\n\nvar pick = require('pick-by-alias');\n\nvar updateDiff = require('update-diff');\n\nvar flatten = require('flatten-vertex-data');\n\nvar ie = require('is-iexplorer');\n\nvar f32 = require('to-float32');\n\nvar parseRect = require('parse-rect');\n\nvar scatter = Scatter;\n\nfunction Scatter(regl, options) {\n  var _this = this;\n\n  if (!(this instanceof Scatter)) return new Scatter(regl, options);\n\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n    regl = null;\n  }\n\n  if (options && options.length) options.positions = options;\n  regl = options.regl; // persistent variables\n\n  var gl = regl._gl,\n      paletteTexture,\n      palette = [],\n      paletteIds = {},\n      // state\n  groups = [],\n      // textures for marker keys\n  markerTextures = [null],\n      markerCache = [null];\n  var maxColors = 255,\n      maxSize = 100; // direct color buffer mode\n  // IE does not support palette anyways\n\n  this.tooManyColors = ie; // texture with color palette\n\n  paletteTexture = regl.texture({\n    data: new Uint8Array(maxColors * 4),\n    width: maxColors,\n    height: 1,\n    type: 'uint8',\n    format: 'rgba',\n    wrapS: 'clamp',\n    wrapT: 'clamp',\n    mag: 'nearest',\n    min: 'nearest'\n  });\n  extend(this, {\n    regl: regl,\n    gl: gl,\n    groups: groups,\n    markerCache: markerCache,\n    markerTextures: markerTextures,\n    palette: palette,\n    paletteIds: paletteIds,\n    paletteTexture: paletteTexture,\n    maxColors: maxColors,\n    maxSize: maxSize,\n    canvas: gl.canvas\n  });\n  this.update(options); // common shader options\n\n  var shaderOptions = {\n    uniforms: {\n      constPointSize: !!options.constPointSize,\n      opacity: regl.prop('opacity'),\n      paletteSize: function paletteSize(ctx, prop) {\n        return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];\n      },\n      pixelRatio: regl.context('pixelRatio'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translate: regl.prop('translate'),\n      translateFract: regl.prop('translateFract'),\n      markerTexture: regl.prop('markerTexture'),\n      paletteTexture: paletteTexture\n    },\n    attributes: {\n      // FIXME: optimize these parts\n      x: function x(ctx, prop) {\n        return prop.xAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      y: function y(ctx, prop) {\n        return prop.yAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      xFract: function xFract(ctx, prop) {\n        return prop.xAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      yFract: function yFract(ctx, prop) {\n        return prop.yAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      size: function size(ctx, prop) {\n        return prop.size.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 0\n        } : {\n          constant: [Math.round(prop.size * 255 / _this.maxSize)]\n        };\n      },\n      borderSize: function borderSize(ctx, prop) {\n        return prop.borderSize.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 1\n        } : {\n          constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]\n        };\n      },\n      colorId: function colorId(ctx, prop) {\n        return prop.color.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: 0\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]\n        };\n      },\n      borderColorId: function borderColorId(ctx, prop) {\n        return prop.borderColor.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: _this.tooManyColors ? 4 : 2\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]\n        };\n      },\n      isActive: function isActive(ctx, prop) {\n        return prop.activation === true ? {\n          constant: [1]\n        } : prop.activation ? prop.activation : {\n          constant: [0]\n        };\n      }\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      // photoshop blending\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    elements: regl.prop('elements'),\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    primitive: 'points'\n  }; // draw sdf-marker\n\n  var markerOptions = extend({}, shaderOptions);\n  markerOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float opacity;\\nuniform sampler2D markerTexture;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat smoothStep(float x, float y) {\\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\\n}\\n\\nvoid main() {\\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\\n\\n  // max-distance alpha\\n  if (dist < 0.003) discard;\\n\\n  // null-border case\\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\\n  }\\n  else {\\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\\n\\n    vec4 color = fragBorderColor;\\n    color.a *= borderColorAmt;\\n    color = mix(color, fragColor, colorAmt);\\n    color.a *= opacity;\\n\\n    gl_FragColor = color;\\n  }\\n\\n}\\n\"]);\n  markerOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\nconst float borderLevel = .5;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = 2. * size * pointSizeScale;\\n  fragPointSize = size * pixelRatio;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragColor = color;\\n  fragBorderColor = borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n\\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\\n}\"]);\n  this.drawMarker = regl(markerOptions); // draw circle\n\n  var circleOptions = extend({}, shaderOptions);\n  circleOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nuniform float opacity;\\n\\nfloat smoothStep(float edge0, float edge1, float x) {\\n\\tfloat t;\\n\\tt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\treturn t * t * (3.0 - 2.0 * t);\\n}\\n\\nvoid main() {\\n\\tfloat radius, alpha = 1.0, delta = fragWidth;\\n\\n\\tradius = length(2.0 * gl_PointCoord.xy - 1.0);\\n\\n\\tif (radius > 1.0 + delta) {\\n\\t\\tdiscard;\\n\\t}\\n\\n\\talpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\\n\\n\\tfloat borderRadius = fragBorderRadius;\\n\\tfloat ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\\n\\tvec4 color = mix(fragColor, fragBorderColor, ratio);\\n\\tcolor.a *= alpha * opacity;\\n\\tgl_FragColor = color;\\n}\\n\"]);\n  circleOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = (size + borderSize) * pointSizeScale;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\\n  fragColor = color;\\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n}\\n\"]); // polyfill IE\n\n  if (ie) {\n    circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep');\n    markerOptions.frag = markerOptions.frag.replace('smoothstep', 'smoothStep');\n  }\n\n  this.drawCircle = regl(circleOptions);\n} // single pass defaults\n\n\nScatter.defaults = {\n  color: 'black',\n  borderColor: 'transparent',\n  borderSize: 0,\n  size: 12,\n  opacity: 1,\n  marker: undefined,\n  viewport: null,\n  range: null,\n  pixelSize: null,\n  count: 0,\n  offset: 0,\n  bounds: null,\n  positions: [],\n  snap: 1e4\n}; // update & redraw\n\nScatter.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  this.draw();\n  return this;\n}; // draw all groups or only indicated ones\n\n\nScatter.prototype.draw = function () {\n  var _this2 = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var groups = this.groups; // if directly array passed - treat as passes\n\n  if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {\n    args = args[0];\n  } // FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\n\n\n  this.regl._refresh();\n\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      this.drawItem(i, args[i]);\n    }\n  } // draw all passes\n  else {\n    groups.forEach(function (group, i) {\n      _this2.drawItem(i);\n    });\n  }\n\n  return this;\n}; // draw specific scatter group\n\n\nScatter.prototype.drawItem = function (id, els) {\n  var groups = this.groups;\n  var group = groups[id]; // debug viewport\n  // let { viewport } = group\n  // gl.enable(gl.SCISSOR_TEST);\n  // gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\n  // gl.clearColor(0, 0, 0, .5);\n  // gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (typeof els === 'number') {\n    id = els;\n    group = groups[els];\n    els = null;\n  }\n\n  if (!(group && group.count && group.opacity)) return; // draw circles\n\n  if (group.activation[0]) {\n    // TODO: optimize this performance by making groups and regl.this props\n    this.drawCircle(this.getMarkerDrawOptions(0, group, els));\n  } // draw all other available markers\n\n\n  var batch = [];\n\n  for (var i = 1; i < group.activation.length; i++) {\n    if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;\n    batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));\n  }\n\n  if (batch.length) {\n    this.drawMarker(batch);\n  }\n}; // get options for the marker ids\n\n\nScatter.prototype.getMarkerDrawOptions = function (markerId, group, elements) {\n  var range = group.range,\n      tree = group.tree,\n      viewport = group.viewport,\n      activation = group.activation,\n      selectionBuffer = group.selectionBuffer,\n      count = group.count;\n  var regl = this.regl; // direct points\n\n  if (!tree) {\n    // if elements array - draw unclustered points\n    if (elements) {\n      return [extend({}, group, {\n        markerTexture: this.markerTextures[markerId],\n        activation: activation[markerId],\n        count: elements.length,\n        elements: elements,\n        offset: 0\n      })];\n    }\n\n    return [extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: activation[markerId],\n      offset: 0\n    })];\n  } // clustered points\n\n\n  var batch = [];\n  var lod = tree.range(range, {\n    lod: true,\n    px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]\n  }); // enable elements by using selection buffer\n\n  if (elements) {\n    var markerActivation = activation[markerId];\n    var mask = markerActivation.data;\n    var data = new Uint8Array(count);\n\n    for (var i = 0; i < elements.length; i++) {\n      var id = elements[i];\n      data[id] = mask ? mask[id] : 1;\n    }\n\n    selectionBuffer.subdata(data);\n  }\n\n  for (var l = lod.length; l--;) {\n    var _lod$l = _slicedToArray(lod[l], 2),\n        from = _lod$l[0],\n        to = _lod$l[1];\n\n    batch.push(extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: elements ? selectionBuffer : activation[markerId],\n      offset: from,\n      count: to - from\n    }));\n  }\n\n  return batch;\n}; // update groups options\n\n\nScatter.prototype.update = function () {\n  var _this3 = this;\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (!args.length) return; // passes are as single array\n\n  if (args.length === 1 && Array.isArray(args[0])) args = args[0];\n  var groups = this.groups,\n      gl = this.gl,\n      regl = this.regl,\n      maxSize = this.maxSize,\n      maxColors = this.maxColors,\n      palette = this.palette;\n  this.groups = groups = args.map(function (options, i) {\n    var group = groups[i];\n    if (options === undefined) return group;\n    if (options === null) options = {\n      positions: null\n    };else if (typeof options === 'function') options = {\n      ondraw: options\n    };else if (typeof options[0] === 'number') options = {\n      positions: options\n    }; // copy options to avoid mutation & handle aliases\n\n    options = pick(options, {\n      positions: 'positions data points',\n      snap: 'snap cluster lod tree',\n      size: 'sizes size radius',\n      borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n      color: 'colors color fill fill-color fillColor',\n      borderColor: 'borderColors borderColor stroke stroke-color strokeColor',\n      marker: 'markers marker shape',\n      range: 'range dataBox databox',\n      viewport: 'viewport viewPort viewBox viewbox',\n      opacity: 'opacity alpha transparency',\n      bounds: 'bound bounds boundaries limits',\n      tooManyColors: 'tooManyColors palette paletteMode optimizePalette enablePalette'\n    });\n    if (options.positions === null) options.positions = [];\n    if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;\n\n    if (!group) {\n      groups[i] = group = {\n        id: i,\n        scale: null,\n        translate: null,\n        scaleFract: null,\n        translateFract: null,\n        // buffers for active markers\n        activation: [],\n        // buffer for filtered markers\n        selectionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'stream',\n          type: 'uint8'\n        }),\n        // buffers with data: it is faster to switch them per-pass\n        // than provide one congregate buffer\n        sizeBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        colorBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        positionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        }),\n        positionFractBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        })\n      };\n      options = extend({}, Scatter.defaults, options);\n    } // force update triggers\n\n\n    if (options.positions && !('marker' in options)) {\n      options.marker = group.marker;\n      delete group.marker;\n    } // updating markers cause recalculating snapping\n\n\n    if (options.marker && !('positions' in options)) {\n      options.positions = group.positions;\n      delete group.positions;\n    } // global count of points\n\n\n    var hasSize = 0,\n        hasColor = 0;\n    updateDiff(group, options, [{\n      snap: true,\n      size: function size(s, group) {\n        if (s == null) s = Scatter.defaults.size;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      borderSize: function borderSize(s, group) {\n        if (s == null) s = Scatter.defaults.borderSize;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      opacity: parseFloat,\n      // add colors to palette, save references\n      color: function color(c, group) {\n        if (c == null) c = Scatter.defaults.color;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      borderColor: function borderColor(c, group) {\n        if (c == null) c = Scatter.defaults.borderColor;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      bounds: function bounds(_bounds, group, options) {\n        if (!('range' in options)) options.range = null;\n        return _bounds;\n      },\n      positions: function positions(_positions, group, options) {\n        var snap = group.snap;\n        var positionBuffer = group.positionBuffer,\n            positionFractBuffer = group.positionFractBuffer,\n            selectionBuffer = group.selectionBuffer; // separate buffers for x/y coordinates\n\n        if (_positions.x || _positions.y) {\n          if (_positions.x.length) {\n            group.xAttr = {\n              buffer: regl.buffer(_positions.x),\n              offset: 0,\n              stride: 4,\n              count: _positions.x.length\n            };\n          } else {\n            group.xAttr = {\n              buffer: _positions.x.buffer,\n              offset: _positions.x.offset * 4 || 0,\n              stride: (_positions.x.stride || 1) * 4,\n              count: _positions.x.count\n            };\n          }\n\n          if (_positions.y.length) {\n            group.yAttr = {\n              buffer: regl.buffer(_positions.y),\n              offset: 0,\n              stride: 4,\n              count: _positions.y.length\n            };\n          } else {\n            group.yAttr = {\n              buffer: _positions.y.buffer,\n              offset: _positions.y.offset * 4 || 0,\n              stride: (_positions.y.stride || 1) * 4,\n              count: _positions.y.count\n            };\n          }\n\n          group.count = Math.max(group.xAttr.count, group.yAttr.count);\n          return _positions;\n        }\n\n        _positions = flatten(_positions, 'float64');\n        var count = group.count = Math.floor(_positions.length / 2);\n        var bounds = group.bounds = count ? getBounds(_positions, 2) : null; // if range is not provided updated - recalc it\n\n        if (!options.range && !group.range) {\n          delete group.range;\n          options.range = bounds;\n        } // reset marker\n\n\n        if (!options.marker && !group.marker) {\n          delete group.marker;\n          options.marker = null;\n        } // build cluster tree if required\n\n\n        if (snap && (snap === true || count > snap)) {\n          group.tree = cluster(_positions, {\n            bounds: bounds\n          });\n        } // existing tree instance\n        else if (snap && snap.length) {\n          group.tree = snap;\n        }\n\n        if (group.tree) {\n          var opts = {\n            primitive: 'points',\n            usage: 'static',\n            data: group.tree,\n            type: 'uint32'\n          };\n          if (group.elements) group.elements(opts);else group.elements = regl.elements(opts);\n        } // update position buffers\n\n\n        var float_data = f32.float32(_positions);\n        positionBuffer({\n          data: float_data,\n          usage: 'dynamic'\n        });\n        var frac_data = f32.fract32(_positions, float_data);\n        positionFractBuffer({\n          data: frac_data,\n          usage: 'dynamic'\n        }); // expand selectionBuffer\n\n        selectionBuffer({\n          data: new Uint8Array(count),\n          type: 'uint8',\n          usage: 'stream'\n        });\n        return _positions;\n      }\n    }, {\n      // create marker ids corresponding to known marker textures\n      marker: function marker(markers, group, options) {\n        var activation = group.activation; // reset marker elements\n\n        activation.forEach(function (buffer) {\n          return buffer && buffer.destroy && buffer.destroy();\n        });\n        activation.length = 0; // single sdf marker\n\n        if (!markers || typeof markers[0] === 'number') {\n          var id = _this3.addMarker(markers);\n\n          activation[id] = true;\n        } // per-point markers use mask buffers to enable markers in vert shader\n        else {\n          var markerMasks = [];\n\n          for (var _i = 0, l = Math.min(markers.length, group.count); _i < l; _i++) {\n            var _id = _this3.addMarker(markers[_i]);\n\n            if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group.count); // enable marker by default\n\n            markerMasks[_id][_i] = 1;\n          }\n\n          for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {\n            if (!markerMasks[_id2]) continue;\n            var opts = {\n              data: markerMasks[_id2],\n              type: 'uint8',\n              usage: 'static'\n            };\n\n            if (!activation[_id2]) {\n              activation[_id2] = regl.buffer(opts);\n            } else {\n              activation[_id2](opts);\n            }\n\n            activation[_id2].data = markerMasks[_id2];\n          }\n        }\n\n        return markers;\n      },\n      range: function range(_range, group, options) {\n        var bounds = group.bounds; // FIXME: why do we need this?\n\n        if (!bounds) return;\n        if (!_range) _range = bounds;\n        group.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n        group.translate = [-_range[0], -_range[1]];\n        group.scaleFract = f32.fract(group.scale);\n        group.translateFract = f32.fract(group.translate);\n        return _range;\n      },\n      viewport: function viewport(vp) {\n        var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]); // normalize viewport to the canvas coordinates\n        // rect.y = gl.drawingBufferHeight - rect.height - rect.y\n\n        return rect;\n      }\n    }]); // update size buffer, if needed\n\n    if (hasSize) {\n      var _group = group,\n          count = _group.count,\n          size = _group.size,\n          borderSize = _group.borderSize,\n          sizeBuffer = _group.sizeBuffer;\n      var sizes = new Uint8Array(count * 2);\n\n      if (size.length || borderSize.length) {\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          // we downscale size to allow for fractions\n          sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);\n          sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);\n        }\n      }\n\n      sizeBuffer({\n        data: sizes,\n        usage: 'dynamic'\n      });\n    } // update color buffer if needed\n\n\n    if (hasColor) {\n      var _group2 = group,\n          _count = _group2.count,\n          color = _group2.color,\n          borderColor = _group2.borderColor,\n          colorBuffer = _group2.colorBuffer;\n      var colors; // if too many colors - put colors to buffer directly\n\n      if (_this3.tooManyColors) {\n        if (color.length || borderColor.length) {\n          colors = new Uint8Array(_count * 8);\n\n          for (var _i3 = 0; _i3 < _count; _i3++) {\n            var _colorId = color[_i3];\n            colors[_i3 * 8] = palette[_colorId * 4];\n            colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];\n            colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];\n            colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];\n            var borderColorId = borderColor[_i3];\n            colors[_i3 * 8 + 4] = palette[borderColorId * 4];\n            colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];\n            colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];\n            colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];\n          }\n        }\n      } // if limited amount of colors - keep palette color picking\n      // that saves significant memory\n      else {\n        if (color.length || borderColor.length) {\n          // we need slight data increase by 2 due to vec4 borderId in shader\n          colors = new Uint8Array(_count * 4 + 2);\n\n          for (var _i4 = 0; _i4 < _count; _i4++) {\n            // put color coords in palette texture\n            if (color[_i4] != null) {\n              colors[_i4 * 4] = color[_i4] % maxColors;\n              colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);\n            }\n\n            if (borderColor[_i4] != null) {\n              colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;\n              colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);\n            }\n          }\n        }\n      }\n\n      colorBuffer({\n        data: colors || new Uint8Array(0),\n        type: 'uint8',\n        usage: 'dynamic'\n      });\n    }\n\n    return group;\n  });\n}; // get (and create) marker texture id\n\n\nScatter.prototype.addMarker = function (sdf) {\n  var markerTextures = this.markerTextures,\n      regl = this.regl,\n      markerCache = this.markerCache;\n  var pos = sdf == null ? 0 : markerCache.indexOf(sdf);\n  if (pos >= 0) return pos; // convert sdf to 0..255 range\n\n  var distArr;\n\n  if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\n    distArr = sdf;\n  } else {\n    distArr = new Uint8Array(sdf.length);\n\n    for (var i = 0, l = sdf.length; i < l; i++) {\n      distArr[i] = sdf[i] * 255;\n    }\n  }\n\n  var radius = Math.floor(Math.sqrt(distArr.length));\n  pos = markerTextures.length;\n  markerCache.push(sdf);\n  markerTextures.push(regl.texture({\n    channels: 1,\n    data: distArr,\n    radius: radius,\n    mag: 'linear',\n    min: 'linear'\n  }));\n  return pos;\n}; // register color to palette, return it's index or list of indexes\n\n\nScatter.prototype.updateColor = function (colors) {\n  var paletteIds = this.paletteIds,\n      palette = this.palette,\n      maxColors = this.maxColors;\n\n  if (!Array.isArray(colors)) {\n    colors = [colors];\n  }\n\n  var idx = []; // if color groups - flatten them\n\n  if (typeof colors[0] === 'number') {\n    var grouped = [];\n\n    if (Array.isArray(colors)) {\n      for (var i = 0; i < colors.length; i += 4) {\n        grouped.push(colors.slice(i, i + 4));\n      }\n    } else {\n      for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {\n        grouped.push(colors.subarray(_i5, _i5 + 4));\n      }\n    }\n\n    colors = grouped;\n  }\n\n  for (var _i6 = 0; _i6 < colors.length; _i6++) {\n    var color = colors[_i6];\n    color = rgba(color, 'uint8');\n    var id = colorId(color, false); // if new color - save it\n\n    if (paletteIds[id] == null) {\n      var pos = palette.length;\n      paletteIds[id] = Math.floor(pos / 4);\n      palette[pos] = color[0];\n      palette[pos + 1] = color[1];\n      palette[pos + 2] = color[2];\n      palette[pos + 3] = color[3];\n    }\n\n    idx[_i6] = paletteIds[id];\n  } // detect if too many colors in palette\n\n\n  if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true; // limit max color\n\n  this.updatePalette(palette); // keep static index for single-color property\n\n  return idx.length === 1 ? idx[0] : idx;\n};\n\nScatter.prototype.updatePalette = function (palette) {\n  if (this.tooManyColors) return;\n  var maxColors = this.maxColors,\n      paletteTexture = this.paletteTexture;\n  var requiredHeight = Math.ceil(palette.length * .25 / maxColors); // pad data\n\n  if (requiredHeight > 1) {\n    palette = palette.slice();\n\n    for (var i = palette.length * .25 % maxColors; i < requiredHeight * maxColors; i++) {\n      palette.push(0, 0, 0, 0);\n    }\n  } // ensure height\n\n\n  if (paletteTexture.height < requiredHeight) {\n    paletteTexture.resize(maxColors, requiredHeight);\n  } // update full data\n\n\n  paletteTexture.subimage({\n    width: Math.min(palette.length * .25, maxColors),\n    height: requiredHeight,\n    data: palette\n  }, 0, 0);\n}; // remove unused stuff\n\n\nScatter.prototype.destroy = function () {\n  this.groups.forEach(function (group) {\n    group.sizeBuffer.destroy();\n    group.positionBuffer.destroy();\n    group.positionFractBuffer.destroy();\n    group.colorBuffer.destroy();\n    group.activation.forEach(function (b) {\n      return b && b.destroy && b.destroy();\n    });\n    group.selectionBuffer.destroy();\n    if (group.elements) group.elements.destroy();\n  });\n  this.groups.length = 0;\n  this.paletteTexture.destroy();\n  this.markerTextures.forEach(function (txt) {\n    return txt && txt.destroy && txt.destroy();\n  });\n  return this;\n};\n\nvar extend$1 = require('object-assign');\n\nvar reglScatter2d = function reglScatter2d(regl, options) {\n  var scatter$1 = new scatter(regl, options);\n  var render = scatter$1.render.bind(scatter$1); // expose API\n\n  extend$1(render, {\n    render: render,\n    update: scatter$1.update.bind(scatter$1),\n    draw: scatter$1.draw.bind(scatter$1),\n    destroy: scatter$1.destroy.bind(scatter$1),\n    regl: scatter$1.regl,\n    gl: scatter$1.gl,\n    canvas: scatter$1.gl.canvas,\n    groups: scatter$1.groups,\n    markers: scatter$1.markerCache,\n    palette: scatter$1.palette\n  });\n  return render;\n};\n\nmodule.exports = reglScatter2d;\n"]},"metadata":{},"sourceType":"script"}