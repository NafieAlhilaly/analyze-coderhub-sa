{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectWrapper;\n\nvar pool = require('typedarray-pool');\n\nvar sweep = require('./lib/sweep');\n\nvar boxIntersectIter = require('./lib/intersect');\n\nfunction boxEmpty(d, box) {\n  for (var j = 0; j < d; ++j) {\n    if (!(box[j] <= box[j + d])) {\n      return true;\n    }\n  }\n\n  return false;\n} //Unpack boxes into a flat typed array, remove empty boxes\n\n\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0;\n  var count = 0;\n\n  for (var i = 0, n = boxes.length; i < n; ++i) {\n    var b = boxes[i];\n\n    if (boxEmpty(d, b)) {\n      continue;\n    }\n\n    for (var j = 0; j < 2 * d; ++j) {\n      data[ptr++] = b[j];\n    }\n\n    ids[count++] = i;\n  }\n\n  return count;\n} //Perform type conversions, check bounds\n\n\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length;\n  var m = blue.length; //If either array is empty, then we can skip this whole thing\n\n  if (n <= 0 || m <= 0) {\n    return;\n  } //Compute dimension, if it is 0 then we skip\n\n\n  var d = red[0].length >>> 1;\n\n  if (d <= 0) {\n    return;\n  }\n\n  var retval; //Convert red boxes\n\n  var redList = pool.mallocDouble(2 * d * n);\n  var redIds = pool.mallocInt32(n);\n  n = convertBoxes(red, d, redList, redIds);\n\n  if (n > 0) {\n    if (d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n);\n      retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);\n    } else {\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2 * d * m);\n      var blueIds = pool.mallocInt32(m);\n      m = convertBoxes(blue, d, blueList, blueIds);\n\n      if (m > 0) {\n        sweep.init(n + m);\n\n        if (d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);\n        }\n\n        pool.free(blueList);\n        pool.free(blueIds);\n      }\n    }\n\n    pool.free(redList);\n    pool.free(redIds);\n  }\n\n  return retval;\n}\n\nvar RESULT;\n\nfunction appendItem(i, j) {\n  RESULT.push([i, j]);\n}\n\nfunction intersectFullArray(x) {\n  RESULT = [];\n  boxIntersect(x, x, appendItem, true);\n  return RESULT;\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = [];\n  boxIntersect(x, y, appendItem, false);\n  return RESULT;\n} //User-friendly wrapper, handle full input and no-visitor cases\n\n\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  switch (arguments.length) {\n    case 1:\n      return intersectFullArray(arg0);\n\n    case 2:\n      if (typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true);\n      } else {\n        return intersectBipartiteArray(arg0, arg1);\n      }\n\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false);\n\n    default:\n      throw new Error('box-intersect: Invalid arguments');\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/box-intersect/index.js"],"names":["module","exports","boxIntersectWrapper","pool","require","sweep","boxIntersectIter","boxEmpty","d","box","j","convertBoxes","boxes","data","ids","ptr","count","i","n","length","b","boxIntersect","red","blue","visit","full","m","retval","redList","mallocDouble","redIds","mallocInt32","init","sweepComplete","blueList","blueIds","sweepBipartite","free","RESULT","appendItem","push","intersectFullArray","x","intersectBipartiteArray","y","arg0","arg1","arg2","arguments","Error"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,mBAAjB;;AAEA,IAAIC,IAAI,GAAGC,OAAO,CAAC,iBAAD,CAAlB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,aAAD,CAAnB;;AACA,IAAIE,gBAAgB,GAAGF,OAAO,CAAC,iBAAD,CAA9B;;AAEA,SAASG,QAAT,CAAkBC,CAAlB,EAAqBC,GAArB,EAA0B;AACxB,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACF,CAAf,EAAkB,EAAEE,CAApB,EAAuB;AACrB,QAAG,EAAED,GAAG,CAACC,CAAD,CAAH,IAAUD,GAAG,CAACC,CAAC,GAACF,CAAH,CAAf,CAAH,EAA0B;AACxB,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,C,CAED;;;AACA,SAASG,YAAT,CAAsBC,KAAtB,EAA6BJ,CAA7B,EAAgCK,IAAhC,EAAsCC,GAAtC,EAA2C;AACzC,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAI,IAAIC,CAAC,GAAC,CAAN,EAASC,CAAC,GAACN,KAAK,CAACO,MAArB,EAA6BF,CAAC,GAACC,CAA/B,EAAkC,EAAED,CAApC,EAAuC;AACrC,QAAIG,CAAC,GAAGR,KAAK,CAACK,CAAD,CAAb;;AACA,QAAGV,QAAQ,CAACC,CAAD,EAAIY,CAAJ,CAAX,EAAmB;AACjB;AACD;;AACD,SAAI,IAAIV,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,IAAEF,CAAjB,EAAoB,EAAEE,CAAtB,EAAyB;AACvBG,MAAAA,IAAI,CAACE,GAAG,EAAJ,CAAJ,GAAcK,CAAC,CAACV,CAAD,CAAf;AACD;;AACDI,IAAAA,GAAG,CAACE,KAAK,EAAN,CAAH,GAAeC,CAAf;AACD;;AACD,SAAOD,KAAP;AACD,C,CAED;;;AACA,SAASK,YAAT,CAAsBC,GAAtB,EAA2BC,IAA3B,EAAiCC,KAAjC,EAAwCC,IAAxC,EAA8C;AAC5C,MAAIP,CAAC,GAAGI,GAAG,CAACH,MAAZ;AACA,MAAIO,CAAC,GAAGH,IAAI,CAACJ,MAAb,CAF4C,CAI5C;;AACA,MAAGD,CAAC,IAAI,CAAL,IAAUQ,CAAC,IAAI,CAAlB,EAAqB;AACnB;AACD,GAP2C,CAS5C;;;AACA,MAAIlB,CAAC,GAAIc,GAAG,CAAC,CAAD,CAAH,CAAOH,MAAR,KAAkB,CAA1B;;AACA,MAAGX,CAAC,IAAI,CAAR,EAAW;AACT;AACD;;AAED,MAAImB,MAAJ,CAf4C,CAiB5C;;AACA,MAAIC,OAAO,GAAIzB,IAAI,CAAC0B,YAAL,CAAkB,IAAErB,CAAF,GAAIU,CAAtB,CAAf;AACA,MAAIY,MAAM,GAAK3B,IAAI,CAAC4B,WAAL,CAAiBb,CAAjB,CAAf;AACAA,EAAAA,CAAC,GAAGP,YAAY,CAACW,GAAD,EAAMd,CAAN,EAASoB,OAAT,EAAkBE,MAAlB,CAAhB;;AAEA,MAAGZ,CAAC,GAAG,CAAP,EAAU;AACR,QAAGV,CAAC,KAAK,CAAN,IAAWiB,IAAd,EAAoB;AAClB;AACApB,MAAAA,KAAK,CAAC2B,IAAN,CAAWd,CAAX;AACAS,MAAAA,MAAM,GAAGtB,KAAK,CAAC4B,aAAN,CACPzB,CADO,EACJgB,KADI,EAEP,CAFO,EAEJN,CAFI,EAEDU,OAFC,EAEQE,MAFR,EAGP,CAHO,EAGJZ,CAHI,EAGDU,OAHC,EAGQE,MAHR,CAAT;AAID,KAPD,MAOO;AAEL;AACA,UAAII,QAAQ,GAAG/B,IAAI,CAAC0B,YAAL,CAAkB,IAAErB,CAAF,GAAIkB,CAAtB,CAAf;AACA,UAAIS,OAAO,GAAIhC,IAAI,CAAC4B,WAAL,CAAiBL,CAAjB,CAAf;AACAA,MAAAA,CAAC,GAAGf,YAAY,CAACY,IAAD,EAAOf,CAAP,EAAU0B,QAAV,EAAoBC,OAApB,CAAhB;;AAEA,UAAGT,CAAC,GAAG,CAAP,EAAU;AACRrB,QAAAA,KAAK,CAAC2B,IAAN,CAAWd,CAAC,GAACQ,CAAb;;AAEA,YAAGlB,CAAC,KAAK,CAAT,EAAY;AACV;AACAmB,UAAAA,MAAM,GAAGtB,KAAK,CAAC+B,cAAN,CACP5B,CADO,EACJgB,KADI,EAEP,CAFO,EAEJN,CAFI,EAEDU,OAFC,EAESE,MAFT,EAGP,CAHO,EAGJJ,CAHI,EAGDQ,QAHC,EAGSC,OAHT,CAAT;AAID,SAND,MAMO;AACL;AACAR,UAAAA,MAAM,GAAGrB,gBAAgB,CACvBE,CADuB,EACpBgB,KADoB,EACVC,IADU,EAEvBP,CAFuB,EAEpBU,OAFoB,EAEVE,MAFU,EAGvBJ,CAHuB,EAGpBQ,QAHoB,EAGVC,OAHU,CAAzB;AAID;;AAEDhC,QAAAA,IAAI,CAACkC,IAAL,CAAUH,QAAV;AACA/B,QAAAA,IAAI,CAACkC,IAAL,CAAUF,OAAV;AACD;AACF;;AAEDhC,IAAAA,IAAI,CAACkC,IAAL,CAAUT,OAAV;AACAzB,IAAAA,IAAI,CAACkC,IAAL,CAAUP,MAAV;AACD;;AAED,SAAOH,MAAP;AACD;;AAGD,IAAIW,MAAJ;;AAEA,SAASC,UAAT,CAAoBtB,CAApB,EAAsBP,CAAtB,EAAyB;AACvB4B,EAAAA,MAAM,CAACE,IAAP,CAAY,CAACvB,CAAD,EAAGP,CAAH,CAAZ;AACD;;AAED,SAAS+B,kBAAT,CAA4BC,CAA5B,EAA+B;AAC7BJ,EAAAA,MAAM,GAAG,EAAT;AACAjB,EAAAA,YAAY,CAACqB,CAAD,EAAIA,CAAJ,EAAOH,UAAP,EAAmB,IAAnB,CAAZ;AACA,SAAOD,MAAP;AACD;;AAED,SAASK,uBAAT,CAAiCD,CAAjC,EAAoCE,CAApC,EAAuC;AACrCN,EAAAA,MAAM,GAAG,EAAT;AACAjB,EAAAA,YAAY,CAACqB,CAAD,EAAIE,CAAJ,EAAOL,UAAP,EAAmB,KAAnB,CAAZ;AACA,SAAOD,MAAP;AACD,C,CAED;;;AACA,SAASpC,mBAAT,CAA6B2C,IAA7B,EAAmCC,IAAnC,EAAyCC,IAAzC,EAA+C;AAC7C,UAAOC,SAAS,CAAC7B,MAAjB;AACE,SAAK,CAAL;AACE,aAAOsB,kBAAkB,CAACI,IAAD,CAAzB;;AACF,SAAK,CAAL;AACE,UAAG,OAAOC,IAAP,KAAgB,UAAnB,EAA+B;AAC7B,eAAOzB,YAAY,CAACwB,IAAD,EAAOA,IAAP,EAAaC,IAAb,EAAmB,IAAnB,CAAnB;AACD,OAFD,MAEO;AACL,eAAOH,uBAAuB,CAACE,IAAD,EAAOC,IAAP,CAA9B;AACD;;AACH,SAAK,CAAL;AACE,aAAOzB,YAAY,CAACwB,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB,KAAnB,CAAnB;;AACF;AACE,YAAM,IAAIE,KAAJ,CAAU,kCAAV,CAAN;AAZJ;AAcD","sourcesContent":["'use strict'\r\n\r\nmodule.exports = boxIntersectWrapper\r\n\r\nvar pool = require('typedarray-pool')\r\nvar sweep = require('./lib/sweep')\r\nvar boxIntersectIter = require('./lib/intersect')\r\n\r\nfunction boxEmpty(d, box) {\r\n  for(var j=0; j<d; ++j) {\r\n    if(!(box[j] <= box[j+d])) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n//Unpack boxes into a flat typed array, remove empty boxes\r\nfunction convertBoxes(boxes, d, data, ids) {\r\n  var ptr = 0\r\n  var count = 0\r\n  for(var i=0, n=boxes.length; i<n; ++i) {\r\n    var b = boxes[i]\r\n    if(boxEmpty(d, b)) {\r\n      continue\r\n    }\r\n    for(var j=0; j<2*d; ++j) {\r\n      data[ptr++] = b[j]\r\n    }\r\n    ids[count++] = i\r\n  }\r\n  return count\r\n}\r\n\r\n//Perform type conversions, check bounds\r\nfunction boxIntersect(red, blue, visit, full) {\r\n  var n = red.length\r\n  var m = blue.length\r\n\r\n  //If either array is empty, then we can skip this whole thing\r\n  if(n <= 0 || m <= 0) {\r\n    return\r\n  }\r\n\r\n  //Compute dimension, if it is 0 then we skip\r\n  var d = (red[0].length)>>>1\r\n  if(d <= 0) {\r\n    return\r\n  }\r\n\r\n  var retval\r\n\r\n  //Convert red boxes\r\n  var redList  = pool.mallocDouble(2*d*n)\r\n  var redIds   = pool.mallocInt32(n)\r\n  n = convertBoxes(red, d, redList, redIds)\r\n\r\n  if(n > 0) {\r\n    if(d === 1 && full) {\r\n      //Special case: 1d complete\r\n      sweep.init(n)\r\n      retval = sweep.sweepComplete(\r\n        d, visit,\r\n        0, n, redList, redIds,\r\n        0, n, redList, redIds)\r\n    } else {\r\n\r\n      //Convert blue boxes\r\n      var blueList = pool.mallocDouble(2*d*m)\r\n      var blueIds  = pool.mallocInt32(m)\r\n      m = convertBoxes(blue, d, blueList, blueIds)\r\n\r\n      if(m > 0) {\r\n        sweep.init(n+m)\r\n\r\n        if(d === 1) {\r\n          //Special case: 1d bipartite\r\n          retval = sweep.sweepBipartite(\r\n            d, visit,\r\n            0, n, redList,  redIds,\r\n            0, m, blueList, blueIds)\r\n        } else {\r\n          //General case:  d>1\r\n          retval = boxIntersectIter(\r\n            d, visit,    full,\r\n            n, redList,  redIds,\r\n            m, blueList, blueIds)\r\n        }\r\n\r\n        pool.free(blueList)\r\n        pool.free(blueIds)\r\n      }\r\n    }\r\n\r\n    pool.free(redList)\r\n    pool.free(redIds)\r\n  }\r\n\r\n  return retval\r\n}\r\n\r\n\r\nvar RESULT\r\n\r\nfunction appendItem(i,j) {\r\n  RESULT.push([i,j])\r\n}\r\n\r\nfunction intersectFullArray(x) {\r\n  RESULT = []\r\n  boxIntersect(x, x, appendItem, true)\r\n  return RESULT\r\n}\r\n\r\nfunction intersectBipartiteArray(x, y) {\r\n  RESULT = []\r\n  boxIntersect(x, y, appendItem, false)\r\n  return RESULT\r\n}\r\n\r\n//User-friendly wrapper, handle full input and no-visitor cases\r\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\r\n  switch(arguments.length) {\r\n    case 1:\r\n      return intersectFullArray(arg0)\r\n    case 2:\r\n      if(typeof arg1 === 'function') {\r\n        return boxIntersect(arg0, arg0, arg1, true)\r\n      } else {\r\n        return intersectBipartiteArray(arg0, arg1)\r\n      }\r\n    case 3:\r\n      return boxIntersect(arg0, arg1, arg2, false)\r\n    default:\r\n      throw new Error('box-intersect: Invalid arguments')\r\n  }\r\n}"]},"metadata":{},"sourceType":"script"}