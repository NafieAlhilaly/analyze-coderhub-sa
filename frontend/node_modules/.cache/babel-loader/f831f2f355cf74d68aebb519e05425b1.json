{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nvar fillText = Lib.fillText;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var subplot = pointData.subplot; // compute winding number about [-180, 180] globe\n\n  var winding = xval >= 0 ? Math.floor((xval + 180) / 360) : Math.ceil((xval - 180) / 360); // shift longitude to [-180, 180] to determine closest point\n\n  var lonShift = winding * 360;\n  var xval2 = xval - lonShift;\n\n  function distFn(d) {\n    var lonlat = d.lonlat;\n    if (lonlat[0] === BADNUM) return Infinity;\n    var lon = Lib.modHalf(lonlat[0], 360);\n    var lat = lonlat[1];\n    var pt = subplot.project([lon, lat]);\n    var dx = pt.x - xa.c2p([xval2, lat]);\n    var dy = pt.y - ya.c2p([lon, yval]);\n    var rad = Math.max(3, d.mrc || 0);\n    return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n  }\n\n  Fx.getClosest(cd, distFn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n  if (pointData.index === false) return;\n  var di = cd[pointData.index];\n  var lonlat = di.lonlat;\n  var lonlatShifted = [Lib.modHalf(lonlat[0], 360) + lonShift, lonlat[1]]; // shift labels back to original winded globe\n\n  var xc = xa.c2p(lonlatShifted);\n  var yc = ya.c2p(lonlatShifted);\n  var rad = di.mrc || 1;\n  pointData.x0 = xc - rad;\n  pointData.x1 = xc + rad;\n  pointData.y0 = yc - rad;\n  pointData.y1 = yc + rad;\n  var fullLayout = {};\n  fullLayout[trace.subplot] = {\n    _subplot: subplot\n  };\n\n  var labels = trace._module.formatLabels(di, trace, fullLayout);\n\n  pointData.lonLabel = labels.lonLabel;\n  pointData.latLabel = labels.latLabel;\n  pointData.color = getTraceColor(trace, di);\n  pointData.extraText = getExtraText(trace, di, cd[0].t.labels);\n  pointData.hovertemplate = trace.hovertemplate;\n  return [pointData];\n}\n\nfunction getExtraText(trace, di, labels) {\n  if (trace.hovertemplate) return;\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var parts = hoverinfo.split('+');\n  var isAll = parts.indexOf('all') !== -1;\n  var hasLon = parts.indexOf('lon') !== -1;\n  var hasLat = parts.indexOf('lat') !== -1;\n  var lonlat = di.lonlat;\n  var text = []; // TODO should we use a mock axis to format hover?\n  // If so, we'll need to make precision be zoom-level dependent\n\n  function format(v) {\n    return v + \"\\xB0\";\n  }\n\n  if (isAll || hasLon && hasLat) {\n    text.push('(' + format(lonlat[1]) + ', ' + format(lonlat[0]) + ')');\n  } else if (hasLon) {\n    text.push(labels.lon + format(lonlat[0]));\n  } else if (hasLat) {\n    text.push(labels.lat + format(lonlat[1]));\n  }\n\n  if (isAll || parts.indexOf('text') !== -1) {\n    fillText(di, trace, text);\n  }\n\n  return text.join('<br>');\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  getExtraText: getExtraText\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/scattermapbox/hover.js"],"names":["Fx","require","Lib","getTraceColor","fillText","BADNUM","hoverPoints","pointData","xval","yval","cd","trace","xa","ya","subplot","winding","Math","floor","ceil","lonShift","xval2","distFn","d","lonlat","Infinity","lon","modHalf","lat","pt","project","dx","x","c2p","dy","y","rad","max","mrc","sqrt","getClosest","index","di","lonlatShifted","xc","yc","x0","x1","y0","y1","fullLayout","_subplot","labels","_module","formatLabels","lonLabel","latLabel","color","extraText","getExtraText","t","hovertemplate","hoverinfo","hi","parts","split","isAll","indexOf","hasLon","hasLat","text","format","v","push","join","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Fx = require('../../components/fx');\nvar Lib = require('../../lib');\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillText = Lib.fillText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var subplot = pointData.subplot;\n\n    // compute winding number about [-180, 180] globe\n    var winding = (xval >= 0) ?\n        Math.floor((xval + 180) / 360) :\n        Math.ceil((xval - 180) / 360);\n\n    // shift longitude to [-180, 180] to determine closest point\n    var lonShift = winding * 360;\n    var xval2 = xval - lonShift;\n\n    function distFn(d) {\n        var lonlat = d.lonlat;\n        if(lonlat[0] === BADNUM) return Infinity;\n\n        var lon = Lib.modHalf(lonlat[0], 360);\n        var lat = lonlat[1];\n        var pt = subplot.project([lon, lat]);\n        var dx = pt.x - xa.c2p([xval2, lat]);\n        var dy = pt.y - ya.c2p([lon, yval]);\n        var rad = Math.max(3, d.mrc || 0);\n\n        return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n    }\n\n    Fx.getClosest(cd, distFn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    var di = cd[pointData.index];\n    var lonlat = di.lonlat;\n    var lonlatShifted = [Lib.modHalf(lonlat[0], 360) + lonShift, lonlat[1]];\n\n    // shift labels back to original winded globe\n    var xc = xa.c2p(lonlatShifted);\n    var yc = ya.c2p(lonlatShifted);\n    var rad = di.mrc || 1;\n\n    pointData.x0 = xc - rad;\n    pointData.x1 = xc + rad;\n    pointData.y0 = yc - rad;\n    pointData.y1 = yc + rad;\n\n    var fullLayout = {};\n    fullLayout[trace.subplot] = {_subplot: subplot};\n    var labels = trace._module.formatLabels(di, trace, fullLayout);\n    pointData.lonLabel = labels.lonLabel;\n    pointData.latLabel = labels.latLabel;\n\n    pointData.color = getTraceColor(trace, di);\n    pointData.extraText = getExtraText(trace, di, cd[0].t.labels);\n    pointData.hovertemplate = trace.hovertemplate;\n\n    return [pointData];\n}\n\nfunction getExtraText(trace, di, labels) {\n    if(trace.hovertemplate) return;\n\n    var hoverinfo = di.hi || trace.hoverinfo;\n    var parts = hoverinfo.split('+');\n    var isAll = parts.indexOf('all') !== -1;\n    var hasLon = parts.indexOf('lon') !== -1;\n    var hasLat = parts.indexOf('lat') !== -1;\n    var lonlat = di.lonlat;\n    var text = [];\n\n    // TODO should we use a mock axis to format hover?\n    // If so, we'll need to make precision be zoom-level dependent\n    function format(v) {\n        return v + '\\u00B0';\n    }\n\n    if(isAll || (hasLon && hasLat)) {\n        text.push('(' + format(lonlat[1]) + ', ' + format(lonlat[0]) + ')');\n    } else if(hasLon) {\n        text.push(labels.lon + format(lonlat[0]));\n    } else if(hasLat) {\n        text.push(labels.lat + format(lonlat[1]));\n    }\n\n    if(isAll || parts.indexOf('text') !== -1) {\n        fillText(di, trace, text);\n    }\n\n    return text.join('<br>');\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    getExtraText: getExtraText\n};\n"]},"metadata":{},"sourceType":"script"}