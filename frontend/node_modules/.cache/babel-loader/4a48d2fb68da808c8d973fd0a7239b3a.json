{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\nvar zoomstartStyle = {\n  cursor: 'pointer'\n};\nvar zoomendStyle = {\n  cursor: 'auto'\n};\n\nfunction createGeoZoom(geo, geoLayout) {\n  var projection = geo.projection;\n  var zoomConstructor;\n\n  if (geoLayout._isScoped) {\n    zoomConstructor = zoomScoped;\n  } else if (geoLayout._isClipped) {\n    zoomConstructor = zoomClipped;\n  } else {\n    zoomConstructor = zoomNonClipped;\n  } // TODO add a conic-specific zoom\n\n\n  return zoomConstructor(geo, projection);\n}\n\nmodule.exports = createGeoZoom; // common to all zoom types\n\nfunction initZoom(geo, projection) {\n  return d3.behavior.zoom().translate(projection.translate()).scale(projection.scale());\n} // sync zoom updates with user & full layout\n\n\nfunction sync(geo, projection, cb) {\n  var id = geo.id;\n  var gd = geo.graphDiv;\n  var layout = gd.layout;\n  var userOpts = layout[id];\n  var fullLayout = gd._fullLayout;\n  var fullOpts = fullLayout[id];\n  var preGUI = {};\n  var eventData = {};\n\n  function set(propStr, val) {\n    preGUI[id + '.' + propStr] = Lib.nestedProperty(userOpts, propStr).get();\n    Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);\n    var fullNp = Lib.nestedProperty(fullOpts, propStr);\n\n    if (fullNp.get() !== val) {\n      fullNp.set(val);\n      Lib.nestedProperty(userOpts, propStr).set(val);\n      eventData[id + '.' + propStr] = val;\n    }\n  }\n\n  cb(set);\n  set('projection.scale', projection.scale() / geo.fitScale);\n  set('fitbounds', false);\n  gd.emit('plotly_relayout', eventData);\n} // zoom for scoped projections\n\n\nfunction zoomScoped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n  }\n\n  function handleZoom() {\n    projection.scale(d3.event.scale).translate(d3.event.translate);\n    geo.render();\n    var center = projection.invert(geo.midPt);\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.center.lon': center[0],\n      'geo.center.lat': center[1]\n    });\n  }\n\n  function syncCb(set) {\n    var center = projection.invert(geo.midPt);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    sync(geo, projection, syncCb);\n  }\n\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n} // zoom for non-clipped projections\n\n\nfunction zoomNonClipped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n  var INSIDETOLORANCEPXS = 2;\n  var mouse0, rotate0, translate0, lastRotate, zoomPoint, mouse1, rotate1, point1, didZoom;\n\n  function position(x) {\n    return projection.invert(x);\n  }\n\n  function outside(x) {\n    var pos = position(x);\n    if (!pos) return true;\n    var pt = projection(pos);\n    return Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS || Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS;\n  }\n\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n    mouse0 = d3.mouse(this);\n    rotate0 = projection.rotate();\n    translate0 = projection.translate();\n    lastRotate = rotate0;\n    zoomPoint = position(mouse0);\n  }\n\n  function handleZoom() {\n    mouse1 = d3.mouse(this);\n\n    if (outside(mouse0)) {\n      zoom.scale(projection.scale());\n      zoom.translate(projection.translate());\n      return;\n    }\n\n    projection.scale(d3.event.scale);\n    projection.translate([translate0[0], d3.event.translate[1]]);\n\n    if (!zoomPoint) {\n      mouse0 = mouse1;\n      zoomPoint = position(mouse0);\n    } else if (position(mouse1)) {\n      point1 = position(mouse1);\n      rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n      projection.rotate(rotate1);\n      lastRotate = rotate1;\n    }\n\n    didZoom = true;\n    geo.render();\n    var rotate = projection.rotate();\n    var center = projection.invert(geo.midPt);\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.center.lon': center[0],\n      'geo.center.lat': center[1],\n      'geo.projection.rotation.lon': -rotate[0]\n    });\n  }\n\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    if (didZoom) sync(geo, projection, syncCb);\n  }\n\n  function syncCb(set) {\n    var rotate = projection.rotate();\n    var center = projection.invert(geo.midPt);\n    set('projection.rotation.lon', -rotate[0]);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n} // zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\n\n\nfunction zoomClipped(geo, projection) {\n  var view = {\n    r: projection.rotate(),\n    k: projection.scale()\n  };\n  var zoom = initZoom(geo, projection);\n  var event = d3eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend');\n  var zooming = 0;\n  var zoomOn = zoom.on;\n  var zoomPoint;\n  zoom.on('zoomstart', function () {\n    d3.select(this).style(zoomstartStyle);\n    var mouse0 = d3.mouse(this);\n    var rotate0 = projection.rotate();\n    var lastRotate = rotate0;\n    var translate0 = projection.translate();\n    var q = quaternionFromEuler(rotate0);\n    zoomPoint = position(projection, mouse0);\n    zoomOn.call(zoom, 'zoom', function () {\n      var mouse1 = d3.mouse(this);\n      projection.scale(view.k = d3.event.scale);\n\n      if (!zoomPoint) {\n        // if no zoomPoint, the mouse wasn't over the actual geography yet\n        // maybe this point is the start... we'll find out next time!\n        mouse0 = mouse1;\n        zoomPoint = position(projection, mouse0);\n      } else if (position(projection, mouse1)) {\n        // check if the point is on the map\n        // if not, don't do anything new but scale\n        // if it is, then we can assume between will exist below\n        // so we don't need the 'bank' function, whatever that is.\n        // go back to original projection temporarily\n        // except for scale... that's kind of independent?\n        projection.rotate(rotate0).translate(translate0); // calculate the new params\n\n        var point1 = position(projection, mouse1);\n        var between = rotateBetween(zoomPoint, point1);\n        var newEuler = eulerFromQuaternion(multiply(q, between));\n        var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n\n        if (!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) || !isFinite(rotateAngles[2])) {\n          rotateAngles = lastRotate;\n        } // update the projection\n\n\n        projection.rotate(rotateAngles);\n        lastRotate = rotateAngles;\n      }\n\n      zoomed(event.of(this, arguments));\n    });\n    zoomstarted(event.of(this, arguments));\n  }).on('zoomend', function () {\n    d3.select(this).style(zoomendStyle);\n    zoomOn.call(zoom, 'zoom', null);\n    zoomended(event.of(this, arguments));\n    sync(geo, projection, syncCb);\n  }).on('zoom.redraw', function () {\n    geo.render();\n\n    var _rotate = projection.rotate();\n\n    geo.graphDiv.emit('plotly_relayouting', {\n      'geo.projection.scale': projection.scale() / geo.fitScale,\n      'geo.projection.rotation.lon': -_rotate[0],\n      'geo.projection.rotation.lat': -_rotate[1]\n    });\n  });\n\n  function zoomstarted(dispatch) {\n    if (!zooming++) dispatch({\n      type: 'zoomstart'\n    });\n  }\n\n  function zoomed(dispatch) {\n    dispatch({\n      type: 'zoom'\n    });\n  }\n\n  function zoomended(dispatch) {\n    if (! --zooming) dispatch({\n      type: 'zoomend'\n    });\n  }\n\n  function syncCb(set) {\n    var _rotate = projection.rotate();\n\n    set('projection.rotation.lon', -_rotate[0]);\n    set('projection.rotation.lat', -_rotate[1]);\n  }\n\n  return d3.rebind(zoom, event, 'on');\n} // -- helper functions for zoomClipped\n\n\nfunction position(projection, point) {\n  var spherical = projection.invert(point);\n  return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\n\nfunction quaternionFromEuler(euler) {\n  var lambda = 0.5 * euler[0] * radians;\n  var phi = 0.5 * euler[1] * radians;\n  var gamma = 0.5 * euler[2] * radians;\n  var sinLambda = Math.sin(lambda);\n  var cosLambda = Math.cos(lambda);\n  var sinPhi = Math.sin(phi);\n  var cosPhi = Math.cos(phi);\n  var sinGamma = Math.sin(gamma);\n  var cosGamma = Math.cos(gamma);\n  return [cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma, sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma, cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma, cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma];\n}\n\nfunction multiply(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return [a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3, a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2, a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1, a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0];\n}\n\nfunction rotateBetween(a, b) {\n  if (!a || !b) return;\n  var axis = cross(a, b);\n  var norm = Math.sqrt(dot(axis, axis));\n  var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));\n  var k = Math.sin(halfgamma) / norm;\n  return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n} // input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\n\n\nfunction unRoll(rotateAngles, pt, lastRotate) {\n  // calculate the fixed point transformed by these Euler angles\n  // but with the desired roll undone\n  var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n  ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n  ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n  var x = pt[0];\n  var y = pt[1];\n  var z = pt[2];\n  var f = ptRotated[0];\n  var g = ptRotated[1];\n  var h = ptRotated[2]; // the following essentially solves:\n  // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n  // for newYaw and newPitch, as best it can\n\n  var theta = Math.atan2(y, x) * degrees;\n  var a = Math.sqrt(x * x + y * y);\n  var b;\n  var newYaw1;\n\n  if (Math.abs(g) > a) {\n    newYaw1 = (g > 0 ? 90 : -90) - theta;\n    b = 0;\n  } else {\n    newYaw1 = Math.asin(g / a) * degrees - theta;\n    b = Math.sqrt(a * a - g * g);\n  }\n\n  var newYaw2 = 180 - newYaw1 - 2 * theta;\n  var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;\n  var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees; // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n\n  var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);\n  var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n  if (dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];else return [newYaw2, newPitch2, lastRotate[2]];\n}\n\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n  var dYaw = angleMod(yaw1 - yaw0);\n  var dPitch = angleMod(pitch1 - pitch0);\n  return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n} // reduce an angle in degrees to [-180,180]\n\n\nfunction angleMod(angle) {\n  return (angle % 360 + 540) % 360 - 180;\n} // rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\n\n\nfunction rotateCartesian(vector, axis, angle) {\n  var angleRads = angle * radians;\n  var vectorOut = vector.slice();\n  var ax1 = axis === 0 ? 1 : 0;\n  var ax2 = axis === 2 ? 1 : 2;\n  var cosa = Math.cos(angleRads);\n  var sina = Math.sin(angleRads);\n  vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n  vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n  return vectorOut;\n}\n\nfunction eulerFromQuaternion(q) {\n  return [Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees, Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees, Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0] * radians;\n  var phi = spherical[1] * radians;\n  var cosPhi = Math.cos(phi);\n  return [cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi)];\n}\n\nfunction dot(a, b) {\n  var s = 0;\n\n  for (var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];\n\n  return s;\n}\n\nfunction cross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n} // Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\n\n\nfunction d3eventDispatch(target) {\n  var i = 0;\n  var n = arguments.length;\n  var argumentz = [];\n\n  while (++i < n) argumentz.push(arguments[i]);\n\n  var dispatch = d3.dispatch.apply(null, argumentz); // Creates a dispatch context for the specified `thiz` (typically, the target\n  // DOM element that received the source event) and `argumentz` (typically, the\n  // data `d` and index `i` of the target element). The returned function can be\n  // used to dispatch an event to any registered listeners; the function takes a\n  // single argument as input, being the event to dispatch. The event must have\n  // a \"type\" attribute which corresponds to a type registered in the\n  // constructor. This context will automatically populate the \"sourceEvent\" and\n  // \"target\" attributes of the event, as well as setting the `d3.event` global\n  // for the duration of the notification.\n\n  dispatch.of = function (thiz, argumentz) {\n    return function (e1) {\n      var e0;\n\n      try {\n        e0 = e1.sourceEvent = d3.event;\n        e1.target = target;\n        d3.event = e1;\n        dispatch[e1.type].apply(thiz, argumentz);\n      } finally {\n        d3.event = e0;\n      }\n    };\n  };\n\n  return dispatch;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/geo/zoom.js"],"names":["d3","require","Lib","Registry","radians","Math","PI","degrees","zoomstartStyle","cursor","zoomendStyle","createGeoZoom","geo","geoLayout","projection","zoomConstructor","_isScoped","zoomScoped","_isClipped","zoomClipped","zoomNonClipped","module","exports","initZoom","behavior","zoom","translate","scale","sync","cb","id","gd","graphDiv","layout","userOpts","fullLayout","_fullLayout","fullOpts","preGUI","eventData","set","propStr","val","nestedProperty","get","call","_preGUI","fullNp","fitScale","emit","handleZoomstart","select","style","handleZoom","event","render","center","invert","midPt","syncCb","handleZoomend","on","INSIDETOLORANCEPXS","mouse0","rotate0","translate0","lastRotate","zoomPoint","mouse1","rotate1","point1","didZoom","position","x","outside","pos","pt","abs","mouse","rotate","view","r","k","d3eventDispatch","zooming","zoomOn","q","quaternionFromEuler","between","rotateBetween","newEuler","eulerFromQuaternion","multiply","rotateAngles","unRoll","isFinite","zoomed","of","arguments","zoomstarted","zoomended","_rotate","dispatch","type","rebind","point","spherical","cartesian","euler","lambda","phi","gamma","sinLambda","sin","cosLambda","cos","sinPhi","cosPhi","sinGamma","cosGamma","a","b","a0","a1","a2","a3","b0","b1","b2","b3","axis","cross","norm","sqrt","dot","halfgamma","acos","max","min","ptRotated","rotateCartesian","y","z","f","g","h","theta","atan2","newYaw1","asin","newYaw2","newPitch1","newPitch2","dist1","angleDistance","dist2","yaw0","pitch0","yaw1","pitch1","dYaw","angleMod","dPitch","angle","vector","angleRads","vectorOut","slice","ax1","ax2","cosa","sina","s","i","n","length","target","argumentz","push","apply","thiz","e1","e0","sourceEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\n\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\nvar zoomstartStyle = {cursor: 'pointer'};\nvar zoomendStyle = {cursor: 'auto'};\n\nfunction createGeoZoom(geo, geoLayout) {\n    var projection = geo.projection;\n    var zoomConstructor;\n\n    if(geoLayout._isScoped) {\n        zoomConstructor = zoomScoped;\n    } else if(geoLayout._isClipped) {\n        zoomConstructor = zoomClipped;\n    } else {\n        zoomConstructor = zoomNonClipped;\n    }\n\n    // TODO add a conic-specific zoom\n\n    return zoomConstructor(geo, projection);\n}\n\nmodule.exports = createGeoZoom;\n\n// common to all zoom types\nfunction initZoom(geo, projection) {\n    return d3.behavior.zoom()\n        .translate(projection.translate())\n        .scale(projection.scale());\n}\n\n// sync zoom updates with user & full layout\nfunction sync(geo, projection, cb) {\n    var id = geo.id;\n    var gd = geo.graphDiv;\n    var layout = gd.layout;\n    var userOpts = layout[id];\n    var fullLayout = gd._fullLayout;\n    var fullOpts = fullLayout[id];\n\n    var preGUI = {};\n    var eventData = {};\n\n    function set(propStr, val) {\n        preGUI[id + '.' + propStr] = Lib.nestedProperty(userOpts, propStr).get();\n        Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);\n\n        var fullNp = Lib.nestedProperty(fullOpts, propStr);\n        if(fullNp.get() !== val) {\n            fullNp.set(val);\n            Lib.nestedProperty(userOpts, propStr).set(val);\n            eventData[id + '.' + propStr] = val;\n        }\n    }\n\n    cb(set);\n    set('projection.scale', projection.scale() / geo.fitScale);\n    set('fitbounds', false);\n    gd.emit('plotly_relayout', eventData);\n}\n\n// zoom for scoped projections\nfunction zoomScoped(geo, projection) {\n    var zoom = initZoom(geo, projection);\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n    }\n\n    function handleZoom() {\n        projection\n            .scale(d3.event.scale)\n            .translate(d3.event.translate);\n        geo.render();\n\n        var center = projection.invert(geo.midPt);\n        geo.graphDiv.emit('plotly_relayouting', {\n            'geo.projection.scale': projection.scale() / geo.fitScale,\n            'geo.center.lon': center[0],\n            'geo.center.lat': center[1]\n        });\n    }\n\n    function syncCb(set) {\n        var center = projection.invert(geo.midPt);\n\n        set('center.lon', center[0]);\n        set('center.lat', center[1]);\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n        sync(geo, projection, syncCb);\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for non-clipped projections\nfunction zoomNonClipped(geo, projection) {\n    var zoom = initZoom(geo, projection);\n\n    var INSIDETOLORANCEPXS = 2;\n\n    var mouse0, rotate0, translate0, lastRotate, zoomPoint,\n        mouse1, rotate1, point1, didZoom;\n\n    function position(x) { return projection.invert(x); }\n\n    function outside(x) {\n        var pos = position(x);\n        if(!pos) return true;\n\n        var pt = projection(pos);\n        return (\n            Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS ||\n            Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS\n        );\n    }\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n\n        mouse0 = d3.mouse(this);\n        rotate0 = projection.rotate();\n        translate0 = projection.translate();\n        lastRotate = rotate0;\n        zoomPoint = position(mouse0);\n    }\n\n    function handleZoom() {\n        mouse1 = d3.mouse(this);\n\n        if(outside(mouse0)) {\n            zoom.scale(projection.scale());\n            zoom.translate(projection.translate());\n            return;\n        }\n\n        projection.scale(d3.event.scale);\n        projection.translate([translate0[0], d3.event.translate[1]]);\n\n        if(!zoomPoint) {\n            mouse0 = mouse1;\n            zoomPoint = position(mouse0);\n        } else if(position(mouse1)) {\n            point1 = position(mouse1);\n            rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n            projection.rotate(rotate1);\n            lastRotate = rotate1;\n        }\n\n        didZoom = true;\n        geo.render();\n\n        var rotate = projection.rotate();\n        var center = projection.invert(geo.midPt);\n        geo.graphDiv.emit('plotly_relayouting', {\n            'geo.projection.scale': projection.scale() / geo.fitScale,\n            'geo.center.lon': center[0],\n            'geo.center.lat': center[1],\n            'geo.projection.rotation.lon': -rotate[0]\n        });\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n        if(didZoom) sync(geo, projection, syncCb);\n    }\n\n    function syncCb(set) {\n        var rotate = projection.rotate();\n        var center = projection.invert(geo.midPt);\n\n        set('projection.rotation.lon', -rotate[0]);\n        set('center.lon', center[0]);\n        set('center.lat', center[1]);\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\nfunction zoomClipped(geo, projection) {\n    var view = {r: projection.rotate(), k: projection.scale()};\n    var zoom = initZoom(geo, projection);\n    var event = d3eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend');\n    var zooming = 0;\n    var zoomOn = zoom.on;\n\n    var zoomPoint;\n\n    zoom.on('zoomstart', function() {\n        d3.select(this).style(zoomstartStyle);\n\n        var mouse0 = d3.mouse(this);\n        var rotate0 = projection.rotate();\n        var lastRotate = rotate0;\n        var translate0 = projection.translate();\n        var q = quaternionFromEuler(rotate0);\n\n        zoomPoint = position(projection, mouse0);\n\n        zoomOn.call(zoom, 'zoom', function() {\n            var mouse1 = d3.mouse(this);\n\n            projection.scale(view.k = d3.event.scale);\n\n            if(!zoomPoint) {\n                // if no zoomPoint, the mouse wasn't over the actual geography yet\n                // maybe this point is the start... we'll find out next time!\n                mouse0 = mouse1;\n                zoomPoint = position(projection, mouse0);\n            } else if(position(projection, mouse1)) {\n                // check if the point is on the map\n                // if not, don't do anything new but scale\n                // if it is, then we can assume between will exist below\n                // so we don't need the 'bank' function, whatever that is.\n\n                // go back to original projection temporarily\n                // except for scale... that's kind of independent?\n                projection\n                    .rotate(rotate0)\n                    .translate(translate0);\n\n                // calculate the new params\n                var point1 = position(projection, mouse1);\n                var between = rotateBetween(zoomPoint, point1);\n                var newEuler = eulerFromQuaternion(multiply(q, between));\n                var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n\n                if(!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) ||\n                   !isFinite(rotateAngles[2])) {\n                    rotateAngles = lastRotate;\n                }\n\n                // update the projection\n                projection.rotate(rotateAngles);\n                lastRotate = rotateAngles;\n            }\n\n            zoomed(event.of(this, arguments));\n        });\n\n        zoomstarted(event.of(this, arguments));\n    })\n    .on('zoomend', function() {\n        d3.select(this).style(zoomendStyle);\n        zoomOn.call(zoom, 'zoom', null);\n        zoomended(event.of(this, arguments));\n        sync(geo, projection, syncCb);\n    })\n    .on('zoom.redraw', function() {\n        geo.render();\n\n        var _rotate = projection.rotate();\n        geo.graphDiv.emit('plotly_relayouting', {\n            'geo.projection.scale': projection.scale() / geo.fitScale,\n            'geo.projection.rotation.lon': -_rotate[0],\n            'geo.projection.rotation.lat': -_rotate[1]\n        });\n    });\n\n    function zoomstarted(dispatch) {\n        if(!zooming++) dispatch({type: 'zoomstart'});\n    }\n\n    function zoomed(dispatch) {\n        dispatch({type: 'zoom'});\n    }\n\n    function zoomended(dispatch) {\n        if(!--zooming) dispatch({type: 'zoomend'});\n    }\n\n    function syncCb(set) {\n        var _rotate = projection.rotate();\n        set('projection.rotation.lon', -_rotate[0]);\n        set('projection.rotation.lat', -_rotate[1]);\n    }\n\n    return d3.rebind(zoom, event, 'on');\n}\n\n// -- helper functions for zoomClipped\n\nfunction position(projection, point) {\n    var spherical = projection.invert(point);\n    return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\n\nfunction quaternionFromEuler(euler) {\n    var lambda = 0.5 * euler[0] * radians;\n    var phi = 0.5 * euler[1] * radians;\n    var gamma = 0.5 * euler[2] * radians;\n    var sinLambda = Math.sin(lambda);\n    var cosLambda = Math.cos(lambda);\n    var sinPhi = Math.sin(phi);\n    var cosPhi = Math.cos(phi);\n    var sinGamma = Math.sin(gamma);\n    var cosGamma = Math.cos(gamma);\n    return [\n        cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma,\n        sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma,\n        cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma,\n        cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma\n    ];\n}\n\nfunction multiply(a, b) {\n    var a0 = a[0];\n    var a1 = a[1];\n    var a2 = a[2];\n    var a3 = a[3];\n    var b0 = b[0];\n    var b1 = b[1];\n    var b2 = b[2];\n    var b3 = b[3];\n    return [\n        a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3,\n        a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2,\n        a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1,\n        a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0\n    ];\n}\n\nfunction rotateBetween(a, b) {\n    if(!a || !b) return;\n    var axis = cross(a, b);\n    var norm = Math.sqrt(dot(axis, axis));\n    var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));\n    var k = Math.sin(halfgamma) / norm;\n    return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n}\n\n// input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\nfunction unRoll(rotateAngles, pt, lastRotate) {\n    // calculate the fixed point transformed by these Euler angles\n    // but with the desired roll undone\n    var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n    ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n    ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n\n    var x = pt[0];\n    var y = pt[1];\n    var z = pt[2];\n    var f = ptRotated[0];\n    var g = ptRotated[1];\n    var h = ptRotated[2];\n\n    // the following essentially solves:\n    // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n    // for newYaw and newPitch, as best it can\n    var theta = Math.atan2(y, x) * degrees;\n    var a = Math.sqrt(x * x + y * y);\n    var b;\n    var newYaw1;\n\n    if(Math.abs(g) > a) {\n        newYaw1 = (g > 0 ? 90 : -90) - theta;\n        b = 0;\n    } else {\n        newYaw1 = Math.asin(g / a) * degrees - theta;\n        b = Math.sqrt(a * a - g * g);\n    }\n\n    var newYaw2 = 180 - newYaw1 - 2 * theta;\n    var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;\n    var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees;\n\n    // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n    var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);\n    var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n\n    if(dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];\n    else return [newYaw2, newPitch2, lastRotate[2]];\n}\n\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n    var dYaw = angleMod(yaw1 - yaw0);\n    var dPitch = angleMod(pitch1 - pitch0);\n    return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n}\n\n// reduce an angle in degrees to [-180,180]\nfunction angleMod(angle) {\n    return (angle % 360 + 540) % 360 - 180;\n}\n\n// rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\nfunction rotateCartesian(vector, axis, angle) {\n    var angleRads = angle * radians;\n    var vectorOut = vector.slice();\n    var ax1 = (axis === 0) ? 1 : 0;\n    var ax2 = (axis === 2) ? 1 : 2;\n    var cosa = Math.cos(angleRads);\n    var sina = Math.sin(angleRads);\n\n    vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n    vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n\n    return vectorOut;\n}\nfunction eulerFromQuaternion(q) {\n    return [\n        Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees,\n        Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees,\n        Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees\n    ];\n}\n\nfunction cartesian(spherical) {\n    var lambda = spherical[0] * radians;\n    var phi = spherical[1] * radians;\n    var cosPhi = Math.cos(phi);\n    return [\n        cosPhi * Math.cos(lambda),\n        cosPhi * Math.sin(lambda),\n        Math.sin(phi)\n    ];\n}\n\nfunction dot(a, b) {\n    var s = 0;\n    for(var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];\n    return s;\n}\n\nfunction cross(a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3eventDispatch(target) {\n    var i = 0;\n    var n = arguments.length;\n    var argumentz = [];\n\n    while(++i < n) argumentz.push(arguments[i]);\n\n    var dispatch = d3.dispatch.apply(null, argumentz);\n\n    // Creates a dispatch context for the specified `thiz` (typically, the target\n    // DOM element that received the source event) and `argumentz` (typically, the\n    // data `d` and index `i` of the target element). The returned function can be\n    // used to dispatch an event to any registered listeners; the function takes a\n    // single argument as input, being the event to dispatch. The event must have\n    // a \"type\" attribute which corresponds to a type registered in the\n    // constructor. This context will automatically populate the \"sourceEvent\" and\n    // \"target\" attributes of the event, as well as setting the `d3.event` global\n    // for the duration of the notification.\n    dispatch.of = function(thiz, argumentz) {\n        return function(e1) {\n            var e0;\n            try {\n                e0 = e1.sourceEvent = d3.event;\n                e1.target = target;\n                d3.event = e1;\n                dispatch[e1.type].apply(thiz, argumentz);\n            } finally {\n                d3.event = e0;\n            }\n        };\n    };\n\n    return dispatch;\n}\n"]},"metadata":{},"sourceType":"script"}