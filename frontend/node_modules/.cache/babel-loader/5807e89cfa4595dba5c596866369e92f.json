{"ast":null,"code":"'use strict';\n\nvar createScatter = require('regl-scatter2d');\n\nvar createLine = require('regl-line2d');\n\nvar createError = require('regl-error2d');\n\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\n\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nfunction getViewport(fullLayout, xaxis, yaxis, plotGlPixelRatio) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width * plotGlPixelRatio;\n  var height = fullLayout.height * plotGlPixelRatio;\n  var l = gs.l * plotGlPixelRatio;\n  var b = gs.b * plotGlPixelRatio;\n  var r = gs.r * plotGlPixelRatio;\n  var t = gs.t * plotGlPixelRatio;\n  var w = gs.w * plotGlPixelRatio;\n  var h = gs.h * plotGlPixelRatio;\n  return [l + xaxis.domain[0] * w, b + yaxis.domain[0] * h, width - r - (1 - xaxis.domain[1]) * w, height - t - (1 - yaxis.domain[1]) * h];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j; // we may have more subplots than initialized data due to Axes.getSubplots method\n\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n\n  if (!success) {\n    scene.init();\n    return;\n  }\n\n  var count = scene.count;\n\n  var regl = fullLayout._glcanvas.data()[0].regl; // that is needed for fills\n\n\n  linkTraces(gd, subplot, cdata);\n\n  if (scene.dirty) {\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl);\n    }\n\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n\n    if (scene.glText === true) {\n      scene.glText = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    } // update main marker options\n\n\n    if (scene.glText) {\n      if (count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = count - scene.glText.length;\n\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - count;\n        var removedTexts = scene.glText.splice(count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n\n          var lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    } // fill requires linked traces, so we generate it's positions here\n\n\n    scene.fillOrder = Lib.repeat(null, count);\n\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n          fillOptions.splitNull = true;\n\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              pos.push(null, null); // keep null to mark end of polygon\n\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(srcPos.slice(last));\n\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        } // detect prev trace positions to exclude from current fill\n\n\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions; // FIXME: likely this logic should be tested better\n\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  } // form batch arrays, and check for selected points\n\n\n  var dragmode = fullLayout.dragmode;\n  var isSelectMode = selectMode(dragmode);\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n  for (i = 0; i < count; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n\n    if (trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n      if (!isSelectMode) isSelectMode = true; // regenerate scene batch, if traces number changed during selection\n\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n\n        var unselPts = [];\n\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n\n        scene.unselectBatch[index] = unselPts;\n      } // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n\n\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n\n  if (isSelectMode) {\n    // create scatter instance by cloning scatter2d\n    if (!scene.select2d) {\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    } // use unselected styles on 'context' canvas\n\n\n    if (scene.scatter2d) {\n      var unselOpts = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};\n      }\n\n      scene.scatter2d.update(unselOpts);\n    } // use selected style on 'focus' canvas\n\n\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        var trace = ((cdscatter || [])[0] || {}).trace || {};\n\n        if (subTypes.hasText(trace)) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    // reset 'context' scatter2d opts to base opts,\n    // thus unsetting markerUnselectedOptions from selection\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  } // provide viewport and range\n\n\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis, gd._context.plotGlPixelRatio),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count); // upload viewport/range data to GPU\n\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/scattergl/plot.js"],"names":["createScatter","require","createLine","createError","Text","Lib","selectMode","prepareRegl","subTypes","linkTraces","styleTextSelection","getViewport","fullLayout","xaxis","yaxis","plotGlPixelRatio","gs","_size","width","height","l","b","r","t","w","h","domain","module","exports","plot","gd","subplot","cdata","length","_fullLayout","scene","_scene","i","j","success","init","count","regl","_glcanvas","data","dirty","error2d","line2d","scatter2d","fill2d","glText","Array","textsToAdd","push","textsToRemove","removedTexts","splice","forEach","text","destroy","update","textOptions","lineOptions","map","positions","srcPos","firstptdef","isNaN","lastptdef","slice","errorBatch","errorXOptions","concat","errorYOptions","markerOptions","fillOrder","repeat","fillOptions","cdscatter","trace","cd","stash","last","fillData","_ownfill","_nexttrace","pos","fill","splitNull","nextTrace","nextOptions","nextPos","Math","floor","xx","yy","fillcolor","_prevtrace","prevLinePos","offset","hole","fillmode","opacity","dragmode","isSelectMode","clickSelectEnabled","clickmode","indexOf","cd0","index","len","_length","x","y","selectedpoints","selPts","selectBatch","selIndices2selPoints","selDict","unselPts","unselectBatch","xpx","ypx","c2p","select2d","unselOpts","markerUnselectedOptions","markerSelectedOptions","hasText","vpRange0","viewport","_context","range","_rl","vpRange"],"mappings":"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","sourcesContent":["'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\n\nfunction getViewport(fullLayout, xaxis, yaxis, plotGlPixelRatio) {\n    var gs = fullLayout._size;\n    var width = fullLayout.width * plotGlPixelRatio;\n    var height = fullLayout.height * plotGlPixelRatio;\n\n    var l = gs.l * plotGlPixelRatio;\n    var b = gs.b * plotGlPixelRatio;\n    var r = gs.r * plotGlPixelRatio;\n    var t = gs.t * plotGlPixelRatio;\n    var w = gs.w * plotGlPixelRatio;\n    var h = gs.h * plotGlPixelRatio;\n    return [\n        l + xaxis.domain[0] * w,\n        b + yaxis.domain[0] * h,\n        (width - r) - (1 - xaxis.domain[1]) * w,\n        (height - t) - (1 - yaxis.domain[1]) * h\n    ];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n    if(!cdata.length) return;\n\n    var fullLayout = gd._fullLayout;\n    var scene = subplot._scene;\n    var xaxis = subplot.xaxis;\n    var yaxis = subplot.yaxis;\n    var i, j;\n\n    // we may have more subplots than initialized data due to Axes.getSubplots method\n    if(!scene) return;\n\n    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n    if(!success) {\n        scene.init();\n        return;\n    }\n\n    var count = scene.count;\n    var regl = fullLayout._glcanvas.data()[0].regl;\n\n    // that is needed for fills\n    linkTraces(gd, subplot, cdata);\n\n    if(scene.dirty) {\n        // make sure scenes are created\n        if(scene.error2d === true) {\n            scene.error2d = createError(regl);\n        }\n        if(scene.line2d === true) {\n            scene.line2d = createLine(regl);\n        }\n        if(scene.scatter2d === true) {\n            scene.scatter2d = createScatter(regl);\n        }\n        if(scene.fill2d === true) {\n            scene.fill2d = createLine(regl);\n        }\n        if(scene.glText === true) {\n            scene.glText = new Array(count);\n            for(i = 0; i < count; i++) {\n                scene.glText[i] = new Text(regl);\n            }\n        }\n\n        // update main marker options\n        if(scene.glText) {\n            if(count > scene.glText.length) {\n                // add gl text marker\n                var textsToAdd = count - scene.glText.length;\n                for(i = 0; i < textsToAdd; i++) {\n                    scene.glText.push(new Text(regl));\n                }\n            } else if(count < scene.glText.length) {\n                // remove gl text marker\n                var textsToRemove = scene.glText.length - count;\n                var removedTexts = scene.glText.splice(count, textsToRemove);\n                removedTexts.forEach(function(text) { text.destroy(); });\n            }\n\n            for(i = 0; i < count; i++) {\n                scene.glText[i].update(scene.textOptions[i]);\n            }\n        }\n        if(scene.line2d) {\n            scene.line2d.update(scene.lineOptions);\n            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {\n                if(lineOptions && lineOptions.positions) {\n                    var srcPos = lineOptions.positions;\n\n                    var firstptdef = 0;\n                    while(firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n                        firstptdef += 2;\n                    }\n                    var lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n                        lastptdef -= 2;\n                    }\n                    lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n                }\n                return lineOptions;\n            });\n            scene.line2d.update(scene.lineOptions);\n        }\n        if(scene.error2d) {\n            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n            scene.error2d.update(errorBatch);\n        }\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n\n        // fill requires linked traces, so we generate it's positions here\n        scene.fillOrder = Lib.repeat(null, count);\n        if(scene.fill2d) {\n            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i) {\n                var cdscatter = cdata[i];\n                if(!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n                var cd = cdscatter[0];\n                var trace = cd.trace;\n                var stash = cd.t;\n                var lineOptions = scene.lineOptions[i];\n                var last, j;\n\n                var fillData = [];\n                if(trace._ownfill) fillData.push(i);\n                if(trace._nexttrace) fillData.push(i + 1);\n                if(fillData.length) scene.fillOrder[i] = fillData;\n\n                var pos = [];\n                var srcPos = (lineOptions && lineOptions.positions) || stash.positions;\n                var firstptdef, lastptdef;\n\n                if(trace.fill === 'tozeroy') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef + 1] !== 0) {\n                        pos = [srcPos[firstptdef], 0];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef + 1] !== 0) {\n                        pos = pos.concat([srcPos[lastptdef], 0]);\n                    }\n                } else if(trace.fill === 'tozerox') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef] !== 0) {\n                        pos = [0, srcPos[firstptdef + 1]];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef] !== 0) {\n                        pos = pos.concat([ 0, srcPos[lastptdef + 1]]);\n                    }\n                } else if(trace.fill === 'toself' || trace.fill === 'tonext') {\n                    pos = [];\n                    last = 0;\n\n                    fillOptions.splitNull = true;\n\n                    for(j = 0; j < srcPos.length; j += 2) {\n                        if(isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n                            pos = pos.concat(srcPos.slice(last, j));\n                            pos.push(srcPos[last], srcPos[last + 1]);\n                            pos.push(null, null); // keep null to mark end of polygon\n                            last = j + 2;\n                        }\n                    }\n                    pos = pos.concat(srcPos.slice(last));\n                    if(last) {\n                        pos.push(srcPos[last], srcPos[last + 1]);\n                    }\n                } else {\n                    var nextTrace = trace._nexttrace;\n\n                    if(nextTrace) {\n                        var nextOptions = scene.lineOptions[i + 1];\n\n                        if(nextOptions) {\n                            var nextPos = nextOptions.positions;\n                            if(trace.fill === 'tonexty') {\n                                pos = srcPos.slice();\n\n                                for(i = Math.floor(nextPos.length / 2); i--;) {\n                                    var xx = nextPos[i * 2];\n                                    var yy = nextPos[i * 2 + 1];\n                                    if(isNaN(xx) || isNaN(yy)) continue;\n                                    pos.push(xx, yy);\n                                }\n                                fillOptions.fill = nextTrace.fillcolor;\n                            }\n                        }\n                    }\n                }\n\n                // detect prev trace positions to exclude from current fill\n                if(trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n                    var prevLinePos = scene.lineOptions[i - 1].positions;\n\n                    // FIXME: likely this logic should be tested better\n                    var offset = pos.length / 2;\n                    last = offset;\n                    var hole = [last];\n                    for(j = 0; j < prevLinePos.length; j += 2) {\n                        if(isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n                            hole.push(j / 2 + offset + 1);\n                            last = j + 2;\n                        }\n                    }\n\n                    pos = pos.concat(prevLinePos);\n                    fillOptions.hole = hole;\n                }\n                fillOptions.fillmode = trace.fill;\n                fillOptions.opacity = trace.opacity;\n                fillOptions.positions = pos;\n\n                return fillOptions;\n            });\n\n            scene.fill2d.update(scene.fillOptions);\n        }\n    }\n\n    // form batch arrays, and check for selected points\n    var dragmode = fullLayout.dragmode;\n    var isSelectMode = selectMode(dragmode);\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n    for(i = 0; i < count; i++) {\n        var cd0 = cdata[i][0];\n        var trace = cd0.trace;\n        var stash = cd0.t;\n        var index = stash.index;\n        var len = trace._length;\n        var x = stash.x;\n        var y = stash.y;\n\n        if(trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n            if(!isSelectMode) isSelectMode = true;\n\n            // regenerate scene batch, if traces number changed during selection\n            if(trace.selectedpoints) {\n                var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n\n                var selDict = {};\n                for(j = 0; j < selPts.length; j++) {\n                    selDict[selPts[j]] = 1;\n                }\n                var unselPts = [];\n                for(j = 0; j < len; j++) {\n                    if(!selDict[j]) unselPts.push(j);\n                }\n                scene.unselectBatch[index] = unselPts;\n            }\n\n            // precalculate px coords since we are not going to pan during select\n            // TODO, could do better here e.g.\n            // - spin that in a webworker\n            // - compute selection from polygons in data coordinates\n            //   (maybe just for linear axes)\n            var xpx = stash.xpx = new Array(len);\n            var ypx = stash.ypx = new Array(len);\n            for(j = 0; j < len; j++) {\n                xpx[j] = xaxis.c2p(x[j]);\n                ypx[j] = yaxis.c2p(y[j]);\n            }\n        } else {\n            stash.xpx = stash.ypx = null;\n        }\n    }\n\n    if(isSelectMode) {\n        // create scatter instance by cloning scatter2d\n        if(!scene.select2d) {\n            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n        }\n\n        // use unselected styles on 'context' canvas\n        if(scene.scatter2d) {\n            var unselOpts = new Array(count);\n            for(i = 0; i < count; i++) {\n                unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ?\n                    scene.markerUnselectedOptions[i] :\n                    {};\n            }\n            scene.scatter2d.update(unselOpts);\n        }\n\n        // use selected style on 'focus' canvas\n        if(scene.select2d) {\n            scene.select2d.update(scene.markerOptions);\n            scene.select2d.update(scene.markerSelectedOptions);\n        }\n\n        if(scene.glText) {\n            cdata.forEach(function(cdscatter) {\n                var trace = ((cdscatter || [])[0] || {}).trace || {};\n                if(subTypes.hasText(trace)) {\n                    styleTextSelection(cdscatter);\n                }\n            });\n        }\n    } else {\n        // reset 'context' scatter2d opts to base opts,\n        // thus unsetting markerUnselectedOptions from selection\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n    }\n\n    // provide viewport and range\n    var vpRange0 = {\n        viewport: getViewport(fullLayout, xaxis, yaxis, gd._context.plotGlPixelRatio),\n        // TODO do we need those fallbacks?\n        range: [\n            (xaxis._rl || xaxis.range)[0],\n            (yaxis._rl || yaxis.range)[0],\n            (xaxis._rl || xaxis.range)[1],\n            (yaxis._rl || yaxis.range)[1]\n        ]\n    };\n    var vpRange = Lib.repeat(vpRange0, scene.count);\n\n    // upload viewport/range data to GPU\n    if(scene.fill2d) {\n        scene.fill2d.update(vpRange);\n    }\n    if(scene.line2d) {\n        scene.line2d.update(vpRange);\n    }\n    if(scene.error2d) {\n        scene.error2d.update(vpRange.concat(vpRange));\n    }\n    if(scene.scatter2d) {\n        scene.scatter2d.update(vpRange);\n    }\n    if(scene.select2d) {\n        scene.select2d.update(vpRange);\n    }\n    if(scene.glText) {\n        scene.glText.forEach(function(text) { text.update(vpRange0); });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}