{"ast":null,"code":"'use strict';\n\nvar Registry = require('../registry');\n\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\n\n\nexports.getSubplotCalcData = function (calcData, type, subplotId) {\n  var basePlotModule = Registry.subplotsRegistry[type];\n  if (!basePlotModule) return [];\n  var attr = basePlotModule.attr;\n  var subplotCalcData = [];\n\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n    if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n  }\n\n  return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\n\n\nexports.getModuleCalcData = function (calcdata, arg1) {\n  var moduleCalcData = [];\n  var remainingCalcData = [];\n  var plotMethod;\n\n  if (typeof arg1 === 'string') {\n    plotMethod = Registry.getModule(arg1).plot;\n  } else if (typeof arg1 === 'function') {\n    plotMethod = arg1;\n  } else {\n    plotMethod = arg1.plot;\n  }\n\n  if (!plotMethod) {\n    return [moduleCalcData, calcdata];\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var trace = cd[0].trace; // N.B.\n    // - 'legendonly' traces do not make it past here\n    // - skip over 'visible' traces that got trimmed completely during calc transforms\n\n    if (trace.visible !== true || trace._length === 0) continue; // group calcdata trace not by 'module' (as the name of this function\n    // would suggest), but by 'module plot method' so that if some traces\n    // share the same module plot method (e.g. bar and histogram), we\n    // only call it one!\n\n    if (trace._module.plot === plotMethod) {\n      moduleCalcData.push(cd);\n    } else {\n      remainingCalcData.push(cd);\n    }\n  }\n\n  return [moduleCalcData, remainingCalcData];\n};\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\n\n\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n  if (!Registry.subplotsRegistry[type]) return [];\n  var attr = Registry.subplotsRegistry[type].attr;\n  var subplotData = [];\n  var trace, subplotX, subplotY;\n\n  if (type === 'gl2d') {\n    var spmatch = subplotId.match(SUBPLOT_PATTERN);\n    subplotX = 'x' + spmatch[1];\n    subplotY = 'y' + spmatch[2];\n  }\n\n  for (var i = 0; i < data.length; i++) {\n    trace = data[i];\n\n    if (type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n      if (trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n        subplotData.push(trace);\n      }\n    } else {\n      if (trace[attr] === subplotId) subplotData.push(trace);\n    }\n  }\n\n  return subplotData;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/get_data.js"],"names":["Registry","require","SUBPLOT_PATTERN","exports","getSubplotCalcData","calcData","type","subplotId","basePlotModule","subplotsRegistry","attr","subplotCalcData","i","length","calcTrace","trace","push","getModuleCalcData","calcdata","arg1","moduleCalcData","remainingCalcData","plotMethod","getModule","plot","cd","visible","_length","_module","getSubplotData","data","subplotData","subplotX","subplotY","spmatch","match","traceIs"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Registry = require('../registry');\nvar SUBPLOT_PATTERN = require('./cartesian/constants').SUBPLOT_PATTERN;\n\n/**\n * Get calcdata trace(s) associated with a given subplot\n *\n * @param {array} calcData: as in gd.calcdata\n * @param {string} type: subplot type\n * @param {string} subplotId: subplot id to look for\n *\n * @return {array} array of calcdata traces\n */\nexports.getSubplotCalcData = function(calcData, type, subplotId) {\n    var basePlotModule = Registry.subplotsRegistry[type];\n    if(!basePlotModule) return [];\n\n    var attr = basePlotModule.attr;\n    var subplotCalcData = [];\n\n    for(var i = 0; i < calcData.length; i++) {\n        var calcTrace = calcData[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace[attr] === subplotId) subplotCalcData.push(calcTrace);\n    }\n\n    return subplotCalcData;\n};\n/**\n * Get calcdata trace(s) that can be plotted with a given module\n * NOTE: this isn't necessarily just exactly matching trace type,\n * if multiple trace types use the same plotting routine, they will be\n * collected here.\n * In order to not plot the same thing multiple times, we return two arrays,\n * the calcdata we *will* plot with this module, and the ones we *won't*\n *\n * @param {array} calcdata: as in gd.calcdata\n * @param {object|string|fn} arg1:\n *  the plotting module, or its name, or its plot method\n *\n * @return {array[array]} [foundCalcdata, remainingCalcdata]\n */\nexports.getModuleCalcData = function(calcdata, arg1) {\n    var moduleCalcData = [];\n    var remainingCalcData = [];\n\n    var plotMethod;\n    if(typeof arg1 === 'string') {\n        plotMethod = Registry.getModule(arg1).plot;\n    } else if(typeof arg1 === 'function') {\n        plotMethod = arg1;\n    } else {\n        plotMethod = arg1.plot;\n    }\n    if(!plotMethod) {\n        return [moduleCalcData, calcdata];\n    }\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var trace = cd[0].trace;\n        // N.B.\n        // - 'legendonly' traces do not make it past here\n        // - skip over 'visible' traces that got trimmed completely during calc transforms\n        if(trace.visible !== true || trace._length === 0) continue;\n\n        // group calcdata trace not by 'module' (as the name of this function\n        // would suggest), but by 'module plot method' so that if some traces\n        // share the same module plot method (e.g. bar and histogram), we\n        // only call it one!\n        if(trace._module.plot === plotMethod) {\n            moduleCalcData.push(cd);\n        } else {\n            remainingCalcData.push(cd);\n        }\n    }\n\n    return [moduleCalcData, remainingCalcData];\n};\n\n/**\n * Get the data trace(s) associated with a given subplot.\n *\n * @param {array} data  plotly full data array.\n * @param {string} type subplot type to look for.\n * @param {string} subplotId subplot id to look for.\n *\n * @return {array} list of trace objects.\n *\n */\nexports.getSubplotData = function getSubplotData(data, type, subplotId) {\n    if(!Registry.subplotsRegistry[type]) return [];\n\n    var attr = Registry.subplotsRegistry[type].attr;\n    var subplotData = [];\n    var trace, subplotX, subplotY;\n\n    if(type === 'gl2d') {\n        var spmatch = subplotId.match(SUBPLOT_PATTERN);\n        subplotX = 'x' + spmatch[1];\n        subplotY = 'y' + spmatch[2];\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        trace = data[i];\n\n        if(type === 'gl2d' && Registry.traceIs(trace, 'gl2d')) {\n            if(trace[attr[0]] === subplotX && trace[attr[1]] === subplotY) {\n                subplotData.push(trace);\n            }\n        } else {\n            if(trace[attr] === subplotId) subplotData.push(trace);\n        }\n    }\n\n    return subplotData;\n};\n"]},"metadata":{},"sourceType":"script"}