{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar Registry = require('../registry');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar filterOps = require('../constants/filter_ops');\n\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\nexports.moduleType = 'transform';\nexports.name = 'filter';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    editType: 'calc',\n    description: ['Determines whether this filter transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    editType: 'calc',\n    description: ['Sets the filter target by which the filter is applied.', 'If a string, `target` is assumed to be a reference to a data array', 'in the parent trace object.', 'To filter about nested variables, use *.* to access them.', 'For example, set `target` to *marker.color* to filter', 'about the marker color array.', 'If an array, `target` is then the data array by which the filter is applied.'].join(' ')\n  },\n  operation: {\n    valType: 'enumerated',\n    values: [].concat(COMPARISON_OPS).concat(INTERVAL_OPS).concat(SET_OPS),\n    dflt: '=',\n    editType: 'calc',\n    description: ['Sets the filter operation.', '*=* keeps items equal to `value`', '*!=* keeps items not equal to `value`', '*<* keeps items less than `value`', '*<=* keeps items less than or equal to `value`', '*>* keeps items greater than `value`', '*>=* keeps items greater than or equal to `value`', '*[]* keeps items inside `value[0]` to `value[1]` including both bounds', '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds', '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]', '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]', '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds', '*)(* keeps items outside `value[0]` to `value[1]`', '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`', '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`', '*{}* keeps items present in a set of values', '*}{* keeps items not present in a set of values'].join(' ')\n  },\n  value: {\n    valType: 'any',\n    dflt: 0,\n    editType: 'calc',\n    description: ['Sets the value or values by which to filter.', 'Values are expected to be in the same type as the data linked', 'to `target`.', 'When `operation` is set to one of', 'the comparison values (' + COMPARISON_OPS + ')', '`value` is expected to be a number or a string.', 'When `operation` is set to one of the interval values', '(' + INTERVAL_OPS + ')', '`value` is expected to be 2-item array where the first item', 'is the lower bound and the second item is the upper bound.', 'When `operation`, is set to one of the set values', '(' + SET_OPS + ')', '`value` is expected to be an array with as many items as', 'the desired set elements.'].join(' ')\n  },\n  preservegaps: {\n    valType: 'boolean',\n    dflt: false,\n    editType: 'calc',\n    description: ['Determines whether or not gaps in data arrays produced by the filter operation', 'are preserved.', 'Setting this to *true* might be useful when plotting a line chart', 'with `connectgaps` set to *false*.'].join(' ')\n  },\n  editType: 'calc'\n};\n\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n\n  if (enabled) {\n    var target = coerce('target');\n\n    if (Lib.isArrayOrTypedArray(target) && target.length === 0) {\n      transformOut.enabled = false;\n      return transformOut;\n    }\n\n    coerce('preservegaps');\n    coerce('operation');\n    coerce('value');\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n    handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n  }\n\n  return transformOut;\n};\n\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var targetCalendar = opts.targetcalendar;\n  var arrayAttrs = trace._arrayAttrs;\n  var preservegaps = opts.preservegaps; // even if you provide targetcalendar, if target is a string and there\n  // is a calendar attribute matching target it will get used instead.\n\n  if (typeof target === 'string') {\n    var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n    if (attrTargetCalendar) targetCalendar = attrTargetCalendar;\n  }\n\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n  var originalArrays = {};\n  var indexToPoints = {};\n  var index = 0;\n\n  function forAllAttrs(fn, index) {\n    for (var j = 0; j < arrayAttrs.length; j++) {\n      var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n      fn(np, index);\n    }\n  }\n\n  var initFn;\n  var fillFn;\n\n  if (preservegaps) {\n    initFn = function initFn(np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set(new Array(len));\n    };\n\n    fillFn = function fillFn(np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get()[index] = val;\n    };\n  } else {\n    initFn = function initFn(np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set([]);\n    };\n\n    fillFn = function fillFn(np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get().push(val);\n    };\n  } // copy all original array attribute values, and clear arrays in trace\n\n\n  forAllAttrs(initFn);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts); // loop through filter array, fill trace arrays if passed\n\n  for (var i = 0; i < len; i++) {\n    var passed = filterFunc(targetArray[i]);\n\n    if (passed) {\n      forAllAttrs(fillFn, i);\n      indexToPoints[index++] = originalPointsAccessor(i);\n    } else if (preservegaps) index++;\n  }\n\n  opts._indexToPoints = indexToPoints;\n  trace._length = index;\n};\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n  var operation = opts.operation;\n  var value = opts.value;\n  var hasArrayValue = Array.isArray(value);\n\n  function isOperationIn(array) {\n    return array.indexOf(operation) !== -1;\n  }\n\n  var d2cValue = function d2cValue(v) {\n    return d2c(v, 0, opts.valuecalendar);\n  };\n\n  var d2cTarget = function d2cTarget(v) {\n    return d2c(v, 0, targetCalendar);\n  };\n\n  var coercedValue;\n\n  if (isOperationIn(COMPARISON_OPS)) {\n    coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n  } else if (isOperationIn(INTERVAL_OPS)) {\n    coercedValue = hasArrayValue ? [d2cValue(value[0]), d2cValue(value[1])] : [d2cValue(value), d2cValue(value)];\n  } else if (isOperationIn(SET_OPS)) {\n    coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n  }\n\n  switch (operation) {\n    case '=':\n      return function (v) {\n        return d2cTarget(v) === coercedValue;\n      };\n\n    case '!=':\n      return function (v) {\n        return d2cTarget(v) !== coercedValue;\n      };\n\n    case '<':\n      return function (v) {\n        return d2cTarget(v) < coercedValue;\n      };\n\n    case '<=':\n      return function (v) {\n        return d2cTarget(v) <= coercedValue;\n      };\n\n    case '>':\n      return function (v) {\n        return d2cTarget(v) > coercedValue;\n      };\n\n    case '>=':\n      return function (v) {\n        return d2cTarget(v) >= coercedValue;\n      };\n\n    case '[]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv <= coercedValue[1];\n      };\n\n    case '()':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv < coercedValue[1];\n      };\n\n    case '[)':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv < coercedValue[1];\n      };\n\n    case '(]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv <= coercedValue[1];\n      };\n\n    case '][':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv >= coercedValue[1];\n      };\n\n    case ')(':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv > coercedValue[1];\n      };\n\n    case '](':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv > coercedValue[1];\n      };\n\n    case ')[':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv >= coercedValue[1];\n      };\n\n    case '{}':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) !== -1;\n      };\n\n    case '}{':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) === -1;\n      };\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/transforms/filter.js"],"names":["Lib","require","Registry","Axes","pointsAccessorFunction","filterOps","COMPARISON_OPS","INTERVAL_OPS","SET_OPS","exports","moduleType","name","attributes","enabled","valType","dflt","editType","description","join","target","strict","noBlank","arrayOk","operation","values","concat","value","preservegaps","supplyDefaults","transformIn","transformOut","coerce","attr","isArrayOrTypedArray","length","handleCalendarDefaults","getComponentMethod","calcTransform","gd","trace","opts","targetArray","getTargetArray","len","_length","Math","min","targetCalendar","targetcalendar","arrayAttrs","_arrayAttrs","attrTargetCalendar","nestedProperty","get","d2c","getDataToCoordFunc","filterFunc","getFilterFunc","originalArrays","indexToPoints","index","forAllAttrs","fn","j","np","initFn","fillFn","astr","extendDeep","set","Array","val","push","originalPointsAccessor","transforms","i","passed","_indexToPoints","hasArrayValue","isArray","isOperationIn","array","indexOf","d2cValue","v","valuecalendar","d2cTarget","coercedValue","map","cv"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar filterOps = require('../constants/filter_ops');\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\n\nexports.moduleType = 'transform';\n\nexports.name = 'filter';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        editType: 'calc',\n        description: [\n            'Determines whether this filter transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        editType: 'calc',\n        description: [\n            'Sets the filter target by which the filter is applied.',\n\n            'If a string, `target` is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To filter about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.color* to filter',\n            'about the marker color array.',\n\n            'If an array, `target` is then the data array by which the filter is applied.'\n        ].join(' ')\n    },\n    operation: {\n        valType: 'enumerated',\n        values: []\n            .concat(COMPARISON_OPS)\n            .concat(INTERVAL_OPS)\n            .concat(SET_OPS),\n        dflt: '=',\n        editType: 'calc',\n        description: [\n            'Sets the filter operation.',\n\n            '*=* keeps items equal to `value`',\n            '*!=* keeps items not equal to `value`',\n\n            '*<* keeps items less than `value`',\n            '*<=* keeps items less than or equal to `value`',\n\n            '*>* keeps items greater than `value`',\n            '*>=* keeps items greater than or equal to `value`',\n\n            '*[]* keeps items inside `value[0]` to `value[1]` including both bounds',\n            '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds',\n            '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]',\n            '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]',\n\n            '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds',\n            '*)(* keeps items outside `value[0]` to `value[1]`',\n            '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`',\n            '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`',\n\n            '*{}* keeps items present in a set of values',\n            '*}{* keeps items not present in a set of values'\n        ].join(' ')\n    },\n    value: {\n        valType: 'any',\n        dflt: 0,\n        editType: 'calc',\n        description: [\n            'Sets the value or values by which to filter.',\n\n            'Values are expected to be in the same type as the data linked',\n            'to `target`.',\n\n            'When `operation` is set to one of',\n            'the comparison values (' + COMPARISON_OPS + ')',\n            '`value` is expected to be a number or a string.',\n\n            'When `operation` is set to one of the interval values',\n            '(' + INTERVAL_OPS + ')',\n            '`value` is expected to be 2-item array where the first item',\n            'is the lower bound and the second item is the upper bound.',\n\n            'When `operation`, is set to one of the set values',\n            '(' + SET_OPS + ')',\n            '`value` is expected to be an array with as many items as',\n            'the desired set elements.'\n        ].join(' ')\n    },\n    preservegaps: {\n        valType: 'boolean',\n        dflt: false,\n        editType: 'calc',\n        description: [\n            'Determines whether or not gaps in data arrays produced by the filter operation',\n            'are preserved.',\n            'Setting this to *true* might be useful when plotting a line chart',\n            'with `connectgaps` set to *false*.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        var target = coerce('target');\n\n        if(Lib.isArrayOrTypedArray(target) && target.length === 0) {\n            transformOut.enabled = false;\n            return transformOut;\n        }\n\n        coerce('preservegaps');\n        coerce('operation');\n        coerce('value');\n\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n        handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var targetCalendar = opts.targetcalendar;\n    var arrayAttrs = trace._arrayAttrs;\n    var preservegaps = opts.preservegaps;\n\n    // even if you provide targetcalendar, if target is a string and there\n    // is a calendar attribute matching target it will get used instead.\n    if(typeof target === 'string') {\n        var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n        if(attrTargetCalendar) targetCalendar = attrTargetCalendar;\n    }\n\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n    var originalArrays = {};\n    var indexToPoints = {};\n    var index = 0;\n\n    function forAllAttrs(fn, index) {\n        for(var j = 0; j < arrayAttrs.length; j++) {\n            var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n            fn(np, index);\n        }\n    }\n\n    var initFn;\n    var fillFn;\n    if(preservegaps) {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set(new Array(len));\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get()[index] = val;\n        };\n    } else {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set([]);\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get().push(val);\n        };\n    }\n\n    // copy all original array attribute values, and clear arrays in trace\n    forAllAttrs(initFn);\n\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n    // loop through filter array, fill trace arrays if passed\n    for(var i = 0; i < len; i++) {\n        var passed = filterFunc(targetArray[i]);\n        if(passed) {\n            forAllAttrs(fillFn, i);\n            indexToPoints[index++] = originalPointsAccessor(i);\n        } else if(preservegaps) index++;\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = index;\n};\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n    var operation = opts.operation;\n    var value = opts.value;\n    var hasArrayValue = Array.isArray(value);\n\n    function isOperationIn(array) {\n        return array.indexOf(operation) !== -1;\n    }\n\n    var d2cValue = function(v) { return d2c(v, 0, opts.valuecalendar); };\n    var d2cTarget = function(v) { return d2c(v, 0, targetCalendar); };\n\n    var coercedValue;\n\n    if(isOperationIn(COMPARISON_OPS)) {\n        coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n    } else if(isOperationIn(INTERVAL_OPS)) {\n        coercedValue = hasArrayValue ?\n            [d2cValue(value[0]), d2cValue(value[1])] :\n            [d2cValue(value), d2cValue(value)];\n    } else if(isOperationIn(SET_OPS)) {\n        coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n    }\n\n    switch(operation) {\n        case '=':\n            return function(v) { return d2cTarget(v) === coercedValue; };\n\n        case '!=':\n            return function(v) { return d2cTarget(v) !== coercedValue; };\n\n        case '<':\n            return function(v) { return d2cTarget(v) < coercedValue; };\n\n        case '<=':\n            return function(v) { return d2cTarget(v) <= coercedValue; };\n\n        case '>':\n            return function(v) { return d2cTarget(v) > coercedValue; };\n\n        case '>=':\n            return function(v) { return d2cTarget(v) >= coercedValue; };\n\n        case '[]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '()':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '[)':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '(]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '][':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case ')(':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case '](':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case ')[':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case '{}':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) !== -1;\n            };\n\n        case '}{':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) === -1;\n            };\n    }\n}\n"]},"metadata":{},"sourceType":"script"}