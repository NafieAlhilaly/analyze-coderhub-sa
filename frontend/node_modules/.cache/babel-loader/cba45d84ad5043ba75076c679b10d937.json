{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib'); // The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\n//\n// ** I do not know which \"weird range loops\" the comment above is referring to.\n\n\nmodule.exports = function (pathinfo, operation) {\n  var i, pi0, pi1;\n\n  var op0 = function (arr) {\n    return arr.reverse();\n  };\n\n  var op1 = function (arr) {\n    return arr;\n  };\n\n  switch (operation) {\n    case '=':\n    case '<':\n      return pathinfo;\n\n    case '>':\n      if (pathinfo.length !== 1) {\n        Lib.warn('Contour data invalid for the specified inequality operation.');\n      } // In this case there should be exactly one contour levels in pathinfo.\n      // We flip all of the data. This will draw the contour as closed.\n\n\n      pi0 = pathinfo[0];\n\n      for (i = 0; i < pi0.edgepaths.length; i++) {\n        pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n      }\n\n      for (i = 0; i < pi0.paths.length; i++) {\n        pi0.paths[i] = op0(pi0.paths[i]);\n      }\n\n      for (i = 0; i < pi0.starts.length; i++) {\n        pi0.starts[i] = op0(pi0.starts[i]);\n      }\n\n      return pathinfo;\n\n    case '][':\n      var tmp = op0;\n      op0 = op1;\n      op1 = tmp;\n    // It's a nice rule, except this definitely *is* what's intended here.\n\n    /* eslint-disable: no-fallthrough */\n\n    case '[]':\n      /* eslint-enable: no-fallthrough */\n      if (pathinfo.length !== 2) {\n        Lib.warn('Contour data invalid for the specified inequality range operation.');\n      } // In this case there should be exactly two contour levels in pathinfo.\n      // - We concatenate the info into one pathinfo.\n      // - We must also flip all of the data in the `[]` case.\n      // This will draw the contours as closed.\n\n\n      pi0 = copyPathinfo(pathinfo[0]);\n      pi1 = copyPathinfo(pathinfo[1]);\n\n      for (i = 0; i < pi0.edgepaths.length; i++) {\n        pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n      }\n\n      for (i = 0; i < pi0.paths.length; i++) {\n        pi0.paths[i] = op0(pi0.paths[i]);\n      }\n\n      for (i = 0; i < pi0.starts.length; i++) {\n        pi0.starts[i] = op0(pi0.starts[i]);\n      }\n\n      while (pi1.edgepaths.length) {\n        pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n      }\n\n      while (pi1.paths.length) {\n        pi0.paths.push(op1(pi1.paths.shift()));\n      }\n\n      while (pi1.starts.length) {\n        pi0.starts.push(op1(pi1.starts.shift()));\n      }\n\n      return [pi0];\n  }\n};\n\nfunction copyPathinfo(pi) {\n  return Lib.extendFlat({}, pi, {\n    edgepaths: Lib.extendDeep([], pi.edgepaths),\n    paths: Lib.extendDeep([], pi.paths),\n    starts: Lib.extendDeep([], pi.starts)\n  });\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/contour/convert_to_constraints.js"],"names":["Lib","require","module","exports","pathinfo","operation","i","pi0","pi1","op0","arr","reverse","op1","length","warn","edgepaths","paths","starts","tmp","copyPathinfo","push","shift","pi","extendFlat","extendDeep"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\n// The contour extraction is great, except it totally fails for constraints because we\n// need weird range loops and flipped contours instead of the usual format. This function\n// does some weird manipulation of the extracted pathinfo data such that it magically\n// draws contours correctly *as* constraints.\n//\n// ** I do not know which \"weird range loops\" the comment above is referring to.\nmodule.exports = function(pathinfo, operation) {\n    var i, pi0, pi1;\n\n    var op0 = function(arr) { return arr.reverse(); };\n    var op1 = function(arr) { return arr; };\n\n    switch(operation) {\n        case '=':\n        case '<':\n            return pathinfo;\n        case '>':\n            if(pathinfo.length !== 1) {\n                Lib.warn('Contour data invalid for the specified inequality operation.');\n            }\n\n            // In this case there should be exactly one contour levels in pathinfo.\n            // We flip all of the data. This will draw the contour as closed.\n            pi0 = pathinfo[0];\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            for(i = 0; i < pi0.starts.length; i++) {\n                pi0.starts[i] = op0(pi0.starts[i]);\n            }\n\n            return pathinfo;\n        case '][':\n            var tmp = op0;\n            op0 = op1;\n            op1 = tmp;\n            // It's a nice rule, except this definitely *is* what's intended here.\n            /* eslint-disable: no-fallthrough */\n        case '[]':\n            /* eslint-enable: no-fallthrough */\n            if(pathinfo.length !== 2) {\n                Lib.warn('Contour data invalid for the specified inequality range operation.');\n            }\n\n            // In this case there should be exactly two contour levels in pathinfo.\n            // - We concatenate the info into one pathinfo.\n            // - We must also flip all of the data in the `[]` case.\n            // This will draw the contours as closed.\n            pi0 = copyPathinfo(pathinfo[0]);\n            pi1 = copyPathinfo(pathinfo[1]);\n\n            for(i = 0; i < pi0.edgepaths.length; i++) {\n                pi0.edgepaths[i] = op0(pi0.edgepaths[i]);\n            }\n            for(i = 0; i < pi0.paths.length; i++) {\n                pi0.paths[i] = op0(pi0.paths[i]);\n            }\n            for(i = 0; i < pi0.starts.length; i++) {\n                pi0.starts[i] = op0(pi0.starts[i]);\n            }\n\n            while(pi1.edgepaths.length) {\n                pi0.edgepaths.push(op1(pi1.edgepaths.shift()));\n            }\n            while(pi1.paths.length) {\n                pi0.paths.push(op1(pi1.paths.shift()));\n            }\n            while(pi1.starts.length) {\n                pi0.starts.push(op1(pi1.starts.shift()));\n            }\n\n            return [pi0];\n    }\n};\n\nfunction copyPathinfo(pi) {\n    return Lib.extendFlat({}, pi, {\n        edgepaths: Lib.extendDeep([], pi.edgepaths),\n        paths: Lib.extendDeep([], pi.paths),\n        starts: Lib.extendDeep([], pi.starts)\n    });\n}\n"]},"metadata":{},"sourceType":"script"}