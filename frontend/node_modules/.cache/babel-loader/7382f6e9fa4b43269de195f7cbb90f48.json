{"ast":null,"code":"'use strict';\n\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\n\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\n  var stackOpts = layout._scatterStackOpts;\n  var stackGroup = coerce('stackgroup');\n\n  if (stackGroup) {\n    // use independent stacking options per subplot\n    var subplot = traceOut.xaxis + traceOut.yaxis;\n    var subplotStackOpts = stackOpts[subplot];\n    if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\n    var groupOpts = subplotStackOpts[stackGroup];\n    var firstTrace = false;\n\n    if (groupOpts) {\n      groupOpts.traces.push(traceOut);\n    } else {\n      groupOpts = subplotStackOpts[stackGroup] = {\n        // keep track of trace indices for use during stacking calculations\n        // this will be filled in during `calc` and used during `crossTraceCalc`\n        // so it's OK if we don't recreate it during a non-calc edit\n        traceIndices: [],\n        // Hold on to the whole set of prior traces\n        // First one is most important, so we can clear defaults\n        // there if we find explicit values only in later traces.\n        // We're only going to *use* the values stored in groupOpts,\n        // but for the editor and validate we want things self-consistent\n        // The full set of traces is used only to fix `fill` default if\n        // we find `orientation: 'h'` beyond the first trace\n        traces: [traceOut]\n      };\n      firstTrace = true;\n    } // TODO: how is this going to work with groupby transforms?\n    // in principle it should be OK I guess, as long as explicit group styles\n    // don't override explicit base-trace styles?\n\n\n    var dflts = {\n      orientation: traceOut.x && !traceOut.y ? 'h' : 'v'\n    };\n\n    for (var i = 0; i < perStackAttrs.length; i++) {\n      var attr = perStackAttrs[i];\n      var attrFound = attr + 'Found';\n\n      if (!groupOpts[attrFound]) {\n        var traceHasAttr = traceIn[attr] !== undefined;\n        var isOrientation = attr === 'orientation';\n\n        if (traceHasAttr || firstTrace) {\n          groupOpts[attr] = coerce(attr, dflts[attr]);\n\n          if (isOrientation) {\n            groupOpts.fillDflt = groupOpts[attr] === 'h' ? 'tonextx' : 'tonexty';\n          }\n\n          if (traceHasAttr) {\n            // Note: this will show a value here even if it's invalid\n            // in which case it will revert to default.\n            groupOpts[attrFound] = true; // Note: only one trace in the stack will get a _fullData\n            // entry for a given stack-wide attribute. If no traces\n            // (or the first trace) specify that attribute, the\n            // first trace will get it. If the first trace does NOT\n            // specify it but some later trace does, then it gets\n            // removed from the first trace and only included in the\n            // one that specified it. This is mostly important for\n            // editors (that want to see the full values to know\n            // what settings are available) and Plotly.react diffing.\n            // Editors may want to use fullLayout._scatterStackOpts\n            // directly and make these settings available from all\n            // traces in the stack... then set the new value into\n            // the first trace, and clear all later traces.\n\n            if (!firstTrace) {\n              delete groupOpts.traces[0][attr]; // orientation can affect default fill of previous traces\n\n              if (isOrientation) {\n                for (var j = 0; j < groupOpts.traces.length - 1; j++) {\n                  var trace2 = groupOpts.traces[j];\n\n                  if (trace2._input.fill !== trace2.fill) {\n                    trace2.fill = groupOpts.fillDflt;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return groupOpts;\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/scatter/stack_defaults.js"],"names":["perStackAttrs","module","exports","handleStackDefaults","traceIn","traceOut","layout","coerce","stackOpts","_scatterStackOpts","stackGroup","subplot","xaxis","yaxis","subplotStackOpts","groupOpts","firstTrace","traces","push","traceIndices","dflts","orientation","x","y","i","length","attr","attrFound","traceHasAttr","undefined","isOrientation","fillDflt","j","trace2","_input","fill"],"mappings":"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","sourcesContent":["'use strict';\n\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\n\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\n    var stackOpts = layout._scatterStackOpts;\n\n    var stackGroup = coerce('stackgroup');\n    if(stackGroup) {\n        // use independent stacking options per subplot\n        var subplot = traceOut.xaxis + traceOut.yaxis;\n        var subplotStackOpts = stackOpts[subplot];\n        if(!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\n\n        var groupOpts = subplotStackOpts[stackGroup];\n        var firstTrace = false;\n        if(groupOpts) {\n            groupOpts.traces.push(traceOut);\n        } else {\n            groupOpts = subplotStackOpts[stackGroup] = {\n                // keep track of trace indices for use during stacking calculations\n                // this will be filled in during `calc` and used during `crossTraceCalc`\n                // so it's OK if we don't recreate it during a non-calc edit\n                traceIndices: [],\n                // Hold on to the whole set of prior traces\n                // First one is most important, so we can clear defaults\n                // there if we find explicit values only in later traces.\n                // We're only going to *use* the values stored in groupOpts,\n                // but for the editor and validate we want things self-consistent\n                // The full set of traces is used only to fix `fill` default if\n                // we find `orientation: 'h'` beyond the first trace\n                traces: [traceOut]\n            };\n            firstTrace = true;\n        }\n        // TODO: how is this going to work with groupby transforms?\n        // in principle it should be OK I guess, as long as explicit group styles\n        // don't override explicit base-trace styles?\n\n        var dflts = {\n            orientation: (traceOut.x && !traceOut.y) ? 'h' : 'v'\n        };\n\n        for(var i = 0; i < perStackAttrs.length; i++) {\n            var attr = perStackAttrs[i];\n            var attrFound = attr + 'Found';\n            if(!groupOpts[attrFound]) {\n                var traceHasAttr = traceIn[attr] !== undefined;\n                var isOrientation = attr === 'orientation';\n                if(traceHasAttr || firstTrace) {\n                    groupOpts[attr] = coerce(attr, dflts[attr]);\n\n                    if(isOrientation) {\n                        groupOpts.fillDflt = groupOpts[attr] === 'h' ?\n                            'tonextx' : 'tonexty';\n                    }\n\n                    if(traceHasAttr) {\n                        // Note: this will show a value here even if it's invalid\n                        // in which case it will revert to default.\n                        groupOpts[attrFound] = true;\n\n                        // Note: only one trace in the stack will get a _fullData\n                        // entry for a given stack-wide attribute. If no traces\n                        // (or the first trace) specify that attribute, the\n                        // first trace will get it. If the first trace does NOT\n                        // specify it but some later trace does, then it gets\n                        // removed from the first trace and only included in the\n                        // one that specified it. This is mostly important for\n                        // editors (that want to see the full values to know\n                        // what settings are available) and Plotly.react diffing.\n                        // Editors may want to use fullLayout._scatterStackOpts\n                        // directly and make these settings available from all\n                        // traces in the stack... then set the new value into\n                        // the first trace, and clear all later traces.\n                        if(!firstTrace) {\n                            delete groupOpts.traces[0][attr];\n\n                            // orientation can affect default fill of previous traces\n                            if(isOrientation) {\n                                for(var j = 0; j < groupOpts.traces.length - 1; j++) {\n                                    var trace2 = groupOpts.traces[j];\n                                    if(trace2._input.fill !== trace2.fill) {\n                                        trace2.fill = groupOpts.fillDflt;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return groupOpts;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}