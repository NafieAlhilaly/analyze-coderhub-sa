{"ast":null,"code":"'use strict';\n\nvar createUniformWrapper = require('./lib/create-uniforms');\n\nvar createAttributeWrapper = require('./lib/create-attributes');\n\nvar makeReflect = require('./lib/reflect');\n\nvar shaderCache = require('./lib/shader-cache');\n\nvar runtime = require('./lib/runtime-reflect');\n\nvar GLError = require(\"./lib/GLError\"); //Shader object\n\n\nfunction Shader(gl) {\n  this.gl = gl;\n  this.gl.lastAttribCount = 0; // fixme where else should we store info, safe but not nice on the gl object\n  //Default initialize these to null\n\n  this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;\n}\n\nvar proto = Shader.prototype;\n\nproto.bind = function () {\n  if (!this.program) {\n    this._relink();\n  } // ensuring that we have the right number of enabled vertex attributes\n\n\n  var i;\n  var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES); // more robust approach\n  //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown\n\n  var oldAttribCount = this.gl.lastAttribCount;\n\n  if (newAttribCount > oldAttribCount) {\n    for (i = oldAttribCount; i < newAttribCount; i++) {\n      this.gl.enableVertexAttribArray(i);\n    }\n  } else if (oldAttribCount > newAttribCount) {\n    for (i = newAttribCount; i < oldAttribCount; i++) {\n      this.gl.disableVertexAttribArray(i);\n    }\n  }\n\n  this.gl.lastAttribCount = newAttribCount;\n  this.gl.useProgram(this.program);\n};\n\nproto.dispose = function () {\n  // disabling vertex attributes so new shader starts with zero\n  // and it's also useful if all shaders are disposed but the\n  // gl context is reused for subsequent replotting\n  var oldAttribCount = this.gl.lastAttribCount;\n\n  for (var i = 0; i < oldAttribCount; i++) {\n    this.gl.disableVertexAttribArray(i);\n  }\n\n  this.gl.lastAttribCount = 0;\n\n  if (this._fref) {\n    this._fref.dispose();\n  }\n\n  if (this._vref) {\n    this._vref.dispose();\n  }\n\n  this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;\n};\n\nfunction compareAttributes(a, b) {\n  if (a.name < b.name) {\n    return -1;\n  }\n\n  return 1;\n} //Update export hook for glslify-live\n\n\nproto.update = function (vertSource, fragSource, uniforms, attributes) {\n  //If only one object passed, assume glslify style output\n  if (!fragSource || arguments.length === 1) {\n    var obj = vertSource;\n    vertSource = obj.vertex;\n    fragSource = obj.fragment;\n    uniforms = obj.uniforms;\n    attributes = obj.attributes;\n  }\n\n  var wrapper = this;\n  var gl = wrapper.gl; //Compile vertex and fragment shaders\n\n  var pvref = wrapper._vref;\n  wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource);\n\n  if (pvref) {\n    pvref.dispose();\n  }\n\n  wrapper.vertShader = wrapper._vref.shader;\n  var pfref = this._fref;\n  wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource);\n\n  if (pfref) {\n    pfref.dispose();\n  }\n\n  wrapper.fragShader = wrapper._fref.shader; //If uniforms/attributes is not specified, use RT reflection\n\n  if (!uniforms || !attributes) {\n    //Create initial test program\n    var testProgram = gl.createProgram();\n    gl.attachShader(testProgram, wrapper.fragShader);\n    gl.attachShader(testProgram, wrapper.vertShader);\n    gl.linkProgram(testProgram);\n\n    if (!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {\n      var errLog = gl.getProgramInfoLog(testProgram);\n      throw new GLError(errLog, 'Error linking program:' + errLog);\n    } //Load data from runtime\n\n\n    uniforms = uniforms || runtime.uniforms(gl, testProgram);\n    attributes = attributes || runtime.attributes(gl, testProgram); //Release test program\n\n    gl.deleteProgram(testProgram);\n  } //Sort attributes lexicographically\n  // overrides undefined WebGL behavior for attribute locations\n\n\n  attributes = attributes.slice();\n  attributes.sort(compareAttributes); //Convert attribute types, read out locations\n\n  var attributeUnpacked = [];\n  var attributeNames = [];\n  var attributeLocations = [];\n  var i;\n\n  for (i = 0; i < attributes.length; ++i) {\n    var attr = attributes[i];\n\n    if (attr.type.indexOf('mat') >= 0) {\n      var size = attr.type.charAt(attr.type.length - 1) | 0;\n      var locVector = new Array(size);\n\n      for (var j = 0; j < size; ++j) {\n        locVector[j] = attributeLocations.length;\n        attributeNames.push(attr.name + '[' + j + ']');\n\n        if (typeof attr.location === 'number') {\n          attributeLocations.push(attr.location + j);\n        } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === 'number') {\n          attributeLocations.push(attr.location[j] | 0);\n        } else {\n          attributeLocations.push(-1);\n        }\n      }\n\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: locVector\n      });\n    } else {\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: [attributeLocations.length]\n      });\n      attributeNames.push(attr.name);\n\n      if (typeof attr.location === 'number') {\n        attributeLocations.push(attr.location | 0);\n      } else {\n        attributeLocations.push(-1);\n      }\n    }\n  } //For all unspecified attributes, assign them lexicographically min attribute\n\n\n  var curLocation = 0;\n\n  for (i = 0; i < attributeLocations.length; ++i) {\n    if (attributeLocations[i] < 0) {\n      while (attributeLocations.indexOf(curLocation) >= 0) {\n        curLocation += 1;\n      }\n\n      attributeLocations[i] = curLocation;\n    }\n  } //Rebuild program and recompute all uniform locations\n\n\n  var uniformLocations = new Array(uniforms.length);\n\n  function relink() {\n    wrapper.program = shaderCache.program(gl, wrapper._vref, wrapper._fref, attributeNames, attributeLocations);\n\n    for (var i = 0; i < uniforms.length; ++i) {\n      uniformLocations[i] = gl.getUniformLocation(wrapper.program, uniforms[i].name);\n    }\n  } //Perform initial linking, reuse program used for reflection\n\n\n  relink(); //Save relinking procedure, defer until runtime\n\n  wrapper._relink = relink; //Generate type info\n\n  wrapper.types = {\n    uniforms: makeReflect(uniforms),\n    attributes: makeReflect(attributes)\n  }; //Generate attribute wrappers\n\n  wrapper.attributes = createAttributeWrapper(gl, wrapper, attributeUnpacked, attributeLocations); //Generate uniform wrappers\n\n  Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(gl, wrapper, uniforms, uniformLocations));\n}; //Compiles and links a shader program with the given attribute and vertex list\n\n\nfunction createShader(gl, vertSource, fragSource, uniforms, attributes) {\n  var shader = new Shader(gl);\n  shader.update(vertSource, fragSource, uniforms, attributes);\n  return shader;\n}\n\nmodule.exports = createShader;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/gl-shader/index.js"],"names":["createUniformWrapper","require","createAttributeWrapper","makeReflect","shaderCache","runtime","GLError","Shader","gl","lastAttribCount","_vref","_fref","_relink","vertShader","fragShader","program","attributes","uniforms","types","proto","prototype","bind","i","newAttribCount","getProgramParameter","ACTIVE_ATTRIBUTES","oldAttribCount","enableVertexAttribArray","disableVertexAttribArray","useProgram","dispose","compareAttributes","a","b","name","update","vertSource","fragSource","arguments","length","obj","vertex","fragment","wrapper","pvref","shader","VERTEX_SHADER","pfref","FRAGMENT_SHADER","testProgram","createProgram","attachShader","linkProgram","LINK_STATUS","errLog","getProgramInfoLog","deleteProgram","slice","sort","attributeUnpacked","attributeNames","attributeLocations","attr","type","indexOf","size","charAt","locVector","Array","j","push","location","isArray","locations","curLocation","uniformLocations","relink","getUniformLocation","Object","defineProperty","createShader","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar createUniformWrapper   = require('./lib/create-uniforms')\nvar createAttributeWrapper = require('./lib/create-attributes')\nvar makeReflect            = require('./lib/reflect')\nvar shaderCache            = require('./lib/shader-cache')\nvar runtime                = require('./lib/runtime-reflect')\nvar GLError                = require(\"./lib/GLError\")\n\n//Shader object\nfunction Shader(gl) {\n  this.gl         = gl\n  this.gl.lastAttribCount = 0  // fixme where else should we store info, safe but not nice on the gl object\n\n  //Default initialize these to null\n  this._vref      =\n  this._fref      =\n  this._relink    =\n  this.vertShader =\n  this.fragShader =\n  this.program    =\n  this.attributes =\n  this.uniforms   =\n  this.types      = null\n}\n\nvar proto = Shader.prototype\n\nproto.bind = function() {\n  if(!this.program) {\n    this._relink()\n  }\n\n  // ensuring that we have the right number of enabled vertex attributes\n  var i\n  var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES) // more robust approach\n  //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown\n  var oldAttribCount = this.gl.lastAttribCount\n  if(newAttribCount > oldAttribCount) {\n    for(i = oldAttribCount; i < newAttribCount; i++) {\n      this.gl.enableVertexAttribArray(i)\n    }\n  } else if(oldAttribCount > newAttribCount) {\n    for(i = newAttribCount; i < oldAttribCount; i++) {\n      this.gl.disableVertexAttribArray(i)\n    }\n  }\n\n  this.gl.lastAttribCount = newAttribCount\n\n  this.gl.useProgram(this.program)\n}\n\nproto.dispose = function() {\n\n  // disabling vertex attributes so new shader starts with zero\n  // and it's also useful if all shaders are disposed but the\n  // gl context is reused for subsequent replotting\n  var oldAttribCount = this.gl.lastAttribCount\n  for (var i = 0; i < oldAttribCount; i++) {\n    this.gl.disableVertexAttribArray(i)\n  }\n  this.gl.lastAttribCount = 0\n\n  if(this._fref) {\n    this._fref.dispose()\n  }\n  if(this._vref) {\n    this._vref.dispose()\n  }\n  this.attributes =\n  this.types      =\n  this.vertShader =\n  this.fragShader =\n  this.program    =\n  this._relink    =\n  this._fref      =\n  this._vref      = null\n}\n\nfunction compareAttributes(a, b) {\n  if(a.name < b.name) {\n    return -1\n  }\n  return 1\n}\n\n//Update export hook for glslify-live\nproto.update = function(\n    vertSource\n  , fragSource\n  , uniforms\n  , attributes) {\n\n  //If only one object passed, assume glslify style output\n  if(!fragSource || arguments.length === 1) {\n    var obj = vertSource\n    vertSource = obj.vertex\n    fragSource = obj.fragment\n    uniforms   = obj.uniforms\n    attributes = obj.attributes\n  }\n\n  var wrapper = this\n  var gl      = wrapper.gl\n\n  //Compile vertex and fragment shaders\n  var pvref = wrapper._vref\n  wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource)\n  if(pvref) {\n    pvref.dispose()\n  }\n  wrapper.vertShader = wrapper._vref.shader\n  var pfref = this._fref\n  wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource)\n  if(pfref) {\n    pfref.dispose()\n  }\n  wrapper.fragShader = wrapper._fref.shader\n\n  //If uniforms/attributes is not specified, use RT reflection\n  if(!uniforms || !attributes) {\n\n    //Create initial test program\n    var testProgram = gl.createProgram()\n    gl.attachShader(testProgram, wrapper.fragShader)\n    gl.attachShader(testProgram, wrapper.vertShader)\n    gl.linkProgram(testProgram)\n    if(!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {\n      var errLog = gl.getProgramInfoLog(testProgram)\n      throw new GLError(errLog, 'Error linking program:' + errLog)\n    }\n\n    //Load data from runtime\n    uniforms   = uniforms   || runtime.uniforms(gl, testProgram)\n    attributes = attributes || runtime.attributes(gl, testProgram)\n\n    //Release test program\n    gl.deleteProgram(testProgram)\n  }\n\n  //Sort attributes lexicographically\n  // overrides undefined WebGL behavior for attribute locations\n  attributes = attributes.slice()\n  attributes.sort(compareAttributes)\n\n  //Convert attribute types, read out locations\n  var attributeUnpacked  = []\n  var attributeNames     = []\n  var attributeLocations = []\n  var i\n  for(i=0; i<attributes.length; ++i) {\n    var attr = attributes[i]\n    if(attr.type.indexOf('mat') >= 0) {\n      var size = attr.type.charAt(attr.type.length-1)|0\n      var locVector = new Array(size)\n      for(var j=0; j<size; ++j) {\n        locVector[j] = attributeLocations.length\n        attributeNames.push(attr.name + '[' + j + ']')\n        if(typeof attr.location === 'number') {\n          attributeLocations.push(attr.location + j)\n        } else if(Array.isArray(attr.location) &&\n                  attr.location.length === size &&\n                  typeof attr.location[j] === 'number') {\n          attributeLocations.push(attr.location[j]|0)\n        } else {\n          attributeLocations.push(-1)\n        }\n      }\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: locVector\n      })\n    } else {\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: [ attributeLocations.length ]\n      })\n      attributeNames.push(attr.name)\n      if(typeof attr.location === 'number') {\n        attributeLocations.push(attr.location|0)\n      } else {\n        attributeLocations.push(-1)\n      }\n    }\n  }\n\n  //For all unspecified attributes, assign them lexicographically min attribute\n  var curLocation = 0\n  for(i=0; i<attributeLocations.length; ++i) {\n    if(attributeLocations[i] < 0) {\n      while(attributeLocations.indexOf(curLocation) >= 0) {\n        curLocation += 1\n      }\n      attributeLocations[i] = curLocation\n    }\n  }\n\n  //Rebuild program and recompute all uniform locations\n  var uniformLocations = new Array(uniforms.length)\n  function relink() {\n    wrapper.program = shaderCache.program(\n        gl\n      , wrapper._vref\n      , wrapper._fref\n      , attributeNames\n      , attributeLocations)\n\n    for(var i=0; i<uniforms.length; ++i) {\n      uniformLocations[i] = gl.getUniformLocation(\n          wrapper.program\n        , uniforms[i].name)\n    }\n  }\n\n  //Perform initial linking, reuse program used for reflection\n  relink()\n\n  //Save relinking procedure, defer until runtime\n  wrapper._relink = relink\n\n  //Generate type info\n  wrapper.types = {\n    uniforms:   makeReflect(uniforms),\n    attributes: makeReflect(attributes)\n  }\n\n  //Generate attribute wrappers\n  wrapper.attributes = createAttributeWrapper(\n      gl\n    , wrapper\n    , attributeUnpacked\n    , attributeLocations)\n\n  //Generate uniform wrappers\n  Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(\n      gl\n    , wrapper\n    , uniforms\n    , uniformLocations))\n}\n\n//Compiles and links a shader program with the given attribute and vertex list\nfunction createShader(\n    gl\n  , vertSource\n  , fragSource\n  , uniforms\n  , attributes) {\n\n  var shader = new Shader(gl)\n\n  shader.update(\n      vertSource\n    , fragSource\n    , uniforms\n    , attributes)\n\n  return shader\n}\n\nmodule.exports = createShader\n"]},"metadata":{},"sourceType":"script"}