{"ast":null,"code":"'use strict';\n\nmodule.exports = createSurfacePlot;\n\nvar bits = require('bit-twiddle');\n\nvar createBuffer = require('gl-buffer');\n\nvar createVAO = require('gl-vao');\n\nvar createTexture = require('gl-texture2d');\n\nvar pool = require('typedarray-pool');\n\nvar colormap = require('colormap');\n\nvar ops = require('ndarray-ops');\n\nvar pack = require('ndarray-pack');\n\nvar ndarray = require('ndarray');\n\nvar surfaceNets = require('surface-nets');\n\nvar multiply = require('gl-mat4/multiply');\n\nvar invert = require('gl-mat4/invert');\n\nvar bsearch = require('binary-search-bounds');\n\nvar gradient = require('ndarray-gradient');\n\nvar shaders = require('./lib/shaders');\n\nvar createShader = shaders.createShader;\nvar createContourShader = shaders.createContourShader;\nvar createPickShader = shaders.createPickShader;\nvar createPickContourShader = shaders.createPickContourShader;\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar QUAD = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 0], [0, 1]];\nvar PERMUTATIONS = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\n(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i];\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    p[u + 0] = 1;\n    p[v + 3] = 1;\n    p[i + 6] = 1;\n  }\n})();\n\nfunction SurfacePickResult(position, index, uv, level, dataCoordinate) {\n  this.position = position;\n  this.index = index;\n  this.uv = uv;\n  this.level = level;\n  this.dataCoordinate = dataCoordinate;\n}\n\nvar N_COLORS = 256;\n\nfunction SurfacePlot(gl, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {\n  this.gl = gl;\n  this.shape = shape;\n  this.bounds = bounds;\n  this.objectOffset = objectOffset;\n  this.intensityBounds = [];\n  this._shader = shader;\n  this._pickShader = pickShader;\n  this._coordinateBuffer = coordinates;\n  this._vao = vao;\n  this._colorMap = colorMap;\n  this._contourShader = contourShader;\n  this._contourPickShader = contourPickShader;\n  this._contourBuffer = contourBuffer;\n  this._contourVAO = contourVAO;\n  this._contourOffsets = [[], [], []];\n  this._contourCounts = [[], [], []];\n  this._vertexCount = 0;\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);\n  this._dynamicBuffer = dynamicBuffer;\n  this._dynamicVAO = dynamicVAO;\n  this._dynamicOffsets = [0, 0, 0];\n  this._dynamicCounts = [0, 0, 0];\n  this.contourWidth = [1, 1, 1];\n  this.contourLevels = [[1], [1], [1]];\n  this.contourTint = [0, 0, 0];\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];\n  this.showContour = true;\n  this.showSurface = true;\n  this.enableHighlight = [true, true, true];\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.highlightTint = [1, 1, 1];\n  this.highlightLevel = [-1, -1, -1]; // Dynamic contour options\n\n  this.enableDynamic = [true, true, true];\n  this.dynamicLevel = [NaN, NaN, NaN];\n  this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.dynamicTint = [1, 1, 1];\n  this.dynamicWidth = [1, 1, 1];\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.surfaceProject = [false, false, false];\n  this.contourProject = [[false, false, false], [false, false, false], [false, false, false]];\n  this.colorBounds = [false, false]; // Store xyz fields, need this for picking\n\n  this._field = [ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0])];\n  this.pickId = 1;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.snapToData = false;\n  this.pixelRatio = 1;\n  this.opacity = 1.0;\n  this.lightPosition = [10, 10000, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.vertexColor = 0;\n  this.dirty = true;\n}\n\nvar proto = SurfacePlot.prototype;\n\nproto.genColormap = function (name, opacityscale) {\n  var hasAlpha = false;\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : c[3];\n    if (a < 1) hasAlpha = true;\n    return [c[0], c[1], c[2], 255 * a];\n  })]);\n  ops.divseq(x, 255.0);\n  this.hasAlphaScale = hasAlpha;\n  return x;\n};\n\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.hasAlphaScale;\n};\n\nproto.isOpaque = function () {\n  return !this.isTransparent();\n};\n\nproto.pickSlots = 1;\n\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\n\nfunction getOpacityFromScale(ratio, opacityscale) {\n  // copied form gl-mesh3d\n  if (!opacityscale) return 1;\n  if (!opacityscale.length) return 1;\n\n  for (var i = 0; i < opacityscale.length; ++i) {\n    if (opacityscale.length < 2) return 1;\n    if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n\n    if (opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n    }\n  }\n\n  return 1;\n}\n\nvar ZERO_VEC = [0, 0, 0];\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [[[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]]\n};\n\nfunction computeProjectionData(camera, obj) {\n  var i, j, k; // Compute cube properties\n\n  var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;\n  var showSurface = obj.showSurface;\n  var showContour = obj.showContour;\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i];\n\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j];\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i];\n\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0;\n    }\n\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1;\n    }\n\n    axisSquish[5 * i] = 0;\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];\n    multiply(axisSquish, camera.model, axisSquish);\n    var nclipBounds = PROJECT_DATA.clipBounds[i];\n\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j];\n      }\n    }\n\n    nclipBounds[0][i] = -1e8;\n    nclipBounds[1][i] = 1e8;\n  }\n\n  PROJECT_DATA.showSurface = showSurface;\n  PROJECT_DATA.showContour = showContour;\n  return PROJECT_DATA;\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n};\nvar MATRIX_INVERSE = IDENTITY.slice();\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\nfunction drawCore(params, transparent) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n\n  this._colorMap.bind(0);\n\n  var uniforms = UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.contourColor = this.contourColor[0];\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  uniforms.kambient = this.ambientLight;\n  uniforms.kdiffuse = this.diffuseLight;\n  uniforms.kspecular = this.specularLight;\n  uniforms.roughness = this.roughness;\n  uniforms.fresnel = this.fresnel;\n  uniforms.opacity = this.opacity;\n  uniforms.height = 0.0;\n  uniforms.permutation = DEFAULT_PERM;\n  uniforms.vertexColor = this.vertexColor; // Compute camera matrix inverse\n\n  var invCameraMatrix = MATRIX_INVERSE;\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n\n  var w = invCameraMatrix[15];\n\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n\n    uniforms.lightPosition[i] = s / w;\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._shader.bind();\n\n    this._shader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue;\n      }\n\n      this._shader.uniforms.model = projectData.projections[i];\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourShader; // Don't apply lighting to contours\n\n    uniforms.kambient = 1.0;\n    uniforms.kdiffuse = 0.0;\n    uniforms.kspecular = 0.0;\n    uniforms.opacity = 1.0;\n    shader.bind();\n    shader.uniforms = uniforms; // Draw contour lines\n\n    var vao = this._contourVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio);\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i];\n          shader.uniforms.contourTint = this.highlightTint[i];\n        } else if (j === 0 || j - 1 === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i];\n          shader.uniforms.contourTint = this.contourTint[i];\n        }\n\n        if (!this._contourCounts[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j];\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j];\n            shader.uniforms.contourTint = this.highlightTint[j];\n          } else if (k === 0 || k - 1 === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j];\n            shader.uniforms.contourTint = this.contourTint[j];\n          }\n\n          if (!this._contourCounts[j][k]) {\n            continue;\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k];\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n        }\n      }\n    }\n\n    vao.unbind(); // Draw dynamic contours\n\n    vao = this._dynamicVAO;\n    vao.bind(); // Draw contour levels\n\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue;\n      }\n\n      shader.uniforms.model = uniforms.model;\n      shader.uniforms.clipBounds = uniforms.clipBounds;\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio);\n      shader.uniforms.contourColor = this.dynamicColor[i];\n      shader.uniforms.contourTint = this.dynamicTint[i];\n      shader.uniforms.height = this.dynamicLevel[i];\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue;\n        }\n\n        shader.uniforms.model = projectData.projections[j];\n        shader.uniforms.clipBounds = projectData.clipBounds[j];\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n      }\n    }\n\n    vao.unbind();\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false);\n};\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true);\n};\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n};\n\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n  var uniforms = PICK_UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.shape = this._field[2].shape;\n  uniforms.pickId = this.pickId / 255.0;\n  uniforms.lowerBound = this.bounds[0];\n  uniforms.upperBound = this.bounds[1];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.permutation = DEFAULT_PERM;\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this);\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind();\n\n    this._pickShader.uniforms = uniforms; // Draw it\n\n    this._vao.bind();\n\n    this._vao.draw(gl.TRIANGLES, this._vertexCount); // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue;\n      }\n\n      this._pickShader.uniforms.model = projectData.projections[i];\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    this._vao.unbind();\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    var vao = this._contourVAO;\n    vao.bind();\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n      shader.uniforms.permutation = PERMUTATIONS[j];\n\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i];\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);\n        }\n      }\n    } // Draw projections of surface\n\n\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k];\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n          }\n        }\n      }\n    }\n\n    vao.unbind();\n  }\n};\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null;\n  }\n\n  if (selection.id !== this.pickId) {\n    return null;\n  }\n\n  var shape = this._field[2].shape;\n  var result = this._pickResult; // Compute uv coordinate\n\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0;\n  var ix = Math.floor(x);\n  var fx = x - ix;\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0;\n  var iy = Math.floor(y);\n  var fy = y - iy;\n  ix += 1;\n  iy += 1; // Compute xyz coordinate\n\n  var pos = result.position;\n  pos[0] = pos[1] = pos[2] = 0;\n\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx;\n\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy;\n      var r = ix + dx;\n      var c = iy + dy;\n      var w = s * t;\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w;\n      }\n    }\n  } // Find closest level\n\n\n  var levelIndex = this._pickResult.level;\n\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);\n\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0;\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]];\n      var b = this.contourLevels[j][levelIndex[j] + 1];\n\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1;\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : ix + 1;\n  result.index[1] = fy < 0.5 ? iy : iy + 1;\n  result.uv[0] = x / shape[0];\n  result.uv[1] = y / shape[1];\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);\n  }\n\n  return result;\n};\n\nproto.padField = function (dstField, srcField) {\n  var srcShape = srcField.shape.slice();\n  var dstShape = dstField.shape.slice(); // Center\n\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField); // Edges\n\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1), srcField.hi(srcShape[0], 1));\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1), srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1));\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]), srcField.hi(1));\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]), srcField.lo(srcShape[0] - 1)); // Corners\n\n  dstField.set(0, 0, srcField.get(0, 0));\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));\n};\n\nfunction handleArray(param, ctor) {\n  if (Array.isArray(param)) {\n    return [ctor(param[0]), ctor(param[1]), ctor(param[2])];\n  }\n\n  return [ctor(param), ctor(param), ctor(param)];\n}\n\nfunction toColor(x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1];\n    }\n\n    return [x[0], x[1], x[2], x[3]];\n  }\n\n  return [0, 0, 0, 1];\n}\n\nfunction handleColor(param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [toColor(param[0]), toColor(param[1]), toColor(param[2])];\n    } else {\n      var c = toColor(param);\n      return [c.slice(), c.slice(), c.slice()];\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {};\n  this.objectOffset = params.objectOffset || this.objectOffset;\n  this.dirty = true;\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number);\n  }\n\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean);\n  }\n\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface;\n  }\n\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean);\n  }\n\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor);\n  }\n\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean);\n    });\n  }\n\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject;\n  }\n\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor);\n  }\n\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number);\n  }\n\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number);\n  }\n\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n  }\n\n  if ('opacityscale' in params) {\n    this.opacityscale = params.opacityscale;\n  }\n\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds;\n  }\n\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n\n  if ('colormap' in params) {\n    this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale));\n  }\n\n  var field = params.field || params.coords && params.coords[2] || null;\n  var levelsChanged = false;\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);\n    } else {\n      field = this._field[2].hi(0, 0);\n    }\n  } // Update field\n\n\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2); // Resize if necessary\n\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data);\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));\n    } // Pad field\n\n\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);\n    this.padField(this._field[2], field); // Save shape of field\n\n    this.shape = field.shape.slice();\n    var shape = this.shape; // Resize coordinate fields if necessary\n\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data);\n        this._field[i].data = pool.mallocFloat(this._field[2].size);\n      }\n\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);\n    } // Generate x/y coordinates\n\n\n    if (params.coords) {\n      var coords = params.coords;\n\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i];\n\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape');\n          }\n        }\n\n        this.padField(this._field[i], coord);\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks;\n\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks');\n      }\n\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i];\n\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick);\n        }\n\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length');\n        } // Make a copy view of the tick array\n\n\n        var tick2 = ndarray(tick.data, shape);\n        tick2.stride[i] = tick.stride[0];\n        tick2.stride[i ^ 1] = 0; // Fill in field array\n\n        this.padField(this._field[i], tick2);\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0];\n        offset[i] = 1;\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);\n      }\n\n      this._field[0].set(0, 0, 0);\n\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j);\n      }\n\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1);\n\n      this._field[1].set(0, 0, 0);\n\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j);\n      }\n\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1);\n    } // Save shape\n\n\n    var fields = this._field; // Compute surface normals\n\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);\n\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror');\n    }\n\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);\n\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0);\n        var dxdv = dfields.get(0, i, j, 1);\n        var dydu = dfields.get(1, i, j, 0);\n        var dydv = dfields.get(1, i, j, 1);\n        var dzdu = dfields.get(2, i, j, 0);\n        var dzdv = dfields.get(2, i, j, 1);\n        var nx = dydu * dzdv - dydv * dzdu;\n        var ny = dzdu * dxdv - dzdv * dxdu;\n        var nz = dxdu * dydv - dxdv * dydu;\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));\n\n          if (nl < 1e-8) {\n            nz = 1.0;\n            ny = nx = 0.0;\n            nl = 1.0;\n          } else {\n            nl = 1.0 / nl;\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl);\n        }\n\n        normals.set(i, j, 0, nx * nl);\n        normals.set(i, j, 1, ny * nl);\n        normals.set(i, j, 2, nz * nl);\n      }\n    }\n\n    pool.free(dfields.data); // Initialize surface\n\n    var lo = [Infinity, Infinity, Infinity];\n    var hi = [-Infinity, -Infinity, -Infinity];\n    var lo_intensity = Infinity;\n    var hi_intensity = -Infinity;\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6;\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count));\n    var tptr = 0;\n    var vertexCount = 0;\n\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop: for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy);\n\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop;\n              }\n            }\n          }\n        }\n\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0];\n          var c = j + QUAD[k][1];\n\n          var tx = this._field[0].get(r + 1, c + 1);\n\n          var ty = this._field[1].get(r + 1, c + 1);\n\n          f = this._field[2].get(r + 1, c + 1);\n          nx = normals.get(r + 1, c + 1, 0);\n          ny = normals.get(r + 1, c + 1, 1);\n          nz = normals.get(r + 1, c + 1, 2);\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c);\n          }\n\n          var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];\n          tverts[tptr++] = r;\n          tverts[tptr++] = c;\n          tverts[tptr++] = tx;\n          tverts[tptr++] = ty;\n          tverts[tptr++] = f;\n          tverts[tptr++] = 0;\n          tverts[tptr++] = vf;\n          tverts[tptr++] = nx;\n          tverts[tptr++] = ny;\n          tverts[tptr++] = nz;\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);\n          lo[2] = Math.min(lo[2], f + this.objectOffset[2]);\n          lo_intensity = Math.min(lo_intensity, vf);\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);\n          hi[2] = Math.max(hi[2], f + this.objectOffset[2]);\n          hi_intensity = Math.max(hi_intensity, vf);\n          vertexCount += 1;\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0];\n      hi_intensity = +params.intensityBounds[1];\n    } // Scale all vertex intensities\n\n\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);\n    }\n\n    this._vertexCount = vertexCount;\n\n    this._coordinateBuffer.update(tverts.subarray(0, tptr));\n\n    pool.freeFloat(tverts);\n    pool.free(normals.data); // Update bounds\n\n    this.bounds = [lo, hi]; // Save intensity\n\n    this.intensity = params.intensity || this._field[2];\n\n    if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n      levelsChanged = true;\n    } // Save intensity bound\n\n\n    this.intensityBounds = [lo_intensity, hi_intensity];\n  } // Update level crossings\n\n\n  if ('levels' in params) {\n    var levels = params.levels;\n\n    if (!Array.isArray(levels[0])) {\n      levels = [[], [], levels];\n    } else {\n      levels = levels.slice();\n    }\n\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice();\n      levels[i].sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i];\n      }\n    }\n\n    change_test: for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true;\n        break;\n      }\n\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true;\n          break change_test;\n        }\n      }\n    }\n\n    this.contourLevels = levels;\n  }\n\n  if (levelsChanged) {\n    fields = this._field;\n    shape = this.shape; // Update contour lines\n\n    var contourVerts = [];\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim];\n      var levelOffsets = [];\n      var levelCounts = [];\n      var parts = [0, 0, 0];\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i]);\n        levelOffsets.push(contourVerts.length / 5 | 0);\n        vertexCount = 0;\n\n        edge_loop: for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j];\n\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]];\n            var x = p[0];\n            var ix = Math.floor(x) | 0;\n            var fx = x - ix;\n            var y = p[1];\n            var iy = Math.floor(y) | 0;\n            var fy = y - iy;\n            var hole = false;\n\n            axis_loop: for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0;\n              var iu = (dim + axis + 1) % 3;\n\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx;\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;\n\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy;\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c);\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);\n                  }\n\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true;\n                    break axis_loop;\n                  }\n\n                  var w = s * t;\n                  parts[axis] += w * f;\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2]);\n              vertexCount += 1;\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop();\n                }\n\n                vertexCount -= 1;\n              }\n\n              continue edge_loop;\n            }\n          }\n        }\n\n        levelCounts.push(vertexCount);\n      } // Store results\n\n\n      this._contourOffsets[dim] = levelOffsets;\n      this._contourCounts[dim] = levelCounts;\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length);\n\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i];\n    }\n\n    this._contourBuffer.update(floatBuffer);\n\n    pool.freeFloat(floatBuffer);\n  }\n};\n\nproto.dispose = function () {\n  this._shader.dispose();\n\n  this._vao.dispose();\n\n  this._coordinateBuffer.dispose();\n\n  this._colorMap.dispose();\n\n  this._contourBuffer.dispose();\n\n  this._contourVAO.dispose();\n\n  this._contourShader.dispose();\n\n  this._contourPickShader.dispose();\n\n  this._dynamicBuffer.dispose();\n\n  this._dynamicVAO.dispose();\n\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data);\n  }\n};\n\nproto.highlight = function (selection) {\n  var i;\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0];\n    this.dyanamicLevel = [NaN, NaN, NaN];\n    this.highlightLevel = [-1, -1, -1];\n    return;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i];\n    } else {\n      this.highlightLevel[i] = -1;\n    }\n  }\n\n  var levels;\n\n  if (this.snapToData) {\n    levels = selection.dataCoordinate;\n  } else {\n    levels = selection.position;\n  }\n\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i];\n  }\n\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return;\n  }\n\n  var vertexCount = 0;\n  var shape = this.shape;\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN;\n      this._dynamicCounts[d] = 0;\n      continue;\n    }\n\n    this.dynamicLevel[d] = levels[d];\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var f = this._field[d];\n    var g = this._field[u];\n    var h = this._field[v];\n    var graph = surfaceNets(f, levels[d]);\n    var edges = graph.cells;\n    var positions = graph.positions;\n    this._dynamicOffsets[d] = vertexCount;\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]];\n        var x = +p[0];\n        var ix = x | 0;\n        var jx = Math.min(ix + 1, shape[0]) | 0;\n        var fx = x - ix;\n        var hx = 1.0 - fx;\n        var y = +p[1];\n        var iy = y | 0;\n        var jy = Math.min(iy + 1, shape[1]) | 0;\n        var fy = y - iy;\n        var hy = 1.0 - fy;\n        var w00 = hx * hy;\n        var w01 = hx * fy;\n        var w10 = fx * hy;\n        var w11 = fx * fy;\n        var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);\n        var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1;\n          }\n\n          break;\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu;\n        scratchBuffer[2 * vertexCount + 1] = cv;\n        vertexCount += 1;\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));\n\n  pool.freeFloat(scratchBuffer);\n};\n\nfunction createSurfacePlot(params) {\n  var gl = params.gl;\n  var shader = createShader(gl);\n  var pickShader = createPickShader(gl);\n  var contourShader = createContourShader(gl);\n  var contourPickShader = createPickContourShader(gl);\n  var coordinateBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: coordinateBuffer,\n    size: 4,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 0\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 16\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 28\n  }]);\n  var contourBuffer = createBuffer(gl);\n  var contourVAO = createVAO(gl, [{\n    buffer: contourBuffer,\n    size: 4,\n    stride: 20,\n    offset: 0\n  }, {\n    buffer: contourBuffer,\n    size: 1,\n    stride: 20,\n    offset: 16\n  }]);\n  var dynamicBuffer = createBuffer(gl);\n  var dynamicVAO = createVAO(gl, [{\n    buffer: dynamicBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }]);\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE);\n  cmap.minFilter = gl.LINEAR;\n  cmap.magFilter = gl.LINEAR;\n  var surface = new SurfacePlot(gl, [0, 0], // shape\n  [[0, 0, 0], [0, 0, 0]], // bounds\n  shader, pickShader, coordinateBuffer, vao, cmap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, [0, 0, 0] // objectOffset\n  );\n  var nparams = {\n    levels: [[], [], []]\n  };\n\n  for (var id in params) {\n    nparams[id] = params[id];\n  }\n\n  nparams.colormap = nparams.colormap || 'jet';\n  surface.update(nparams);\n  return surface;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/gl-surface3d/surface.js"],"names":["module","exports","createSurfacePlot","bits","require","createBuffer","createVAO","createTexture","pool","colormap","ops","pack","ndarray","surfaceNets","multiply","invert","bsearch","gradient","shaders","createShader","createContourShader","createPickShader","createPickContourShader","SURFACE_VERTEX_SIZE","IDENTITY","QUAD","PERMUTATIONS","i","p","u","v","SurfacePickResult","position","index","uv","level","dataCoordinate","N_COLORS","SurfacePlot","gl","shape","bounds","shader","pickShader","coordinates","vao","colorMap","contourShader","contourPickShader","contourBuffer","contourVAO","dynamicBuffer","dynamicVAO","objectOffset","intensityBounds","_shader","_pickShader","_coordinateBuffer","_vao","_colorMap","_contourShader","_contourPickShader","_contourBuffer","_contourVAO","_contourOffsets","_contourCounts","_vertexCount","_pickResult","_dynamicBuffer","_dynamicVAO","_dynamicOffsets","_dynamicCounts","contourWidth","contourLevels","contourTint","contourColor","showContour","showSurface","enableHighlight","highlightColor","highlightTint","highlightLevel","enableDynamic","dynamicLevel","NaN","dynamicColor","dynamicTint","dynamicWidth","axesBounds","Infinity","surfaceProject","contourProject","colorBounds","_field","mallocFloat","pickId","clipBounds","snapToData","pixelRatio","opacity","lightPosition","ambientLight","diffuseLight","specularLight","roughness","fresnel","vertexColor","dirty","proto","prototype","genColormap","name","opacityscale","hasAlpha","x","nshades","format","map","c","a","getOpacityFromScale","divseq","hasAlphaScale","isTransparent","isOpaque","pickSlots","setPickBase","id","ratio","length","d","ZERO_VEC","PROJECT_DATA","projections","slice","computeProjectionData","camera","obj","j","k","cubeAxis","axes","lastCubeProps","axis","axisSquish","model","nclipBounds","UNIFORMS","view","projection","inverseModel","lowerBound","upperBound","height","permutation","zOffset","kambient","kdiffuse","kspecular","eyePosition","MATRIX_INVERSE","DEFAULT_PERM","drawCore","params","transparent","disable","CULL_FACE","bind","uniforms","clipClamped","Math","min","max","invCameraMatrix","w","s","projectData","draw","TRIANGLES","vertexCount","unbind","lineWidth","LINES","call","drawTransparent","PICK_UNIFORMS","drawPick","pick","selection","result","value","ix","floor","fx","y","iy","fy","pos","dx","dy","t","r","get","levelIndex","le","b","abs","padField","dstField","srcField","srcShape","dstShape","assign","lo","hi","set","handleArray","param","ctor","Array","isArray","toColor","handleColor","update","Number","Boolean","setPixels","field","coords","levelsChanged","fsize","data","freeFloat","nextPow2","size","Error","coord","ticks","tick","tick2","stride","offset","fields","dfields","normals","dxdu","dxdv","dydu","dydv","dzdu","dzdv","nx","ny","nz","nl","sqrt","free","lo_intensity","hi_intensity","count","tverts","tptr","j_loop","f","isNaN","isFinite","tx","ty","intensity","vf","subarray","levels","sort","change_test","contourVerts","dim","contourLevel","levelOffsets","levelCounts","parts","graph","push","edge_loop","cells","e","positions","hole","axis_loop","iu","l","pop","floatBuffer","dispose","highlight","dyanamicLevel","scratchBuffer","g","h","edges","jx","hx","jy","hy","w00","w01","w10","w11","cu","cv","coordinateBuffer","buffer","type","FLOAT","cmap","RGBA","UNSIGNED_BYTE","minFilter","LINEAR","magFilter","surface","nparams"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = createSurfacePlot\n\nvar bits = require('bit-twiddle')\nvar createBuffer = require('gl-buffer')\nvar createVAO = require('gl-vao')\nvar createTexture = require('gl-texture2d')\nvar pool = require('typedarray-pool')\nvar colormap = require('colormap')\nvar ops = require('ndarray-ops')\nvar pack = require('ndarray-pack')\nvar ndarray = require('ndarray')\nvar surfaceNets = require('surface-nets')\nvar multiply = require('gl-mat4/multiply')\nvar invert = require('gl-mat4/invert')\nvar bsearch = require('binary-search-bounds')\nvar gradient = require('ndarray-gradient')\nvar shaders = require('./lib/shaders')\n\nvar createShader = shaders.createShader\nvar createContourShader = shaders.createContourShader\nvar createPickShader = shaders.createPickShader\nvar createPickContourShader = shaders.createPickContourShader\n\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3)\n\nvar IDENTITY = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1 ]\n\nvar QUAD = [\n  [0, 0],\n  [0, 1],\n  [1, 0],\n  [1, 1],\n  [1, 0],\n  [0, 1]\n]\n\nvar PERMUTATIONS = [\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n;(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i]\n    var u = (i + 1) % 3\n    var v = (i + 2) % 3\n    p[u + 0] = 1\n    p[v + 3] = 1\n    p[i + 6] = 1\n  }\n})()\n\nfunction SurfacePickResult (position, index, uv, level, dataCoordinate) {\n  this.position = position\n  this.index = index\n  this.uv = uv\n  this.level = level\n  this.dataCoordinate = dataCoordinate\n}\n\nvar N_COLORS = 256\n\nfunction SurfacePlot (\n  gl,\n  shape,\n  bounds,\n  shader,\n  pickShader,\n  coordinates,\n  vao,\n  colorMap,\n  contourShader,\n  contourPickShader,\n  contourBuffer,\n  contourVAO,\n  dynamicBuffer,\n  dynamicVAO,\n  objectOffset) {\n  this.gl = gl\n  this.shape = shape\n  this.bounds = bounds\n  this.objectOffset = objectOffset\n  this.intensityBounds = []\n\n  this._shader = shader\n  this._pickShader = pickShader\n  this._coordinateBuffer = coordinates\n  this._vao = vao\n  this._colorMap = colorMap\n\n  this._contourShader = contourShader\n  this._contourPickShader = contourPickShader\n  this._contourBuffer = contourBuffer\n  this._contourVAO = contourVAO\n  this._contourOffsets = [[], [], []]\n  this._contourCounts = [[], [], []]\n  this._vertexCount = 0\n\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0])\n\n  this._dynamicBuffer = dynamicBuffer\n  this._dynamicVAO = dynamicVAO\n  this._dynamicOffsets = [0, 0, 0]\n  this._dynamicCounts = [0, 0, 0]\n\n  this.contourWidth = [ 1, 1, 1 ]\n  this.contourLevels = [[1], [1], [1]]\n  this.contourTint = [0, 0, 0]\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]\n\n  this.showContour = true\n  this.showSurface = true\n\n  this.enableHighlight = [true, true, true]\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]\n  this.highlightTint = [ 1, 1, 1 ]\n  this.highlightLevel = [-1, -1, -1]\n\n  // Dynamic contour options\n  this.enableDynamic = [ true, true, true ]\n  this.dynamicLevel = [ NaN, NaN, NaN ]\n  this.dynamicColor = [ [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1] ]\n  this.dynamicTint = [ 1, 1, 1 ]\n  this.dynamicWidth = [ 1, 1, 1 ]\n\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]\n  this.surfaceProject = [ false, false, false ]\n  this.contourProject = [[ false, false, false ],\n    [ false, false, false ],\n    [ false, false, false ]]\n\n  this.colorBounds = [ false, false ]\n\n  // Store xyz fields, need this for picking\n  this._field = [\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]) ]\n\n  this.pickId = 1\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]]\n\n  this.snapToData = false\n\n  this.pixelRatio = 1\n\n  this.opacity = 1.0\n\n  this.lightPosition = [10, 10000, 0]\n  this.ambientLight = 0.8\n  this.diffuseLight = 0.8\n  this.specularLight = 2.0\n  this.roughness = 0.5\n  this.fresnel = 1.5\n  this.vertexColor = 0\n\n  this.dirty = true\n}\n\nvar proto = SurfacePlot.prototype\n\nproto.genColormap = function (name, opacityscale) {\n  var hasAlpha = false\n\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : c[3]\n    if(a < 1) hasAlpha = true\n    return [c[0], c[1], c[2], 255 * a]\n  })])\n  ops.divseq(x, 255.0)\n\n  this.hasAlphaScale = hasAlpha\n  return x\n}\n\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.hasAlphaScale\n}\n\nproto.isOpaque = function () {\n  return !this.isTransparent()\n}\n\nproto.pickSlots = 1\n\nproto.setPickBase = function (id) {\n  this.pickId = id\n}\n\nfunction getOpacityFromScale(ratio, opacityscale) { // copied form gl-mesh3d\n  if(!opacityscale) return 1\n  if(!opacityscale.length) return 1\n\n  for(var i = 0; i < opacityscale.length; ++i) {\n    if(opacityscale.length < 2) return 1\n    if(opacityscale[i][0] === ratio) return opacityscale[i][1]\n    if(opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0])\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1]\n    }\n  }\n\n  return 1\n}\n\nvar ZERO_VEC = [0, 0, 0]\n\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]]]\n}\n\nfunction computeProjectionData (camera, obj) {\n  var i, j, k\n\n  // Compute cube properties\n  var cubeAxis = (obj.axes && obj.axes.lastCubeProps.axis) || ZERO_VEC\n\n  var showSurface = obj.showSurface\n  var showContour = obj.showContour\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i]\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j]\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i]\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0\n    }\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1\n    }\n    axisSquish[5 * i] = 0\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i]\n    multiply(axisSquish, camera.model, axisSquish)\n\n    var nclipBounds = PROJECT_DATA.clipBounds[i]\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j]\n      }\n    }\n    nclipBounds[0][i] = -1e8\n    nclipBounds[1][i] = 1e8\n  }\n\n  PROJECT_DATA.showSurface = showSurface\n  PROJECT_DATA.showContour = showContour\n\n  return PROJECT_DATA\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n}\n\nvar MATRIX_INVERSE = IDENTITY.slice()\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\nfunction drawCore (params, transparent) {\n  params = params || {}\n  var gl = this.gl\n\n  gl.disable(gl.CULL_FACE)\n\n  this._colorMap.bind(0)\n\n  var uniforms = UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]]\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.contourColor = this.contourColor[0]\n\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model)\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  uniforms.kambient = this.ambientLight\n  uniforms.kdiffuse = this.diffuseLight\n  uniforms.kspecular = this.specularLight\n\n  uniforms.roughness = this.roughness\n  uniforms.fresnel = this.fresnel\n  uniforms.opacity = this.opacity\n\n  uniforms.height = 0.0\n  uniforms.permutation = DEFAULT_PERM\n\n  uniforms.vertexColor = this.vertexColor\n\n  // Compute camera matrix inverse\n  var invCameraMatrix = MATRIX_INVERSE\n  multiply(invCameraMatrix, uniforms.view, uniforms.model)\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix)\n  invert(invCameraMatrix, invCameraMatrix)\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15]\n  }\n\n  var w = invCameraMatrix[15]\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3]\n  }\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i]\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j]\n    }\n    uniforms.lightPosition[i] = s / w\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface)  {\n    // Set up uniforms\n    this._shader.bind()\n    this._shader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue\n      }\n      this._shader.uniforms.model = projectData.projections[i]\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourShader\n\n    // Don't apply lighting to contours\n    uniforms.kambient = 1.0\n    uniforms.kdiffuse = 0.0\n    uniforms.kspecular = 0.0\n    uniforms.opacity = 1.0\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    // Draw contour lines\n    var vao = this._contourVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio)\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i]\n          shader.uniforms.contourTint = this.highlightTint[i]\n        } else if (j === 0 || (j - 1) === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i]\n          shader.uniforms.contourTint = this.contourTint[i]\n        }\n        if (!this._contourCounts[i][j]) {\n          continue\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j]\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j])\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j]\n            shader.uniforms.contourTint = this.highlightTint[j]\n          } else if (k === 0 || (k - 1) === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j]\n            shader.uniforms.contourTint = this.contourTint[j]\n          }\n          if (!this._contourCounts[j][k]) {\n            continue\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k]\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n        }\n      }\n    }\n\n    vao.unbind()\n\n    // Draw dynamic contours\n    vao = this._dynamicVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue\n      }\n\n      shader.uniforms.model = uniforms.model\n      shader.uniforms.clipBounds = uniforms.clipBounds\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio)\n\n      shader.uniforms.contourColor = this.dynamicColor[i]\n      shader.uniforms.contourTint = this.dynamicTint[i]\n      shader.uniforms.height = this.dynamicLevel[i]\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue\n        }\n\n        shader.uniforms.model = projectData.projections[j]\n        shader.uniforms.clipBounds = projectData.clipBounds[j]\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false)\n}\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true)\n}\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n}\n\nproto.drawPick = function (params) {\n  params = params || {}\n  var gl = this.gl\n  gl.disable(gl.CULL_FACE)\n\n  var uniforms = PICK_UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.shape = this._field[2].shape\n  uniforms.pickId = this.pickId / 255.0\n  uniforms.lowerBound = this.bounds[0]\n  uniforms.upperBound = this.bounds[1]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.permutation = DEFAULT_PERM\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind()\n    this._pickShader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n    this._vao.draw(gl.TRIANGLES, this._vertexCount)\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue\n      }\n      this._pickShader.uniforms.model = projectData.projections[i]\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    var vao = this._contourVAO\n    vao.bind()\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n      shader.uniforms.permutation = PERMUTATIONS[j]\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i]\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i])\n        }\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k]\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n          }\n        }\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null\n  }\n\n  if (selection.id !== this.pickId) {\n    return null\n  }\n\n  var shape = this._field[2].shape\n\n  var result = this._pickResult\n\n  // Compute uv coordinate\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0\n  var ix = Math.floor(x)\n  var fx = x - ix\n\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0\n  var iy = Math.floor(y)\n  var fy = y - iy\n\n  ix += 1\n  iy += 1\n\n  // Compute xyz coordinate\n  var pos = result.position\n  pos[0] = pos[1] = pos[2] = 0\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy\n\n      var r = ix + dx\n      var c = iy + dy\n      var w = s * t\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w\n      }\n    }\n  }\n\n  // Find closest level\n  var levelIndex = this._pickResult.level\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j])\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]]\n      var b = this.contourLevels[j][levelIndex[j] + 1]\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : (ix + 1)\n  result.index[1] = fy < 0.5 ? iy : (iy + 1)\n\n  result.uv[0] = x / shape[0]\n  result.uv[1] = y / shape[1]\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1])\n  }\n\n  return result\n}\n\nproto.padField = function(dstField, srcField) {\n  var srcShape = srcField.shape.slice()\n  var dstShape = dstField.shape.slice()\n\n  // Center\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField)\n\n  // Edges\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1),\n    srcField.hi(srcShape[0], 1))\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1),\n    srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1))\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]),\n    srcField.hi(1))\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]),\n    srcField.lo(srcShape[0] - 1))\n  // Corners\n  dstField.set(0, 0, srcField.get(0, 0))\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1))\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0))\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1))\n}\n\nfunction handleArray (param, ctor) {\n  if (Array.isArray(param)) {\n    return [ ctor(param[0]), ctor(param[1]), ctor(param[2]) ]\n  }\n  return [ ctor(param), ctor(param), ctor(param) ]\n}\n\nfunction toColor (x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1]\n    }\n    return [x[0], x[1], x[2], x[3]]\n  }\n  return [0, 0, 0, 1]\n}\n\nfunction handleColor (param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [\n        toColor(param[0]),\n        toColor(param[1]),\n        toColor(param[2]) ]\n    } else {\n      var c = toColor(param)\n      return [\n        c.slice(),\n        c.slice(),\n        c.slice() ]\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {}\n\n  this.objectOffset = params.objectOffset || this.objectOffset\n\n  this.dirty = true\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number)\n  }\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean)\n  }\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface\n  }\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean)\n  }\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor)\n  }\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean)\n    })\n  }\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject\n  }\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor)\n  }\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number)\n  }\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number)\n  }\n  if ('opacity' in params) {\n    this.opacity = params.opacity\n  }\n  if('opacityscale' in params) {\n    this.opacityscale = params.opacityscale\n  }\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds\n  }\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n  if ('colormap' in params) {\n    this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale))\n  }\n\n  var field = params.field || (params.coords && params.coords[2]) || null\n  var levelsChanged = false\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2)\n    } else {\n      field = this._field[2].hi(0, 0)\n    }\n  }\n\n  // Update field\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2)\n\n    // Resize if necessary\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data)\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize))\n    }\n\n    // Pad field\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2])\n    this.padField(this._field[2], field)\n\n    // Save shape of field\n    this.shape = field.shape.slice()\n    var shape = this.shape\n\n    // Resize coordinate fields if necessary\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data)\n        this._field[i].data = pool.mallocFloat(this._field[2].size)\n      }\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2])\n    }\n\n    // Generate x/y coordinates\n    if (params.coords) {\n      var coords = params.coords\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y')\n      }\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i]\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape')\n          }\n        }\n        this.padField(this._field[i], coord)\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks')\n      }\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i]\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick)\n        }\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length')\n        }\n        // Make a copy view of the tick array\n        var tick2 = ndarray(tick.data, shape)\n        tick2.stride[i] = tick.stride[0]\n        tick2.stride[i ^ 1] = 0\n\n        // Fill in field array\n        this.padField(this._field[i], tick2)\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0]\n        offset[i] = 1\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0)\n      }\n      this._field[0].set(0, 0, 0)\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j)\n      }\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1)\n      this._field[1].set(0, 0, 0)\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j)\n      }\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1)\n    }\n\n    // Save shape\n    var fields = this._field\n\n    // Compute surface normals\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2])\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror')\n    }\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3])\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0)\n        var dxdv = dfields.get(0, i, j, 1)\n        var dydu = dfields.get(1, i, j, 0)\n        var dydv = dfields.get(1, i, j, 1)\n        var dzdu = dfields.get(2, i, j, 0)\n        var dzdv = dfields.get(2, i, j, 1)\n\n        var nx = dydu * dzdv - dydv * dzdu\n        var ny = dzdu * dxdv - dzdv * dxdu\n        var nz = dxdu * dydv - dxdv * dydu\n\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz)\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz))\n          if (nl < 1e-8) {\n            nz = 1.0\n            ny = nx = 0.0\n            nl = 1.0\n          } else {\n            nl = 1.0 / nl\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl)\n        }\n\n        normals.set(i, j, 0, nx * nl)\n        normals.set(i, j, 1, ny * nl)\n        normals.set(i, j, 2, nz * nl)\n      }\n    }\n    pool.free(dfields.data)\n\n    // Initialize surface\n    var lo = [ Infinity, Infinity, Infinity ]\n    var hi = [ -Infinity, -Infinity, -Infinity ]\n    var lo_intensity = Infinity\n    var hi_intensity = -Infinity\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count))\n    var tptr = 0\n    var vertexCount = 0\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop:\n      for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy)\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop\n              }\n            }\n          }\n        }\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0]\n          var c = j + QUAD[k][1]\n\n          var tx = this._field[0].get(r + 1, c + 1)\n          var ty = this._field[1].get(r + 1, c + 1)\n          f =      this._field[2].get(r + 1, c + 1)\n\n          nx = normals.get(r + 1, c + 1, 0)\n          ny = normals.get(r + 1, c + 1, 1)\n          nz = normals.get(r + 1, c + 1, 2)\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c)\n          }\n\n          var vf = (params.intensity) ?\n            params.intensity.get(r, c) :\n            f + this.objectOffset[2];\n\n          tverts[tptr++] = r\n          tverts[tptr++] = c\n          tverts[tptr++] = tx\n          tverts[tptr++] = ty\n          tverts[tptr++] = f\n          tverts[tptr++] = 0\n          tverts[tptr++] = vf\n          tverts[tptr++] = nx\n          tverts[tptr++] = ny\n          tverts[tptr++] = nz\n\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0])\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1])\n          lo[2] = Math.min(lo[2], f  + this.objectOffset[2])\n          lo_intensity = Math.min(lo_intensity, vf)\n\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0])\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1])\n          hi[2] = Math.max(hi[2], f  + this.objectOffset[2])\n          hi_intensity = Math.max(hi_intensity, vf)\n\n          vertexCount += 1\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0]\n      hi_intensity = +params.intensityBounds[1]\n    }\n\n    // Scale all vertex intensities\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity)\n    }\n\n    this._vertexCount = vertexCount\n    this._coordinateBuffer.update(tverts.subarray(0, tptr))\n    pool.freeFloat(tverts)\n    pool.free(normals.data)\n\n    // Update bounds\n    this.bounds = [lo, hi]\n\n    // Save intensity\n    this.intensity = params.intensity || this._field[2]\n\n    if(this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n        levelsChanged = true\n    }\n\n    // Save intensity bound\n    this.intensityBounds = [lo_intensity, hi_intensity]\n  }\n\n  // Update level crossings\n  if ('levels' in params) {\n    var levels = params.levels\n    if (!Array.isArray(levels[0])) {\n      levels = [ [], [], levels ]\n    } else {\n      levels = levels.slice()\n    }\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice()\n      levels[i].sort(function (a, b) {\n        return a - b\n      })\n    }\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i]\n      }\n    }\n    change_test:\n    for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true\n        break\n      }\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true\n          break change_test\n        }\n      }\n    }\n    this.contourLevels = levels\n  }\n\n  if (levelsChanged) {\n    fields = this._field\n    shape = this.shape\n\n    // Update contour lines\n    var contourVerts = []\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim]\n\n      var levelOffsets = []\n      var levelCounts = []\n\n      var parts = [0, 0, 0]\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i])\n\n        levelOffsets.push((contourVerts.length / 5) | 0)\n        vertexCount = 0\n\n        edge_loop:\n        for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j]\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]]\n\n            var x = p[0]\n            var ix = Math.floor(x) | 0\n            var fx = x - ix\n\n            var y = p[1]\n            var iy = Math.floor(y) | 0\n            var fy = y - iy\n\n            var hole = false\n            axis_loop:\n            for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0\n              var iu = (dim + axis + 1) % 3\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c)\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0])\n                  }\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true\n                    break axis_loop\n                  }\n\n                  var w = s * t\n                  parts[axis] += w * f\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(\n                parts[0],\n                parts[1],\n                p[0],\n                p[1],\n                parts[2]\n              )\n              vertexCount += 1\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop()\n                }\n                vertexCount -= 1\n              }\n              continue edge_loop\n            }\n          }\n        }\n        levelCounts.push(vertexCount)\n      }\n\n      // Store results\n      this._contourOffsets[dim] = levelOffsets\n      this._contourCounts[dim] = levelCounts\n\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length)\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i]\n    }\n    this._contourBuffer.update(floatBuffer)\n    pool.freeFloat(floatBuffer)\n  }\n}\n\nproto.dispose = function () {\n  this._shader.dispose()\n  this._vao.dispose()\n  this._coordinateBuffer.dispose()\n  this._colorMap.dispose()\n  this._contourBuffer.dispose()\n  this._contourVAO.dispose()\n  this._contourShader.dispose()\n  this._contourPickShader.dispose()\n  this._dynamicBuffer.dispose()\n  this._dynamicVAO.dispose()\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data)\n  }\n}\n\nproto.highlight = function (selection) {\n  var i\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0]\n    this.dyanamicLevel = [NaN, NaN, NaN]\n    this.highlightLevel = [-1, -1, -1]\n    return\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i]\n    } else {\n      this.highlightLevel[i] = -1\n    }\n  }\n\n  var levels\n  if (this.snapToData) {\n    levels = selection.dataCoordinate\n  } else {\n    levels = selection.position\n  }\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i]\n  }\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) &&\n    (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) &&\n    (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return\n  }\n\n  var vertexCount = 0\n  var shape = this.shape\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1])\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN\n      this._dynamicCounts[d] = 0\n      continue\n    }\n\n    this.dynamicLevel[d] = levels[d]\n\n    var u = (d + 1) % 3\n    var v = (d + 2) % 3\n\n    var f = this._field[d]\n    var g = this._field[u]\n    var h = this._field[v]\n\n    var graph = surfaceNets(f, levels[d])\n    var edges = graph.cells\n    var positions = graph.positions\n\n    this._dynamicOffsets[d] = vertexCount\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]]\n\n        var x = +p[0]\n        var ix = x | 0\n        var jx = Math.min(ix + 1, shape[0]) | 0\n        var fx = x - ix\n        var hx = 1.0 - fx\n\n        var y = +p[1]\n        var iy = y | 0\n        var jy = Math.min(iy + 1, shape[1]) | 0\n        var fy = y - iy\n        var hy = 1.0 - fy\n\n        var w00 = hx * hy\n        var w01 = hx * fy\n        var w10 = fx * hy\n        var w11 = fx * fy\n\n        var cu = w00 * g.get(ix, iy) +\n          w01 * g.get(ix, jy) +\n          w10 * g.get(jx, iy) +\n          w11 * g.get(jx, jy)\n\n        var cv = w00 * h.get(ix, iy) +\n          w01 * h.get(ix, jy) +\n          w10 * h.get(jx, iy) +\n          w11 * h.get(jx, jy)\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1\n          }\n          break\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu\n        scratchBuffer[2 * vertexCount + 1] = cv\n\n        vertexCount += 1\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d]\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount))\n  pool.freeFloat(scratchBuffer)\n}\n\nfunction createSurfacePlot (params) {\n  var gl = params.gl\n\n  var shader = createShader(gl)\n  var pickShader = createPickShader(gl)\n  var contourShader = createContourShader(gl)\n  var contourPickShader = createPickContourShader(gl)\n\n  var coordinateBuffer = createBuffer(gl)\n  var vao = createVAO(gl, [\n    { buffer: coordinateBuffer,\n      size: 4,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 0\n    },\n    { buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 16\n    },\n    {\n      buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 28\n    }\n  ])\n\n  var contourBuffer = createBuffer(gl)\n  var contourVAO = createVAO(gl, [\n    {\n      buffer: contourBuffer,\n      size: 4,\n      stride: 20,\n      offset: 0\n    },\n    {\n      buffer: contourBuffer,\n      size: 1,\n      stride: 20,\n      offset: 16\n    }\n  ])\n\n  var dynamicBuffer = createBuffer(gl)\n  var dynamicVAO = createVAO(gl, [\n    {\n      buffer: dynamicBuffer,\n      size: 2,\n      type: gl.FLOAT\n    }])\n\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE)\n  cmap.minFilter = gl.LINEAR\n  cmap.magFilter = gl.LINEAR\n\n  var surface = new SurfacePlot(\n    gl,\n    [0, 0], // shape\n    [[0, 0, 0], [0, 0, 0]], // bounds\n    shader,\n    pickShader,\n    coordinateBuffer,\n    vao,\n    cmap,\n    contourShader,\n    contourPickShader,\n    contourBuffer,\n    contourVAO,\n    dynamicBuffer,\n    dynamicVAO,\n    [0, 0, 0] // objectOffset\n  )\n\n  var nparams = {\n    levels: [[], [], []]\n  }\n  for (var id in params) {\n    nparams[id] = params[id]\n  }\n  nparams.colormap = nparams.colormap || 'jet'\n\n  surface.update(nparams)\n\n  return surface\n}\n"]},"metadata":{},"sourceType":"script"}