{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib'); // Maybe add kernels more down the road,\n// but note that the default `spanmode: 'soft'` bounds might have\n// to become kernel-dependent\n\n\nvar kernels = {\n  gaussian: function (v) {\n    return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * v * v);\n  }\n};\n\nexports.makeKDE = function (calcItem, trace, vals) {\n  var len = vals.length;\n  var kernel = kernels.gaussian;\n  var bandwidth = calcItem.bandwidth;\n  var factor = 1 / (len * bandwidth); // don't use Lib.aggNums to skip isNumeric checks\n\n  return function (x) {\n    var sum = 0;\n\n    for (var i = 0; i < len; i++) {\n      sum += kernel((x - vals[i]) / bandwidth);\n    }\n\n    return factor * sum;\n  };\n};\n\nexports.getPositionOnKdePath = function (calcItem, trace, valuePx) {\n  var posLetter, valLetter;\n\n  if (trace.orientation === 'h') {\n    posLetter = 'y';\n    valLetter = 'x';\n  } else {\n    posLetter = 'x';\n    valLetter = 'y';\n  }\n\n  var pointOnPath = Lib.findPointOnPath(calcItem.path, valuePx, valLetter, {\n    pathLength: calcItem.pathLength\n  });\n  var posCenterPx = calcItem.posCenterPx;\n  var posOnPath0 = pointOnPath[posLetter];\n  var posOnPath1 = trace.side === 'both' ? 2 * posCenterPx - posOnPath0 : posCenterPx;\n  return [posOnPath0, posOnPath1];\n};\n\nexports.getKdeValue = function (calcItem, trace, valueDist) {\n  var vals = calcItem.pts.map(exports.extractVal);\n  var kde = exports.makeKDE(calcItem, trace, vals);\n  return kde(valueDist) / calcItem.posDensityScale;\n};\n\nexports.extractVal = function (o) {\n  return o.v;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/violin/helpers.js"],"names":["Lib","require","kernels","gaussian","v","Math","sqrt","PI","exp","exports","makeKDE","calcItem","trace","vals","len","length","kernel","bandwidth","factor","x","sum","i","getPositionOnKdePath","valuePx","posLetter","valLetter","orientation","pointOnPath","findPointOnPath","path","pathLength","posCenterPx","posOnPath0","posOnPath1","side","getKdeValue","valueDist","pts","map","extractVal","kde","posDensityScale","o"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB,C,CAEA;AACA;AACA;;;AACA,IAAIC,OAAO,GAAG;AACVC,EAAAA,QAAQ,EAAE,UAASC,CAAT,EAAY;AAClB,WAAQ,IAAIC,IAAI,CAACC,IAAL,CAAU,IAAID,IAAI,CAACE,EAAnB,CAAL,GAA+BF,IAAI,CAACG,GAAL,CAAS,CAAC,GAAD,GAAOJ,CAAP,GAAWA,CAApB,CAAtC;AACH;AAHS,CAAd;;AAMAK,OAAO,CAACC,OAAR,GAAkB,UAASC,QAAT,EAAmBC,KAAnB,EAA0BC,IAA1B,EAAgC;AAC9C,MAAIC,GAAG,GAAGD,IAAI,CAACE,MAAf;AACA,MAAIC,MAAM,GAAGd,OAAO,CAACC,QAArB;AACA,MAAIc,SAAS,GAAGN,QAAQ,CAACM,SAAzB;AACA,MAAIC,MAAM,GAAG,KAAKJ,GAAG,GAAGG,SAAX,CAAb,CAJ8C,CAM9C;;AACA,SAAO,UAASE,CAAT,EAAY;AACf,QAAIC,GAAG,GAAG,CAAV;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGP,GAAnB,EAAwBO,CAAC,EAAzB,EAA6B;AACzBD,MAAAA,GAAG,IAAIJ,MAAM,CAAC,CAACG,CAAC,GAAGN,IAAI,CAACQ,CAAD,CAAT,IAAgBJ,SAAjB,CAAb;AACH;;AACD,WAAOC,MAAM,GAAGE,GAAhB;AACH,GAND;AAOH,CAdD;;AAgBAX,OAAO,CAACa,oBAAR,GAA+B,UAASX,QAAT,EAAmBC,KAAnB,EAA0BW,OAA1B,EAAmC;AAC9D,MAAIC,SAAJ,EAAeC,SAAf;;AAEA,MAAGb,KAAK,CAACc,WAAN,KAAsB,GAAzB,EAA8B;AAC1BF,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,GAAZ;AACH,GAHD,MAGO;AACHD,IAAAA,SAAS,GAAG,GAAZ;AACAC,IAAAA,SAAS,GAAG,GAAZ;AACH;;AAED,MAAIE,WAAW,GAAG3B,GAAG,CAAC4B,eAAJ,CACdjB,QAAQ,CAACkB,IADK,EAEdN,OAFc,EAGdE,SAHc,EAId;AAACK,IAAAA,UAAU,EAAEnB,QAAQ,CAACmB;AAAtB,GAJc,CAAlB;AAOA,MAAIC,WAAW,GAAGpB,QAAQ,CAACoB,WAA3B;AACA,MAAIC,UAAU,GAAGL,WAAW,CAACH,SAAD,CAA5B;AACA,MAAIS,UAAU,GAAGrB,KAAK,CAACsB,IAAN,KAAe,MAAf,GACb,IAAIH,WAAJ,GAAkBC,UADL,GAEbD,WAFJ;AAIA,SAAO,CAACC,UAAD,EAAaC,UAAb,CAAP;AACH,CAzBD;;AA2BAxB,OAAO,CAAC0B,WAAR,GAAsB,UAASxB,QAAT,EAAmBC,KAAnB,EAA0BwB,SAA1B,EAAqC;AACvD,MAAIvB,IAAI,GAAGF,QAAQ,CAAC0B,GAAT,CAAaC,GAAb,CAAiB7B,OAAO,CAAC8B,UAAzB,CAAX;AACA,MAAIC,GAAG,GAAG/B,OAAO,CAACC,OAAR,CAAgBC,QAAhB,EAA0BC,KAA1B,EAAiCC,IAAjC,CAAV;AACA,SAAO2B,GAAG,CAACJ,SAAD,CAAH,GAAiBzB,QAAQ,CAAC8B,eAAjC;AACH,CAJD;;AAMAhC,OAAO,CAAC8B,UAAR,GAAqB,UAASG,CAAT,EAAY;AAAE,SAAOA,CAAC,CAACtC,CAAT;AAAa,CAAhD","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\n// Maybe add kernels more down the road,\n// but note that the default `spanmode: 'soft'` bounds might have\n// to become kernel-dependent\nvar kernels = {\n    gaussian: function(v) {\n        return (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * v * v);\n    }\n};\n\nexports.makeKDE = function(calcItem, trace, vals) {\n    var len = vals.length;\n    var kernel = kernels.gaussian;\n    var bandwidth = calcItem.bandwidth;\n    var factor = 1 / (len * bandwidth);\n\n    // don't use Lib.aggNums to skip isNumeric checks\n    return function(x) {\n        var sum = 0;\n        for(var i = 0; i < len; i++) {\n            sum += kernel((x - vals[i]) / bandwidth);\n        }\n        return factor * sum;\n    };\n};\n\nexports.getPositionOnKdePath = function(calcItem, trace, valuePx) {\n    var posLetter, valLetter;\n\n    if(trace.orientation === 'h') {\n        posLetter = 'y';\n        valLetter = 'x';\n    } else {\n        posLetter = 'x';\n        valLetter = 'y';\n    }\n\n    var pointOnPath = Lib.findPointOnPath(\n        calcItem.path,\n        valuePx,\n        valLetter,\n        {pathLength: calcItem.pathLength}\n    );\n\n    var posCenterPx = calcItem.posCenterPx;\n    var posOnPath0 = pointOnPath[posLetter];\n    var posOnPath1 = trace.side === 'both' ?\n        2 * posCenterPx - posOnPath0 :\n        posCenterPx;\n\n    return [posOnPath0, posOnPath1];\n};\n\nexports.getKdeValue = function(calcItem, trace, valueDist) {\n    var vals = calcItem.pts.map(exports.extractVal);\n    var kde = exports.makeKDE(calcItem, trace, vals);\n    return kde(valueDist) / calcItem.posDensityScale;\n};\n\nexports.extractVal = function(o) { return o.v; };\n"]},"metadata":{},"sourceType":"script"}