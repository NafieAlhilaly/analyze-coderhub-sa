{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar Plots = require('../plots/plots');\n\nvar PlotSchema = require('./plot_schema');\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\n\nmodule.exports = function validate(data, layout) {\n  if (data === undefined) data = [];\n  if (layout === undefined) layout = {};\n  var schema = PlotSchema.get();\n  var errorList = [];\n  var gd = {\n    _context: Lib.extendFlat({}, dfltConfig)\n  };\n  var dataIn, layoutIn;\n\n  if (isArray(data)) {\n    gd.data = Lib.extendDeep([], data);\n    dataIn = data;\n  } else {\n    gd.data = [];\n    dataIn = [];\n    errorList.push(format('array', 'data'));\n  }\n\n  if (isPlainObject(layout)) {\n    gd.layout = Lib.extendDeep({}, layout);\n    layoutIn = layout;\n  } else {\n    gd.layout = {};\n    layoutIn = {};\n\n    if (arguments.length > 1) {\n      errorList.push(format('object', 'layout'));\n    }\n  } // N.B. dataIn and layoutIn are in general not the same as\n  // gd.data and gd.layout after supplyDefaults as some attributes\n  // in gd.data and gd.layout (still) get mutated during this step.\n\n\n  Plots.supplyDefaults(gd);\n  var dataOut = gd._fullData;\n  var len = dataIn.length;\n\n  for (var i = 0; i < len; i++) {\n    var traceIn = dataIn[i];\n    var base = ['data', i];\n\n    if (!isPlainObject(traceIn)) {\n      errorList.push(format('object', base));\n      continue;\n    }\n\n    var traceOut = dataOut[i];\n    var traceType = traceOut.type;\n    var traceSchema = schema.traces[traceType].attributes; // PlotSchema does something fancy with trace 'type', reset it here\n    // to make the trace schema compatible with Lib.validate.\n\n    traceSchema.type = {\n      valType: 'enumerated',\n      values: [traceType]\n    };\n\n    if (traceOut.visible === false && traceIn.visible !== false) {\n      errorList.push(format('invisible', base));\n    }\n\n    crawl(traceIn, traceOut, traceSchema, errorList, base);\n    var transformsIn = traceIn.transforms;\n    var transformsOut = traceOut.transforms;\n\n    if (transformsIn) {\n      if (!isArray(transformsIn)) {\n        errorList.push(format('array', base, ['transforms']));\n      }\n\n      base.push('transforms');\n\n      for (var j = 0; j < transformsIn.length; j++) {\n        var path = ['transforms', j];\n        var transformType = transformsIn[j].type;\n\n        if (!isPlainObject(transformsIn[j])) {\n          errorList.push(format('object', base, path));\n          continue;\n        }\n\n        var transformSchema = schema.transforms[transformType] ? schema.transforms[transformType].attributes : {}; // add 'type' to transform schema to validate the transform type\n\n        transformSchema.type = {\n          valType: 'enumerated',\n          values: Object.keys(schema.transforms)\n        };\n        crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n      }\n    }\n  }\n\n  var layoutOut = gd._fullLayout;\n  var layoutSchema = fillLayoutSchema(schema, dataOut);\n  crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout'); // return undefined if no validation errors were found\n\n  return errorList.length === 0 ? void 0 : errorList;\n};\n\nfunction crawl(objIn, objOut, schema, list, base, path) {\n  path = path || [];\n  var keys = Object.keys(objIn);\n\n  for (var i = 0; i < keys.length; i++) {\n    var k = keys[i]; // transforms are handled separately\n\n    if (k === 'transforms') continue;\n    var p = path.slice();\n    p.push(k);\n    var valIn = objIn[k];\n    var valOut = objOut[k];\n    var nestedSchema = getNestedSchema(schema, k);\n    var nestedValType = (nestedSchema || {}).valType;\n    var isInfoArray = nestedValType === 'info_array';\n    var isColorscale = nestedValType === 'colorscale';\n    var items = (nestedSchema || {}).items;\n\n    if (!isInSchema(schema, k)) {\n      list.push(format('schema', base, p));\n    } else if (isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== 'any') {\n      crawl(valIn, valOut, nestedSchema, list, base, p);\n    } else if (isInfoArray && isArray(valIn)) {\n      if (valIn.length > valOut.length) {\n        list.push(format('unused', base, p.concat(valOut.length)));\n      }\n\n      var len = valOut.length;\n      var arrayItems = Array.isArray(items);\n      if (arrayItems) len = Math.min(len, items.length);\n      var m, n, item, valInPart, valOutPart;\n\n      if (nestedSchema.dimensions === 2) {\n        for (n = 0; n < len; n++) {\n          if (isArray(valIn[n])) {\n            if (valIn[n].length > valOut[n].length) {\n              list.push(format('unused', base, p.concat(n, valOut[n].length)));\n            }\n\n            var len2 = valOut[n].length;\n\n            for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {\n              item = arrayItems ? items[n][m] : items;\n              valInPart = valIn[n][m];\n              valOutPart = valOut[n][m];\n\n              if (!Lib.validate(valInPart, item)) {\n                list.push(format('value', base, p.concat(n, m), valInPart));\n              } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));\n              }\n            }\n          } else {\n            list.push(format('array', base, p.concat(n), valIn[n]));\n          }\n        }\n      } else {\n        for (n = 0; n < len; n++) {\n          item = arrayItems ? items[n] : items;\n          valInPart = valIn[n];\n          valOutPart = valOut[n];\n\n          if (!Lib.validate(valInPart, item)) {\n            list.push(format('value', base, p.concat(n), valInPart));\n          } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n            list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));\n          }\n        }\n      }\n    } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {\n      var _nestedSchema = items[Object.keys(items)[0]];\n      var indexList = [];\n\n      var j, _p; // loop over valOut items while keeping track of their\n      // corresponding input container index (given by _index)\n\n\n      for (j = 0; j < valOut.length; j++) {\n        var _index = valOut[j]._index || j;\n\n        _p = p.slice();\n\n        _p.push(_index);\n\n        if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n          indexList.push(_index);\n          var valInj = valIn[_index];\n          var valOutj = valOut[j];\n\n          if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {\n            list.push(format('invisible', base, _p));\n          } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);\n        }\n      } // loop over valIn to determine where it went wrong for some items\n\n\n      for (j = 0; j < valIn.length; j++) {\n        _p = p.slice();\n\n        _p.push(j);\n\n        if (!isPlainObject(valIn[j])) {\n          list.push(format('object', base, _p, valIn[j]));\n        } else if (indexList.indexOf(j) === -1) {\n          list.push(format('unused', base, _p));\n        }\n      }\n    } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {\n      list.push(format('object', base, p, valIn));\n    } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {\n      list.push(format('array', base, p, valIn));\n    } else if (!(k in objOut)) {\n      list.push(format('unused', base, p, valIn));\n    } else if (!Lib.validate(valIn, nestedSchema)) {\n      list.push(format('value', base, p, valIn));\n    } else if (nestedSchema.valType === 'enumerated' && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {\n      list.push(format('dynamic', base, p, valIn, valOut));\n    }\n  }\n\n  return list;\n} // the 'full' layout schema depends on the traces types presents\n\n\nfunction fillLayoutSchema(schema, dataOut) {\n  var layoutSchema = schema.layout.layoutAttributes;\n\n  for (var i = 0; i < dataOut.length; i++) {\n    var traceOut = dataOut[i];\n    var traceSchema = schema.traces[traceOut.type];\n    var traceLayoutAttr = traceSchema.layoutAttributes;\n\n    if (traceLayoutAttr) {\n      if (traceOut.subplot) {\n        Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);\n      } else {\n        Lib.extendFlat(layoutSchema, traceLayoutAttr);\n      }\n    }\n  }\n\n  return layoutSchema;\n} // validation error codes\n\n\nvar code2msgFunc = {\n  object: function object(base, astr) {\n    var prefix;\n    if (base === 'layout' && astr === '') prefix = 'The layout argument';else if (base[0] === 'data' && astr === '') {\n      prefix = 'Trace ' + base[1] + ' in the data argument';\n    } else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an object container';\n  },\n  array: function array(base, astr) {\n    var prefix;\n    if (base === 'data') prefix = 'The data argument';else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an array container';\n  },\n  schema: function schema(base, astr) {\n    return inBase(base) + 'key ' + astr + ' is not part of the schema';\n  },\n  unused: function unused(base, astr, valIn) {\n    var target = isPlainObject(valIn) ? 'container' : 'key';\n    return inBase(base) + target + ' ' + astr + ' did not get coerced';\n  },\n  dynamic: function dynamic(base, astr, valIn, valOut) {\n    return [inBase(base) + 'key', astr, '(set to \\'' + valIn + '\\')', 'got reset to', '\\'' + valOut + '\\'', 'during defaults.'].join(' ');\n  },\n  invisible: function invisible(base, astr) {\n    return (astr ? inBase(base) + 'item ' + astr : 'Trace ' + base[1]) + ' got defaulted to be not visible';\n  },\n  value: function value(base, astr, valIn) {\n    return [inBase(base) + 'key ' + astr, 'is set to an invalid value (' + valIn + ')'].join(' ');\n  }\n};\n\nfunction inBase(base) {\n  if (isArray(base)) return 'In data trace ' + base[1] + ', ';\n  return 'In ' + base + ', ';\n}\n\nfunction format(code, base, path, valIn, valOut) {\n  path = path || '';\n  var container, trace; // container is either 'data' or 'layout\n  // trace is the trace index if 'data', null otherwise\n\n  if (isArray(base)) {\n    container = base[0];\n    trace = base[1];\n  } else {\n    container = base;\n    trace = null;\n  }\n\n  var astr = convertPathToAttributeString(path);\n  var msg = code2msgFunc[code](base, astr, valIn, valOut); // log to console if logger config option is enabled\n\n  Lib.log(msg);\n  return {\n    code: code,\n    container: container,\n    trace: trace,\n    path: path,\n    astr: astr,\n    msg: msg\n  };\n}\n\nfunction isInSchema(schema, key) {\n  var parts = splitKey(key);\n  var keyMinusId = parts.keyMinusId;\n  var id = parts.id;\n\n  if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {\n    return true;\n  }\n\n  return key in schema;\n}\n\nfunction getNestedSchema(schema, key) {\n  if (key in schema) return schema[key];\n  var parts = splitKey(key);\n  return schema[parts.keyMinusId];\n}\n\nvar idRegex = Lib.counterRegex('([a-z]+)');\n\nfunction splitKey(key) {\n  var idMatch = key.match(idRegex);\n  return {\n    keyMinusId: idMatch && idMatch[1],\n    id: idMatch && idMatch[2]\n  };\n}\n\nfunction convertPathToAttributeString(path) {\n  if (!isArray(path)) return String(path);\n  var astr = '';\n\n  for (var i = 0; i < path.length; i++) {\n    var p = path[i];\n\n    if (typeof p === 'number') {\n      astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n    } else {\n      astr += p;\n    }\n\n    if (i < path.length - 1) astr += '.';\n  }\n\n  return astr;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plot_api/validate.js"],"names":["Lib","require","Plots","PlotSchema","dfltConfig","isPlainObject","isArray","Array","isArrayOrTypedArray","module","exports","validate","data","layout","undefined","schema","get","errorList","gd","_context","extendFlat","dataIn","layoutIn","extendDeep","push","format","arguments","length","supplyDefaults","dataOut","_fullData","len","i","traceIn","base","traceOut","traceType","type","traceSchema","traces","attributes","valType","values","visible","crawl","transformsIn","transforms","transformsOut","j","path","transformType","transformSchema","Object","keys","layoutOut","_fullLayout","layoutSchema","fillLayoutSchema","objIn","objOut","list","k","p","slice","valIn","valOut","nestedSchema","getNestedSchema","nestedValType","isInfoArray","isColorscale","items","isInSchema","concat","arrayItems","Math","min","m","n","item","valInPart","valOutPart","dimensions","len2","_nestedSchema","indexList","_p","_index","valInj","valOutj","indexOf","coerceNumber","layoutAttributes","traceLayoutAttr","subplot","dflt","code2msgFunc","object","astr","prefix","inBase","array","unused","target","dynamic","join","invisible","value","code","container","trace","convertPathToAttributeString","msg","log","key","parts","splitKey","keyMinusId","id","_isSubplotObj","idRegex","counterRegex","idMatch","match","String","substr"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar PlotSchema = require('./plot_schema');\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\nmodule.exports = function validate(data, layout) {\n    if(data === undefined) data = [];\n    if(layout === undefined) layout = {};\n\n    var schema = PlotSchema.get();\n    var errorList = [];\n    var gd = {_context: Lib.extendFlat({}, dfltConfig)};\n\n    var dataIn, layoutIn;\n\n    if(isArray(data)) {\n        gd.data = Lib.extendDeep([], data);\n        dataIn = data;\n    } else {\n        gd.data = [];\n        dataIn = [];\n        errorList.push(format('array', 'data'));\n    }\n\n    if(isPlainObject(layout)) {\n        gd.layout = Lib.extendDeep({}, layout);\n        layoutIn = layout;\n    } else {\n        gd.layout = {};\n        layoutIn = {};\n        if(arguments.length > 1) {\n            errorList.push(format('object', 'layout'));\n        }\n    }\n\n    // N.B. dataIn and layoutIn are in general not the same as\n    // gd.data and gd.layout after supplyDefaults as some attributes\n    // in gd.data and gd.layout (still) get mutated during this step.\n\n    Plots.supplyDefaults(gd);\n\n    var dataOut = gd._fullData;\n    var len = dataIn.length;\n\n    for(var i = 0; i < len; i++) {\n        var traceIn = dataIn[i];\n        var base = ['data', i];\n\n        if(!isPlainObject(traceIn)) {\n            errorList.push(format('object', base));\n            continue;\n        }\n\n        var traceOut = dataOut[i];\n        var traceType = traceOut.type;\n        var traceSchema = schema.traces[traceType].attributes;\n\n        // PlotSchema does something fancy with trace 'type', reset it here\n        // to make the trace schema compatible with Lib.validate.\n        traceSchema.type = {\n            valType: 'enumerated',\n            values: [traceType]\n        };\n\n        if(traceOut.visible === false && traceIn.visible !== false) {\n            errorList.push(format('invisible', base));\n        }\n\n        crawl(traceIn, traceOut, traceSchema, errorList, base);\n\n        var transformsIn = traceIn.transforms;\n        var transformsOut = traceOut.transforms;\n\n        if(transformsIn) {\n            if(!isArray(transformsIn)) {\n                errorList.push(format('array', base, ['transforms']));\n            }\n\n            base.push('transforms');\n\n            for(var j = 0; j < transformsIn.length; j++) {\n                var path = ['transforms', j];\n                var transformType = transformsIn[j].type;\n\n                if(!isPlainObject(transformsIn[j])) {\n                    errorList.push(format('object', base, path));\n                    continue;\n                }\n\n                var transformSchema = schema.transforms[transformType] ?\n                    schema.transforms[transformType].attributes :\n                    {};\n\n                // add 'type' to transform schema to validate the transform type\n                transformSchema.type = {\n                    valType: 'enumerated',\n                    values: Object.keys(schema.transforms)\n                };\n\n                crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n            }\n        }\n    }\n\n    var layoutOut = gd._fullLayout;\n    var layoutSchema = fillLayoutSchema(schema, dataOut);\n\n    crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');\n\n    // return undefined if no validation errors were found\n    return (errorList.length === 0) ? void(0) : errorList;\n};\n\nfunction crawl(objIn, objOut, schema, list, base, path) {\n    path = path || [];\n\n    var keys = Object.keys(objIn);\n\n    for(var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n\n        // transforms are handled separately\n        if(k === 'transforms') continue;\n\n        var p = path.slice();\n        p.push(k);\n\n        var valIn = objIn[k];\n        var valOut = objOut[k];\n\n        var nestedSchema = getNestedSchema(schema, k);\n        var nestedValType = (nestedSchema || {}).valType;\n        var isInfoArray = nestedValType === 'info_array';\n        var isColorscale = nestedValType === 'colorscale';\n        var items = (nestedSchema || {}).items;\n\n        if(!isInSchema(schema, k)) {\n            list.push(format('schema', base, p));\n        } else if(isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== 'any') {\n            crawl(valIn, valOut, nestedSchema, list, base, p);\n        } else if(isInfoArray && isArray(valIn)) {\n            if(valIn.length > valOut.length) {\n                list.push(format('unused', base, p.concat(valOut.length)));\n            }\n            var len = valOut.length;\n            var arrayItems = Array.isArray(items);\n            if(arrayItems) len = Math.min(len, items.length);\n            var m, n, item, valInPart, valOutPart;\n            if(nestedSchema.dimensions === 2) {\n                for(n = 0; n < len; n++) {\n                    if(isArray(valIn[n])) {\n                        if(valIn[n].length > valOut[n].length) {\n                            list.push(format('unused', base, p.concat(n, valOut[n].length)));\n                        }\n                        var len2 = valOut[n].length;\n                        for(m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {\n                            item = arrayItems ? items[n][m] : items;\n                            valInPart = valIn[n][m];\n                            valOutPart = valOut[n][m];\n                            if(!Lib.validate(valInPart, item)) {\n                                list.push(format('value', base, p.concat(n, m), valInPart));\n                            } else if(valOutPart !== valInPart && valOutPart !== +valInPart) {\n                                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));\n                            }\n                        }\n                    } else {\n                        list.push(format('array', base, p.concat(n), valIn[n]));\n                    }\n                }\n            } else {\n                for(n = 0; n < len; n++) {\n                    item = arrayItems ? items[n] : items;\n                    valInPart = valIn[n];\n                    valOutPart = valOut[n];\n                    if(!Lib.validate(valInPart, item)) {\n                        list.push(format('value', base, p.concat(n), valInPart));\n                    } else if(valOutPart !== valInPart && valOutPart !== +valInPart) {\n                        list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));\n                    }\n                }\n            }\n        } else if(nestedSchema.items && !isInfoArray && isArray(valIn)) {\n            var _nestedSchema = items[Object.keys(items)[0]];\n            var indexList = [];\n\n            var j, _p;\n\n            // loop over valOut items while keeping track of their\n            // corresponding input container index (given by _index)\n            for(j = 0; j < valOut.length; j++) {\n                var _index = valOut[j]._index || j;\n\n                _p = p.slice();\n                _p.push(_index);\n\n                if(isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n                    indexList.push(_index);\n                    var valInj = valIn[_index];\n                    var valOutj = valOut[j];\n                    if(isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {\n                        list.push(format('invisible', base, _p));\n                    } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);\n                }\n            }\n\n            // loop over valIn to determine where it went wrong for some items\n            for(j = 0; j < valIn.length; j++) {\n                _p = p.slice();\n                _p.push(j);\n\n                if(!isPlainObject(valIn[j])) {\n                    list.push(format('object', base, _p, valIn[j]));\n                } else if(indexList.indexOf(j) === -1) {\n                    list.push(format('unused', base, _p));\n                }\n            }\n        } else if(!isPlainObject(valIn) && isPlainObject(valOut)) {\n            list.push(format('object', base, p, valIn));\n        } else if(!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {\n            list.push(format('array', base, p, valIn));\n        } else if(!(k in objOut)) {\n            list.push(format('unused', base, p, valIn));\n        } else if(!Lib.validate(valIn, nestedSchema)) {\n            list.push(format('value', base, p, valIn));\n        } else if(nestedSchema.valType === 'enumerated' &&\n            ((nestedSchema.coerceNumber && valIn !== +valOut) || valIn !== valOut)\n        ) {\n            list.push(format('dynamic', base, p, valIn, valOut));\n        }\n    }\n\n    return list;\n}\n\n// the 'full' layout schema depends on the traces types presents\nfunction fillLayoutSchema(schema, dataOut) {\n    var layoutSchema = schema.layout.layoutAttributes;\n\n    for(var i = 0; i < dataOut.length; i++) {\n        var traceOut = dataOut[i];\n        var traceSchema = schema.traces[traceOut.type];\n        var traceLayoutAttr = traceSchema.layoutAttributes;\n\n        if(traceLayoutAttr) {\n            if(traceOut.subplot) {\n                Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);\n            } else {\n                Lib.extendFlat(layoutSchema, traceLayoutAttr);\n            }\n        }\n    }\n\n    return layoutSchema;\n}\n\n// validation error codes\nvar code2msgFunc = {\n    object: function(base, astr) {\n        var prefix;\n\n        if(base === 'layout' && astr === '') prefix = 'The layout argument';\n        else if(base[0] === 'data' && astr === '') {\n            prefix = 'Trace ' + base[1] + ' in the data argument';\n        } else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an object container';\n    },\n    array: function(base, astr) {\n        var prefix;\n\n        if(base === 'data') prefix = 'The data argument';\n        else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an array container';\n    },\n    schema: function(base, astr) {\n        return inBase(base) + 'key ' + astr + ' is not part of the schema';\n    },\n    unused: function(base, astr, valIn) {\n        var target = isPlainObject(valIn) ? 'container' : 'key';\n\n        return inBase(base) + target + ' ' + astr + ' did not get coerced';\n    },\n    dynamic: function(base, astr, valIn, valOut) {\n        return [\n            inBase(base) + 'key',\n            astr,\n            '(set to \\'' + valIn + '\\')',\n            'got reset to',\n            '\\'' + valOut + '\\'',\n            'during defaults.'\n        ].join(' ');\n    },\n    invisible: function(base, astr) {\n        return (\n            astr ? (inBase(base) + 'item ' + astr) : ('Trace ' + base[1])\n        ) + ' got defaulted to be not visible';\n    },\n    value: function(base, astr, valIn) {\n        return [\n            inBase(base) + 'key ' + astr,\n            'is set to an invalid value (' + valIn + ')'\n        ].join(' ');\n    }\n};\n\nfunction inBase(base) {\n    if(isArray(base)) return 'In data trace ' + base[1] + ', ';\n\n    return 'In ' + base + ', ';\n}\n\nfunction format(code, base, path, valIn, valOut) {\n    path = path || '';\n\n    var container, trace;\n\n    // container is either 'data' or 'layout\n    // trace is the trace index if 'data', null otherwise\n\n    if(isArray(base)) {\n        container = base[0];\n        trace = base[1];\n    } else {\n        container = base;\n        trace = null;\n    }\n\n    var astr = convertPathToAttributeString(path);\n    var msg = code2msgFunc[code](base, astr, valIn, valOut);\n\n    // log to console if logger config option is enabled\n    Lib.log(msg);\n\n    return {\n        code: code,\n        container: container,\n        trace: trace,\n        path: path,\n        astr: astr,\n        msg: msg\n    };\n}\n\nfunction isInSchema(schema, key) {\n    var parts = splitKey(key);\n    var keyMinusId = parts.keyMinusId;\n    var id = parts.id;\n\n    if((keyMinusId in schema) && schema[keyMinusId]._isSubplotObj && id) {\n        return true;\n    }\n\n    return (key in schema);\n}\n\nfunction getNestedSchema(schema, key) {\n    if(key in schema) return schema[key];\n\n    var parts = splitKey(key);\n\n    return schema[parts.keyMinusId];\n}\n\nvar idRegex = Lib.counterRegex('([a-z]+)');\n\nfunction splitKey(key) {\n    var idMatch = key.match(idRegex);\n\n    return {\n        keyMinusId: idMatch && idMatch[1],\n        id: idMatch && idMatch[2]\n    };\n}\n\nfunction convertPathToAttributeString(path) {\n    if(!isArray(path)) return String(path);\n\n    var astr = '';\n\n    for(var i = 0; i < path.length; i++) {\n        var p = path[i];\n\n        if(typeof p === 'number') {\n            astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n        } else {\n            astr += p;\n        }\n\n        if(i < path.length - 1) astr += '.';\n    }\n\n    return astr;\n}\n"]},"metadata":{},"sourceType":"script"}