{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar binFunctions = require('../histogram/bin_functions');\n\nvar normFunctions = require('../histogram/norm_functions');\n\nvar doAvg = require('../histogram/average');\n\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\n\nvar calcAllAutoBins = require('../histogram/calc').calcAllAutoBins;\n\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var xcalendar = trace.xcalendar;\n  var ycalendar = trace.ycalendar;\n\n  var xr2c = function (v) {\n    return xa.r2c(v, 0, xcalendar);\n  };\n\n  var yr2c = function (v) {\n    return ya.r2c(v, 0, ycalendar);\n  };\n\n  var xc2r = function (v) {\n    return xa.c2r(v, 0, xcalendar);\n  };\n\n  var yc2r = function (v) {\n    return ya.c2r(v, 0, ycalendar);\n  };\n\n  var i, j, n, m; // calculate the bins\n\n  var xBinsAndPos = calcAllAutoBins(gd, trace, xa, 'x');\n  var xBinSpec = xBinsAndPos[0];\n  var xPos0 = xBinsAndPos[1];\n  var yBinsAndPos = calcAllAutoBins(gd, trace, ya, 'y');\n  var yBinSpec = yBinsAndPos[0];\n  var yPos0 = yBinsAndPos[1];\n  var serieslen = trace._length;\n  if (xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);\n  if (yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen); // make the empty bin array & scale the map\n\n  var z = [];\n  var onecol = [];\n  var zerocol = [];\n  var nonuniformBinsX = typeof xBinSpec.size === 'string';\n  var nonuniformBinsY = typeof yBinSpec.size === 'string';\n  var xEdges = [];\n  var yEdges = [];\n  var xbins = nonuniformBinsX ? xEdges : xBinSpec;\n  var ybins = nonuniformBinsY ? yEdges : yBinSpec;\n  var total = 0;\n  var counts = [];\n  var inputPoints = [];\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densitynorm = norm.indexOf('density') !== -1;\n  var extremefunc = func === 'max' || func === 'min';\n  var sizeinit = extremefunc ? null : 0;\n  var binfunc = binFunctions.count;\n  var normfunc = normFunctions[norm];\n  var doavg = false;\n  var xinc = [];\n  var yinc = []; // set a binning function other than count?\n  // for binning functions: check first for 'z',\n  // then 'mc' in case we had a colored scatter plot\n  // and want to transfer these colors to the 2D histo\n  // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n\n  var rawCounterData = 'z' in trace ? trace.z : 'marker' in trace && Array.isArray(trace.marker.color) ? trace.marker.color : '';\n\n  if (rawCounterData && func !== 'count') {\n    doavg = func === 'avg';\n    binfunc = binFunctions[func];\n  } // decrease end a little in case of rounding errors\n\n\n  var xBinSize = xBinSpec.size;\n  var xBinStart = xr2c(xBinSpec.start);\n  var xBinEnd = xr2c(xBinSpec.end) + (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;\n\n  for (i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {\n    onecol.push(sizeinit);\n    xEdges.push(i);\n    if (doavg) zerocol.push(0);\n  }\n\n  xEdges.push(i);\n  var nx = onecol.length;\n  var dx = (i - xBinStart) / nx;\n  var x0 = xc2r(xBinStart + dx / 2);\n  var yBinSize = yBinSpec.size;\n  var yBinStart = yr2c(yBinSpec.start);\n  var yBinEnd = yr2c(yBinSpec.end) + (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;\n\n  for (i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {\n    z.push(onecol.slice());\n    yEdges.push(i);\n    var ipCol = new Array(nx);\n\n    for (j = 0; j < nx; j++) ipCol[j] = [];\n\n    inputPoints.push(ipCol);\n    if (doavg) counts.push(zerocol.slice());\n  }\n\n  yEdges.push(i);\n  var ny = z.length;\n  var dy = (i - yBinStart) / ny;\n  var y0 = yc2r(yBinStart + dy / 2);\n\n  if (densitynorm) {\n    xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n    yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n  } // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n\n\n  if (!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n  if (!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins); // put data into bins\n\n  var uniqueValsPerX = true;\n  var uniqueValsPerY = true;\n  var xVals = new Array(nx);\n  var yVals = new Array(ny);\n  var xGapLow = Infinity;\n  var xGapHigh = Infinity;\n  var yGapLow = Infinity;\n  var yGapHigh = Infinity;\n\n  for (i = 0; i < serieslen; i++) {\n    var xi = xPos0[i];\n    var yi = yPos0[i];\n    n = Lib.findBin(xi, xbins);\n    m = Lib.findBin(yi, ybins);\n\n    if (n >= 0 && n < nx && m >= 0 && m < ny) {\n      total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n      inputPoints[m][n].push(i);\n\n      if (uniqueValsPerX) {\n        if (xVals[n] === undefined) xVals[n] = xi;else if (xVals[n] !== xi) uniqueValsPerX = false;\n      }\n\n      if (uniqueValsPerY) {\n        if (yVals[m] === undefined) yVals[m] = yi;else if (yVals[m] !== yi) uniqueValsPerY = false;\n      }\n\n      xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n      xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n      yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n      yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n    }\n  } // normalize, if needed\n\n\n  if (doavg) {\n    for (m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n  }\n\n  if (normfunc) {\n    for (m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n  }\n\n  return {\n    x: xPos0,\n    xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n    x0: x0,\n    dx: dx,\n    y: yPos0,\n    yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n    y0: y0,\n    dy: dy,\n    z: z,\n    pts: inputPoints\n  };\n};\n\nfunction makeIncrements(len, bins, dv, nonuniform) {\n  var out = new Array(len);\n  var i;\n\n  if (nonuniform) {\n    for (i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n  } else {\n    var inc = 1 / dv;\n\n    for (i = 0; i < len; i++) out[i] = inc;\n  }\n\n  return out;\n}\n\nfunction binsToCalc(r2c, bins) {\n  return {\n    start: r2c(bins.start),\n    end: r2c(bins.end),\n    size: bins.size\n  };\n}\n\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n  var i;\n  var len = edges.length - 1;\n  var out = new Array(len);\n  var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n\n  for (i = 0; i < len; i++) {\n    var v = (uniqueVals || [])[i];\n    out[i] = v === undefined ? [roundFn(edges[i]), roundFn(edges[i + 1], true)] : [v, v];\n  }\n\n  return out;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/histogram2d/calc.js"],"names":["Lib","require","Axes","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","calcAllAutoBins","module","exports","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","xcalendar","ycalendar","xr2c","v","r2c","yr2c","xc2r","c2r","yc2r","i","j","n","m","xBinsAndPos","xBinSpec","xPos0","yBinsAndPos","yBinSpec","yPos0","serieslen","_length","length","splice","z","onecol","zerocol","nonuniformBinsX","size","nonuniformBinsY","xEdges","yEdges","xbins","ybins","total","counts","inputPoints","norm","histnorm","func","histfunc","densitynorm","indexOf","extremefunc","sizeinit","binfunc","count","normfunc","doavg","xinc","yinc","rawCounterData","Array","isArray","marker","color","xBinSize","xBinStart","start","xBinEnd","end","tickIncrement","push","nx","dx","x0","yBinSize","yBinStart","yBinEnd","slice","ipCol","ny","dy","y0","makeIncrements","type","binsToCalc","uniqueValsPerX","uniqueValsPerY","xVals","yVals","xGapLow","Infinity","xGapHigh","yGapLow","yGapHigh","xi","yi","findBin","undefined","Math","min","x","xRanges","getRanges","y","yRanges","pts","len","bins","dv","nonuniform","out","inc","edges","uniqueVals","gapLow","gapHigh","ax","calendar","roundFn"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar binFunctions = require('../histogram/bin_functions');\nvar normFunctions = require('../histogram/norm_functions');\nvar doAvg = require('../histogram/average');\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\nvar calcAllAutoBins = require('../histogram/calc').calcAllAutoBins;\n\nmodule.exports = function calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var xr2c = function(v) { return xa.r2c(v, 0, xcalendar); };\n    var yr2c = function(v) { return ya.r2c(v, 0, ycalendar); };\n    var xc2r = function(v) { return xa.c2r(v, 0, xcalendar); };\n    var yc2r = function(v) { return ya.c2r(v, 0, ycalendar); };\n\n    var i, j, n, m;\n\n    // calculate the bins\n    var xBinsAndPos = calcAllAutoBins(gd, trace, xa, 'x');\n    var xBinSpec = xBinsAndPos[0];\n    var xPos0 = xBinsAndPos[1];\n    var yBinsAndPos = calcAllAutoBins(gd, trace, ya, 'y');\n    var yBinSpec = yBinsAndPos[0];\n    var yPos0 = yBinsAndPos[1];\n\n    var serieslen = trace._length;\n    if(xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);\n    if(yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen);\n\n    // make the empty bin array & scale the map\n    var z = [];\n    var onecol = [];\n    var zerocol = [];\n    var nonuniformBinsX = typeof xBinSpec.size === 'string';\n    var nonuniformBinsY = typeof yBinSpec.size === 'string';\n    var xEdges = [];\n    var yEdges = [];\n    var xbins = nonuniformBinsX ? xEdges : xBinSpec;\n    var ybins = nonuniformBinsY ? yEdges : yBinSpec;\n    var total = 0;\n    var counts = [];\n    var inputPoints = [];\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densitynorm = norm.indexOf('density') !== -1;\n    var extremefunc = func === 'max' || func === 'min';\n    var sizeinit = extremefunc ? null : 0;\n    var binfunc = binFunctions.count;\n    var normfunc = normFunctions[norm];\n    var doavg = false;\n    var xinc = [];\n    var yinc = [];\n\n    // set a binning function other than count?\n    // for binning functions: check first for 'z',\n    // then 'mc' in case we had a colored scatter plot\n    // and want to transfer these colors to the 2D histo\n    // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n    var rawCounterData = ('z' in trace) ?\n        trace.z :\n        (('marker' in trace && Array.isArray(trace.marker.color)) ?\n            trace.marker.color : '');\n    if(rawCounterData && func !== 'count') {\n        doavg = func === 'avg';\n        binfunc = binFunctions[func];\n    }\n\n    // decrease end a little in case of rounding errors\n    var xBinSize = xBinSpec.size;\n    var xBinStart = xr2c(xBinSpec.start);\n    var xBinEnd = xr2c(xBinSpec.end) +\n        (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;\n\n    for(i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {\n        onecol.push(sizeinit);\n        xEdges.push(i);\n        if(doavg) zerocol.push(0);\n    }\n    xEdges.push(i);\n\n    var nx = onecol.length;\n    var dx = (i - xBinStart) / nx;\n    var x0 = xc2r(xBinStart + dx / 2);\n\n    var yBinSize = yBinSpec.size;\n    var yBinStart = yr2c(yBinSpec.start);\n    var yBinEnd = yr2c(yBinSpec.end) +\n        (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;\n\n    for(i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {\n        z.push(onecol.slice());\n        yEdges.push(i);\n        var ipCol = new Array(nx);\n        for(j = 0; j < nx; j++) ipCol[j] = [];\n        inputPoints.push(ipCol);\n        if(doavg) counts.push(zerocol.slice());\n    }\n    yEdges.push(i);\n\n    var ny = z.length;\n    var dy = (i - yBinStart) / ny;\n    var y0 = yc2r(yBinStart + dy / 2);\n\n    if(densitynorm) {\n        xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n        yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n    }\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n    if(!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins);\n\n    // put data into bins\n    var uniqueValsPerX = true;\n    var uniqueValsPerY = true;\n    var xVals = new Array(nx);\n    var yVals = new Array(ny);\n    var xGapLow = Infinity;\n    var xGapHigh = Infinity;\n    var yGapLow = Infinity;\n    var yGapHigh = Infinity;\n    for(i = 0; i < serieslen; i++) {\n        var xi = xPos0[i];\n        var yi = yPos0[i];\n        n = Lib.findBin(xi, xbins);\n        m = Lib.findBin(yi, ybins);\n        if(n >= 0 && n < nx && m >= 0 && m < ny) {\n            total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n            inputPoints[m][n].push(i);\n\n            if(uniqueValsPerX) {\n                if(xVals[n] === undefined) xVals[n] = xi;\n                else if(xVals[n] !== xi) uniqueValsPerX = false;\n            }\n            if(uniqueValsPerY) {\n                if(yVals[m] === undefined) yVals[m] = yi;\n                else if(yVals[m] !== yi) uniqueValsPerY = false;\n            }\n\n            xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n            xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n            yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n            yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n        }\n    }\n    // normalize, if needed\n    if(doavg) {\n        for(m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n    }\n    if(normfunc) {\n        for(m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n    }\n\n    return {\n        x: xPos0,\n        xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n        x0: x0,\n        dx: dx,\n        y: yPos0,\n        yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n        y0: y0,\n        dy: dy,\n        z: z,\n        pts: inputPoints\n    };\n};\n\nfunction makeIncrements(len, bins, dv, nonuniform) {\n    var out = new Array(len);\n    var i;\n    if(nonuniform) {\n        for(i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n    } else {\n        var inc = 1 / dv;\n        for(i = 0; i < len; i++) out[i] = inc;\n    }\n    return out;\n}\n\nfunction binsToCalc(r2c, bins) {\n    return {\n        start: r2c(bins.start),\n        end: r2c(bins.end),\n        size: bins.size\n    };\n}\n\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n    var i;\n    var len = edges.length - 1;\n    var out = new Array(len);\n    var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n\n    for(i = 0; i < len; i++) {\n        var v = (uniqueVals || [])[i];\n        out[i] = v === undefined ?\n            [roundFn(edges[i]), roundFn(edges[i + 1], true)] :\n            [v, v];\n    }\n    return out;\n}\n"]},"metadata":{},"sourceType":"script"}