{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar makeComputeError = require('./compute_error');\n\nmodule.exports = function calc(gd) {\n  var calcdata = gd.calcdata;\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var calcTrace = calcdata[i];\n    var trace = calcTrace[0].trace;\n\n    if (trace.visible === true && Registry.traceIs(trace, 'errorBarsOK')) {\n      var xa = Axes.getFromId(gd, trace.xaxis);\n      var ya = Axes.getFromId(gd, trace.yaxis);\n      calcOneAxis(calcTrace, trace, xa, 'x');\n      calcOneAxis(calcTrace, trace, ya, 'y');\n    }\n  }\n};\n\nfunction calcOneAxis(calcTrace, trace, axis, coord) {\n  var opts = trace['error_' + coord] || {};\n  var isVisible = opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1;\n  var vals = [];\n  if (!isVisible) return;\n  var computeError = makeComputeError(opts);\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var iIn = calcPt.i; // for types that don't include `i` in each calcdata point\n\n    if (iIn === undefined) iIn = i; // for stacked area inserted points\n    // TODO: errorbars have been tested cursorily with stacked area,\n    // but not thoroughly. It's not even really clear what you want to do:\n    // Should it just be calculated based on that trace's size data?\n    // Should you add errors from below in quadrature?\n    // And what about normalization, where in principle the errors shrink\n    // again when you get up to the top end?\n    // One option would be to forbid errorbars with stacking until we\n    // decide how to handle these questions.\n    else if (iIn === null) continue;\n    var calcCoord = calcPt[coord];\n    if (!isNumeric(axis.c2l(calcCoord))) continue;\n    var errors = computeError(calcCoord, iIn);\n\n    if (isNumeric(errors[0]) && isNumeric(errors[1])) {\n      var shoe = calcPt[coord + 's'] = calcCoord - errors[0];\n      var hat = calcPt[coord + 'h'] = calcCoord + errors[1];\n      vals.push(shoe, hat);\n    }\n  }\n\n  var axId = axis._id;\n  var baseExtremes = trace._extremes[axId];\n  var extremes = Axes.findExtremes(axis, vals, Lib.extendFlat({\n    tozero: baseExtremes.opts.tozero\n  }, {\n    padded: true\n  }));\n  baseExtremes.min = baseExtremes.min.concat(extremes.min);\n  baseExtremes.max = baseExtremes.max.concat(extremes.max);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/components/errorbars/calc.js"],"names":["isNumeric","require","Registry","Axes","Lib","makeComputeError","module","exports","calc","gd","calcdata","i","length","calcTrace","trace","visible","traceIs","xa","getFromId","xaxis","ya","yaxis","calcOneAxis","axis","coord","opts","isVisible","indexOf","type","vals","computeError","calcPt","iIn","undefined","calcCoord","c2l","errors","shoe","hat","push","axId","_id","baseExtremes","_extremes","extremes","findExtremes","extendFlat","tozero","padded","min","concat","max"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\n\nvar makeComputeError = require('./compute_error');\n\nmodule.exports = function calc(gd) {\n    var calcdata = gd.calcdata;\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var calcTrace = calcdata[i];\n        var trace = calcTrace[0].trace;\n\n        if(trace.visible === true && Registry.traceIs(trace, 'errorBarsOK')) {\n            var xa = Axes.getFromId(gd, trace.xaxis);\n            var ya = Axes.getFromId(gd, trace.yaxis);\n            calcOneAxis(calcTrace, trace, xa, 'x');\n            calcOneAxis(calcTrace, trace, ya, 'y');\n        }\n    }\n};\n\nfunction calcOneAxis(calcTrace, trace, axis, coord) {\n    var opts = trace['error_' + coord] || {};\n    var isVisible = (opts.visible && ['linear', 'log'].indexOf(axis.type) !== -1);\n    var vals = [];\n\n    if(!isVisible) return;\n\n    var computeError = makeComputeError(opts);\n\n    for(var i = 0; i < calcTrace.length; i++) {\n        var calcPt = calcTrace[i];\n\n        var iIn = calcPt.i;\n\n        // for types that don't include `i` in each calcdata point\n        if(iIn === undefined) iIn = i;\n\n        // for stacked area inserted points\n        // TODO: errorbars have been tested cursorily with stacked area,\n        // but not thoroughly. It's not even really clear what you want to do:\n        // Should it just be calculated based on that trace's size data?\n        // Should you add errors from below in quadrature?\n        // And what about normalization, where in principle the errors shrink\n        // again when you get up to the top end?\n        // One option would be to forbid errorbars with stacking until we\n        // decide how to handle these questions.\n        else if(iIn === null) continue;\n\n        var calcCoord = calcPt[coord];\n\n        if(!isNumeric(axis.c2l(calcCoord))) continue;\n\n        var errors = computeError(calcCoord, iIn);\n        if(isNumeric(errors[0]) && isNumeric(errors[1])) {\n            var shoe = calcPt[coord + 's'] = calcCoord - errors[0];\n            var hat = calcPt[coord + 'h'] = calcCoord + errors[1];\n            vals.push(shoe, hat);\n        }\n    }\n\n    var axId = axis._id;\n    var baseExtremes = trace._extremes[axId];\n    var extremes = Axes.findExtremes(\n        axis,\n        vals,\n        Lib.extendFlat({tozero: baseExtremes.opts.tozero}, {padded: true})\n    );\n    baseExtremes.min = baseExtremes.min.concat(extremes.min);\n    baseExtremes.max = baseExtremes.max.concat(extremes.max);\n}\n"]},"metadata":{},"sourceType":"script"}