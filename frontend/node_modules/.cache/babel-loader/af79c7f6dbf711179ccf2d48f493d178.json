{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nvar vec4 = require('gl-vec4');\n\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\nvar streamToTube = function streamToTube(stream, maxDivergence, minDistance, maxNorm) {\n  var points = stream.points;\n  var velocities = stream.velocities;\n  var divergences = stream.divergences;\n  var verts = [];\n  var faces = [];\n  var vectors = [];\n  var previousVerts = [];\n  var currentVerts = [];\n  var intensities = [];\n  var previousIntensity = 0;\n  var currentIntensity = 0;\n  var currentVector = vec4.create();\n  var previousVector = vec4.create();\n  var facets = 8;\n\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    var fwd = velocities[i];\n    var r = divergences[i];\n\n    if (maxDivergence === 0) {\n      r = minDistance * 0.05;\n    }\n\n    currentIntensity = vec3.length(fwd) / maxNorm;\n    currentVector = vec4.create();\n    vec3.copy(currentVector, fwd);\n    currentVector[3] = r;\n\n    for (var a = 0; a < facets; a++) {\n      currentVerts[a] = [p[0], p[1], p[2], a];\n    }\n\n    if (previousVerts.length > 0) {\n      for (var a = 0; a < facets; a++) {\n        var a1 = (a + 1) % facets;\n        verts.push(previousVerts[a], currentVerts[a], currentVerts[a1], currentVerts[a1], previousVerts[a1], previousVerts[a]);\n        vectors.push(previousVector, currentVector, currentVector, currentVector, previousVector, previousVector);\n        intensities.push(previousIntensity, currentIntensity, currentIntensity, currentIntensity, previousIntensity, previousIntensity);\n        var len = verts.length;\n        faces.push([len - 6, len - 5, len - 4], [len - 3, len - 2, len - 1]);\n      }\n    }\n\n    var tmp1 = previousVerts;\n    previousVerts = currentVerts;\n    currentVerts = tmp1;\n    var tmp2 = previousVector;\n    previousVector = currentVector;\n    currentVector = tmp2;\n    var tmp3 = previousIntensity;\n    previousIntensity = currentIntensity;\n    currentIntensity = tmp3;\n  }\n\n  return {\n    positions: verts,\n    cells: faces,\n    vectors: vectors,\n    vertexIntensity: intensities\n  };\n};\n\nvar createTubes = function createTubes(streams, colormap, maxDivergence, minDistance) {\n  var maxNorm = 0;\n\n  for (var i = 0; i < streams.length; i++) {\n    var velocities = streams[i].velocities;\n\n    for (var j = 0; j < velocities.length; j++) {\n      maxNorm = Math.max(maxNorm, vec3.length(velocities[j]));\n    }\n  }\n\n  var tubes = streams.map(function (s) {\n    return streamToTube(s, maxDivergence, minDistance, maxNorm);\n  });\n  var positions = [];\n  var cells = [];\n  var vectors = [];\n  var vertexIntensity = [];\n\n  for (var i = 0; i < tubes.length; i++) {\n    var tube = tubes[i];\n    var offset = positions.length;\n    positions = positions.concat(tube.positions);\n    vectors = vectors.concat(tube.vectors);\n    vertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n\n    for (var j = 0; j < tube.cells.length; j++) {\n      var cell = tube.cells[j];\n      var newCell = [];\n      cells.push(newCell);\n\n      for (var k = 0; k < cell.length; k++) {\n        newCell.push(cell[k] + offset);\n      }\n    }\n  }\n\n  return {\n    positions: positions,\n    cells: cells,\n    vectors: vectors,\n    vertexIntensity: vertexIntensity,\n    colormap: colormap\n  };\n};\n\nvar findLastSmallerIndex = function findLastSmallerIndex(points, v) {\n  var len = points.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    var p = points[i];\n    if (p === v) return i;else if (p > v) return i - 1;\n  }\n\n  return i;\n};\n\nvar clamp = function clamp(v, min, max) {\n  return v < min ? min : v > max ? max : v;\n};\n\nvar sampleMeshgrid = function sampleMeshgrid(point, vectorField, gridInfo) {\n  var vectors = vectorField.vectors;\n  var meshgrid = vectorField.meshgrid;\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = meshgrid[0].length;\n  var h = meshgrid[1].length;\n  var d = meshgrid[2].length; // Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n  // The nearest smaller value index for x is the index x0 such that\n  // meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\n  var x0 = findLastSmallerIndex(meshgrid[0], x);\n  var y0 = findLastSmallerIndex(meshgrid[1], y);\n  var z0 = findLastSmallerIndex(meshgrid[2], z); // Get the nearest larger meshgrid value indices.\n  // From the above \"nearest smaller value\", we know that\n  //   meshgrid[0][x0] < x\n  //   meshgrid[0][x0+1] >= x\n\n  var x1 = x0 + 1;\n  var y1 = y0 + 1;\n  var z1 = z0 + 1;\n  x0 = clamp(x0, 0, w - 1);\n  x1 = clamp(x1, 0, w - 1);\n  y0 = clamp(y0, 0, h - 1);\n  y1 = clamp(y1, 0, h - 1);\n  z0 = clamp(z0, 0, d - 1);\n  z1 = clamp(z1, 0, d - 1); // Reject points outside the meshgrid, return a zero vector.\n\n  if (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w - 1 || y1 > h - 1 || z1 > d - 1) {\n    return vec3.create();\n  } // Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\n\n  var mX0 = meshgrid[0][x0];\n  var mX1 = meshgrid[0][x1];\n  var mY0 = meshgrid[1][y0];\n  var mY1 = meshgrid[1][y1];\n  var mZ0 = meshgrid[2][z0];\n  var mZ1 = meshgrid[2][z1];\n  var xf = (x - mX0) / (mX1 - mX0);\n  var yf = (y - mY0) / (mY1 - mY0);\n  var zf = (z - mZ0) / (mZ1 - mZ0);\n  if (!isFinite(xf)) xf = 0.5;\n  if (!isFinite(yf)) yf = 0.5;\n  if (!isFinite(zf)) zf = 0.5;\n  var x0off;\n  var x1off;\n  var y0off;\n  var y1off;\n  var z0off;\n  var z1off;\n\n  if (gridInfo.reversedX) {\n    x0 = w - 1 - x0;\n    x1 = w - 1 - x1;\n  }\n\n  if (gridInfo.reversedY) {\n    y0 = h - 1 - y0;\n    y1 = h - 1 - y1;\n  }\n\n  if (gridInfo.reversedZ) {\n    z0 = d - 1 - z0;\n    z1 = d - 1 - z1;\n  }\n\n  switch (gridInfo.filled) {\n    case 5:\n      // 'zyx'\n      z0off = z0;\n      z1off = z1;\n      y0off = y0 * d;\n      y1off = y1 * d;\n      x0off = x0 * d * h;\n      x1off = x1 * d * h;\n      break;\n\n    case 4:\n      // 'zxy'\n      z0off = z0;\n      z1off = z1;\n      x0off = x0 * d;\n      x1off = x1 * d;\n      y0off = y0 * d * w;\n      y1off = y1 * d * w;\n      break;\n\n    case 3:\n      // 'yzx'\n      y0off = y0;\n      y1off = y1;\n      z0off = z0 * h;\n      z1off = z1 * h;\n      x0off = x0 * h * d;\n      x1off = x1 * h * d;\n      break;\n\n    case 2:\n      // 'yxz'\n      y0off = y0;\n      y1off = y1;\n      x0off = x0 * h;\n      x1off = x1 * h;\n      z0off = z0 * h * w;\n      z1off = z1 * h * w;\n      break;\n\n    case 1:\n      // 'xzy'\n      x0off = x0;\n      x1off = x1;\n      z0off = z0 * w;\n      z1off = z1 * w;\n      y0off = y0 * w * d;\n      y1off = y1 * w * d;\n      break;\n\n    default:\n      // case 0: // 'xyz'\n      x0off = x0;\n      x1off = x1;\n      y0off = y0 * w;\n      y1off = y1 * w;\n      z0off = z0 * w * h;\n      z1off = z1 * w * h;\n      break;\n  } // Sample data vectors around the (x,y,z) point.\n\n\n  var v000 = vectors[x0off + y0off + z0off];\n  var v001 = vectors[x0off + y0off + z1off];\n  var v010 = vectors[x0off + y1off + z0off];\n  var v011 = vectors[x0off + y1off + z1off];\n  var v100 = vectors[x1off + y0off + z0off];\n  var v101 = vectors[x1off + y0off + z1off];\n  var v110 = vectors[x1off + y1off + z0off];\n  var v111 = vectors[x1off + y1off + z1off];\n  var c00 = vec3.create();\n  var c01 = vec3.create();\n  var c10 = vec3.create();\n  var c11 = vec3.create();\n  vec3.lerp(c00, v000, v100, xf);\n  vec3.lerp(c01, v001, v101, xf);\n  vec3.lerp(c10, v010, v110, xf);\n  vec3.lerp(c11, v011, v111, xf);\n  var c0 = vec3.create();\n  var c1 = vec3.create();\n  vec3.lerp(c0, c00, c10, yf);\n  vec3.lerp(c1, c01, c11, yf);\n  var c = vec3.create();\n  vec3.lerp(c, c0, c1, zf);\n  return c;\n};\n\nvar vabs = function vabs(dst, v) {\n  var x = v[0];\n  var y = v[1];\n  var z = v[2];\n  dst[0] = x < 0 ? -x : x;\n  dst[1] = y < 0 ? -y : y;\n  dst[2] = z < 0 ? -z : z;\n  return dst;\n};\n\nvar findMinSeparation = function findMinSeparation(xs) {\n  var minSeparation = Infinity;\n  xs.sort(function (a, b) {\n    return a - b;\n  });\n  var len = xs.length;\n\n  for (var i = 1; i < len; i++) {\n    var d = Math.abs(xs[i] - xs[i - 1]);\n\n    if (d < minSeparation) {\n      minSeparation = d;\n    }\n  }\n\n  return minSeparation;\n}; // Finds the minimum per-component distance in positions.\n//\n\n\nvar calculateMinPositionDistance = function calculateMinPositionDistance(positions) {\n  var xs = [],\n      ys = [],\n      zs = [];\n  var xi = {},\n      yi = {},\n      zi = {};\n  var len = positions.length;\n\n  for (var i = 0; i < len; i++) {\n    var p = positions[i];\n    var x = p[0],\n        y = p[1],\n        z = p[2]; // Split the positions array into arrays of unique component values.\n    //\n    // Why go through the trouble of using a uniqueness hash table vs\n    // sort and uniq:\n    //\n    // Suppose you've got a million positions in a 100x100x100 grid.\n    //\n    // Using a uniqueness hash table, you're doing 1M array reads,\n    // 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n    // sorting three 100-element arrays and iterating over them.\n    // Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n    //          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n    //          =~ 15M\n    //\n    // Sort and uniq solution would do 1M array reads, 3M array inserts,\n    // sort three 1M-element arrays and iterate over them.\n    // Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n    //          1M + 3M + 41.4M + 3M\n    //          =~ 48.4M\n    //\n    // Guessing that a hard-coded sort & uniq would be faster due to not having\n    // to run a hashing function on everything. More memory usage though\n    // (bunch of small hash tables vs. duplicating the input array.)\n    //\n    // In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n    // maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n    // Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n    //\n    // ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n    //\n\n    if (!xi[x]) {\n      xs.push(x);\n      xi[x] = true;\n    }\n\n    if (!yi[y]) {\n      ys.push(y);\n      yi[y] = true;\n    }\n\n    if (!zi[z]) {\n      zs.push(z);\n      zi[z] = true;\n    }\n  }\n\n  var xSep = findMinSeparation(xs);\n  var ySep = findMinSeparation(ys);\n  var zSep = findMinSeparation(zs);\n  var minSeparation = Math.min(xSep, ySep, zSep);\n  return isFinite(minSeparation) ? minSeparation : 1;\n};\n\nmodule.exports = function (vectorField, bounds) {\n  var positions = vectorField.startingPositions;\n  var maxLength = vectorField.maxLength || 1000;\n  var tubeSize = vectorField.tubeSize || 1;\n  var absoluteTubeSize = vectorField.absoluteTubeSize;\n  var gridFill = vectorField.gridFill || '+x+y+z';\n  var gridInfo = {};\n\n  if (gridFill.indexOf('-x') !== -1) {\n    gridInfo.reversedX = true;\n  }\n\n  if (gridFill.indexOf('-y') !== -1) {\n    gridInfo.reversedY = true;\n  }\n\n  if (gridFill.indexOf('-z') !== -1) {\n    gridInfo.reversedZ = true;\n  }\n\n  gridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n  var getVelocity = vectorField.getVelocity || function (p) {\n    return sampleMeshgrid(p, vectorField, gridInfo);\n  };\n\n  var getDivergence = vectorField.getDivergence || function (p, v0) {\n    var dp = vec3.create();\n    var e = 0.0001;\n    vec3.add(dp, p, [e, 0, 0]);\n    var vx = getVelocity(dp);\n    vec3.subtract(vx, vx, v0);\n    vec3.scale(vx, vx, 1 / e);\n    vec3.add(dp, p, [0, e, 0]);\n    var vy = getVelocity(dp);\n    vec3.subtract(vy, vy, v0);\n    vec3.scale(vy, vy, 1 / e);\n    vec3.add(dp, p, [0, 0, e]);\n    var vz = getVelocity(dp);\n    vec3.subtract(vz, vz, v0);\n    vec3.scale(vz, vz, 1 / e);\n    vec3.add(dp, vx, vy);\n    vec3.add(dp, dp, vz);\n    return dp;\n  };\n\n  var streams = [];\n  var minX = bounds[0][0],\n      minY = bounds[0][1],\n      minZ = bounds[0][2];\n  var maxX = bounds[1][0],\n      maxY = bounds[1][1],\n      maxZ = bounds[1][2];\n\n  var inBounds = function inBounds(p) {\n    var x = p[0];\n    var y = p[1];\n    var z = p[2];\n    return !(x < minX || x > maxX || y < minY || y > maxY || z < minZ || z > maxZ);\n  };\n\n  var boundsSize = vec3.distance(bounds[0], bounds[1]);\n  var maxStepSize = 10 * boundsSize / maxLength;\n  var maxStepSizeSq = maxStepSize * maxStepSize;\n  var minDistance = 1;\n  var maxDivergence = 0; // For component-wise divergence vec3.create();\n  // In case we need to do component-wise divergence visualization\n  // var tmp = vec3.create();\n\n  var len = positions.length;\n\n  if (len > 1) {\n    minDistance = calculateMinPositionDistance(positions);\n  }\n\n  for (var i = 0; i < len; i++) {\n    var p = vec3.create();\n    vec3.copy(p, positions[i]);\n    var stream = [p];\n    var velocities = [];\n    var v = getVelocity(p);\n    var op = p;\n    velocities.push(v);\n    var divergences = [];\n    var dv = getDivergence(p, v);\n    var dvLength = vec3.length(dv);\n\n    if (isFinite(dvLength) && dvLength > maxDivergence) {\n      maxDivergence = dvLength;\n    } // In case we need to do component-wise divergence visualization\n    // vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n    divergences.push(dvLength);\n    streams.push({\n      points: stream,\n      velocities: velocities,\n      divergences: divergences\n    });\n    var j = 0;\n\n    while (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n      j++;\n      var np = vec3.clone(v);\n      var sqLen = vec3.squaredLength(np);\n\n      if (sqLen === 0) {\n        break;\n      } else if (sqLen > maxStepSizeSq) {\n        vec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n      }\n\n      vec3.add(np, np, p);\n      v = getVelocity(np);\n\n      if (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n        stream.push(np);\n        op = np;\n        velocities.push(v);\n        var dv = getDivergence(np, v);\n        var dvLength = vec3.length(dv);\n\n        if (isFinite(dvLength) && dvLength > maxDivergence) {\n          maxDivergence = dvLength;\n        } // In case we need to do component-wise divergence visualization\n        //vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n        divergences.push(dvLength);\n      }\n\n      p = np;\n    }\n  }\n\n  var tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n\n  if (absoluteTubeSize) {\n    tubes.tubeScale = absoluteTubeSize;\n  } else {\n    // Avoid division by zero.\n    if (maxDivergence === 0) {\n      maxDivergence = 1;\n    }\n\n    tubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n  }\n\n  return tubes;\n};\n\nvar shaders = require('./lib/shaders');\n\nvar createMesh = require('gl-cone3d').createMesh;\n\nmodule.exports.createTubeMesh = function (gl, params) {\n  return createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'streamtube'\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/gl-streamtube3d/streamtube.js"],"names":["vec3","require","vec4","GRID_TYPES","streamToTube","stream","maxDivergence","minDistance","maxNorm","points","velocities","divergences","verts","faces","vectors","previousVerts","currentVerts","intensities","previousIntensity","currentIntensity","currentVector","create","previousVector","facets","i","length","p","fwd","r","copy","a","a1","push","len","tmp1","tmp2","tmp3","positions","cells","vertexIntensity","createTubes","streams","colormap","j","Math","max","tubes","map","s","tube","offset","concat","cell","newCell","k","findLastSmallerIndex","v","clamp","min","sampleMeshgrid","point","vectorField","gridInfo","meshgrid","x","y","z","w","h","d","x0","y0","z0","x1","y1","z1","mX0","mX1","mY0","mY1","mZ0","mZ1","xf","yf","zf","isFinite","x0off","x1off","y0off","y1off","z0off","z1off","reversedX","reversedY","reversedZ","filled","v000","v001","v010","v011","v100","v101","v110","v111","c00","c01","c10","c11","lerp","c0","c1","c","vabs","dst","findMinSeparation","xs","minSeparation","Infinity","sort","b","abs","calculateMinPositionDistance","ys","zs","xi","yi","zi","xSep","ySep","zSep","module","exports","bounds","startingPositions","maxLength","tubeSize","absoluteTubeSize","gridFill","indexOf","replace","getVelocity","getDivergence","v0","dp","e","add","vx","subtract","scale","vy","vz","minX","minY","minZ","maxX","maxY","maxZ","inBounds","boundsSize","distance","maxStepSize","maxStepSizeSq","op","dv","dvLength","np","clone","sqLen","squaredLength","sqrt","squaredDistance","tubeScale","shaders","createMesh","createTubeMesh","gl","params","traceType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar vec3 = require('gl-vec3');\nvar vec4 = require('gl-vec4');\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\nvar streamToTube = function(stream, maxDivergence, minDistance, maxNorm) {\n\tvar points = stream.points;\n\tvar velocities = stream.velocities;\n\tvar divergences = stream.divergences;\n\n\tvar verts = [];\n\tvar faces = [];\n\tvar vectors = [];\n\tvar previousVerts = [];\n\tvar currentVerts = [];\n\tvar intensities = [];\n\tvar previousIntensity = 0;\n\tvar currentIntensity = 0;\n\tvar currentVector = vec4.create();\n\tvar previousVector = vec4.create();\n\n\tvar facets = 8;\n\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar p = points[i];\n\t\tvar fwd = velocities[i];\n\t\tvar r = divergences[i];\n\t\tif (maxDivergence === 0) {\n\t\t\tr = minDistance * 0.05;\n\t\t}\n\t\tcurrentIntensity = vec3.length(fwd) / maxNorm;\n\n\t\tcurrentVector = vec4.create();\n\t\tvec3.copy(currentVector, fwd);\n\t\tcurrentVector[3] = r;\n\n\t\tfor (var a = 0; a < facets; a++) {\n\t\t\tcurrentVerts[a] = [p[0], p[1], p[2], a];\n\t\t}\n\t\tif (previousVerts.length > 0) {\n\t\t\tfor (var a = 0; a < facets; a++) {\n\t\t\t\tvar a1 = (a+1) % facets;\n\t\t\t\tverts.push(\n\t\t\t\t\tpreviousVerts[a],\n\t\t\t\t\tcurrentVerts[a],\n\t\t\t\t\tcurrentVerts[a1],\n\n\t\t\t\t\tcurrentVerts[a1],\n\t\t\t\t\tpreviousVerts[a1],\n\t\t\t\t\tpreviousVerts[a]\n\t\t\t\t);\n\t\t\t\tvectors.push(\n\t\t\t\t\tpreviousVector,\n\t\t\t\t\tcurrentVector,\n\t\t\t\t\tcurrentVector,\n\n\t\t\t\t\tcurrentVector,\n\t\t\t\t\tpreviousVector,\n\t\t\t\t\tpreviousVector\n\t\t\t\t);\n\t\t\t\tintensities.push(\n\t\t\t\t\tpreviousIntensity,\n\t\t\t\t\tcurrentIntensity,\n\t\t\t\t\tcurrentIntensity,\n\n\t\t\t\t\tcurrentIntensity,\n\t\t\t\t\tpreviousIntensity,\n\t\t\t\t\tpreviousIntensity\n\t\t\t\t);\n\n\t\t\t\tvar len = verts.length;\n\t\t\t\tfaces.push(\n\t\t\t\t\t[len-6, len-5, len-4],\n\t\t\t\t\t[len-3, len-2, len-1]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tvar tmp1 = previousVerts;\n\t\tpreviousVerts = currentVerts;\n\t\tcurrentVerts = tmp1;\n\n\t\tvar tmp2 = previousVector;\n\t\tpreviousVector = currentVector;\n\t\tcurrentVector = tmp2;\n\n\t\tvar tmp3 = previousIntensity;\n\t\tpreviousIntensity = currentIntensity;\n\t\tcurrentIntensity = tmp3;\n\t}\n\treturn {\n\t\tpositions: verts,\n\t\tcells: faces,\n\t\tvectors: vectors,\n\t\tvertexIntensity: intensities\n\t};\n};\n\nvar createTubes = function(streams, colormap, maxDivergence, minDistance) {\n\n\tvar maxNorm = 0;\n\tfor (var i=0; i<streams.length; i++) {\n\t\tvar velocities = streams[i].velocities;\n\t\tfor (var j=0; j<velocities.length; j++) {\n\t\t\tmaxNorm = Math.max(maxNorm,\n\t\t\t\tvec3.length(velocities[j])\n\t\t\t);\n\t\t}\n\t}\n\n\tvar tubes = streams.map(function(s) {\n\t\treturn streamToTube(s, maxDivergence, minDistance, maxNorm);\n\t});\n\n\tvar positions = [];\n\tvar cells = [];\n\tvar vectors = [];\n\tvar vertexIntensity = [];\n\tfor (var i=0; i < tubes.length; i++) {\n\t\tvar tube = tubes[i];\n\t\tvar offset = positions.length;\n\t\tpositions = positions.concat(tube.positions);\n\t\tvectors = vectors.concat(tube.vectors);\n\t\tvertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n\t\tfor (var j=0; j<tube.cells.length; j++) {\n\t\t\tvar cell = tube.cells[j];\n\t\t\tvar newCell = [];\n\t\t\tcells.push(newCell);\n\t\t\tfor (var k=0; k<cell.length; k++) {\n\t\t\t\tnewCell.push(cell[k] + offset);\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tpositions: positions,\n\t\tcells: cells,\n\t\tvectors: vectors,\n\t\tvertexIntensity: vertexIntensity,\n\t\tcolormap: colormap\n\t};\n};\n\nvar findLastSmallerIndex = function(points, v) {\n  var len = points.length;\n  var i;\n  for (i=0; i<len; i++) {\n  \tvar p = points[i];\n  \tif (p === v) return i;\n    else if (p > v) return i-1;\n  }\n  return i;\n};\n\nvar clamp = function(v, min, max) {\n\treturn v < min ? min : (v > max ? max : v);\n};\n\nvar sampleMeshgrid = function(point, vectorField, gridInfo) {\n\tvar vectors = vectorField.vectors;\n\tvar meshgrid = vectorField.meshgrid;\n\n\tvar x = point[0];\n\tvar y = point[1];\n\tvar z = point[2];\n\n\tvar w = meshgrid[0].length;\n\tvar h = meshgrid[1].length;\n\tvar d = meshgrid[2].length;\n\n\t// Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n\t// The nearest smaller value index for x is the index x0 such that\n\t// meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\tvar x0 = findLastSmallerIndex(meshgrid[0], x);\n\tvar y0 = findLastSmallerIndex(meshgrid[1], y);\n\tvar z0 = findLastSmallerIndex(meshgrid[2], z);\n\n\t// Get the nearest larger meshgrid value indices.\n\t// From the above \"nearest smaller value\", we know that\n\t//   meshgrid[0][x0] < x\n\t//   meshgrid[0][x0+1] >= x\n\tvar x1 = x0 + 1;\n\tvar y1 = y0 + 1;\n\tvar z1 = z0 + 1;\n\n\tx0 = clamp(x0, 0, w-1);\n\tx1 = clamp(x1, 0, w-1);\n\ty0 = clamp(y0, 0, h-1);\n\ty1 = clamp(y1, 0, h-1);\n\tz0 = clamp(z0, 0, d-1);\n\tz1 = clamp(z1, 0, d-1);\n\n\t// Reject points outside the meshgrid, return a zero vector.\n\tif (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w-1 || y1 > h-1 || z1 > d-1) {\n\t\treturn vec3.create();\n\t}\n\n\t// Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\tvar mX0 = meshgrid[0][x0];\n\tvar mX1 = meshgrid[0][x1];\n\tvar mY0 = meshgrid[1][y0];\n\tvar mY1 = meshgrid[1][y1];\n\tvar mZ0 = meshgrid[2][z0];\n\tvar mZ1 = meshgrid[2][z1];\n\tvar xf = (x - mX0) / (mX1 - mX0);\n\tvar yf = (y - mY0) / (mY1 - mY0);\n\tvar zf = (z - mZ0) / (mZ1 - mZ0);\n\n\tif (!isFinite(xf)) xf = 0.5;\n\tif (!isFinite(yf)) yf = 0.5;\n\tif (!isFinite(zf)) zf = 0.5;\n\n\tvar x0off;\n\tvar x1off;\n\tvar y0off;\n\tvar y1off;\n\tvar z0off;\n\tvar z1off;\n\n\tif(gridInfo.reversedX) {\n\t\tx0 = w - 1 - x0;\n\t\tx1 = w - 1 - x1;\n\t}\n\n\tif(gridInfo.reversedY) {\n\t\ty0 = h - 1 - y0;\n\t\ty1 = h - 1 - y1;\n\t}\n\n\tif(gridInfo.reversedZ) {\n\t\tz0 = d - 1 - z0;\n\t\tz1 = d - 1 - z1;\n\t}\n\n\tswitch(gridInfo.filled) {\n\t\tcase 5: // 'zyx'\n\t\t\tz0off = z0;\n\t\t\tz1off = z1;\n\t\t\ty0off = y0*d;\n\t\t\ty1off = y1*d;\n\t\t\tx0off = x0*d*h;\n\t\t\tx1off = x1*d*h;\n\t\t\tbreak;\n\n\t\tcase 4: // 'zxy'\n\t\t\tz0off = z0;\n\t\t\tz1off = z1;\n\t\t\tx0off = x0*d;\n\t\t\tx1off = x1*d;\n\t\t\ty0off = y0*d*w;\n\t\t\ty1off = y1*d*w;\n\t\t\tbreak;\n\n\t\tcase 3: // 'yzx'\n\t\t\ty0off = y0;\n\t\t\ty1off = y1;\n\t\t\tz0off = z0*h;\n\t\t\tz1off = z1*h;\n\t\t\tx0off = x0*h*d;\n\t\t\tx1off = x1*h*d;\n\t\t\tbreak;\n\n\t\tcase 2: // 'yxz'\n\t\t\ty0off = y0;\n\t\t\ty1off = y1;\n\t\t\tx0off = x0*h;\n\t\t\tx1off = x1*h;\n\t\t\tz0off = z0*h*w;\n\t\t\tz1off = z1*h*w;\n\t\t\tbreak;\n\n\t\tcase 1: // 'xzy'\n\t\t\tx0off = x0;\n\t\t\tx1off = x1;\n\t\t\tz0off = z0*w;\n\t\t\tz1off = z1*w;\n\t\t\ty0off = y0*w*d;\n\t\t\ty1off = y1*w*d;\n\t\t\tbreak;\n\n\t\tdefault: // case 0: // 'xyz'\n\t\t\tx0off = x0;\n\t\t\tx1off = x1;\n\t\t\ty0off = y0*w;\n\t\t\ty1off = y1*w;\n\t\t\tz0off = z0*w*h;\n\t\t\tz1off = z1*w*h;\n\t\t\tbreak;\n\t}\n\n\t// Sample data vectors around the (x,y,z) point.\n\tvar v000 = vectors[x0off + y0off + z0off];\n\tvar v001 = vectors[x0off + y0off + z1off];\n\tvar v010 = vectors[x0off + y1off + z0off];\n\tvar v011 = vectors[x0off + y1off + z1off];\n\tvar v100 = vectors[x1off + y0off + z0off];\n\tvar v101 = vectors[x1off + y0off + z1off];\n\tvar v110 = vectors[x1off + y1off + z0off];\n\tvar v111 = vectors[x1off + y1off + z1off];\n\n\tvar c00 = vec3.create();\n\tvar c01 = vec3.create();\n\tvar c10 = vec3.create();\n\tvar c11 = vec3.create();\n\n\tvec3.lerp(c00, v000, v100, xf);\n\tvec3.lerp(c01, v001, v101, xf);\n\tvec3.lerp(c10, v010, v110, xf);\n\tvec3.lerp(c11, v011, v111, xf);\n\n\tvar c0 = vec3.create();\n\tvar c1 = vec3.create();\n\n\tvec3.lerp(c0, c00, c10, yf);\n\tvec3.lerp(c1, c01, c11, yf);\n\n\tvar c = vec3.create();\n\n\tvec3.lerp(c, c0, c1, zf);\n\n\treturn c;\n};\n\n\nvar vabs = function(dst, v) {\n\tvar x = v[0];\n\tvar y = v[1];\n\tvar z = v[2];\n\tdst[0] = x < 0 ? -x : x;\n\tdst[1] = y < 0 ? -y : y;\n\tdst[2] = z < 0 ? -z : z;\n\treturn dst;\n};\n\nvar findMinSeparation = function(xs) {\n\tvar minSeparation = Infinity;\n\txs.sort(function(a, b) { return a - b; });\n\tvar len = xs.length;\n\tfor (var i=1; i<len; i++) {\n\t\tvar d = Math.abs(xs[i] - xs[i-1]);\n\t\tif (d < minSeparation) {\n\t\t\tminSeparation = d;\n\t\t}\n\t}\n\treturn minSeparation;\n};\n\n// Finds the minimum per-component distance in positions.\n//\nvar calculateMinPositionDistance = function(positions) {\n\tvar xs = [], ys = [], zs = [];\n\tvar xi = {}, yi = {}, zi = {};\n\tvar len = positions.length;\n\tfor (var i=0; i<len; i++) {\n\t\tvar p = positions[i];\n\t\tvar x = p[0], y = p[1], z = p[2];\n\n\t\t// Split the positions array into arrays of unique component values.\n\t\t//\n\t\t// Why go through the trouble of using a uniqueness hash table vs\n\t\t// sort and uniq:\n\t\t//\n\t\t// Suppose you've got a million positions in a 100x100x100 grid.\n\t\t//\n\t\t// Using a uniqueness hash table, you're doing 1M array reads,\n\t\t// 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n\t\t// sorting three 100-element arrays and iterating over them.\n\t\t// Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n\t\t//          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n\t\t//          =~ 15M\n\t\t//\n\t\t// Sort and uniq solution would do 1M array reads, 3M array inserts,\n\t\t// sort three 1M-element arrays and iterate over them.\n\t\t// Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n\t\t//          1M + 3M + 41.4M + 3M\n\t\t//          =~ 48.4M\n\t\t//\n\t\t// Guessing that a hard-coded sort & uniq would be faster due to not having\n\t\t// to run a hashing function on everything. More memory usage though\n\t\t// (bunch of small hash tables vs. duplicating the input array.)\n\t\t//\n\t\t// In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n\t\t// maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n\t\t// Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n\t\t//\n\t\t// ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n\t\t//\n\t\tif (!xi[x]) {\n\t\t\txs.push(x);\n\t\t\txi[x] = true;\n\t\t}\n\t\tif (!yi[y]) {\n\t\t\tys.push(y);\n\t\t\tyi[y] = true;\n\t\t}\n\t\tif (!zi[z]) {\n\t\t\tzs.push(z);\n\t\t\tzi[z] = true;\n\t\t}\n\t}\n\tvar xSep = findMinSeparation(xs);\n\tvar ySep = findMinSeparation(ys);\n\tvar zSep = findMinSeparation(zs);\n\tvar minSeparation = Math.min(xSep, ySep, zSep);\n\n\treturn isFinite(minSeparation) ? minSeparation : 1;\n};\n\nmodule.exports = function(vectorField, bounds) {\n\tvar positions = vectorField.startingPositions;\n\tvar maxLength = vectorField.maxLength || 1000;\n\tvar tubeSize = vectorField.tubeSize || 1;\n\tvar absoluteTubeSize = vectorField.absoluteTubeSize;\n\tvar gridFill = vectorField.gridFill || '+x+y+z';\n\n\tvar gridInfo = {};\n\tif(gridFill.indexOf('-x') !== -1) { gridInfo.reversedX = true; }\n\tif(gridFill.indexOf('-y') !== -1) { gridInfo.reversedY = true; }\n\tif(gridFill.indexOf('-z') !== -1) { gridInfo.reversedZ = true; }\n\tgridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n\tvar getVelocity = vectorField.getVelocity || function(p) {\n\t\treturn sampleMeshgrid(p, vectorField, gridInfo);\n\t};\n\n\tvar getDivergence = vectorField.getDivergence || function(p, v0) {\n\t\tvar dp = vec3.create();\n\t\tvar e = 0.0001;\n\n\t\tvec3.add(dp, p, [e, 0, 0]);\n\t\tvar vx = getVelocity(dp);\n\t\tvec3.subtract(vx, vx, v0);\n\t\tvec3.scale(vx, vx, 1/e);\n\n\t\tvec3.add(dp, p, [0, e, 0]);\n\t\tvar vy = getVelocity(dp);\n\t\tvec3.subtract(vy, vy, v0);\n\t\tvec3.scale(vy, vy, 1/e);\n\n\t\tvec3.add(dp, p, [0, 0, e]);\n\t\tvar vz = getVelocity(dp);\n\t\tvec3.subtract(vz, vz, v0);\n\t\tvec3.scale(vz, vz, 1/e);\n\n\t\tvec3.add(dp, vx, vy);\n\t\tvec3.add(dp, dp, vz);\n\t\treturn dp;\n\t};\n\n\tvar streams = [];\n\n\tvar minX = bounds[0][0], minY = bounds[0][1], minZ = bounds[0][2];\n\tvar maxX = bounds[1][0], maxY = bounds[1][1], maxZ = bounds[1][2];\n\n\tvar inBounds = function(p) {\n\t\tvar x = p[0];\n\t\tvar y = p[1];\n\t\tvar z = p[2];\n\t\treturn !(\n\t\t\tx < minX || x > maxX ||\n\t\t\ty < minY || y > maxY ||\n\t\t\tz < minZ || z > maxZ\n\t\t);\n\t};\n\n\tvar boundsSize = vec3.distance(bounds[0], bounds[1]);\n\tvar maxStepSize = 10 * boundsSize / maxLength;\n\tvar maxStepSizeSq = maxStepSize * maxStepSize;\n\n\tvar minDistance = 1;\n\tvar maxDivergence = 0; // For component-wise divergence vec3.create();\n\n\t// In case we need to do component-wise divergence visualization\n\t// var tmp = vec3.create();\n\n\tvar len = positions.length;\n\tif (len > 1) {\n\t\tminDistance = calculateMinPositionDistance(positions);\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tvar p = vec3.create();\n\t\tvec3.copy(p, positions[i]);\n\n\t\tvar stream = [p];\n\t\tvar velocities = [];\n\t\tvar v = getVelocity(p);\n\t\tvar op = p;\n\t\tvelocities.push(v);\n\n\t\tvar divergences = [];\n\n\t\tvar dv = getDivergence(p, v);\n\t\tvar dvLength = vec3.length(dv);\n\t\tif (isFinite(dvLength) && dvLength > maxDivergence) {\n\t\t\tmaxDivergence = dvLength;\n\t\t}\n\t\t// In case we need to do component-wise divergence visualization\n\t\t// vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\t\tdivergences.push(dvLength);\n\n\t\tstreams.push({points: stream, velocities: velocities, divergences: divergences});\n\n\t\tvar j = 0;\n\n\t\twhile (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n\t\t\tj++;\n\t\t\tvar np = vec3.clone(v);\n\t\t\tvar sqLen = vec3.squaredLength(np);\n\t\t\tif (sqLen === 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (sqLen > maxStepSizeSq) {\n\t\t\t\tvec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n\t\t\t}\n\t\t\tvec3.add(np, np, p);\n\n\t\t\tv = getVelocity(np);\n\n\t\t\tif (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n\t\t\t\tstream.push(np);\n\t\t\t\top = np;\n\t\t\t\tvelocities.push(v);\n\t\t\t\tvar dv = getDivergence(np, v);\n\t\t\t\tvar dvLength = vec3.length(dv);\n\t\t\t\tif (isFinite(dvLength) && dvLength > maxDivergence) {\n\t\t\t\t\tmaxDivergence = dvLength;\n\t\t\t\t}\n\t\t\t\t// In case we need to do component-wise divergence visualization\n\t\t\t\t//vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\t\t\t\tdivergences.push(dvLength);\n\t\t\t}\n\n\t\t\tp = np;\n\t\t}\n\t}\n\n\tvar tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n\n\tif (absoluteTubeSize) {\n\t\ttubes.tubeScale = absoluteTubeSize;\n\t} else {\n\t\t// Avoid division by zero.\n\t\tif (maxDivergence === 0) {\n\t\t\tmaxDivergence = 1;\n\t\t}\n\t\ttubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n\t}\n\n\treturn tubes;\n};\n\nvar shaders = require('./lib/shaders');\nvar createMesh = require('gl-cone3d').createMesh;\nmodule.exports.createTubeMesh = function(gl, params) {\n\treturn createMesh(gl, params, {\n\t\tshaders: shaders,\n\t\ttraceType: 'streamtube'\n\t});\n}\n"]},"metadata":{},"sourceType":"script"}