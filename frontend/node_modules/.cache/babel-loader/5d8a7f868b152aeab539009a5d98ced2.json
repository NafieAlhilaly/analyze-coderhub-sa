{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n  var inHover = opts._inHover;\n  var grouped = helpers.isGrouped(opts);\n  var reversed = helpers.isReversed(opts);\n  var lgroupToTraces = {};\n  var lgroups = [];\n  var hasOneNonBlankGroup = false;\n  var slicesShown = {};\n  var lgroupi = 0;\n  var maxNameLength = 0;\n  var i, j;\n\n  function addOneItem(legendGroup, legendItem) {\n    // each '' legend group is treated as a separate group\n    if (legendGroup === '' || !helpers.isGrouped(opts)) {\n      // TODO: check this against fullData legendgroups?\n      var uniqueGroup = '~~i' + lgroupi;\n      lgroups.push(uniqueGroup);\n      lgroupToTraces[uniqueGroup] = [legendItem];\n      lgroupi++;\n    } else if (lgroups.indexOf(legendGroup) === -1) {\n      lgroups.push(legendGroup);\n      hasOneNonBlankGroup = true;\n      lgroupToTraces[legendGroup] = [legendItem];\n    } else {\n      lgroupToTraces[legendGroup].push(legendItem);\n    }\n  } // build an { legendgroup: [cd0, cd0], ... } object\n\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var lgroup = trace.legendgroup;\n    if (!inHover && (!trace.visible || !trace.showlegend)) continue;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n      for (j = 0; j < cd.length; j++) {\n        var labelj = cd[j].label;\n\n        if (!slicesShown[lgroup][labelj]) {\n          addOneItem(lgroup, {\n            label: labelj,\n            color: cd[j].color,\n            i: cd[j].i,\n            trace: trace,\n            pts: cd[j].pts\n          });\n          slicesShown[lgroup][labelj] = true;\n          maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n        }\n      }\n    } else {\n      addOneItem(lgroup, cd0);\n      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n    }\n  } // won't draw a legend in this case\n\n\n  if (!lgroups.length) return []; // collapse all groups into one if all groups are blank\n\n  var shouldCollapse = !hasOneNonBlankGroup || !grouped;\n  var legendData = [];\n\n  for (i = 0; i < lgroups.length; i++) {\n    var t = lgroupToTraces[lgroups[i]];\n\n    if (shouldCollapse) {\n      legendData.push(t[0]);\n    } else {\n      legendData.push(t);\n    }\n  }\n\n  if (shouldCollapse) legendData = [legendData];\n\n  for (i = 0; i < legendData.length; i++) {\n    // find minimum rank within group\n    var groupMinRank = Infinity;\n\n    for (j = 0; j < legendData[i].length; j++) {\n      var rank = legendData[i][j].trace.legendrank;\n      if (groupMinRank > rank) groupMinRank = rank;\n    } // record on first group element\n\n\n    legendData[i][0]._groupMinRank = groupMinRank;\n    legendData[i][0]._preGroupSort = i;\n  }\n\n  var orderFn1 = function orderFn1(a, b) {\n    return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  };\n\n  var orderFn2 = function orderFn2(a, b) {\n    return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  }; // sort considering minimum group legendrank\n\n\n  legendData.forEach(function (a, k) {\n    a[0]._preGroupSort = k;\n  });\n  legendData.sort(orderFn1);\n\n  for (i = 0; i < legendData.length; i++) {\n    // sort considering trace.legendrank and legend.traceorder\n    legendData[i].forEach(function (a, k) {\n      a._preSort = k;\n    });\n    legendData[i].sort(orderFn2);\n    var firstItemTrace = legendData[i][0].trace;\n    var groupTitle = null; // get group title text\n\n    for (j = 0; j < legendData[i].length; j++) {\n      var gt = legendData[i][j].trace.legendgrouptitle;\n\n      if (gt && gt.text) {\n        groupTitle = gt;\n        if (inHover) gt.font = opts._groupTitleFont;\n        break;\n      }\n    } // reverse order\n\n\n    if (reversed) legendData[i].reverse();\n\n    if (groupTitle) {\n      var hasPieLike = false;\n\n      for (j = 0; j < legendData[i].length; j++) {\n        if (Registry.traceIs(legendData[i][j].trace, 'pie-like')) {\n          hasPieLike = true;\n          break;\n        }\n      } // set group title text\n\n\n      legendData[i].unshift({\n        i: -1,\n        groupTitle: groupTitle,\n        noClick: hasPieLike,\n        trace: {\n          showlegend: firstItemTrace.showlegend,\n          legendgroup: firstItemTrace.legendgroup,\n          visible: opts.groupclick === 'toggleitem' ? true : firstItemTrace.visible\n        }\n      });\n    } // rearrange lgroupToTraces into a d3-friendly array of arrays\n\n\n    for (j = 0; j < legendData[i].length; j++) {\n      legendData[i][j] = [legendData[i][j]];\n    }\n  } // number of legend groups - needed in legend/draw.js\n\n\n  opts._lgroupsLength = legendData.length; // maximum name/label length - needed in legend/draw.js\n\n  opts._maxNameLength = maxNameLength;\n  return legendData;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/legend/get_legend_data.js"],"names":["Registry","require","helpers","module","exports","getLegendData","calcdata","opts","inHover","_inHover","grouped","isGrouped","reversed","isReversed","lgroupToTraces","lgroups","hasOneNonBlankGroup","slicesShown","lgroupi","maxNameLength","i","j","addOneItem","legendGroup","legendItem","uniqueGroup","push","indexOf","length","cd","cd0","trace","lgroup","legendgroup","visible","showlegend","traceIs","labelj","label","color","pts","Math","max","name","shouldCollapse","legendData","t","groupMinRank","Infinity","rank","legendrank","_groupMinRank","_preGroupSort","orderFn1","a","b","orderFn2","_preSort","forEach","k","sort","firstItemTrace","groupTitle","gt","legendgrouptitle","text","font","_groupTitleFont","reverse","hasPieLike","unshift","noClick","groupclick","_lgroupsLength","_maxNameLength"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n    var inHover = opts._inHover;\n    var grouped = helpers.isGrouped(opts);\n    var reversed = helpers.isReversed(opts);\n\n    var lgroupToTraces = {};\n    var lgroups = [];\n    var hasOneNonBlankGroup = false;\n    var slicesShown = {};\n    var lgroupi = 0;\n    var maxNameLength = 0;\n    var i, j;\n\n    function addOneItem(legendGroup, legendItem) {\n        // each '' legend group is treated as a separate group\n        if(legendGroup === '' || !helpers.isGrouped(opts)) {\n            // TODO: check this against fullData legendgroups?\n            var uniqueGroup = '~~i' + lgroupi;\n            lgroups.push(uniqueGroup);\n            lgroupToTraces[uniqueGroup] = [legendItem];\n            lgroupi++;\n        } else if(lgroups.indexOf(legendGroup) === -1) {\n            lgroups.push(legendGroup);\n            hasOneNonBlankGroup = true;\n            lgroupToTraces[legendGroup] = [legendItem];\n        } else {\n            lgroupToTraces[legendGroup].push(legendItem);\n        }\n    }\n\n    // build an { legendgroup: [cd0, cd0], ... } object\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var lgroup = trace.legendgroup;\n\n        if(!inHover && (!trace.visible || !trace.showlegend)) continue;\n\n        if(Registry.traceIs(trace, 'pie-like')) {\n            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n            for(j = 0; j < cd.length; j++) {\n                var labelj = cd[j].label;\n\n                if(!slicesShown[lgroup][labelj]) {\n                    addOneItem(lgroup, {\n                        label: labelj,\n                        color: cd[j].color,\n                        i: cd[j].i,\n                        trace: trace,\n                        pts: cd[j].pts\n                    });\n\n                    slicesShown[lgroup][labelj] = true;\n                    maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n                }\n            }\n        } else {\n            addOneItem(lgroup, cd0);\n            maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n        }\n    }\n\n    // won't draw a legend in this case\n    if(!lgroups.length) return [];\n\n    // collapse all groups into one if all groups are blank\n    var shouldCollapse = !hasOneNonBlankGroup || !grouped;\n\n    var legendData = [];\n    for(i = 0; i < lgroups.length; i++) {\n        var t = lgroupToTraces[lgroups[i]];\n        if(shouldCollapse) {\n            legendData.push(t[0]);\n        } else {\n            legendData.push(t);\n        }\n    }\n    if(shouldCollapse) legendData = [legendData];\n\n    for(i = 0; i < legendData.length; i++) {\n        // find minimum rank within group\n        var groupMinRank = Infinity;\n        for(j = 0; j < legendData[i].length; j++) {\n            var rank = legendData[i][j].trace.legendrank;\n            if(groupMinRank > rank) groupMinRank = rank;\n        }\n\n        // record on first group element\n        legendData[i][0]._groupMinRank = groupMinRank;\n        legendData[i][0]._preGroupSort = i;\n    }\n\n    var orderFn1 = function(a, b) {\n        return (\n            (a[0]._groupMinRank - b[0]._groupMinRank) ||\n            (a[0]._preGroupSort - b[0]._preGroupSort) // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n        );\n    };\n\n    var orderFn2 = function(a, b) {\n        return (\n            (a.trace.legendrank - b.trace.legendrank) ||\n            (a._preSort - b._preSort) // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n        );\n    };\n\n    // sort considering minimum group legendrank\n    legendData.forEach(function(a, k) { a[0]._preGroupSort = k; });\n    legendData.sort(orderFn1);\n    for(i = 0; i < legendData.length; i++) {\n        // sort considering trace.legendrank and legend.traceorder\n        legendData[i].forEach(function(a, k) { a._preSort = k; });\n        legendData[i].sort(orderFn2);\n\n        var firstItemTrace = legendData[i][0].trace;\n\n        var groupTitle = null;\n        // get group title text\n        for(j = 0; j < legendData[i].length; j++) {\n            var gt = legendData[i][j].trace.legendgrouptitle;\n            if(gt && gt.text) {\n                groupTitle = gt;\n                if(inHover) gt.font = opts._groupTitleFont;\n                break;\n            }\n        }\n\n        // reverse order\n        if(reversed) legendData[i].reverse();\n\n        if(groupTitle) {\n            var hasPieLike = false;\n            for(j = 0; j < legendData[i].length; j++) {\n                if(Registry.traceIs(legendData[i][j].trace, 'pie-like')) {\n                    hasPieLike = true;\n                    break;\n                }\n            }\n\n            // set group title text\n            legendData[i].unshift({\n                i: -1,\n                groupTitle: groupTitle,\n                noClick: hasPieLike,\n                trace: {\n                    showlegend: firstItemTrace.showlegend,\n                    legendgroup: firstItemTrace.legendgroup,\n                    visible: opts.groupclick === 'toggleitem' ? true : firstItemTrace.visible\n                }\n            });\n        }\n\n        // rearrange lgroupToTraces into a d3-friendly array of arrays\n        for(j = 0; j < legendData[i].length; j++) {\n            legendData[i][j] = [\n                legendData[i][j]\n            ];\n        }\n    }\n\n    // number of legend groups - needed in legend/draw.js\n    opts._lgroupsLength = legendData.length;\n    // maximum name/label length - needed in legend/draw.js\n    opts._maxNameLength = maxNameLength;\n\n    return legendData;\n};\n"]},"metadata":{},"sourceType":"script"}