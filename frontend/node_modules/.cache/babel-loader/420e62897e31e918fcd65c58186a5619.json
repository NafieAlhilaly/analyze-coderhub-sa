{"ast":null,"code":"'use strict';\n\nvar nestedProperty = require('./nested_property');\n\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/; // bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\n\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\n\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n  keyName = keyName || 'name';\n  valueName = valueName || 'value';\n  var i, arr, baseProp;\n  var changeTypes = {};\n\n  if (path && path.length) {\n    baseProp = nestedProperty(baseObj, path);\n    arr = baseProp.get();\n  } else {\n    arr = baseObj;\n  }\n\n  path = path || ''; // Construct an index:\n\n  var indexLookup = {};\n\n  if (arr) {\n    for (i = 0; i < arr.length; i++) {\n      indexLookup[arr[i][keyName]] = i;\n    }\n  }\n\n  var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n  var obj = {\n    set: function (name, value) {\n      var changeType = value === null ? UNSET : NONE; // create the base array if necessary\n\n      if (!arr) {\n        if (!baseProp || changeType === UNSET) return;\n        arr = [];\n        baseProp.set(arr);\n      }\n\n      var idx = indexLookup[name];\n\n      if (idx === undefined) {\n        if (changeType === UNSET) return;\n        changeType = changeType | BOTH;\n        idx = arr.length;\n        indexLookup[name] = idx;\n      } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n        changeType = changeType | VALUE;\n      }\n\n      var newValue = arr[idx] = arr[idx] || {};\n      newValue[keyName] = name;\n\n      if (isSimpleValueProp) {\n        newValue[valueName] = value;\n      } else {\n        nestedProperty(newValue, valueName).set(value);\n      } // If it's not an unset, force that bit to be unset. This is all related to the fact\n      // that undefined and null are a bit specially implemented in nestedProperties.\n\n\n      if (value !== null) {\n        changeType = changeType & ~UNSET;\n      }\n\n      changeTypes[idx] = changeTypes[idx] | changeType;\n      return obj;\n    },\n    get: function (name) {\n      if (!arr) return;\n      var idx = indexLookup[name];\n\n      if (idx === undefined) {\n        return undefined;\n      } else if (isSimpleValueProp) {\n        return arr[idx][valueName];\n      } else {\n        return nestedProperty(arr[idx], valueName).get();\n      }\n    },\n    rename: function (name, newName) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      changeTypes[idx] = changeTypes[idx] | NAME;\n      indexLookup[newName] = idx;\n      delete indexLookup[name];\n      arr[idx][keyName] = newName;\n      return obj;\n    },\n    remove: function (name) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      var object = arr[idx];\n\n      if (Object.keys(object).length > 2) {\n        // This object contains more than just the key/value, so unset\n        // the value without modifying the entry otherwise:\n        changeTypes[idx] = changeTypes[idx] | VALUE;\n        return obj.set(name, null);\n      }\n\n      if (isSimpleValueProp) {\n        for (i = idx; i < arr.length; i++) {\n          changeTypes[i] = changeTypes[i] | BOTH;\n        }\n\n        for (i = idx; i < arr.length; i++) {\n          indexLookup[arr[i][keyName]]--;\n        }\n\n        arr.splice(idx, 1);\n        delete indexLookup[name];\n      } else {\n        // Perform this update *strictly* so we can check whether the result's\n        // been pruned. If so, it's a removal. If not, it's a value unset only.\n        nestedProperty(object, valueName).set(null); // Now check if the top level nested property has any keys left. If so,\n        // the object still has values so we only want to unset the key. If not,\n        // the entire object can be removed since there's no other data.\n        // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n        changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n      }\n\n      return obj;\n    },\n    constructUpdate: function () {\n      var astr, idx;\n      var update = {};\n      var changed = Object.keys(changeTypes);\n\n      for (var i = 0; i < changed.length; i++) {\n        idx = changed[i];\n        astr = path + '[' + idx + ']';\n\n        if (arr[idx]) {\n          if (changeTypes[idx] & NAME) {\n            update[astr + '.' + keyName] = arr[idx][keyName];\n          }\n\n          if (changeTypes[idx] & VALUE) {\n            if (isSimpleValueProp) {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];\n            } else {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();\n            }\n          }\n        } else {\n          update[astr] = null;\n        }\n      }\n\n      return update;\n    }\n  };\n  return obj;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/lib/keyed_container.js"],"names":["nestedProperty","require","SIMPLE_PROPERTY_REGEX","NONE","NAME","VALUE","BOTH","UNSET","module","exports","keyedContainer","baseObj","path","keyName","valueName","i","arr","baseProp","changeTypes","length","get","indexLookup","isSimpleValueProp","test","obj","set","name","value","changeType","idx","undefined","newValue","rename","newName","remove","object","Object","keys","splice","constructUpdate","astr","update","changed"],"mappings":"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","sourcesContent":["'use strict';\n\nvar nestedProperty = require('./nested_property');\n\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n// bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\n\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n    keyName = keyName || 'name';\n    valueName = valueName || 'value';\n    var i, arr, baseProp;\n    var changeTypes = {};\n\n    if(path && path.length) {\n        baseProp = nestedProperty(baseObj, path);\n        arr = baseProp.get();\n    } else {\n        arr = baseObj;\n    }\n\n    path = path || '';\n\n    // Construct an index:\n    var indexLookup = {};\n    if(arr) {\n        for(i = 0; i < arr.length; i++) {\n            indexLookup[arr[i][keyName]] = i;\n        }\n    }\n\n    var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n\n    var obj = {\n        set: function(name, value) {\n            var changeType = value === null ? UNSET : NONE;\n\n            // create the base array if necessary\n            if(!arr) {\n                if(!baseProp || changeType === UNSET) return;\n\n                arr = [];\n                baseProp.set(arr);\n            }\n\n            var idx = indexLookup[name];\n            if(idx === undefined) {\n                if(changeType === UNSET) return;\n\n                changeType = changeType | BOTH;\n                idx = arr.length;\n                indexLookup[name] = idx;\n            } else if(value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n                changeType = changeType | VALUE;\n            }\n\n            var newValue = arr[idx] = arr[idx] || {};\n            newValue[keyName] = name;\n\n            if(isSimpleValueProp) {\n                newValue[valueName] = value;\n            } else {\n                nestedProperty(newValue, valueName).set(value);\n            }\n\n            // If it's not an unset, force that bit to be unset. This is all related to the fact\n            // that undefined and null are a bit specially implemented in nestedProperties.\n            if(value !== null) {\n                changeType = changeType & ~UNSET;\n            }\n\n            changeTypes[idx] = changeTypes[idx] | changeType;\n\n            return obj;\n        },\n        get: function(name) {\n            if(!arr) return;\n\n            var idx = indexLookup[name];\n\n            if(idx === undefined) {\n                return undefined;\n            } else if(isSimpleValueProp) {\n                return arr[idx][valueName];\n            } else {\n                return nestedProperty(arr[idx], valueName).get();\n            }\n        },\n        rename: function(name, newName) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n            changeTypes[idx] = changeTypes[idx] | NAME;\n\n            indexLookup[newName] = idx;\n            delete indexLookup[name];\n\n            arr[idx][keyName] = newName;\n\n            return obj;\n        },\n        remove: function(name) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n\n            var object = arr[idx];\n            if(Object.keys(object).length > 2) {\n                // This object contains more than just the key/value, so unset\n                // the value without modifying the entry otherwise:\n                changeTypes[idx] = changeTypes[idx] | VALUE;\n                return obj.set(name, null);\n            }\n\n            if(isSimpleValueProp) {\n                for(i = idx; i < arr.length; i++) {\n                    changeTypes[i] = changeTypes[i] | BOTH;\n                }\n                for(i = idx; i < arr.length; i++) {\n                    indexLookup[arr[i][keyName]]--;\n                }\n                arr.splice(idx, 1);\n                delete(indexLookup[name]);\n            } else {\n                // Perform this update *strictly* so we can check whether the result's\n                // been pruned. If so, it's a removal. If not, it's a value unset only.\n                nestedProperty(object, valueName).set(null);\n\n                // Now check if the top level nested property has any keys left. If so,\n                // the object still has values so we only want to unset the key. If not,\n                // the entire object can be removed since there's no other data.\n                // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n                changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n            }\n\n            return obj;\n        },\n        constructUpdate: function() {\n            var astr, idx;\n            var update = {};\n            var changed = Object.keys(changeTypes);\n            for(var i = 0; i < changed.length; i++) {\n                idx = changed[i];\n                astr = path + '[' + idx + ']';\n                if(arr[idx]) {\n                    if(changeTypes[idx] & NAME) {\n                        update[astr + '.' + keyName] = arr[idx][keyName];\n                    }\n                    if(changeTypes[idx] & VALUE) {\n                        if(isSimpleValueProp) {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : arr[idx][valueName];\n                        } else {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : nestedProperty(arr[idx], valueName).get();\n                        }\n                    }\n                } else {\n                    update[astr] = null;\n                }\n            }\n\n            return update;\n        }\n    };\n\n    return obj;\n};\n"]},"metadata":{},"sourceType":"script"}