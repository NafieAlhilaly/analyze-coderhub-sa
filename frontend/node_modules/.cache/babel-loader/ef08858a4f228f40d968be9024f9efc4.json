{"ast":null,"code":"'use strict';\n\nvar scatterHover = require('../scatter/hover');\n\nvar fillText = require('../../lib').fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var scatterPointData = scatterHover(pointData, xval, yval, hovermode);\n  if (!scatterPointData || scatterPointData[0].index === false) return;\n  var newPointData = scatterPointData[0]; // if hovering on a fill, we don't show any point data so the label is\n  // unchanged from what scatter gives us - except that it needs to\n  // be constrained to the trianglular plot area, not just the rectangular\n  // area defined by the synthetic x and y axes\n  // TODO: in some cases the vertical middle of the shape is not within\n  // the triangular viewport at all, so the label can become disconnected\n  // from the shape entirely. But calculating what portion of the shape\n  // is actually visible, as constrained by the diagonal axis lines, is not\n  // so easy and anyway we lost the information we would have needed to do\n  // this inside scatterHover.\n\n  if (newPointData.index === undefined) {\n    var yFracUp = 1 - newPointData.y0 / pointData.ya._length;\n    var xLen = pointData.xa._length;\n    var xMin = xLen * yFracUp / 2;\n    var xMax = xLen - xMin;\n    newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);\n    newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);\n    return scatterPointData;\n  }\n\n  var cdi = newPointData.cd[newPointData.index];\n  newPointData.a = cdi.a;\n  newPointData.b = cdi.b;\n  newPointData.xLabelVal = undefined;\n  newPointData.yLabelVal = undefined; // TODO: nice formatting, and label by axis title, for a, b, and c?\n\n  var trace = newPointData.trace;\n  var carpet = trace._carpet;\n\n  var labels = trace._module.formatLabels(cdi, trace);\n\n  newPointData.yLabel = labels.yLabel;\n  delete newPointData.text;\n  var text = [];\n\n  function textPart(ax, val) {\n    var prefix;\n\n    if (ax.labelprefix && ax.labelprefix.length > 0) {\n      prefix = ax.labelprefix.replace(/ = $/, '');\n    } else {\n      prefix = ax._hovertitle;\n    }\n\n    text.push(prefix + ': ' + val.toFixed(3) + ax.labelsuffix);\n  }\n\n  if (!trace.hovertemplate) {\n    var hoverinfo = cdi.hi || trace.hoverinfo;\n    var parts = hoverinfo.split('+');\n    if (parts.indexOf('all') !== -1) parts = ['a', 'b', 'text'];\n    if (parts.indexOf('a') !== -1) textPart(carpet.aaxis, cdi.a);\n    if (parts.indexOf('b') !== -1) textPart(carpet.baxis, cdi.b);\n    text.push('y: ' + newPointData.yLabel);\n\n    if (parts.indexOf('text') !== -1) {\n      fillText(cdi, trace, text);\n    }\n\n    newPointData.extraText = text.join('<br>');\n  }\n\n  return scatterPointData;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/scattercarpet/hover.js"],"names":["scatterHover","require","fillText","module","exports","hoverPoints","pointData","xval","yval","hovermode","scatterPointData","index","newPointData","undefined","yFracUp","y0","ya","_length","xLen","xa","xMin","xMax","x0","Math","max","min","x1","cdi","cd","a","b","xLabelVal","yLabelVal","trace","carpet","_carpet","labels","_module","formatLabels","yLabel","text","textPart","ax","val","prefix","labelprefix","length","replace","_hovertitle","push","toFixed","labelsuffix","hovertemplate","hoverinfo","hi","parts","split","indexOf","aaxis","baxis","extraText","join"],"mappings":"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","sourcesContent":["'use strict';\n\nvar scatterHover = require('../scatter/hover');\nvar fillText = require('../../lib').fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var scatterPointData = scatterHover(pointData, xval, yval, hovermode);\n    if(!scatterPointData || scatterPointData[0].index === false) return;\n\n    var newPointData = scatterPointData[0];\n\n    // if hovering on a fill, we don't show any point data so the label is\n    // unchanged from what scatter gives us - except that it needs to\n    // be constrained to the trianglular plot area, not just the rectangular\n    // area defined by the synthetic x and y axes\n    // TODO: in some cases the vertical middle of the shape is not within\n    // the triangular viewport at all, so the label can become disconnected\n    // from the shape entirely. But calculating what portion of the shape\n    // is actually visible, as constrained by the diagonal axis lines, is not\n    // so easy and anyway we lost the information we would have needed to do\n    // this inside scatterHover.\n    if(newPointData.index === undefined) {\n        var yFracUp = 1 - (newPointData.y0 / pointData.ya._length);\n        var xLen = pointData.xa._length;\n        var xMin = xLen * yFracUp / 2;\n        var xMax = xLen - xMin;\n        newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);\n        newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);\n        return scatterPointData;\n    }\n\n    var cdi = newPointData.cd[newPointData.index];\n\n    newPointData.a = cdi.a;\n    newPointData.b = cdi.b;\n\n    newPointData.xLabelVal = undefined;\n    newPointData.yLabelVal = undefined;\n    // TODO: nice formatting, and label by axis title, for a, b, and c?\n\n    var trace = newPointData.trace;\n    var carpet = trace._carpet;\n\n    var labels = trace._module.formatLabels(cdi, trace);\n    newPointData.yLabel = labels.yLabel;\n\n    delete newPointData.text;\n    var text = [];\n\n    function textPart(ax, val) {\n        var prefix;\n\n        if(ax.labelprefix && ax.labelprefix.length > 0) {\n            prefix = ax.labelprefix.replace(/ = $/, '');\n        } else {\n            prefix = ax._hovertitle;\n        }\n\n        text.push(prefix + ': ' + val.toFixed(3) + ax.labelsuffix);\n    }\n\n\n    if(!trace.hovertemplate) {\n        var hoverinfo = cdi.hi || trace.hoverinfo;\n        var parts = hoverinfo.split('+');\n\n        if(parts.indexOf('all') !== -1) parts = ['a', 'b', 'text'];\n        if(parts.indexOf('a') !== -1) textPart(carpet.aaxis, cdi.a);\n        if(parts.indexOf('b') !== -1) textPart(carpet.baxis, cdi.b);\n\n        text.push('y: ' + newPointData.yLabel);\n\n        if(parts.indexOf('text') !== -1) {\n            fillText(cdi, trace, text);\n        }\n\n        newPointData.extraText = text.join('<br>');\n    }\n\n    return scatterPointData;\n};\n"]},"metadata":{},"sourceType":"script"}