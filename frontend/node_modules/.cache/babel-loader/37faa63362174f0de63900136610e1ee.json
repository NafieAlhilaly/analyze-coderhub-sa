{"ast":null,"code":"'use strict';\n\nvar filterOps = require('../../constants/filter_ops');\n\nvar isNumeric = require('fast-isnumeric'); // This syntax conforms to the existing filter transform syntax, but we don't care\n// about open vs. closed intervals for simply drawing contours constraints:\n\n\nmodule.exports = {\n  '[]': makeRangeSettings('[]'),\n  '][': makeRangeSettings(']['),\n  '>': makeInequalitySettings('>'),\n  '<': makeInequalitySettings('<'),\n  '=': makeInequalitySettings('=')\n}; // This does not in any way shape or form support calendars. It's adapted from\n// transforms/filter.js.\n\nfunction coerceValue(operation, value) {\n  var hasArrayValue = Array.isArray(value);\n  var coercedValue;\n\n  function coerce(value) {\n    return isNumeric(value) ? +value : null;\n  }\n\n  if (filterOps.COMPARISON_OPS2.indexOf(operation) !== -1) {\n    coercedValue = hasArrayValue ? coerce(value[0]) : coerce(value);\n  } else if (filterOps.INTERVAL_OPS.indexOf(operation) !== -1) {\n    coercedValue = hasArrayValue ? [coerce(value[0]), coerce(value[1])] : [coerce(value), coerce(value)];\n  } else if (filterOps.SET_OPS.indexOf(operation) !== -1) {\n    coercedValue = hasArrayValue ? value.map(coerce) : [coerce(value)];\n  }\n\n  return coercedValue;\n} // Returns a parabola scaled so that the min/max is either +/- 1 and zero at the two values\n// provided. The data is mapped by this function when constructing intervals so that it's\n// very easy to construct contours as normal.\n\n\nfunction makeRangeSettings(operation) {\n  return function (value) {\n    value = coerceValue(operation, value); // Ensure proper ordering:\n\n    var min = Math.min(value[0], value[1]);\n    var max = Math.max(value[0], value[1]);\n    return {\n      start: min,\n      end: max,\n      size: max - min\n    };\n  };\n}\n\nfunction makeInequalitySettings(operation) {\n  return function (value) {\n    value = coerceValue(operation, value);\n    return {\n      start: value,\n      end: Infinity,\n      size: Infinity\n    };\n  };\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/contour/constraint_mapping.js"],"names":["filterOps","require","isNumeric","module","exports","makeRangeSettings","makeInequalitySettings","coerceValue","operation","value","hasArrayValue","Array","isArray","coercedValue","coerce","COMPARISON_OPS2","indexOf","INTERVAL_OPS","SET_OPS","map","min","Math","max","start","end","size","Infinity"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,4BAAD,CAAvB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAD,CAAvB,C,CAEA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB;AACb,QAAMC,iBAAiB,CAAC,IAAD,CADV;AAEb,QAAMA,iBAAiB,CAAC,IAAD,CAFV;AAGb,OAAKC,sBAAsB,CAAC,GAAD,CAHd;AAIb,OAAKA,sBAAsB,CAAC,GAAD,CAJd;AAKb,OAAKA,sBAAsB,CAAC,GAAD;AALd,CAAjB,C,CAQA;AACA;;AACA,SAASC,WAAT,CAAqBC,SAArB,EAAgCC,KAAhC,EAAuC;AACnC,MAAIC,aAAa,GAAGC,KAAK,CAACC,OAAN,CAAcH,KAAd,CAApB;AAEA,MAAII,YAAJ;;AAEA,WAASC,MAAT,CAAgBL,KAAhB,EAAuB;AACnB,WAAOP,SAAS,CAACO,KAAD,CAAT,GAAoB,CAACA,KAArB,GAA8B,IAArC;AACH;;AAED,MAAGT,SAAS,CAACe,eAAV,CAA0BC,OAA1B,CAAkCR,SAAlC,MAAiD,CAAC,CAArD,EAAwD;AACpDK,IAAAA,YAAY,GAAGH,aAAa,GAAGI,MAAM,CAACL,KAAK,CAAC,CAAD,CAAN,CAAT,GAAsBK,MAAM,CAACL,KAAD,CAAxD;AACH,GAFD,MAEO,IAAGT,SAAS,CAACiB,YAAV,CAAuBD,OAAvB,CAA+BR,SAA/B,MAA8C,CAAC,CAAlD,EAAqD;AACxDK,IAAAA,YAAY,GAAGH,aAAa,GACxB,CAACI,MAAM,CAACL,KAAK,CAAC,CAAD,CAAN,CAAP,EAAmBK,MAAM,CAACL,KAAK,CAAC,CAAD,CAAN,CAAzB,CADwB,GAExB,CAACK,MAAM,CAACL,KAAD,CAAP,EAAgBK,MAAM,CAACL,KAAD,CAAtB,CAFJ;AAGH,GAJM,MAIA,IAAGT,SAAS,CAACkB,OAAV,CAAkBF,OAAlB,CAA0BR,SAA1B,MAAyC,CAAC,CAA7C,EAAgD;AACnDK,IAAAA,YAAY,GAAGH,aAAa,GAAGD,KAAK,CAACU,GAAN,CAAUL,MAAV,CAAH,GAAuB,CAACA,MAAM,CAACL,KAAD,CAAP,CAAnD;AACH;;AAED,SAAOI,YAAP;AACH,C,CAED;AACA;AACA;;;AACA,SAASR,iBAAT,CAA2BG,SAA3B,EAAsC;AAClC,SAAO,UAASC,KAAT,EAAgB;AACnBA,IAAAA,KAAK,GAAGF,WAAW,CAACC,SAAD,EAAYC,KAAZ,CAAnB,CADmB,CAGnB;;AACA,QAAIW,GAAG,GAAGC,IAAI,CAACD,GAAL,CAASX,KAAK,CAAC,CAAD,CAAd,EAAmBA,KAAK,CAAC,CAAD,CAAxB,CAAV;AACA,QAAIa,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASb,KAAK,CAAC,CAAD,CAAd,EAAmBA,KAAK,CAAC,CAAD,CAAxB,CAAV;AAEA,WAAO;AACHc,MAAAA,KAAK,EAAEH,GADJ;AAEHI,MAAAA,GAAG,EAAEF,GAFF;AAGHG,MAAAA,IAAI,EAAEH,GAAG,GAAGF;AAHT,KAAP;AAKH,GAZD;AAaH;;AAED,SAASd,sBAAT,CAAgCE,SAAhC,EAA2C;AACvC,SAAO,UAASC,KAAT,EAAgB;AACnBA,IAAAA,KAAK,GAAGF,WAAW,CAACC,SAAD,EAAYC,KAAZ,CAAnB;AAEA,WAAO;AACHc,MAAAA,KAAK,EAAEd,KADJ;AAEHe,MAAAA,GAAG,EAAEE,QAFF;AAGHD,MAAAA,IAAI,EAAEC;AAHH,KAAP;AAKH,GARD;AASH","sourcesContent":["'use strict';\n\nvar filterOps = require('../../constants/filter_ops');\nvar isNumeric = require('fast-isnumeric');\n\n// This syntax conforms to the existing filter transform syntax, but we don't care\n// about open vs. closed intervals for simply drawing contours constraints:\nmodule.exports = {\n    '[]': makeRangeSettings('[]'),\n    '][': makeRangeSettings(']['),\n    '>': makeInequalitySettings('>'),\n    '<': makeInequalitySettings('<'),\n    '=': makeInequalitySettings('=')\n};\n\n// This does not in any way shape or form support calendars. It's adapted from\n// transforms/filter.js.\nfunction coerceValue(operation, value) {\n    var hasArrayValue = Array.isArray(value);\n\n    var coercedValue;\n\n    function coerce(value) {\n        return isNumeric(value) ? (+value) : null;\n    }\n\n    if(filterOps.COMPARISON_OPS2.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? coerce(value[0]) : coerce(value);\n    } else if(filterOps.INTERVAL_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ?\n            [coerce(value[0]), coerce(value[1])] :\n            [coerce(value), coerce(value)];\n    } else if(filterOps.SET_OPS.indexOf(operation) !== -1) {\n        coercedValue = hasArrayValue ? value.map(coerce) : [coerce(value)];\n    }\n\n    return coercedValue;\n}\n\n// Returns a parabola scaled so that the min/max is either +/- 1 and zero at the two values\n// provided. The data is mapped by this function when constructing intervals so that it's\n// very easy to construct contours as normal.\nfunction makeRangeSettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        // Ensure proper ordering:\n        var min = Math.min(value[0], value[1]);\n        var max = Math.max(value[0], value[1]);\n\n        return {\n            start: min,\n            end: max,\n            size: max - min\n        };\n    };\n}\n\nfunction makeInequalitySettings(operation) {\n    return function(value) {\n        value = coerceValue(operation, value);\n\n        return {\n            start: value,\n            end: Infinity,\n            size: Infinity\n        };\n    };\n}\n"]},"metadata":{},"sourceType":"script"}