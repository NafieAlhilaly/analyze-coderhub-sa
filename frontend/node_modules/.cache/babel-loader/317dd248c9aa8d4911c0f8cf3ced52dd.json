{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar fillText = Lib.fillText;\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var hoveron = trace.hoveron;\n  var closeBoxData = [];\n  var closePtData;\n\n  if (hoveron.indexOf('boxes') !== -1) {\n    closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n  }\n\n  if (hoveron.indexOf('points') !== -1) {\n    closePtData = hoverOnPoints(pointData, xval, yval);\n  } // If there's a point in range and hoveron has points, show the best single point only.\n  // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n\n\n  if (hovermode === 'closest') {\n    if (closePtData) return [closePtData];\n    return closeBoxData;\n  } // Otherwise in compare mode, allow a point AND the box stats to be labeled\n  // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n\n\n  if (closePtData) {\n    closeBoxData.push(closePtData);\n    return closeBoxData;\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isViolin = trace.type === 'violin';\n  var closeBoxData = [];\n  var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos, hoverPseudoDistance, spikePseudoDistance;\n  var boxDelta = t.bdPos;\n  var boxDeltaPos, boxDeltaNeg;\n  var posAcceptance = t.wHover;\n\n  var shiftPos = function (di) {\n    return pAxis.c2l(di.pos) + t.bPos - pAxis.c2l(pVal);\n  };\n\n  if (isViolin && trace.side !== 'both') {\n    if (trace.side === 'positive') {\n      dPos = function (di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n      };\n\n      boxDeltaPos = boxDelta;\n      boxDeltaNeg = 0;\n    }\n\n    if (trace.side === 'negative') {\n      dPos = function (di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n      };\n\n      boxDeltaPos = 0;\n      boxDeltaNeg = boxDelta;\n    }\n  } else {\n    dPos = function (di) {\n      var pos = shiftPos(di);\n      return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n    };\n\n    boxDeltaPos = boxDeltaNeg = boxDelta;\n  }\n\n  var dVal;\n\n  if (isViolin) {\n    dVal = function (di) {\n      return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n    };\n  } else {\n    dVal = function (di) {\n      return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n    };\n  }\n\n  if (trace.orientation === 'h') {\n    vVal = xval;\n    pVal = yval;\n    dx = dVal;\n    dy = dPos;\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    vVal = yval;\n    pVal = xval;\n    dx = dPos;\n    dy = dVal;\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  } // if two boxes are overlaying, let the narrowest one win\n\n\n  var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n  // and create the item(s) in closedata for this point\n\n  if (pointData.index === false) return [];\n  var di = cd[pointData.index];\n  var lc = trace.line.color;\n  var mc = (trace.marker || {}).color;\n  if (Color.opacity(lc) && trace.line.width) pointData.color = lc;else if (Color.opacity(mc) && trace.boxpoints) pointData.color = mc;else pointData.color = trace.fillcolor;\n  pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);\n  pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);\n  pointData[pLetter + 'LabelVal'] = di.orig_p !== undefined ? di.orig_p : di.pos;\n  var spikePosAttr = pLetter + 'Spike';\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData[spikePosAttr] = pAxis.c2p(di.pos, true); // box plots: each \"point\" gets many labels\n\n  var usedVals = {};\n  var attrs = ['med', 'q1', 'q3', 'min', 'max'];\n\n  if (trace.boxmean || (trace.meanline || {}).visible) {\n    attrs.push('mean');\n  }\n\n  if (trace.boxpoints || trace.points) {\n    attrs.push('lf', 'uf');\n  }\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!(attr in di) || di[attr] in usedVals) continue;\n    usedVals[di[attr]] = true; // copy out to a new object for each value to label\n\n    var val = di[attr];\n    var valPx = vAxis.c2p(val, true);\n    var pointData2 = Lib.extendFlat({}, pointData);\n    pointData2.attr = attr;\n    pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n    pointData2[vLetter + 'LabelVal'] = val;\n    pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val, trace[vLetter + 'hoverformat']); // Note: introduced to be able to distinguish a\n    // clicked point from a box during click-to-select\n\n    pointData2.hoverOnBox = true;\n\n    if (attr === 'mean' && 'sd' in di && trace.boxmean === 'sd') {\n      pointData2[vLetter + 'err'] = di.sd;\n    } // only keep name and spikes on the first item (median)\n\n\n    pointData.name = '';\n    pointData.spikeDistance = undefined;\n    pointData[spikePosAttr] = undefined; // no hovertemplate support yet\n\n    pointData2.hovertemplate = false;\n    closeBoxData.push(pointData2);\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var xPx = xa.c2p(xval);\n  var yPx = ya.c2p(yval);\n  var closePtData;\n\n  var dx = function (di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n  };\n\n  var dy = function (di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n  };\n\n  var distfn = Fx.quadrature(dx, dy); // show one point per trace\n\n  var ijClosest = false;\n  var di, pt;\n\n  for (var i = 0; i < cd.length; i++) {\n    di = cd[i];\n\n    for (var j = 0; j < (di.pts || []).length; j++) {\n      pt = di.pts[j];\n      var newDistance = distfn(pt);\n\n      if (newDistance <= pointData.distance) {\n        pointData.distance = newDistance;\n        ijClosest = [i, j];\n      }\n    }\n  }\n\n  if (!ijClosest) return false;\n  di = cd[ijClosest[0]];\n  pt = di.pts[ijClosest[1]];\n  var xc = xa.c2p(pt.x, true);\n  var yc = ya.c2p(pt.y, true);\n  var rad = pt.mrc || 1;\n  closePtData = Lib.extendFlat({}, pointData, {\n    // corresponds to index in x/y input data array\n    index: pt.i,\n    color: (trace.marker || {}).color,\n    name: trace.name,\n    x0: xc - rad,\n    x1: xc + rad,\n    y0: yc - rad,\n    y1: yc + rad,\n    spikeDistance: pointData.distance,\n    hovertemplate: trace.hovertemplate\n  });\n  var origPos = di.orig_p;\n  var pos = origPos !== undefined ? origPos : di.pos;\n  var pa;\n\n  if (trace.orientation === 'h') {\n    pa = ya;\n    closePtData.xLabelVal = pt.x;\n    closePtData.yLabelVal = pos;\n  } else {\n    pa = xa;\n    closePtData.xLabelVal = pos;\n    closePtData.yLabelVal = pt.y;\n  }\n\n  var pLetter = pa._id.charAt(0);\n\n  closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n  fillText(pt, trace, closePtData);\n  return closePtData;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBoxes: hoverOnBoxes,\n  hoverOnPoints: hoverOnPoints\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/box/hover.js"],"names":["Axes","require","Lib","Fx","Color","fillText","hoverPoints","pointData","xval","yval","hovermode","cd","trace","hoveron","closeBoxData","closePtData","indexOf","concat","hoverOnBoxes","hoverOnPoints","push","xa","ya","t","isViolin","type","pLetter","vLetter","pAxis","vAxis","vVal","pVal","dx","dy","dPos","hoverPseudoDistance","spikePseudoDistance","boxDelta","bdPos","boxDeltaPos","boxDeltaNeg","posAcceptance","wHover","shiftPos","di","c2l","pos","bPos","side","inbox","dVal","span","min","max","orientation","pseudoDistance","Math","abs","r2c","range","maxHoverDistance","maxSpikeDistance","dxy","distfn","getDistanceFunction","getClosest","index","lc","line","color","mc","marker","opacity","width","boxpoints","fillcolor","c2p","orig_p","undefined","spikePosAttr","spikeDistance","usedVals","attrs","boxmean","meanline","visible","points","i","length","attr","val","valPx","pointData2","extendFlat","labels","hoverLabelText","hoverOnBox","sd","name","hovertemplate","xPx","yPx","rad","mrc","x","y","quadrature","ijClosest","pt","j","pts","newDistance","distance","xc","yc","x0","x1","y0","y1","origPos","pa","xLabelVal","yLabelVal","_id","charAt","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillText = Lib.fillText;\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var hoveron = trace.hoveron;\n    var closeBoxData = [];\n    var closePtData;\n\n    if(hoveron.indexOf('boxes') !== -1) {\n        closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n    }\n\n    if(hoveron.indexOf('points') !== -1) {\n        closePtData = hoverOnPoints(pointData, xval, yval);\n    }\n\n    // If there's a point in range and hoveron has points, show the best single point only.\n    // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n    if(hovermode === 'closest') {\n        if(closePtData) return [closePtData];\n        return closeBoxData;\n    }\n\n    // Otherwise in compare mode, allow a point AND the box stats to be labeled\n    // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n    if(closePtData) {\n        closeBoxData.push(closePtData);\n        return closeBoxData;\n    }\n    return closeBoxData;\n}\n\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isViolin = trace.type === 'violin';\n    var closeBoxData = [];\n\n    var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos,\n        hoverPseudoDistance, spikePseudoDistance;\n\n    var boxDelta = t.bdPos;\n    var boxDeltaPos, boxDeltaNeg;\n    var posAcceptance = t.wHover;\n    var shiftPos = function(di) { return pAxis.c2l(di.pos) + t.bPos - pAxis.c2l(pVal); };\n\n    if(isViolin && trace.side !== 'both') {\n        if(trace.side === 'positive') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n            };\n            boxDeltaPos = boxDelta;\n            boxDeltaNeg = 0;\n        }\n        if(trace.side === 'negative') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n            };\n            boxDeltaPos = 0;\n            boxDeltaNeg = boxDelta;\n        }\n    } else {\n        dPos = function(di) {\n            var pos = shiftPos(di);\n            return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n        };\n        boxDeltaPos = boxDeltaNeg = boxDelta;\n    }\n\n    var dVal;\n\n    if(isViolin) {\n        dVal = function(di) {\n            return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n        };\n    } else {\n        dVal = function(di) {\n            return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n        };\n    }\n\n    if(trace.orientation === 'h') {\n        vVal = xval;\n        pVal = yval;\n        dx = dVal;\n        dy = dPos;\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        vVal = yval;\n        pVal = xval;\n        dx = dPos;\n        dy = dVal;\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    // if two boxes are overlaying, let the narrowest one win\n    var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n    hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n    spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    // and create the item(s) in closedata for this point\n    if(pointData.index === false) return [];\n\n    var di = cd[pointData.index];\n    var lc = trace.line.color;\n    var mc = (trace.marker || {}).color;\n\n    if(Color.opacity(lc) && trace.line.width) pointData.color = lc;\n    else if(Color.opacity(mc) && trace.boxpoints) pointData.color = mc;\n    else pointData.color = trace.fillcolor;\n\n    pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);\n    pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);\n\n    pointData[pLetter + 'LabelVal'] = di.orig_p !== undefined ? di.orig_p : di.pos;\n\n    var spikePosAttr = pLetter + 'Spike';\n    pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n    pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n\n    // box plots: each \"point\" gets many labels\n    var usedVals = {};\n    var attrs = ['med', 'q1', 'q3', 'min', 'max'];\n\n    if(trace.boxmean || (trace.meanline || {}).visible) {\n        attrs.push('mean');\n    }\n    if(trace.boxpoints || trace.points) {\n        attrs.push('lf', 'uf');\n    }\n\n    for(var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n\n        if(!(attr in di) || (di[attr] in usedVals)) continue;\n        usedVals[di[attr]] = true;\n\n        // copy out to a new object for each value to label\n        var val = di[attr];\n        var valPx = vAxis.c2p(val, true);\n        var pointData2 = Lib.extendFlat({}, pointData);\n\n        pointData2.attr = attr;\n        pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n        pointData2[vLetter + 'LabelVal'] = val;\n        pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val, trace[vLetter + 'hoverformat']);\n\n        // Note: introduced to be able to distinguish a\n        // clicked point from a box during click-to-select\n        pointData2.hoverOnBox = true;\n\n        if(attr === 'mean' && ('sd' in di) && trace.boxmean === 'sd') {\n            pointData2[vLetter + 'err'] = di.sd;\n        }\n\n        // only keep name and spikes on the first item (median)\n        pointData.name = '';\n        pointData.spikeDistance = undefined;\n        pointData[spikePosAttr] = undefined;\n\n        // no hovertemplate support yet\n        pointData2.hovertemplate = false;\n\n        closeBoxData.push(pointData2);\n    }\n\n    return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var xPx = xa.c2p(xval);\n    var yPx = ya.c2p(yval);\n    var closePtData;\n\n    var dx = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n    };\n    var dy = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n    };\n    var distfn = Fx.quadrature(dx, dy);\n\n    // show one point per trace\n    var ijClosest = false;\n    var di, pt;\n\n    for(var i = 0; i < cd.length; i++) {\n        di = cd[i];\n\n        for(var j = 0; j < (di.pts || []).length; j++) {\n            pt = di.pts[j];\n\n            var newDistance = distfn(pt);\n            if(newDistance <= pointData.distance) {\n                pointData.distance = newDistance;\n                ijClosest = [i, j];\n            }\n        }\n    }\n\n    if(!ijClosest) return false;\n\n    di = cd[ijClosest[0]];\n    pt = di.pts[ijClosest[1]];\n\n    var xc = xa.c2p(pt.x, true);\n    var yc = ya.c2p(pt.y, true);\n    var rad = pt.mrc || 1;\n\n    closePtData = Lib.extendFlat({}, pointData, {\n        // corresponds to index in x/y input data array\n        index: pt.i,\n        color: (trace.marker || {}).color,\n        name: trace.name,\n        x0: xc - rad,\n        x1: xc + rad,\n        y0: yc - rad,\n        y1: yc + rad,\n        spikeDistance: pointData.distance,\n        hovertemplate: trace.hovertemplate\n    });\n\n    var origPos = di.orig_p;\n    var pos = origPos !== undefined ? origPos : di.pos;\n    var pa;\n    if(trace.orientation === 'h') {\n        pa = ya;\n        closePtData.xLabelVal = pt.x;\n        closePtData.yLabelVal = pos;\n    } else {\n        pa = xa;\n        closePtData.xLabelVal = pos;\n        closePtData.yLabelVal = pt.y;\n    }\n\n    var pLetter = pa._id.charAt(0);\n    closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n\n    fillText(pt, trace, closePtData);\n\n    return closePtData;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverOnBoxes: hoverOnBoxes,\n    hoverOnPoints: hoverOnPoints\n};\n"]},"metadata":{},"sourceType":"script"}