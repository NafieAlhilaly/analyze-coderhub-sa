{"ast":null,"code":"'use strict';\n\nvar Loggers = require('./lib/loggers');\n\nvar noop = require('./lib/noop');\n\nvar pushUnique = require('./lib/push_unique');\n\nvar isPlainObject = require('./lib/is_plain_object');\n\nvar addStyleRule = require('./lib/dom').addStyleRule;\n\nvar ExtendModule = require('./lib/extend');\n\nvar basePlotAttributes = require('./plots/attributes');\n\nvar baseLayoutAttributes = require('./plots/layout_attributes');\n\nvar extendFlat = ExtendModule.extendFlat;\nvar extendDeepAll = ExtendModule.extendDeepAll;\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\nexports.traceLayoutAttributes = {};\nexports.localeRegistry = {};\nexports.apiMethodRegistry = {};\nexports.collectableSubplotTypes = null;\n/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */\n\nexports.register = function register(_modules) {\n  exports.collectableSubplotTypes = null;\n\n  if (!_modules) {\n    throw new Error('No argument passed to Plotly.register.');\n  } else if (_modules && !Array.isArray(_modules)) {\n    _modules = [_modules];\n  }\n\n  for (var i = 0; i < _modules.length; i++) {\n    var newModule = _modules[i];\n\n    if (!newModule) {\n      throw new Error('Invalid module was attempted to be registered!');\n    }\n\n    switch (newModule.moduleType) {\n      case 'trace':\n        registerTraceModule(newModule);\n        break;\n\n      case 'transform':\n        registerTransformModule(newModule);\n        break;\n\n      case 'component':\n        registerComponentModule(newModule);\n        break;\n\n      case 'locale':\n        registerLocale(newModule);\n        break;\n\n      case 'apiMethod':\n        var name = newModule.name;\n        exports.apiMethodRegistry[name] = newModule.fn;\n        break;\n\n      default:\n        throw new Error('Invalid module was attempted to be registered!');\n    }\n  }\n};\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\n\n\nexports.getModule = function (trace) {\n  var _module = exports.modules[getTraceType(trace)];\n  if (!_module) return false;\n  return _module._module;\n};\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\n\n\nexports.traceIs = function (traceType, category) {\n  traceType = getTraceType(traceType); // old Chart Studio Cloud workspace hack, nothing to see here\n\n  if (traceType === 'various') return false;\n  var _module = exports.modules[traceType];\n\n  if (!_module) {\n    if (traceType) {\n      Loggers.log('Unrecognized trace type ' + traceType + '.');\n    }\n\n    _module = exports.modules[basePlotAttributes.type.dflt];\n  }\n\n  return !!_module.categories[category];\n};\n/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */\n\n\nexports.getTransformIndices = function (data, type) {\n  var indices = [];\n  var transforms = data.transforms || [];\n\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n};\n/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */\n\n\nexports.hasTransform = function (data, type) {\n  var transforms = data.transforms || [];\n\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\n\n\nexports.getComponentMethod = function (name, method) {\n  var _module = exports.componentsRegistry[name];\n  if (!_module) return noop;\n  return _module[method] || noop;\n};\n/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */\n\n\nexports.call = function () {\n  var name = arguments[0];\n  var args = [].slice.call(arguments, 1);\n  return exports.apiMethodRegistry[name].apply(null, args);\n};\n\nfunction registerTraceModule(_module) {\n  var thisType = _module.name;\n  var categoriesIn = _module.categories;\n  var meta = _module.meta;\n\n  if (exports.modules[thisType]) {\n    Loggers.log('Type ' + thisType + ' already registered');\n    return;\n  }\n\n  if (!exports.subplotsRegistry[_module.basePlotModule.name]) {\n    registerSubplot(_module.basePlotModule);\n  }\n\n  var categoryObj = {};\n\n  for (var i = 0; i < categoriesIn.length; i++) {\n    categoryObj[categoriesIn[i]] = true;\n    exports.allCategories[categoriesIn[i]] = true;\n  }\n\n  exports.modules[thisType] = {\n    _module: _module,\n    categories: categoryObj\n  };\n\n  if (meta && Object.keys(meta).length) {\n    exports.modules[thisType].meta = meta;\n  }\n\n  exports.allTypes.push(thisType);\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTrace(componentName, thisType);\n  }\n  /*\n   * Collect all trace layout attributes in one place for easier lookup later\n   * but don't merge them into the base schema as it would confuse the docs\n   * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n   */\n\n\n  if (_module.layoutAttributes) {\n    extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);\n  }\n\n  var basePlotModule = _module.basePlotModule;\n  var bpmName = basePlotModule.name; // add mapbox-gl CSS here to avoid console warning on instantiation\n\n  if (bpmName === 'mapbox') {\n    var styleRules = basePlotModule.constants.styleRules;\n\n    for (var k in styleRules) {\n      addStyleRule('.js-plotly-plot .plotly .mapboxgl-' + k, styleRules[k]);\n    }\n  } // if `plotly-geo-assets.js` is not included,\n  // add `PlotlyGeoAssets` global to stash references to all fetched\n  // topojson / geojson data\n\n\n  if ((bpmName === 'geo' || bpmName === 'mapbox') && typeof window !== undefined && window.PlotlyGeoAssets === undefined) {\n    window.PlotlyGeoAssets = {\n      topojson: {}\n    };\n  }\n}\n\nfunction registerSubplot(_module) {\n  var plotType = _module.name;\n\n  if (exports.subplotsRegistry[plotType]) {\n    Loggers.log('Plot type ' + plotType + ' already registered.');\n    return;\n  } // relayout array handling will look for component module methods with this\n  // name and won't find them because this is a subplot module... but that\n  // should be fine, it will just fall back on redrawing the plot.\n\n\n  findArrayRegexps(_module); // not sure what's best for the 'cartesian' type at this point\n\n  exports.subplotsRegistry[plotType] = _module;\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToSubplot(componentName, _module.name);\n  }\n}\n\nfunction registerComponentModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Component module *name* must be a string.');\n  }\n\n  var name = _module.name;\n  exports.componentsRegistry[name] = _module;\n\n  if (_module.layoutAttributes) {\n    if (_module.layoutAttributes._isLinkedToArray) {\n      pushUnique(exports.layoutArrayContainers, name);\n    }\n\n    findArrayRegexps(_module);\n  }\n\n  for (var traceType in exports.modules) {\n    mergeComponentAttrsToTrace(name, traceType);\n  }\n\n  for (var subplotName in exports.subplotsRegistry) {\n    mergeComponentAttrsToSubplot(name, subplotName);\n  }\n\n  for (var transformType in exports.transformsRegistry) {\n    mergeComponentAttrsToTransform(name, transformType);\n  }\n\n  if (_module.schema && _module.schema.layout) {\n    extendDeepAll(baseLayoutAttributes, _module.schema.layout);\n  }\n}\n\nfunction registerTransformModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Transform module *name* must be a string.');\n  }\n\n  var prefix = 'Transform module ' + _module.name;\n  var hasTransform = typeof _module.transform === 'function';\n  var hasCalcTransform = typeof _module.calcTransform === 'function';\n\n  if (!hasTransform && !hasCalcTransform) {\n    throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n  }\n\n  if (hasTransform && hasCalcTransform) {\n    Loggers.log([prefix + ' has both a *transform* and *calcTransform* methods.', 'Please note that all *transform* methods are executed', 'before all *calcTransform* methods.'].join(' '));\n  }\n\n  if (!isPlainObject(_module.attributes)) {\n    Loggers.log(prefix + ' registered without an *attributes* object.');\n  }\n\n  if (typeof _module.supplyDefaults !== 'function') {\n    Loggers.log(prefix + ' registered without a *supplyDefaults* method.');\n  }\n\n  exports.transformsRegistry[_module.name] = _module;\n\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTransform(componentName, _module.name);\n  }\n}\n\nfunction registerLocale(_module) {\n  var locale = _module.name;\n  var baseLocale = locale.split('-')[0];\n  var newDict = _module.dictionary;\n  var newFormat = _module.format;\n  var hasDict = newDict && Object.keys(newDict).length;\n  var hasFormat = newFormat && Object.keys(newFormat).length;\n  var locales = exports.localeRegistry;\n  var localeObj = locales[locale];\n  if (!localeObj) locales[locale] = localeObj = {}; // Should we use this dict for the base locale?\n  // In case we're overwriting a previous dict for this locale, check\n  // whether the base matches the full locale dict now. If we're not\n  // overwriting, locales[locale] is undefined so this just checks if\n  // baseLocale already had a dict or not.\n  // Same logic for dateFormats\n\n  if (baseLocale !== locale) {\n    var baseLocaleObj = locales[baseLocale];\n    if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};\n\n    if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {\n      baseLocaleObj.dictionary = newDict;\n    }\n\n    if (hasFormat && baseLocaleObj.format === localeObj.format) {\n      baseLocaleObj.format = newFormat;\n    }\n  }\n\n  if (hasDict) localeObj.dictionary = newDict;\n  if (hasFormat) localeObj.format = newFormat;\n}\n\nfunction findArrayRegexps(_module) {\n  if (_module.layoutAttributes) {\n    var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n\n    if (arrayAttrRegexps) {\n      for (var i = 0; i < arrayAttrRegexps.length; i++) {\n        pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n      }\n    }\n  }\n}\n\nfunction mergeComponentAttrsToTrace(componentName, traceType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.traces) return;\n  var traceAttrs = componentSchema.traces[traceType];\n\n  if (traceAttrs) {\n    extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);\n  }\n}\n\nfunction mergeComponentAttrsToTransform(componentName, transformType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.transforms) return;\n  var transformAttrs = componentSchema.transforms[transformType];\n\n  if (transformAttrs) {\n    extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);\n  }\n}\n\nfunction mergeComponentAttrsToSubplot(componentName, subplotName) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.subplots) return;\n  var subplotModule = exports.subplotsRegistry[subplotName];\n  var subplotAttrs = subplotModule.layoutAttributes;\n  var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;\n  if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];\n  var componentLayoutAttrs = componentSchema.subplots[subplotAttr];\n\n  if (subplotAttrs && componentLayoutAttrs) {\n    extendDeepAll(subplotAttrs, componentLayoutAttrs);\n  }\n}\n\nfunction getTraceType(traceType) {\n  if (typeof traceType === 'object') traceType = traceType.type;\n  return traceType;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/registry.js"],"names":["Loggers","require","noop","pushUnique","isPlainObject","addStyleRule","ExtendModule","basePlotAttributes","baseLayoutAttributes","extendFlat","extendDeepAll","exports","modules","allCategories","allTypes","subplotsRegistry","transformsRegistry","componentsRegistry","layoutArrayContainers","layoutArrayRegexes","traceLayoutAttributes","localeRegistry","apiMethodRegistry","collectableSubplotTypes","register","_modules","Error","Array","isArray","i","length","newModule","moduleType","registerTraceModule","registerTransformModule","registerComponentModule","registerLocale","name","fn","getModule","trace","_module","getTraceType","traceIs","traceType","category","log","type","dflt","categories","getTransformIndices","data","indices","transforms","push","hasTransform","getComponentMethod","method","call","arguments","args","slice","apply","thisType","categoriesIn","meta","basePlotModule","registerSubplot","categoryObj","Object","keys","componentName","mergeComponentAttrsToTrace","layoutAttributes","bpmName","styleRules","constants","k","window","undefined","PlotlyGeoAssets","topojson","plotType","findArrayRegexps","mergeComponentAttrsToSubplot","_isLinkedToArray","subplotName","transformType","mergeComponentAttrsToTransform","schema","layout","prefix","transform","hasCalcTransform","calcTransform","join","attributes","supplyDefaults","locale","baseLocale","split","newDict","dictionary","newFormat","format","hasDict","hasFormat","locales","localeObj","baseLocaleObj","arrayAttrRegexps","_arrayAttrRegexps","componentSchema","traces","traceAttrs","transformAttrs","subplots","subplotModule","subplotAttrs","subplotAttr","attr","componentLayoutAttrs"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Loggers = require('./lib/loggers');\nvar noop = require('./lib/noop');\nvar pushUnique = require('./lib/push_unique');\nvar isPlainObject = require('./lib/is_plain_object');\nvar addStyleRule = require('./lib/dom').addStyleRule;\nvar ExtendModule = require('./lib/extend');\n\nvar basePlotAttributes = require('./plots/attributes');\nvar baseLayoutAttributes = require('./plots/layout_attributes');\n\nvar extendFlat = ExtendModule.extendFlat;\nvar extendDeepAll = ExtendModule.extendDeepAll;\n\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\nexports.traceLayoutAttributes = {};\nexports.localeRegistry = {};\nexports.apiMethodRegistry = {};\nexports.collectableSubplotTypes = null;\n\n/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */\nexports.register = function register(_modules) {\n    exports.collectableSubplotTypes = null;\n\n    if(!_modules) {\n        throw new Error('No argument passed to Plotly.register.');\n    } else if(_modules && !Array.isArray(_modules)) {\n        _modules = [_modules];\n    }\n\n    for(var i = 0; i < _modules.length; i++) {\n        var newModule = _modules[i];\n\n        if(!newModule) {\n            throw new Error('Invalid module was attempted to be registered!');\n        }\n\n        switch(newModule.moduleType) {\n            case 'trace':\n                registerTraceModule(newModule);\n                break;\n            case 'transform':\n                registerTransformModule(newModule);\n                break;\n            case 'component':\n                registerComponentModule(newModule);\n                break;\n            case 'locale':\n                registerLocale(newModule);\n                break;\n            case 'apiMethod':\n                var name = newModule.name;\n                exports.apiMethodRegistry[name] = newModule.fn;\n                break;\n            default:\n                throw new Error('Invalid module was attempted to be registered!');\n        }\n    }\n};\n\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\nexports.getModule = function(trace) {\n    var _module = exports.modules[getTraceType(trace)];\n    if(!_module) return false;\n    return _module._module;\n};\n\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\nexports.traceIs = function(traceType, category) {\n    traceType = getTraceType(traceType);\n\n    // old Chart Studio Cloud workspace hack, nothing to see here\n    if(traceType === 'various') return false;\n\n    var _module = exports.modules[traceType];\n\n    if(!_module) {\n        if(traceType) {\n            Loggers.log('Unrecognized trace type ' + traceType + '.');\n        }\n\n        _module = exports.modules[basePlotAttributes.type.dflt];\n    }\n\n    return !!_module.categories[category];\n};\n\n/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */\nexports.getTransformIndices = function(data, type) {\n    var indices = [];\n    var transforms = data.transforms || [];\n    for(var i = 0; i < transforms.length; i++) {\n        if(transforms[i].type === type) {\n            indices.push(i);\n        }\n    }\n    return indices;\n};\n\n/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */\nexports.hasTransform = function(data, type) {\n    var transforms = data.transforms || [];\n    for(var i = 0; i < transforms.length; i++) {\n        if(transforms[i].type === type) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\nexports.getComponentMethod = function(name, method) {\n    var _module = exports.componentsRegistry[name];\n\n    if(!_module) return noop;\n    return _module[method] || noop;\n};\n\n/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */\nexports.call = function() {\n    var name = arguments[0];\n    var args = [].slice.call(arguments, 1);\n    return exports.apiMethodRegistry[name].apply(null, args);\n};\n\nfunction registerTraceModule(_module) {\n    var thisType = _module.name;\n    var categoriesIn = _module.categories;\n    var meta = _module.meta;\n\n    if(exports.modules[thisType]) {\n        Loggers.log('Type ' + thisType + ' already registered');\n        return;\n    }\n\n    if(!exports.subplotsRegistry[_module.basePlotModule.name]) {\n        registerSubplot(_module.basePlotModule);\n    }\n\n    var categoryObj = {};\n    for(var i = 0; i < categoriesIn.length; i++) {\n        categoryObj[categoriesIn[i]] = true;\n        exports.allCategories[categoriesIn[i]] = true;\n    }\n\n    exports.modules[thisType] = {\n        _module: _module,\n        categories: categoryObj\n    };\n\n    if(meta && Object.keys(meta).length) {\n        exports.modules[thisType].meta = meta;\n    }\n\n    exports.allTypes.push(thisType);\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToTrace(componentName, thisType);\n    }\n\n    /*\n     * Collect all trace layout attributes in one place for easier lookup later\n     * but don't merge them into the base schema as it would confuse the docs\n     * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n     */\n    if(_module.layoutAttributes) {\n        extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);\n    }\n\n    var basePlotModule = _module.basePlotModule;\n    var bpmName = basePlotModule.name;\n\n    // add mapbox-gl CSS here to avoid console warning on instantiation\n    if(bpmName === 'mapbox') {\n        var styleRules = basePlotModule.constants.styleRules;\n        for(var k in styleRules) {\n            addStyleRule('.js-plotly-plot .plotly .mapboxgl-' + k, styleRules[k]);\n        }\n    }\n\n    // if `plotly-geo-assets.js` is not included,\n    // add `PlotlyGeoAssets` global to stash references to all fetched\n    // topojson / geojson data\n    if((bpmName === 'geo' || bpmName === 'mapbox') &&\n        (typeof window !== undefined && window.PlotlyGeoAssets === undefined)\n    ) {\n        window.PlotlyGeoAssets = {topojson: {}};\n    }\n}\n\nfunction registerSubplot(_module) {\n    var plotType = _module.name;\n\n    if(exports.subplotsRegistry[plotType]) {\n        Loggers.log('Plot type ' + plotType + ' already registered.');\n        return;\n    }\n\n    // relayout array handling will look for component module methods with this\n    // name and won't find them because this is a subplot module... but that\n    // should be fine, it will just fall back on redrawing the plot.\n    findArrayRegexps(_module);\n\n    // not sure what's best for the 'cartesian' type at this point\n    exports.subplotsRegistry[plotType] = _module;\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToSubplot(componentName, _module.name);\n    }\n}\n\nfunction registerComponentModule(_module) {\n    if(typeof _module.name !== 'string') {\n        throw new Error('Component module *name* must be a string.');\n    }\n\n    var name = _module.name;\n    exports.componentsRegistry[name] = _module;\n\n    if(_module.layoutAttributes) {\n        if(_module.layoutAttributes._isLinkedToArray) {\n            pushUnique(exports.layoutArrayContainers, name);\n        }\n        findArrayRegexps(_module);\n    }\n\n    for(var traceType in exports.modules) {\n        mergeComponentAttrsToTrace(name, traceType);\n    }\n\n    for(var subplotName in exports.subplotsRegistry) {\n        mergeComponentAttrsToSubplot(name, subplotName);\n    }\n\n    for(var transformType in exports.transformsRegistry) {\n        mergeComponentAttrsToTransform(name, transformType);\n    }\n\n    if(_module.schema && _module.schema.layout) {\n        extendDeepAll(baseLayoutAttributes, _module.schema.layout);\n    }\n}\n\nfunction registerTransformModule(_module) {\n    if(typeof _module.name !== 'string') {\n        throw new Error('Transform module *name* must be a string.');\n    }\n\n    var prefix = 'Transform module ' + _module.name;\n    var hasTransform = typeof _module.transform === 'function';\n    var hasCalcTransform = typeof _module.calcTransform === 'function';\n\n    if(!hasTransform && !hasCalcTransform) {\n        throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n    }\n    if(hasTransform && hasCalcTransform) {\n        Loggers.log([\n            prefix + ' has both a *transform* and *calcTransform* methods.',\n            'Please note that all *transform* methods are executed',\n            'before all *calcTransform* methods.'\n        ].join(' '));\n    }\n    if(!isPlainObject(_module.attributes)) {\n        Loggers.log(prefix + ' registered without an *attributes* object.');\n    }\n    if(typeof _module.supplyDefaults !== 'function') {\n        Loggers.log(prefix + ' registered without a *supplyDefaults* method.');\n    }\n\n    exports.transformsRegistry[_module.name] = _module;\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToTransform(componentName, _module.name);\n    }\n}\n\nfunction registerLocale(_module) {\n    var locale = _module.name;\n    var baseLocale = locale.split('-')[0];\n\n    var newDict = _module.dictionary;\n    var newFormat = _module.format;\n    var hasDict = newDict && Object.keys(newDict).length;\n    var hasFormat = newFormat && Object.keys(newFormat).length;\n\n    var locales = exports.localeRegistry;\n\n    var localeObj = locales[locale];\n    if(!localeObj) locales[locale] = localeObj = {};\n\n    // Should we use this dict for the base locale?\n    // In case we're overwriting a previous dict for this locale, check\n    // whether the base matches the full locale dict now. If we're not\n    // overwriting, locales[locale] is undefined so this just checks if\n    // baseLocale already had a dict or not.\n    // Same logic for dateFormats\n    if(baseLocale !== locale) {\n        var baseLocaleObj = locales[baseLocale];\n        if(!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};\n\n        if(hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {\n            baseLocaleObj.dictionary = newDict;\n        }\n        if(hasFormat && baseLocaleObj.format === localeObj.format) {\n            baseLocaleObj.format = newFormat;\n        }\n    }\n\n    if(hasDict) localeObj.dictionary = newDict;\n    if(hasFormat) localeObj.format = newFormat;\n}\n\nfunction findArrayRegexps(_module) {\n    if(_module.layoutAttributes) {\n        var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n        if(arrayAttrRegexps) {\n            for(var i = 0; i < arrayAttrRegexps.length; i++) {\n                pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n            }\n        }\n    }\n}\n\nfunction mergeComponentAttrsToTrace(componentName, traceType) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.traces) return;\n\n    var traceAttrs = componentSchema.traces[traceType];\n    if(traceAttrs) {\n        extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);\n    }\n}\n\nfunction mergeComponentAttrsToTransform(componentName, transformType) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.transforms) return;\n\n    var transformAttrs = componentSchema.transforms[transformType];\n    if(transformAttrs) {\n        extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);\n    }\n}\n\nfunction mergeComponentAttrsToSubplot(componentName, subplotName) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.subplots) return;\n\n    var subplotModule = exports.subplotsRegistry[subplotName];\n    var subplotAttrs = subplotModule.layoutAttributes;\n    var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;\n    if(Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];\n\n    var componentLayoutAttrs = componentSchema.subplots[subplotAttr];\n    if(subplotAttrs && componentLayoutAttrs) {\n        extendDeepAll(subplotAttrs, componentLayoutAttrs);\n    }\n}\n\nfunction getTraceType(traceType) {\n    if(typeof traceType === 'object') traceType = traceType.type;\n    return traceType;\n}\n"]},"metadata":{},"sourceType":"script"}