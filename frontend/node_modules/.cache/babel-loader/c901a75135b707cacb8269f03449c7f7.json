{"ast":null,"code":"import { min, ascending, max, mean, sum } from 'd3-array';\nimport { map, nest } from 'd3-collection';\nimport { linkHorizontal } from 'd3-shape';\nimport findCircuits from 'elementary-circuits-directed-graph'; // For a given link, return the target node's depth\n\nfunction targetDepth(d) {\n  return d.target.depth;\n} // The depth of a node when the nodeAlign (align) is set to 'left'\n\n\nfunction left(node) {\n  return node.depth;\n} // The depth of a node when the nodeAlign (align) is set to 'right'\n\n\nfunction right(node, n) {\n  return n - 1 - node.height;\n} // The depth of a node when the nodeAlign (align) is set to 'justify'\n\n\nfunction justify(node, n) {\n  return node.sourceLinks.length ? node.depth : n - 1;\n} // The depth of a node when the nodeAlign (align) is set to 'center'\n\n\nfunction center(node) {\n  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;\n} // returns a function, using the parameter given to the sankey setting\n\n\nfunction constant(x) {\n  return function () {\n    return x;\n  };\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; /// https://github.com/tomshanley/d3-sankeyCircular-circular\n// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths\n\n\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n} // sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths\n\n\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n} // sort nodes' breadth (ie top to bottom in a column)\n// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node\n// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom\n\n\nfunction ascendingBreadth(a, b) {\n  if (a.partOfCycle === b.partOfCycle) {\n    return a.y0 - b.y0;\n  } else {\n    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n} // return the value of a node or link\n\n\nfunction value(d) {\n  return d.value;\n} // return the vertical center of a node\n\n\nfunction nodeCenter(node) {\n  return (node.y0 + node.y1) / 2;\n} // return the vertical center of a link's source node\n\n\nfunction linkSourceCenter(link) {\n  return nodeCenter(link.source);\n} // return the vertical center of a link's target node\n\n\nfunction linkTargetCenter(link) {\n  return nodeCenter(link.target);\n} // Return the default value for ID for node, d.index\n\n\nfunction defaultId(d) {\n  return d.index;\n} // Return the default object the graph's nodes, graph.nodes\n\n\nfunction defaultNodes(graph) {\n  return graph.nodes;\n} // Return the default object the graph's nodes, graph.links\n\n\nfunction defaultLinks(graph) {\n  return graph.links;\n} // Return the node from the collection that matches the provided ID, or throw an error if no match\n\n\nfunction find(nodeById, id) {\n  var node = nodeById.get(id);\n  if (!node) throw new Error('missing: ' + id);\n  return node;\n}\n\nfunction getNodeID(node, id) {\n  return id(node);\n} // The main sankeyCircular functions\n// Some constants for circular link calculations\n\n\nvar verticalMargin = 25;\nvar baseRadius = 10;\nvar scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped\n\nfunction sankeyCircular() {\n  // Set the default values\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      // extent\n  dx = 24,\n      // nodeWidth\n  py,\n      // nodePadding, for vertical postioning\n  id = defaultId,\n      align = justify,\n      nodes = defaultNodes,\n      links = defaultLinks,\n      iterations = 32,\n      circularLinkGap = 2,\n      paddingRatio,\n      sortNodes = null;\n\n  function sankeyCircular() {\n    var graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments) // Process the graph's nodes and links, setting their positions\n      // 1.  Associate the nodes with their respective links, and vice versa\n\n    };\n    computeNodeLinks(graph); // 2.  Determine which links result in a circular path in the graph\n\n    identifyCircles(graph, id, sortNodes); // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links\n\n    computeNodeValues(graph); // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n\n    computeNodeDepths(graph); // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n\n    selectCircularLinkTypes(graph, id); // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n\n    computeNodeBreadths(graph, iterations, id);\n    computeLinkBreadths(graph); // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n\n    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n\n    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n      resolveNodeLinkOverlaps(graph, y0, y1, id);\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n    } // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n\n\n    fillHeight(graph, y0, y1); // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  } // end of sankeyCircular function\n  // Set the sankeyCircular parameters\n  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap\n\n\n  sankeyCircular.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : id;\n  };\n\n  sankeyCircular.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : align;\n  };\n\n  sankeyCircular.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankeyCircular) : dx;\n  };\n\n  sankeyCircular.nodePadding = function (_) {\n    return arguments.length ? (py = +_, sankeyCircular) : py;\n  };\n\n  sankeyCircular.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : nodes;\n  };\n\n  sankeyCircular.links = function (_) {\n    return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : links;\n  };\n\n  sankeyCircular.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];\n  };\n\n  sankeyCircular.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];\n  };\n\n  sankeyCircular.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;\n  };\n\n  sankeyCircular.circularLinkGap = function (_) {\n    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;\n  };\n\n  sankeyCircular.nodePaddingRatio = function (_) {\n    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;\n  };\n\n  sankeyCircular.sortNodes = function (_) {\n    return arguments.length ? (sortNodes = _, sankeyCircular) : sortNodes;\n  };\n\n  sankeyCircular.update = function (graph) {\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    // computeNodeDepths(graph)\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id); // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    // computeNodeBreadths(graph, iterations, id)\n\n    computeLinkBreadths(graph); // Force position of circular link type based on position\n\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        link.circularLinkType = link.y0 + link.y1 < y1 ? 'top' : 'bottom';\n        link.source.circularLinkType = link.circularLinkType;\n        link.target.circularLinkType = link.circularLinkType;\n      }\n    });\n    sortSourceLinks(graph, y1, id, false); // Sort links but do not move nodes\n\n    sortTargetLinks(graph, y1, id); // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    // var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    // for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n    //\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //   resolveNodeLinkOverlaps(graph, y0, y1, id)\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //\n    // }\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    // fillHeight(graph, y0, y1)\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  }; // Populate the sourceLinks and targetLinks for each node.\n  // Also, if the source and target are not objects, assume they are indices.\n\n\n  function computeNodeLinks(graph) {\n    graph.nodes.forEach(function (node, i) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    var nodeById = map(graph.nodes, id);\n    graph.links.forEach(function (link, i) {\n      link.index = i;\n      var source = link.source;\n      var target = link.target;\n\n      if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) !== 'object') {\n        source = link.source = find(nodeById, source);\n      }\n\n      if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== 'object') {\n        target = link.target = find(nodeById, target);\n      }\n\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n    return graph;\n  } // Compute the value (size) and cycleness of each node by summing the associated links.\n\n\n  function computeNodeValues(graph) {\n    graph.nodes.forEach(function (node) {\n      node.partOfCycle = false;\n      node.value = Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value));\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    });\n  }\n\n  function getCircleMargins(graph) {\n    var totalTopLinksWidth = 0,\n        totalBottomLinksWidth = 0,\n        totalRightLinksWidth = 0,\n        totalLeftLinksWidth = 0;\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        if (link.circularLinkType == 'top') {\n          totalTopLinksWidth = totalTopLinksWidth + link.width;\n        } else {\n          totalBottomLinksWidth = totalBottomLinksWidth + link.width;\n        }\n\n        if (link.target.column == 0) {\n          totalLeftLinksWidth = totalLeftLinksWidth + link.width;\n        }\n\n        if (link.source.column == maxColumn) {\n          totalRightLinksWidth = totalRightLinksWidth + link.width;\n        }\n      }\n    }); //account for radius of curves and padding between links\n\n    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;\n    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;\n    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;\n    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;\n    return {\n      \"top\": totalTopLinksWidth,\n      \"bottom\": totalBottomLinksWidth,\n      \"left\": totalLeftLinksWidth,\n      \"right\": totalRightLinksWidth\n    };\n  } // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links\n\n\n  function scaleSankeySize(graph, margin) {\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n    var currentWidth = x1 - x0;\n    var currentHeight = y1 - y0;\n    var newWidth = currentWidth + margin.right + margin.left;\n    var newHeight = currentHeight + margin.top + margin.bottom;\n    var scaleX = currentWidth / newWidth;\n    var scaleY = currentHeight / newHeight;\n    x0 = x0 * scaleX + margin.left;\n    x1 = margin.right == 0 ? x1 : x1 * scaleX;\n    y0 = y0 * scaleY + margin.top;\n    y1 = y1 * scaleY;\n    graph.nodes.forEach(function (node) {\n      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);\n      node.x1 = node.x0 + dx;\n    });\n    return scaleY;\n  } // Iteratively assign the depth for each node.\n  // Nodes are assigned the maximum depth of incoming neighbors plus one;\n  // nodes with no incoming links are assigned depth zero, while\n  // nodes with no outgoing links are assigned the maximum depth.\n\n\n  function computeNodeDepths(graph) {\n    var nodes, next, x;\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.depth = x;\n        node.sourceLinks.forEach(function (link) {\n          if (next.indexOf(link.target) < 0 && !link.circular) {\n            next.push(link.target);\n          }\n        });\n      });\n    }\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.height = x;\n        node.targetLinks.forEach(function (link) {\n          if (next.indexOf(link.source) < 0 && !link.circular) {\n            next.push(link.source);\n          }\n        });\n      });\n    } // assign column numbers, and get max value\n\n\n    graph.nodes.forEach(function (node) {\n      node.column = Math.floor(align.call(null, node, x));\n    });\n  } // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)\n\n\n  function computeNodeBreadths(graph, iterations, id) {\n    var columns = nest().key(function (d) {\n      return d.column;\n    }).sortKeys(ascending).entries(graph.nodes).map(function (d) {\n      return d.values;\n    });\n    initializeNodeBreadth(id);\n    resolveCollisions();\n\n    for (var alpha = 1, n = iterations; n > 0; --n) {\n      relaxLeftAndRight(alpha *= 0.99, id);\n      resolveCollisions();\n    }\n\n    function initializeNodeBreadth(id) {\n      //override py if nodePadding has been set\n      if (paddingRatio) {\n        var padding = Infinity;\n        columns.forEach(function (nodes) {\n          var thisPadding = y1 * paddingRatio / (nodes.length + 1);\n          padding = thisPadding < padding ? thisPadding : padding;\n        });\n        py = padding;\n      }\n\n      var ky = min(columns, function (nodes) {\n        return (y1 - y0 - (nodes.length - 1) * py) / sum(nodes, value);\n      }); //calculate the widths of the links\n\n      ky = ky * scale;\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      }); //determine how much to scale down the chart, based on circular links\n\n      var margin = getCircleMargins(graph);\n      var ratio = scaleSankeySize(graph, margin); //re-calculate widths\n\n      ky = ky * ratio;\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n      columns.forEach(function (nodes) {\n        var nodesLength = nodes.length;\n        nodes.forEach(function (node, i) {\n          if (node.depth == columns.length - 1 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.depth == 0 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.partOfCycle) {\n            if (numberOfNonSelfLinkingCycles(node, id) == 0) {\n              node.y0 = y1 / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else if (node.circularLinkType == 'top') {\n              node.y0 = y0 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = y1 - node.value * ky - i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          } else {\n            if (margin.top == 0 || margin.bottom == 0) {\n              node.y0 = (y1 - y0) / nodesLength * i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          }\n        });\n      });\n    } // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position\n    // and shift up/down to be closer to the vertical middle of those targets and sources\n\n\n    function relaxLeftAndRight(alpha, id) {\n      var columnsLength = columns.length;\n      columns.forEach(function (nodes) {\n        var n = nodes.length;\n        var depth = nodes[0].depth;\n        nodes.forEach(function (node) {\n          // check the node is not an orphan\n          var nodeHeight;\n\n          if (node.sourceLinks.length || node.targetLinks.length) {\n            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) ;else if (depth == 0 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else if (depth == columnsLength - 1 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else {\n              var avg = 0;\n              var avgTargetY = mean(node.sourceLinks, linkTargetCenter);\n              var avgSourceY = mean(node.targetLinks, linkSourceCenter);\n\n              if (avgTargetY && avgSourceY) {\n                avg = (avgTargetY + avgSourceY) / 2;\n              } else {\n                avg = avgTargetY || avgSourceY;\n              }\n\n              var dy = (avg - nodeCenter(node)) * alpha; // positive if it node needs to move down\n\n              node.y0 += dy;\n              node.y1 += dy;\n            }\n          }\n        });\n      });\n    } // For each column, check if nodes are overlapping, and if so, shift up/down\n\n\n    function resolveCollisions() {\n      columns.forEach(function (nodes) {\n        var node,\n            dy,\n            y = y0,\n            n = nodes.length,\n            i; // Push any overlapping nodes down.\n\n        nodes.sort(ascendingBreadth);\n\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dy = y - node.y0;\n\n          if (dy > 0) {\n            node.y0 += dy;\n            node.y1 += dy;\n          }\n\n          y = node.y1 + py;\n        } // If the bottommost node goes outside the bounds, push it back up.\n\n\n        dy = y - py - y1;\n\n        if (dy > 0) {\n          y = node.y0 -= dy, node.y1 -= dy; // Push any overlapping nodes back up.\n\n          for (i = n - 2; i >= 0; --i) {\n            node = nodes[i];\n            dy = node.y1 + py - y;\n            if (dy > 0) node.y0 -= dy, node.y1 -= dy;\n            y = node.y0;\n          }\n        }\n      });\n    }\n  } // Assign the links y0 and y1 based on source/target nodes position,\n  // plus the link's relative position to other links to the same node\n\n\n  function computeLinkBreadths(graph) {\n    graph.nodes.forEach(function (node) {\n      node.sourceLinks.sort(ascendingTargetBreadth);\n      node.targetLinks.sort(ascendingSourceBreadth);\n    });\n    graph.nodes.forEach(function (node) {\n      var y0 = node.y0;\n      var y1 = y0; // start from the bottom of the node for cycle links\n\n      var y0cycle = node.y1;\n      var y1cycle = y0cycle;\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y0 = y0cycle - link.width / 2;\n          y0cycle = y0cycle - link.width;\n        } else {\n          link.y0 = y0 + link.width / 2;\n          y0 += link.width;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y1 = y1cycle - link.width / 2;\n          y1cycle = y1cycle - link.width;\n        } else {\n          link.y1 = y1 + link.width / 2;\n          y1 += link.width;\n        }\n      });\n    });\n  }\n\n  return sankeyCircular;\n} /// /////////////////////////////////////////////////////////////////////////////////\n// Cycle functions\n// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043\n// Identify circles in the link objects\n\n\nfunction identifyCircles(graph, id, sortNodes) {\n  var circularLinkID = 0;\n\n  if (sortNodes === null) {\n    // Building adjacency graph\n    var adjList = [];\n\n    for (var i = 0; i < graph.links.length; i++) {\n      var link = graph.links[i];\n      var source = link.source.index;\n      var target = link.target.index;\n      if (!adjList[source]) adjList[source] = [];\n      if (!adjList[target]) adjList[target] = []; // Add links if not already in set\n\n      if (adjList[source].indexOf(target) === -1) adjList[source].push(target);\n    } // Find all elementary circuits\n\n\n    var cycles = findCircuits(adjList); // Sort by circuits length\n\n    cycles.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var circularLinks = {};\n\n    for (i = 0; i < cycles.length; i++) {\n      var cycle = cycles[i];\n      var last = cycle.slice(-2);\n      if (!circularLinks[last[0]]) circularLinks[last[0]] = {};\n      circularLinks[last[0]][last[1]] = true;\n    }\n\n    graph.links.forEach(function (link) {\n      var target = link.target.index;\n      var source = link.source.index; // If self-linking or a back-edge\n\n      if (target === source || circularLinks[source] && circularLinks[source][target]) {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      } else {\n        link.circular = false;\n      }\n    });\n  } else {\n    graph.links.forEach(function (link) {\n      if (link.source[sortNodes] < link.target[sortNodes]) {\n        link.circular = false;\n      } else {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      }\n    });\n  }\n} // Assign a circular link type (top or bottom), based on:\n// - if the source/target node already has circular links, then use the same type\n// - if not, choose the type with fewer links\n\n\nfunction selectCircularLinkTypes(graph, id) {\n  var numberOfTops = 0;\n  var numberOfBottoms = 0;\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      // if either souce or target has type already use that\n      if (link.source.circularLinkType || link.target.circularLinkType) {\n        // default to source type if available\n        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;\n      } else {\n        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';\n      }\n\n      if (link.circularLinkType == 'top') {\n        numberOfTops = numberOfTops + 1;\n      } else {\n        numberOfBottoms = numberOfBottoms + 1;\n      }\n\n      graph.nodes.forEach(function (node) {\n        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    }\n  }); //correct self-linking links to be same direction as node\n\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      //if both source and target node are same type, then link should have same type\n      if (link.source.circularLinkType == link.target.circularLinkType) {\n        link.circularLinkType = link.source.circularLinkType;\n      } //if link is selflinking, then link should have same type as node\n\n\n      if (selfLinking(link, id)) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n    }\n  });\n} // Return the angle between a straight line between the source and target of the link, and the vertical plane of the node\n\n\nfunction linkAngle(link) {\n  var adjacent = Math.abs(link.y1 - link.y0);\n  var opposite = Math.abs(link.target.x0 - link.source.x1);\n  return Math.atan(opposite / adjacent);\n} // Check if two circular links potentially overlap\n\n\nfunction circularLinksCross(link1, link2) {\n  if (link1.source.column < link2.target.column) {\n    return false;\n  } else if (link1.target.column > link2.source.column) {\n    return false;\n  } else {\n    return true;\n  }\n} // Return the number of circular links for node, not including self linking links\n\n\nfunction numberOfNonSelfLinkingCycles(node, id) {\n  var sourceCount = 0;\n  node.sourceLinks.forEach(function (l) {\n    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;\n  });\n  var targetCount = 0;\n  node.targetLinks.forEach(function (l) {\n    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;\n  });\n  return sourceCount + targetCount;\n} // Check if a circular link is the only circular link for both its source and target node\n\n\nfunction onlyCircularLink(link) {\n  var nodeSourceLinks = link.source.sourceLinks;\n  var sourceCount = 0;\n  nodeSourceLinks.forEach(function (l) {\n    sourceCount = l.circular ? sourceCount + 1 : sourceCount;\n  });\n  var nodeTargetLinks = link.target.targetLinks;\n  var targetCount = 0;\n  nodeTargetLinks.forEach(function (l) {\n    targetCount = l.circular ? targetCount + 1 : targetCount;\n  });\n\n  if (sourceCount > 1 || targetCount > 1) {\n    return false;\n  } else {\n    return true;\n  }\n} // creates vertical buffer values per set of top/bottom links\n\n\nfunction calcVerticalBuffer(links, circularLinkGap, id) {\n  links.sort(sortLinkColumnAscending);\n  links.forEach(function (link, i) {\n    var buffer = 0;\n\n    if (selfLinking(link, id) && onlyCircularLink(link)) {\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    } else {\n      var j = 0;\n\n      for (j; j < i; j++) {\n        if (circularLinksCross(links[i], links[j])) {\n          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;\n          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;\n        }\n      }\n\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    }\n  });\n  return links;\n} // calculate the optimum path for a link to reduce overlaps\n\n\nfunction addCircularPathData(graph, circularLinkGap, y1, id) {\n  //var baseRadius = 10\n  var buffer = 5; //var verticalMargin = 25\n\n  var minY = min(graph.links, function (link) {\n    return link.source.y0;\n  }); // create object for circular Path Data\n\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData = {};\n    }\n  }); // calc vertical offsets per top/bottom links\n\n  var topLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'top';\n  });\n  /* topLinks = */\n\n  calcVerticalBuffer(topLinks, circularLinkGap, id);\n  var bottomLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'bottom';\n  });\n  /* bottomLinks = */\n\n  calcVerticalBuffer(bottomLinks, circularLinkGap, id); // add the base data for each link\n\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData.arcRadius = link.width + baseRadius;\n      link.circularPathData.leftNodeBuffer = buffer;\n      link.circularPathData.rightNodeBuffer = buffer;\n      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;\n      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;\n      link.circularPathData.targetX = link.target.x0;\n      link.circularPathData.sourceY = link.y0;\n      link.circularPathData.targetY = link.y1; // for self linking paths, and that the only circular link in/out of that node\n\n      if (selfLinking(link, id) && onlyCircularLink(link)) {\n        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;\n\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      } else {\n        // else calculate normally\n        // add left extent coordinates, based on links with same source column and circularLink type\n        var thisColumn = link.source.column;\n        var thisCircularLinkType = link.circularLinkType;\n        var sameColumnLinks = graph.links.filter(function (l) {\n          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkSourceYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkSourceYAscending);\n        }\n\n        var radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n\n          radiusOffset = radiusOffset + l.width;\n        }); // add right extent coordinates, based on links with same target column and circularLink type\n\n        thisColumn = link.target.column;\n        sameColumnLinks = graph.links.filter(function (l) {\n          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkTargetYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkTargetYAscending);\n        }\n\n        radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n\n          radiusOffset = radiusOffset + l.width;\n        }); // bottom links\n\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = Math.max(y1, link.source.y1, link.target.y1) + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      } // all links\n\n\n      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;\n      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;\n    }\n\n    if (link.circular) {\n      link.path = createCircularPathString(link);\n    } else {\n      var normalPath = linkHorizontal().source(function (d) {\n        var x = d.source.x0 + (d.source.x1 - d.source.x0);\n        var y = d.y0;\n        return [x, y];\n      }).target(function (d) {\n        var x = d.target.x0;\n        var y = d.y1;\n        return [x, y];\n      });\n      link.path = normalPath(link);\n    }\n  });\n} // create a d path using the addCircularPathData\n\n\nfunction createCircularPathString(link) {\n  var pathString = ''; // 'pathData' is assigned a value but never used\n  // var pathData = {}\n\n  if (link.circularLinkType == 'top') {\n    pathString = // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' + // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' + // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line up to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' + // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' + // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line down\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' + // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  } else {\n    // bottom path\n    pathString = // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' + // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' + // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line down to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' + // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' + // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line up\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' + // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' + // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  }\n\n  return pathString;\n} // sort links based on the distance between the source and tartget node columns\n// if the same, then use Y position of the source node\n\n\nfunction sortLinkColumnAscending(link1, link2) {\n  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {\n    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);\n  } else {\n    return linkColumnDistance(link2) - linkColumnDistance(link1);\n  }\n} // sort ascending links by their source vertical position, y0\n\n\nfunction sortLinkSourceYAscending(link1, link2) {\n  return link1.y0 - link2.y0;\n} // sort descending links by their source vertical position, y0\n\n\nfunction sortLinkSourceYDescending(link1, link2) {\n  return link2.y0 - link1.y0;\n} // sort ascending links by their target vertical position, y1\n\n\nfunction sortLinkTargetYAscending(link1, link2) {\n  return link1.y1 - link2.y1;\n} // sort descending links by their target vertical position, y1\n\n\nfunction sortLinkTargetYDescending(link1, link2) {\n  return link2.y1 - link1.y1;\n} // return the distance between the link's target and source node, in terms of the nodes' column\n\n\nfunction linkColumnDistance(link) {\n  return link.target.column - link.source.column;\n} // return the distance between the link's target and source node, in terms of the nodes' X coordinate\n\n\nfunction linkXLength(link) {\n  return link.target.x0 - link.source.x1;\n} // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\n\n\nfunction linkPerpendicularYToLinkSource(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink); // get the adjacent length to the other link's x position\n\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle); // add or subtract from longer link1's original y1, depending on the slope\n\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;\n  return yPerpendicular;\n} // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\n\n\nfunction linkPerpendicularYToLinkTarget(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink); // get the adjacent length to the other link's x position\n\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle); // add or subtract from longer link's original y1, depending on the slope\n\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;\n  return yPerpendicular;\n} // Move any nodes that overlap links which span 2+ columns\n\n\nfunction resolveNodeLinkOverlaps(graph, y0, y1, id) {\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      return;\n    }\n\n    if (link.target.column - link.source.column > 1) {\n      var columnToTest = link.source.column + 1;\n      var maxColumnToTest = link.target.column - 1;\n      var i = 1;\n      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;\n\n      for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {\n        graph.nodes.forEach(function (node) {\n          if (node.column == columnToTest) {\n            var t = i / (numberOfColumnsToTest + 1); // Find all the points of a cubic bezier curve in javascript\n            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript\n\n            var B0_t = Math.pow(1 - t, 3);\n            var B1_t = 3 * t * Math.pow(1 - t, 2);\n            var B2_t = 3 * Math.pow(t, 2) * (1 - t);\n            var B3_t = Math.pow(t, 3);\n            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;\n            var linkY0AtColumn = py_t - link.width / 2;\n            var linkY1AtColumn = py_t + link.width / 2;\n            var dy; // If top of link overlaps node, push node up\n\n            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {\n              dy = node.y1 - linkY0AtColumn + 10;\n              dy = node.circularLinkType == 'bottom' ? dy : -dy;\n              node = adjustNodeHeight(node, dy, y0, y1); // check if other nodes need to move up too\n\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n\n                if (nodesOverlap(node, otherNode)) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {\n              // If bottom of link overlaps node, push node down\n              dy = linkY1AtColumn - node.y0 + 10;\n              node = adjustNodeHeight(node, dy, y0, y1); // check if other nodes need to move down too\n\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {\n              // if link completely overlaps node\n              dy = linkY1AtColumn - node.y0 + 10;\n              node = adjustNodeHeight(node, dy, y0, y1);\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n  });\n} // check if two nodes overlap\n\n\nfunction nodesOverlap(nodeA, nodeB) {\n  // test if nodeA top partially overlaps nodeB\n  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {\n    return true;\n  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {\n    // test if nodeA bottom partially overlaps nodeB\n    return true;\n  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {\n    // test if nodeA covers nodeB\n    return true;\n  } else {\n    return false;\n  }\n} // update a node, and its associated links, vertical positions (y0, y1)\n\n\nfunction adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {\n  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {\n    node.y0 = node.y0 + dy;\n    node.y1 = node.y1 + dy;\n    node.targetLinks.forEach(function (l) {\n      l.y1 = l.y1 + dy;\n    });\n    node.sourceLinks.forEach(function (l) {\n      l.y0 = l.y0 + dy;\n    });\n  }\n\n  return node;\n} // sort and set the links' y0 for each node\n\n\nfunction sortSourceLinks(graph, y1, id, moveNodes) {\n  graph.nodes.forEach(function (node) {\n    // move any nodes up which are off the bottom\n    if (moveNodes && node.y + (node.y1 - node.y0) > y1) {\n      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);\n    }\n\n    var nodesSourceLinks = graph.links.filter(function (l) {\n      return getNodeID(l.source, id) == getNodeID(node, id);\n    });\n    var nodeSourceLinksLength = nodesSourceLinks.length; // if more than 1 link then sort\n\n    if (nodeSourceLinksLength > 1) {\n      nodesSourceLinks.sort(function (link1, link2) {\n        // if both are not circular...\n        if (!link1.circular && !link2.circular) {\n          // if the target nodes are the same column, then sort by the link's target y\n          if (link1.target.column == link2.target.column) {\n            return link1.y1 - link2.y1;\n          } else if (!sameInclines(link1, link2)) {\n            // if the links slope in different directions, then sort by the link's target y\n            return link1.y1 - link2.y1; // if the links slope in same directions, then sort by any overlap\n          } else {\n            if (link1.target.column > link2.target.column) {\n              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);\n              return link1.y1 - link2Adj;\n            }\n\n            if (link2.target.column > link1.target.column) {\n              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);\n              return link1Adj - link2.y1;\n            }\n          }\n        } // if only one is circular, the move top links up, or bottom links down\n\n\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        } // if both links are circular...\n\n\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link1.target.y1 - link2.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.target.column - link1.target.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link2.target.y1 - link1.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.target.column - link2.target.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    } // update y0 for links\n\n\n    var ySourceOffset = node.y0;\n    nodesSourceLinks.forEach(function (link) {\n      link.y0 = ySourceOffset + link.width / 2;\n      ySourceOffset = ySourceOffset + link.width;\n    }); // correct any circular bottom links so they are at the bottom of the node\n\n    nodesSourceLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0; // sum the widths of any links that are below this link\n\n        for (j; j < nodeSourceLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;\n        }\n\n        link.y0 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n} // sort and set the links' y1 for each node\n\n\nfunction sortTargetLinks(graph, y1, id) {\n  graph.nodes.forEach(function (node) {\n    var nodesTargetLinks = graph.links.filter(function (l) {\n      return getNodeID(l.target, id) == getNodeID(node, id);\n    });\n    var nodesTargetLinksLength = nodesTargetLinks.length;\n\n    if (nodesTargetLinksLength > 1) {\n      nodesTargetLinks.sort(function (link1, link2) {\n        // if both are not circular, the base on the source y position\n        if (!link1.circular && !link2.circular) {\n          if (link1.source.column == link2.source.column) {\n            return link1.y0 - link2.y0;\n          } else if (!sameInclines(link1, link2)) {\n            return link1.y0 - link2.y0;\n          } else {\n            // get the angle of the link to the further source node (ie the smaller column)\n            if (link2.source.column < link1.source.column) {\n              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);\n              return link1.y0 - link2Adj;\n            }\n\n            if (link1.source.column < link2.source.column) {\n              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);\n              return link1Adj - link2.y0;\n            }\n          }\n        } // if only one is circular, the move top links up, or bottom links down\n\n\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        } // if both links are circular...\n\n\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.source.column - link2.source.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.source.column - link1.source.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    } // update y1 for links\n\n\n    var yTargetOffset = node.y0;\n    nodesTargetLinks.forEach(function (link) {\n      link.y1 = yTargetOffset + link.width / 2;\n      yTargetOffset = yTargetOffset + link.width;\n    }); // correct any circular bottom links so they are at the bottom of the node\n\n    nodesTargetLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0; // sum the widths of any links that are below this link\n\n        for (j; j < nodesTargetLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;\n        }\n\n        link.y1 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n} // test if links both slope up, or both slope down\n\n\nfunction sameInclines(link1, link2) {\n  return incline(link1) == incline(link2);\n} // returns the slope of a link, from source to target\n// up => slopes up from source to target\n// down => slopes down from source to target\n\n\nfunction incline(link) {\n  return link.y0 - link.y1 > 0 ? 'up' : 'down';\n} // check if link is self linking, ie links a node to the same node\n\n\nfunction selfLinking(link, id) {\n  return getNodeID(link.source, id) == getNodeID(link.target, id);\n}\n\nfunction fillHeight(graph, y0, y1) {\n  var nodes = graph.nodes;\n  var links = graph.links;\n  var top = false;\n  var bottom = false;\n  links.forEach(function (link) {\n    if (link.circularLinkType == \"top\") {\n      top = true;\n    } else if (link.circularLinkType == \"bottom\") {\n      bottom = true;\n    }\n  });\n\n  if (top == false || bottom == false) {\n    var minY0 = min(nodes, function (node) {\n      return node.y0;\n    });\n    var maxY1 = max(nodes, function (node) {\n      return node.y1;\n    });\n    var currentHeight = maxY1 - minY0;\n    var chartHeight = y1 - y0;\n    var ratio = chartHeight / currentHeight;\n    nodes.forEach(function (node) {\n      var nodeHeight = (node.y1 - node.y0) * ratio;\n      node.y0 = (node.y0 - minY0) * ratio;\n      node.y1 = node.y0 + nodeHeight;\n    });\n    links.forEach(function (link) {\n      link.y0 = (link.y0 - minY0) * ratio;\n      link.y1 = (link.y1 - minY0) * ratio;\n      link.width = link.width * ratio;\n    });\n  }\n}\n\nexport { sankeyCircular, center as sankeyCenter, left as sankeyLeft, right as sankeyRight, justify as sankeyJustify };","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/@plotly/d3-sankey-circular/dist/d3-sankey-circular.es.js"],"names":["min","ascending","max","mean","sum","map","nest","linkHorizontal","findCircuits","targetDepth","d","target","depth","left","node","right","n","height","justify","sourceLinks","length","center","targetLinks","constant","x","_typeof","Symbol","iterator","obj","constructor","prototype","ascendingSourceBreadth","a","b","ascendingBreadth","source","index","ascendingTargetBreadth","partOfCycle","y0","circularLinkType","value","nodeCenter","y1","linkSourceCenter","link","linkTargetCenter","defaultId","defaultNodes","graph","nodes","defaultLinks","links","find","nodeById","id","get","Error","getNodeID","verticalMargin","baseRadius","scale","sankeyCircular","x0","x1","dx","py","align","iterations","circularLinkGap","paddingRatio","sortNodes","apply","arguments","computeNodeLinks","identifyCircles","computeNodeValues","computeNodeDepths","selectCircularLinkTypes","computeNodeBreadths","computeLinkBreadths","linkSortingIterations","iteration","sortSourceLinks","sortTargetLinks","resolveNodeLinkOverlaps","fillHeight","addCircularPathData","nodeId","_","nodeAlign","nodeWidth","nodePadding","size","extent","nodePaddingRatio","update","forEach","circular","i","push","Math","getCircleMargins","totalTopLinksWidth","totalBottomLinksWidth","totalRightLinksWidth","totalLeftLinksWidth","maxColumn","column","width","scaleSankeySize","margin","currentWidth","currentHeight","newWidth","newHeight","top","bottom","scaleX","scaleY","next","indexOf","floor","call","columns","key","sortKeys","entries","values","initializeNodeBreadth","resolveCollisions","alpha","relaxLeftAndRight","padding","Infinity","thisPadding","ky","ratio","nodesLength","numberOfNonSelfLinkingCycles","columnsLength","nodeHeight","avg","avgTargetY","avgSourceY","dy","y","sort","y0cycle","y1cycle","circularLinkID","adjList","cycles","circularLinks","cycle","last","slice","numberOfTops","numberOfBottoms","selfLinking","linkAngle","adjacent","abs","opposite","atan","circularLinksCross","link1","link2","sourceCount","l","targetCount","onlyCircularLink","nodeSourceLinks","nodeTargetLinks","calcVerticalBuffer","sortLinkColumnAscending","buffer","circularPathData","verticalBuffer","j","bufferOverThisLink","minY","topLinks","filter","bottomLinks","arcRadius","leftNodeBuffer","rightNodeBuffer","sourceWidth","sourceX","targetX","sourceY","targetY","leftSmallArcRadius","leftLargeArcRadius","rightSmallArcRadius","rightLargeArcRadius","verticalFullExtent","verticalLeftInnerExtent","verticalRightInnerExtent","thisColumn","thisCircularLinkType","sameColumnLinks","sortLinkSourceYDescending","sortLinkSourceYAscending","radiusOffset","sortLinkTargetYDescending","sortLinkTargetYAscending","leftInnerExtent","rightInnerExtent","leftFullExtent","rightFullExtent","path","createCircularPathString","normalPath","pathString","linkColumnDistance","linkXLength","linkPerpendicularYToLinkSource","longerLink","shorterLink","angle","heightFromY1ToPependicular","tan","yPerpendicular","incline","linkPerpendicularYToLinkTarget","columnToTest","maxColumnToTest","numberOfColumnsToTest","t","B0_t","pow","B1_t","B2_t","B3_t","py_t","linkY0AtColumn","linkY1AtColumn","adjustNodeHeight","otherNode","nodesOverlap","nodeA","nodeB","sankeyY0","sankeyY1","moveNodes","nodesSourceLinks","nodeSourceLinksLength","sameInclines","link2Adj","link1Adj","ySourceOffset","offsetFromBottom","nodesTargetLinks","nodesTargetLinksLength","yTargetOffset","minY0","maxY1","chartHeight","sankeyCenter","sankeyLeft","sankeyRight","sankeyJustify"],"mappings":"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","sourcesContent":["import { min, ascending, max, mean, sum } from 'd3-array';\nimport { map, nest } from 'd3-collection';\nimport { linkHorizontal } from 'd3-shape';\nimport findCircuits from 'elementary-circuits-directed-graph';\n\n// For a given link, return the target node's depth\nfunction targetDepth(d) {\n  return d.target.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'left'\nfunction left(node) {\n  return node.depth;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'right'\nfunction right(node, n) {\n  return n - 1 - node.height;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'justify'\nfunction justify(node, n) {\n  return node.sourceLinks.length ? node.depth : n - 1;\n}\n\n// The depth of a node when the nodeAlign (align) is set to 'center'\nfunction center(node) {\n  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;\n}\n\n// returns a function, using the parameter given to the sankey setting\nfunction constant(x) {\n  return function () {\n    return x;\n  };\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/// https://github.com/tomshanley/d3-sankeyCircular-circular\n\n// sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\n\n// sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\n\n// sort nodes' breadth (ie top to bottom in a column)\n// if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node\n// else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom\nfunction ascendingBreadth(a, b) {\n  if (a.partOfCycle === b.partOfCycle) {\n    return a.y0 - b.y0;\n  } else {\n    if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\n// return the value of a node or link\nfunction value(d) {\n  return d.value;\n}\n\n// return the vertical center of a node\nfunction nodeCenter(node) {\n  return (node.y0 + node.y1) / 2;\n}\n\n// return the vertical center of a link's source node\nfunction linkSourceCenter(link) {\n  return nodeCenter(link.source);\n}\n\n// return the vertical center of a link's target node\nfunction linkTargetCenter(link) {\n  return nodeCenter(link.target);\n}\n\n// Return the default value for ID for node, d.index\nfunction defaultId(d) {\n  return d.index;\n}\n\n// Return the default object the graph's nodes, graph.nodes\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\n\n// Return the default object the graph's nodes, graph.links\nfunction defaultLinks(graph) {\n  return graph.links;\n}\n\n// Return the node from the collection that matches the provided ID, or throw an error if no match\nfunction find(nodeById, id) {\n  var node = nodeById.get(id);\n  if (!node) throw new Error('missing: ' + id);\n  return node;\n}\n\nfunction getNodeID(node, id) {\n  return id(node);\n}\n\n// The main sankeyCircular functions\n\n// Some constants for circular link calculations\nvar verticalMargin = 25;\nvar baseRadius = 10;\nvar scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped\n\nfunction sankeyCircular () {\n  // Set the default values\n  var x0 = 0,\n      y0 = 0,\n      x1 = 1,\n      y1 = 1,\n      // extent\n  dx = 24,\n      // nodeWidth\n  py,\n      // nodePadding, for vertical postioning\n  id = defaultId,\n      align = justify,\n      nodes = defaultNodes,\n      links = defaultLinks,\n      iterations = 32,\n      circularLinkGap = 2,\n      paddingRatio,\n      sortNodes = null;\n\n  function sankeyCircular() {\n    var graph = {\n      nodes: nodes.apply(null, arguments),\n      links: links.apply(null, arguments)\n\n      // Process the graph's nodes and links, setting their positions\n\n      // 1.  Associate the nodes with their respective links, and vice versa\n    };computeNodeLinks(graph);\n\n    // 2.  Determine which links result in a circular path in the graph\n    identifyCircles(graph, id, sortNodes);\n\n    // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links\n    computeNodeValues(graph);\n\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    computeNodeDepths(graph);\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    computeNodeBreadths(graph, iterations, id);\n    computeLinkBreadths(graph);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n      resolveNodeLinkOverlaps(graph, y0, y1, id);\n      sortSourceLinks(graph, y1, id);\n      sortTargetLinks(graph, y1, id);\n    }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    fillHeight(graph, y0, y1);\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n\n    return graph;\n  } // end of sankeyCircular function\n\n\n  // Set the sankeyCircular parameters\n  // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap\n  sankeyCircular.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : id;\n  };\n\n  sankeyCircular.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : align;\n  };\n\n  sankeyCircular.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankeyCircular) : dx;\n  };\n\n  sankeyCircular.nodePadding = function (_) {\n    return arguments.length ? (py = +_, sankeyCircular) : py;\n  };\n\n  sankeyCircular.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : nodes;\n  };\n\n  sankeyCircular.links = function (_) {\n    return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankeyCircular) : links;\n  };\n\n  sankeyCircular.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];\n  };\n\n  sankeyCircular.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];\n  };\n\n  sankeyCircular.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankeyCircular) : iterations;\n  };\n\n  sankeyCircular.circularLinkGap = function (_) {\n    return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;\n  };\n\n  sankeyCircular.nodePaddingRatio = function (_) {\n    return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;\n  };\n\n  sankeyCircular.sortNodes = function (_) {\n    return arguments.length ? (sortNodes = _, sankeyCircular) : sortNodes;\n  };\n\n  sankeyCircular.update = function (graph) {\n    // 5.  Calculate the nodes' depth based on the incoming and outgoing links\n    //     Sets the nodes':\n    //     - depth:  the depth in the graph\n    //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right\n    //     - x0, x1: the x coordinates, as is relates to visual position from left to right\n    // computeNodeDepths(graph)\n\n    // 3.  Determine how the circular links will be drawn,\n    //     either travelling back above the main chart (\"top\")\n    //     or below the main chart (\"bottom\")\n    selectCircularLinkTypes(graph, id);\n\n    // 6.  Calculate the nodes' and links' vertical position within their respective column\n    //     Also readjusts sankeyCircular size if circular links are needed, and node x's\n    // computeNodeBreadths(graph, iterations, id)\n    computeLinkBreadths(graph);\n\n    // Force position of circular link type based on position\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        link.circularLinkType = link.y0 + link.y1 < y1 ? 'top' : 'bottom';\n\n        link.source.circularLinkType = link.circularLinkType;\n        link.target.circularLinkType = link.circularLinkType;\n      }\n    });\n\n    sortSourceLinks(graph, y1, id, false); // Sort links but do not move nodes\n    sortTargetLinks(graph, y1, id);\n\n    // 7.  Sort links per node, based on the links' source/target nodes' breadths\n    // 8.  Adjust nodes that overlap links that span 2+ columns\n    // var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement\n    // for (var iteration = 0; iteration < linkSortingIterations; iteration++) {\n    //\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //   resolveNodeLinkOverlaps(graph, y0, y1, id)\n    //   sortSourceLinks(graph, y1, id)\n    //   sortTargetLinks(graph, y1, id)\n    //\n    // }\n\n    // 8.1  Adjust node and link positions back to fill height of chart area if compressed\n    // fillHeight(graph, y0, y1)\n\n    // 9. Calculate visually appealling path for the circular paths, and create the \"d\" string\n    addCircularPathData(graph, circularLinkGap, y1, id);\n    return graph;\n  };\n\n  // Populate the sourceLinks and targetLinks for each node.\n  // Also, if the source and target are not objects, assume they are indices.\n  function computeNodeLinks(graph) {\n    graph.nodes.forEach(function (node, i) {\n      node.index = i;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    var nodeById = map(graph.nodes, id);\n    graph.links.forEach(function (link, i) {\n      link.index = i;\n      var source = link.source;\n      var target = link.target;\n      if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) !== 'object') {\n        source = link.source = find(nodeById, source);\n      }\n      if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== 'object') {\n        target = link.target = find(nodeById, target);\n      }\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n    return graph;\n  }\n\n  // Compute the value (size) and cycleness of each node by summing the associated links.\n  function computeNodeValues(graph) {\n    graph.nodes.forEach(function (node) {\n      node.partOfCycle = false;\n      node.value = Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value));\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          node.partOfCycle = true;\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    });\n  }\n\n  function getCircleMargins(graph) {\n    var totalTopLinksWidth = 0,\n        totalBottomLinksWidth = 0,\n        totalRightLinksWidth = 0,\n        totalLeftLinksWidth = 0;\n\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n\n    graph.links.forEach(function (link) {\n      if (link.circular) {\n        if (link.circularLinkType == 'top') {\n          totalTopLinksWidth = totalTopLinksWidth + link.width;\n        } else {\n          totalBottomLinksWidth = totalBottomLinksWidth + link.width;\n        }\n\n        if (link.target.column == 0) {\n          totalLeftLinksWidth = totalLeftLinksWidth + link.width;\n        }\n\n        if (link.source.column == maxColumn) {\n          totalRightLinksWidth = totalRightLinksWidth + link.width;\n        }\n      }\n    });\n\n    //account for radius of curves and padding between links\n    totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;\n    totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;\n    totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;\n    totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;\n\n    return { \"top\": totalTopLinksWidth, \"bottom\": totalBottomLinksWidth, \"left\": totalLeftLinksWidth, \"right\": totalRightLinksWidth };\n  }\n\n  // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links\n  function scaleSankeySize(graph, margin) {\n\n    var maxColumn = max(graph.nodes, function (node) {\n      return node.column;\n    });\n\n    var currentWidth = x1 - x0;\n    var currentHeight = y1 - y0;\n\n    var newWidth = currentWidth + margin.right + margin.left;\n    var newHeight = currentHeight + margin.top + margin.bottom;\n\n    var scaleX = currentWidth / newWidth;\n    var scaleY = currentHeight / newHeight;\n\n    x0 = x0 * scaleX + margin.left;\n    x1 = margin.right == 0 ? x1 : x1 * scaleX;\n    y0 = y0 * scaleY + margin.top;\n    y1 = y1 * scaleY;\n\n    graph.nodes.forEach(function (node) {\n      node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);\n      node.x1 = node.x0 + dx;\n    });\n\n    return scaleY;\n  }\n\n  // Iteratively assign the depth for each node.\n  // Nodes are assigned the maximum depth of incoming neighbors plus one;\n  // nodes with no incoming links are assigned depth zero, while\n  // nodes with no outgoing links are assigned the maximum depth.\n  function computeNodeDepths(graph) {\n    var nodes, next, x;\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.depth = x;\n        node.sourceLinks.forEach(function (link) {\n          if (next.indexOf(link.target) < 0 && !link.circular) {\n            next.push(link.target);\n          }\n        });\n      });\n    }\n\n    for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n      nodes.forEach(function (node) {\n        node.height = x;\n        node.targetLinks.forEach(function (link) {\n          if (next.indexOf(link.source) < 0 && !link.circular) {\n            next.push(link.source);\n          }\n        });\n      });\n    }\n\n    // assign column numbers, and get max value\n    graph.nodes.forEach(function (node) {\n      node.column = Math.floor(align.call(null, node, x));\n    });\n  }\n\n  // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)\n  function computeNodeBreadths(graph, iterations, id) {\n    var columns = nest().key(function (d) {\n      return d.column;\n    }).sortKeys(ascending).entries(graph.nodes).map(function (d) {\n      return d.values;\n    });\n\n    initializeNodeBreadth(id);\n    resolveCollisions();\n\n    for (var alpha = 1, n = iterations; n > 0; --n) {\n      relaxLeftAndRight(alpha *= 0.99, id);\n      resolveCollisions();\n    }\n\n    function initializeNodeBreadth(id) {\n\n      //override py if nodePadding has been set\n      if (paddingRatio) {\n        var padding = Infinity;\n        columns.forEach(function (nodes) {\n          var thisPadding = y1 * paddingRatio / (nodes.length + 1);\n          padding = thisPadding < padding ? thisPadding : padding;\n        });\n        py = padding;\n      }\n\n      var ky = min(columns, function (nodes) {\n        return (y1 - y0 - (nodes.length - 1) * py) / sum(nodes, value);\n      });\n\n      //calculate the widths of the links\n      ky = ky * scale;\n\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n\n      //determine how much to scale down the chart, based on circular links\n      var margin = getCircleMargins(graph);\n      var ratio = scaleSankeySize(graph, margin);\n\n      //re-calculate widths\n      ky = ky * ratio;\n\n      graph.links.forEach(function (link) {\n        link.width = link.value * ky;\n      });\n\n      columns.forEach(function (nodes) {\n        var nodesLength = nodes.length;\n        nodes.forEach(function (node, i) {\n          if (node.depth == columns.length - 1 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.depth == 0 && nodesLength == 1) {\n            node.y0 = y1 / 2 - node.value * ky;\n            node.y1 = node.y0 + node.value * ky;\n          } else if (node.partOfCycle) {\n            if (numberOfNonSelfLinkingCycles(node, id) == 0) {\n              node.y0 = y1 / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else if (node.circularLinkType == 'top') {\n              node.y0 = y0 + i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = y1 - node.value * ky - i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          } else {\n            if (margin.top == 0 || margin.bottom == 0) {\n              node.y0 = (y1 - y0) / nodesLength * i;\n              node.y1 = node.y0 + node.value * ky;\n            } else {\n              node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;\n              node.y1 = node.y0 + node.value * ky;\n            }\n          }\n        });\n      });\n    }\n\n    // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position\n    // and shift up/down to be closer to the vertical middle of those targets and sources\n    function relaxLeftAndRight(alpha, id) {\n      var columnsLength = columns.length;\n\n      columns.forEach(function (nodes) {\n        var n = nodes.length;\n        var depth = nodes[0].depth;\n\n        nodes.forEach(function (node) {\n          // check the node is not an orphan\n          var nodeHeight;\n          if (node.sourceLinks.length || node.targetLinks.length) {\n            if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) ; else if (depth == 0 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else if (depth == columnsLength - 1 && n == 1) {\n              nodeHeight = node.y1 - node.y0;\n\n              node.y0 = y1 / 2 - nodeHeight / 2;\n              node.y1 = y1 / 2 + nodeHeight / 2;\n            } else {\n              var avg = 0;\n\n              var avgTargetY = mean(node.sourceLinks, linkTargetCenter);\n              var avgSourceY = mean(node.targetLinks, linkSourceCenter);\n\n              if (avgTargetY && avgSourceY) {\n                avg = (avgTargetY + avgSourceY) / 2;\n              } else {\n                avg = avgTargetY || avgSourceY;\n              }\n\n              var dy = (avg - nodeCenter(node)) * alpha;\n              // positive if it node needs to move down\n              node.y0 += dy;\n              node.y1 += dy;\n            }\n          }\n        });\n      });\n    }\n\n    // For each column, check if nodes are overlapping, and if so, shift up/down\n    function resolveCollisions() {\n      columns.forEach(function (nodes) {\n        var node,\n            dy,\n            y = y0,\n            n = nodes.length,\n            i;\n\n        // Push any overlapping nodes down.\n        nodes.sort(ascendingBreadth);\n\n        for (i = 0; i < n; ++i) {\n          node = nodes[i];\n          dy = y - node.y0;\n\n          if (dy > 0) {\n            node.y0 += dy;\n            node.y1 += dy;\n          }\n          y = node.y1 + py;\n        }\n\n        // If the bottommost node goes outside the bounds, push it back up.\n        dy = y - py - y1;\n        if (dy > 0) {\n          y = node.y0 -= dy, node.y1 -= dy;\n\n          // Push any overlapping nodes back up.\n          for (i = n - 2; i >= 0; --i) {\n            node = nodes[i];\n            dy = node.y1 + py - y;\n            if (dy > 0) node.y0 -= dy, node.y1 -= dy;\n            y = node.y0;\n          }\n        }\n      });\n    }\n  }\n\n  // Assign the links y0 and y1 based on source/target nodes position,\n  // plus the link's relative position to other links to the same node\n  function computeLinkBreadths(graph) {\n    graph.nodes.forEach(function (node) {\n      node.sourceLinks.sort(ascendingTargetBreadth);\n      node.targetLinks.sort(ascendingSourceBreadth);\n    });\n    graph.nodes.forEach(function (node) {\n      var y0 = node.y0;\n      var y1 = y0;\n\n      // start from the bottom of the node for cycle links\n      var y0cycle = node.y1;\n      var y1cycle = y0cycle;\n\n      node.sourceLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y0 = y0cycle - link.width / 2;\n          y0cycle = y0cycle - link.width;\n        } else {\n          link.y0 = y0 + link.width / 2;\n          y0 += link.width;\n        }\n      });\n      node.targetLinks.forEach(function (link) {\n        if (link.circular) {\n          link.y1 = y1cycle - link.width / 2;\n          y1cycle = y1cycle - link.width;\n        } else {\n          link.y1 = y1 + link.width / 2;\n          y1 += link.width;\n        }\n      });\n    });\n  }\n\n  return sankeyCircular;\n}\n\n/// /////////////////////////////////////////////////////////////////////////////////\n// Cycle functions\n// portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043\n\n// Identify circles in the link objects\nfunction identifyCircles(graph, id, sortNodes) {\n  var circularLinkID = 0;\n  if (sortNodes === null) {\n\n    // Building adjacency graph\n    var adjList = [];\n    for (var i = 0; i < graph.links.length; i++) {\n      var link = graph.links[i];\n      var source = link.source.index;\n      var target = link.target.index;\n      if (!adjList[source]) adjList[source] = [];\n      if (!adjList[target]) adjList[target] = [];\n\n      // Add links if not already in set\n      if (adjList[source].indexOf(target) === -1) adjList[source].push(target);\n    }\n\n    // Find all elementary circuits\n    var cycles = findCircuits(adjList);\n\n    // Sort by circuits length\n    cycles.sort(function (a, b) {\n      return a.length - b.length;\n    });\n\n    var circularLinks = {};\n    for (i = 0; i < cycles.length; i++) {\n      var cycle = cycles[i];\n      var last = cycle.slice(-2);\n      if (!circularLinks[last[0]]) circularLinks[last[0]] = {};\n      circularLinks[last[0]][last[1]] = true;\n    }\n\n    graph.links.forEach(function (link) {\n      var target = link.target.index;\n      var source = link.source.index;\n      // If self-linking or a back-edge\n      if (target === source || circularLinks[source] && circularLinks[source][target]) {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      } else {\n        link.circular = false;\n      }\n    });\n  } else {\n    graph.links.forEach(function (link) {\n      if (link.source[sortNodes] < link.target[sortNodes]) {\n        link.circular = false;\n      } else {\n        link.circular = true;\n        link.circularLinkID = circularLinkID;\n        circularLinkID = circularLinkID + 1;\n      }\n    });\n  }\n}\n\n// Assign a circular link type (top or bottom), based on:\n// - if the source/target node already has circular links, then use the same type\n// - if not, choose the type with fewer links\nfunction selectCircularLinkTypes(graph, id) {\n  var numberOfTops = 0;\n  var numberOfBottoms = 0;\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      // if either souce or target has type already use that\n      if (link.source.circularLinkType || link.target.circularLinkType) {\n        // default to source type if available\n        link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;\n      } else {\n        link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';\n      }\n\n      if (link.circularLinkType == 'top') {\n        numberOfTops = numberOfTops + 1;\n      } else {\n        numberOfBottoms = numberOfBottoms + 1;\n      }\n\n      graph.nodes.forEach(function (node) {\n        if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {\n          node.circularLinkType = link.circularLinkType;\n        }\n      });\n    }\n  });\n\n  //correct self-linking links to be same direction as node\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      //if both source and target node are same type, then link should have same type\n      if (link.source.circularLinkType == link.target.circularLinkType) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n      //if link is selflinking, then link should have same type as node\n      if (selfLinking(link, id)) {\n        link.circularLinkType = link.source.circularLinkType;\n      }\n    }\n  });\n}\n\n// Return the angle between a straight line between the source and target of the link, and the vertical plane of the node\nfunction linkAngle(link) {\n  var adjacent = Math.abs(link.y1 - link.y0);\n  var opposite = Math.abs(link.target.x0 - link.source.x1);\n\n  return Math.atan(opposite / adjacent);\n}\n\n// Check if two circular links potentially overlap\nfunction circularLinksCross(link1, link2) {\n  if (link1.source.column < link2.target.column) {\n    return false;\n  } else if (link1.target.column > link2.source.column) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// Return the number of circular links for node, not including self linking links\nfunction numberOfNonSelfLinkingCycles(node, id) {\n  var sourceCount = 0;\n  node.sourceLinks.forEach(function (l) {\n    sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;\n  });\n\n  var targetCount = 0;\n  node.targetLinks.forEach(function (l) {\n    targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;\n  });\n\n  return sourceCount + targetCount;\n}\n\n// Check if a circular link is the only circular link for both its source and target node\nfunction onlyCircularLink(link) {\n  var nodeSourceLinks = link.source.sourceLinks;\n  var sourceCount = 0;\n  nodeSourceLinks.forEach(function (l) {\n    sourceCount = l.circular ? sourceCount + 1 : sourceCount;\n  });\n\n  var nodeTargetLinks = link.target.targetLinks;\n  var targetCount = 0;\n  nodeTargetLinks.forEach(function (l) {\n    targetCount = l.circular ? targetCount + 1 : targetCount;\n  });\n\n  if (sourceCount > 1 || targetCount > 1) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// creates vertical buffer values per set of top/bottom links\nfunction calcVerticalBuffer(links, circularLinkGap, id) {\n  links.sort(sortLinkColumnAscending);\n  links.forEach(function (link, i) {\n    var buffer = 0;\n\n    if (selfLinking(link, id) && onlyCircularLink(link)) {\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    } else {\n      var j = 0;\n      for (j; j < i; j++) {\n        if (circularLinksCross(links[i], links[j])) {\n          var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;\n          buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;\n        }\n      }\n\n      link.circularPathData.verticalBuffer = buffer + link.width / 2;\n    }\n  });\n\n  return links;\n}\n\n// calculate the optimum path for a link to reduce overlaps\nfunction addCircularPathData(graph, circularLinkGap, y1, id) {\n  //var baseRadius = 10\n  var buffer = 5;\n  //var verticalMargin = 25\n\n  var minY = min(graph.links, function (link) {\n    return link.source.y0;\n  });\n\n  // create object for circular Path Data\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData = {};\n    }\n  });\n\n  // calc vertical offsets per top/bottom links\n  var topLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'top';\n  });\n  /* topLinks = */calcVerticalBuffer(topLinks, circularLinkGap, id);\n\n  var bottomLinks = graph.links.filter(function (l) {\n    return l.circularLinkType == 'bottom';\n  });\n  /* bottomLinks = */calcVerticalBuffer(bottomLinks, circularLinkGap, id);\n\n  // add the base data for each link\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      link.circularPathData.arcRadius = link.width + baseRadius;\n      link.circularPathData.leftNodeBuffer = buffer;\n      link.circularPathData.rightNodeBuffer = buffer;\n      link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;\n      link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;\n      link.circularPathData.targetX = link.target.x0;\n      link.circularPathData.sourceY = link.y0;\n      link.circularPathData.targetY = link.y1;\n\n      // for self linking paths, and that the only circular link in/out of that node\n      if (selfLinking(link, id) && onlyCircularLink(link)) {\n        link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;\n        link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;\n\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      } else {\n        // else calculate normally\n        // add left extent coordinates, based on links with same source column and circularLink type\n        var thisColumn = link.source.column;\n        var thisCircularLinkType = link.circularLinkType;\n        var sameColumnLinks = graph.links.filter(function (l) {\n          return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkSourceYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkSourceYAscending);\n        }\n\n        var radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // add right extent coordinates, based on links with same target column and circularLink type\n        thisColumn = link.target.column;\n        sameColumnLinks = graph.links.filter(function (l) {\n          return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;\n        });\n        if (link.circularLinkType == 'bottom') {\n          sameColumnLinks.sort(sortLinkTargetYDescending);\n        } else {\n          sameColumnLinks.sort(sortLinkTargetYAscending);\n        }\n\n        radiusOffset = 0;\n        sameColumnLinks.forEach(function (l, i) {\n          if (l.circularLinkID == link.circularLinkID) {\n            link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;\n            link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;\n          }\n          radiusOffset = radiusOffset + l.width;\n        });\n\n        // bottom links\n        if (link.circularLinkType == 'bottom') {\n          link.circularPathData.verticalFullExtent = Math.max(y1, link.source.y1, link.target.y1) + verticalMargin + link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;\n        } else {\n          // top links\n          link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;\n          link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;\n          link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;\n        }\n      }\n\n      // all links\n      link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;\n      link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;\n      link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;\n    }\n\n    if (link.circular) {\n      link.path = createCircularPathString(link);\n    } else {\n      var normalPath = linkHorizontal().source(function (d) {\n        var x = d.source.x0 + (d.source.x1 - d.source.x0);\n        var y = d.y0;\n        return [x, y];\n      }).target(function (d) {\n        var x = d.target.x0;\n        var y = d.y1;\n        return [x, y];\n      });\n      link.path = normalPath(link);\n    }\n  });\n}\n\n// create a d path using the addCircularPathData\nfunction createCircularPathString(link) {\n  var pathString = '';\n  // 'pathData' is assigned a value but never used\n  // var pathData = {}\n\n  if (link.circularLinkType == 'top') {\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line up to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line down\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  } else {\n    // bottom path\n    pathString =\n    // start at the right of the source node\n    'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +\n    // line right to buffer point\n    'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X\n    // line down to buffer point\n    'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X\n    // line left to buffer point\n    'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X\n    // line up\n    'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +\n    // Arc around: Centre of arc X and  //Centre of arc Y\n    'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +\n    // End of arc X //End of arc Y\n    link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X\n    // line to end\n    'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;\n  }\n\n  return pathString;\n}\n\n// sort links based on the distance between the source and tartget node columns\n// if the same, then use Y position of the source node\nfunction sortLinkColumnAscending(link1, link2) {\n  if (linkColumnDistance(link1) == linkColumnDistance(link2)) {\n    return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);\n  } else {\n    return linkColumnDistance(link2) - linkColumnDistance(link1);\n  }\n}\n\n// sort ascending links by their source vertical position, y0\nfunction sortLinkSourceYAscending(link1, link2) {\n  return link1.y0 - link2.y0;\n}\n\n// sort descending links by their source vertical position, y0\nfunction sortLinkSourceYDescending(link1, link2) {\n  return link2.y0 - link1.y0;\n}\n\n// sort ascending links by their target vertical position, y1\nfunction sortLinkTargetYAscending(link1, link2) {\n  return link1.y1 - link2.y1;\n}\n\n// sort descending links by their target vertical position, y1\nfunction sortLinkTargetYDescending(link1, link2) {\n  return link2.y1 - link1.y1;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' column\nfunction linkColumnDistance(link) {\n  return link.target.column - link.source.column;\n}\n\n// return the distance between the link's target and source node, in terms of the nodes' X coordinate\nfunction linkXLength(link) {\n  return link.target.x0 - link.source.x1;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkSource(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link1's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;\n\n  return yPerpendicular;\n}\n\n// Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.\n// * approx, based on a straight line from target to source, when in fact the path is a bezier\nfunction linkPerpendicularYToLinkTarget(longerLink, shorterLink) {\n  // get the angle for the longer link\n  var angle = linkAngle(longerLink);\n\n  // get the adjacent length to the other link's x position\n  var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);\n\n  // add or subtract from longer link's original y1, depending on the slope\n  var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;\n\n  return yPerpendicular;\n}\n\n// Move any nodes that overlap links which span 2+ columns\nfunction resolveNodeLinkOverlaps(graph, y0, y1, id) {\n\n  graph.links.forEach(function (link) {\n    if (link.circular) {\n      return;\n    }\n\n    if (link.target.column - link.source.column > 1) {\n      var columnToTest = link.source.column + 1;\n      var maxColumnToTest = link.target.column - 1;\n\n      var i = 1;\n      var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;\n\n      for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {\n        graph.nodes.forEach(function (node) {\n          if (node.column == columnToTest) {\n            var t = i / (numberOfColumnsToTest + 1);\n\n            // Find all the points of a cubic bezier curve in javascript\n            // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript\n\n            var B0_t = Math.pow(1 - t, 3);\n            var B1_t = 3 * t * Math.pow(1 - t, 2);\n            var B2_t = 3 * Math.pow(t, 2) * (1 - t);\n            var B3_t = Math.pow(t, 3);\n\n            var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;\n\n            var linkY0AtColumn = py_t - link.width / 2;\n            var linkY1AtColumn = py_t + link.width / 2;\n            var dy;\n\n            // If top of link overlaps node, push node up\n            if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {\n\n              dy = node.y1 - linkY0AtColumn + 10;\n              dy = node.circularLinkType == 'bottom' ? dy : -dy;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move up too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (nodesOverlap(node, otherNode)) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {\n              // If bottom of link overlaps node, push node down\n              dy = linkY1AtColumn - node.y0 + 10;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              // check if other nodes need to move down too\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {\n              // if link completely overlaps node\n              dy = linkY1AtColumn - node.y0 + 10;\n\n              node = adjustNodeHeight(node, dy, y0, y1);\n\n              graph.nodes.forEach(function (otherNode) {\n                // don't need to check itself or nodes at different columns\n                if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {\n                  return;\n                }\n                if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {\n                  adjustNodeHeight(otherNode, dy, y0, y1);\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n  });\n}\n\n// check if two nodes overlap\nfunction nodesOverlap(nodeA, nodeB) {\n  // test if nodeA top partially overlaps nodeB\n  if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {\n    return true;\n  } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {\n    // test if nodeA bottom partially overlaps nodeB\n    return true;\n  } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {\n    // test if nodeA covers nodeB\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// update a node, and its associated links, vertical positions (y0, y1)\nfunction adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {\n  if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {\n    node.y0 = node.y0 + dy;\n    node.y1 = node.y1 + dy;\n\n    node.targetLinks.forEach(function (l) {\n      l.y1 = l.y1 + dy;\n    });\n\n    node.sourceLinks.forEach(function (l) {\n      l.y0 = l.y0 + dy;\n    });\n  }\n  return node;\n}\n\n// sort and set the links' y0 for each node\nfunction sortSourceLinks(graph, y1, id, moveNodes) {\n  graph.nodes.forEach(function (node) {\n    // move any nodes up which are off the bottom\n    if (moveNodes && node.y + (node.y1 - node.y0) > y1) {\n      node.y = node.y - (node.y + (node.y1 - node.y0) - y1);\n    }\n\n    var nodesSourceLinks = graph.links.filter(function (l) {\n      return getNodeID(l.source, id) == getNodeID(node, id);\n    });\n\n    var nodeSourceLinksLength = nodesSourceLinks.length;\n\n    // if more than 1 link then sort\n    if (nodeSourceLinksLength > 1) {\n      nodesSourceLinks.sort(function (link1, link2) {\n        // if both are not circular...\n        if (!link1.circular && !link2.circular) {\n          // if the target nodes are the same column, then sort by the link's target y\n          if (link1.target.column == link2.target.column) {\n            return link1.y1 - link2.y1;\n          } else if (!sameInclines(link1, link2)) {\n            // if the links slope in different directions, then sort by the link's target y\n            return link1.y1 - link2.y1;\n\n            // if the links slope in same directions, then sort by any overlap\n          } else {\n            if (link1.target.column > link2.target.column) {\n              var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);\n              return link1.y1 - link2Adj;\n            }\n            if (link2.target.column > link1.target.column) {\n              var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);\n              return link1Adj - link2.y1;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link1.target.y1 - link2.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.target.column - link1.target.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.target.column === link2.target.column) {\n              return link2.target.y1 - link1.target.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.target.column - link2.target.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y0 for links\n    var ySourceOffset = node.y0;\n\n    nodesSourceLinks.forEach(function (link) {\n      link.y0 = ySourceOffset + link.width / 2;\n      ySourceOffset = ySourceOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesSourceLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodeSourceLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;\n        }\n        link.y0 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// sort and set the links' y1 for each node\nfunction sortTargetLinks(graph, y1, id) {\n  graph.nodes.forEach(function (node) {\n    var nodesTargetLinks = graph.links.filter(function (l) {\n      return getNodeID(l.target, id) == getNodeID(node, id);\n    });\n\n    var nodesTargetLinksLength = nodesTargetLinks.length;\n\n    if (nodesTargetLinksLength > 1) {\n      nodesTargetLinks.sort(function (link1, link2) {\n        // if both are not circular, the base on the source y position\n        if (!link1.circular && !link2.circular) {\n          if (link1.source.column == link2.source.column) {\n            return link1.y0 - link2.y0;\n          } else if (!sameInclines(link1, link2)) {\n            return link1.y0 - link2.y0;\n          } else {\n            // get the angle of the link to the further source node (ie the smaller column)\n            if (link2.source.column < link1.source.column) {\n              var link2Adj = linkPerpendicularYToLinkSource(link2, link1);\n\n              return link1.y0 - link2Adj;\n            }\n            if (link1.source.column < link2.source.column) {\n              var link1Adj = linkPerpendicularYToLinkSource(link1, link2);\n\n              return link1Adj - link2.y0;\n            }\n          }\n        }\n\n        // if only one is circular, the move top links up, or bottom links down\n        if (link1.circular && !link2.circular) {\n          return link1.circularLinkType == 'top' ? -1 : 1;\n        } else if (link2.circular && !link1.circular) {\n          return link2.circularLinkType == 'top' ? 1 : -1;\n        }\n\n        // if both links are circular...\n        if (link1.circular && link2.circular) {\n          // ...and they both loop the same way (both top)\n          if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link1.source.column - link2.source.column;\n            }\n          } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {\n            // ...and they both loop the same way (both bottom)\n            // ...and they both connect to a target with same column, then sort by the target's y\n            if (link1.source.column === link2.source.column) {\n              return link1.source.y1 - link2.source.y1;\n            } else {\n              // ...and they connect to different column targets, then sort by how far back they\n              return link2.source.column - link1.source.column;\n            }\n          } else {\n            // ...and they loop around different ways, the move top up and bottom down\n            return link1.circularLinkType == 'top' ? -1 : 1;\n          }\n        }\n      });\n    }\n\n    // update y1 for links\n    var yTargetOffset = node.y0;\n\n    nodesTargetLinks.forEach(function (link) {\n      link.y1 = yTargetOffset + link.width / 2;\n      yTargetOffset = yTargetOffset + link.width;\n    });\n\n    // correct any circular bottom links so they are at the bottom of the node\n    nodesTargetLinks.forEach(function (link, i) {\n      if (link.circularLinkType == 'bottom') {\n        var j = i + 1;\n        var offsetFromBottom = 0;\n        // sum the widths of any links that are below this link\n        for (j; j < nodesTargetLinksLength; j++) {\n          offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;\n        }\n        link.y1 = node.y1 - offsetFromBottom - link.width / 2;\n      }\n    });\n  });\n}\n\n// test if links both slope up, or both slope down\nfunction sameInclines(link1, link2) {\n  return incline(link1) == incline(link2);\n}\n\n// returns the slope of a link, from source to target\n// up => slopes up from source to target\n// down => slopes down from source to target\nfunction incline(link) {\n  return link.y0 - link.y1 > 0 ? 'up' : 'down';\n}\n\n// check if link is self linking, ie links a node to the same node\nfunction selfLinking(link, id) {\n  return getNodeID(link.source, id) == getNodeID(link.target, id);\n}\n\nfunction fillHeight(graph, y0, y1) {\n\n  var nodes = graph.nodes;\n  var links = graph.links;\n\n  var top = false;\n  var bottom = false;\n\n  links.forEach(function (link) {\n    if (link.circularLinkType == \"top\") {\n      top = true;\n    } else if (link.circularLinkType == \"bottom\") {\n      bottom = true;\n    }\n  });\n\n  if (top == false || bottom == false) {\n    var minY0 = min(nodes, function (node) {\n      return node.y0;\n    });\n    var maxY1 = max(nodes, function (node) {\n      return node.y1;\n    });\n    var currentHeight = maxY1 - minY0;\n    var chartHeight = y1 - y0;\n    var ratio = chartHeight / currentHeight;\n\n    nodes.forEach(function (node) {\n      var nodeHeight = (node.y1 - node.y0) * ratio;\n      node.y0 = (node.y0 - minY0) * ratio;\n      node.y1 = node.y0 + nodeHeight;\n    });\n\n    links.forEach(function (link) {\n      link.y0 = (link.y0 - minY0) * ratio;\n      link.y1 = (link.y1 - minY0) * ratio;\n      link.width = link.width * ratio;\n    });\n  }\n}\n\nexport { sankeyCircular, center as sankeyCenter, left as sankeyLeft, right as sankeyRight, justify as sankeyJustify };\n"]},"metadata":{},"sourceType":"module"}