{"ast":null,"code":"'use strict';\n\nmodule.exports = createAttributeWrapper;\n\nvar GLError = require(\"./GLError\");\n\nfunction ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc) {\n  this._gl = gl;\n  this._wrapper = wrapper;\n  this._index = index;\n  this._locations = locations;\n  this._dimension = dimension;\n  this._constFunc = constFunc;\n}\n\nvar proto = ShaderAttribute.prototype;\n\nproto.pointer = function setAttribPointer(type, normalized, stride, offset) {\n  var self = this;\n  var gl = self._gl;\n  var location = self._locations[self._index];\n  gl.vertexAttribPointer(location, self._dimension, type || gl.FLOAT, !!normalized, stride || 0, offset || 0);\n  gl.enableVertexAttribArray(location);\n};\n\nproto.set = function (x0, x1, x2, x3) {\n  return this._constFunc(this._locations[this._index], x0, x1, x2, x3);\n};\n\nObject.defineProperty(proto, 'location', {\n  get: function () {\n    return this._locations[this._index];\n  },\n  set: function (v) {\n    if (v !== this._locations[this._index]) {\n      this._locations[this._index] = v | 0;\n      this._wrapper.program = null;\n    }\n\n    return v | 0;\n  }\n});\nvar allFns = [function (gl, v, x0) {\n  if (x0.length === undefined) {\n    return gl.vertexAttrib1f(v, x0);\n  } else {\n    return gl.vertexAttrib1fv(v, x0);\n  }\n}, function (gl, v, x0, x1) {\n  if (x0.length === undefined) {\n    return gl.vertexAttrib2f(v, x0, x1);\n  } else {\n    return gl.vertexAttrib2fv(v, x0);\n  }\n}, function (gl, v, x0, x1, x2) {\n  if (x0.length === undefined) {\n    return gl.vertexAttrib3f(v, x0, x1, x2);\n  } else {\n    return gl.vertexAttrib3fv(v, x0);\n  }\n}, function (gl, v, x0, x1, x2, x3) {\n  if (x0.length === undefined) {\n    return gl.vertexAttrib4f(v, x0, x1, x2, x3);\n  } else {\n    return gl.vertexAttrib4fv(v, x0);\n  }\n}]; //Adds a vector attribute to obj\n\nfunction addVectorAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n  var constFunc = allFns[dimension]; //Create attribute wrapper\n\n  var attr = new ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc); //Create accessor\n\n  Object.defineProperty(obj, name, {\n    set: function (x) {\n      gl.disableVertexAttribArray(locations[index]);\n      constFunc(gl, locations[index], x);\n      return x;\n    },\n    get: function () {\n      return attr;\n    },\n    enumerable: true\n  });\n}\n\nfunction addMatrixAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n  var parts = new Array(dimension);\n  var attrs = new Array(dimension);\n\n  for (var i = 0; i < dimension; ++i) {\n    addVectorAttribute(gl, wrapper, index[i], locations, dimension, parts, i);\n    attrs[i] = parts[i];\n  }\n\n  Object.defineProperty(parts, 'location', {\n    set: function (v) {\n      if (Array.isArray(v)) {\n        for (var i = 0; i < dimension; ++i) {\n          attrs[i].location = v[i];\n        }\n      } else {\n        for (var i = 0; i < dimension; ++i) {\n          attrs[i].location = v + i;\n        }\n      }\n\n      return v;\n    },\n    get: function () {\n      var result = new Array(dimension);\n\n      for (var i = 0; i < dimension; ++i) {\n        result[i] = locations[index[i]];\n      }\n\n      return result;\n    },\n    enumerable: true\n  });\n\n  parts.pointer = function (type, normalized, stride, offset) {\n    type = type || gl.FLOAT;\n    normalized = !!normalized;\n    stride = stride || dimension * dimension;\n    offset = offset || 0;\n\n    for (var i = 0; i < dimension; ++i) {\n      var location = locations[index[i]];\n      gl.vertexAttribPointer(location, dimension, type, normalized, stride, offset + i * dimension);\n      gl.enableVertexAttribArray(location);\n    }\n  };\n\n  var scratch = new Array(dimension);\n  var vertexAttrib = gl['vertexAttrib' + dimension + 'fv'];\n  Object.defineProperty(obj, name, {\n    set: function (x) {\n      for (var i = 0; i < dimension; ++i) {\n        var loc = locations[index[i]];\n        gl.disableVertexAttribArray(loc);\n\n        if (Array.isArray(x[0])) {\n          vertexAttrib.call(gl, loc, x[i]);\n        } else {\n          for (var j = 0; j < dimension; ++j) {\n            scratch[j] = x[dimension * i + j];\n          }\n\n          vertexAttrib.call(gl, loc, scratch);\n        }\n      }\n\n      return x;\n    },\n    get: function () {\n      return parts;\n    },\n    enumerable: true\n  });\n} //Create shims for attributes\n\n\nfunction createAttributeWrapper(gl, wrapper, attributes, locations) {\n  var obj = {};\n\n  for (var i = 0, n = attributes.length; i < n; ++i) {\n    var a = attributes[i];\n    var name = a.name;\n    var type = a.type;\n    var locs = a.locations;\n\n    switch (type) {\n      case 'bool':\n      case 'int':\n      case 'float':\n        addVectorAttribute(gl, wrapper, locs[0], locations, 1, obj, name);\n        break;\n\n      default:\n        if (type.indexOf('vec') >= 0) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n          }\n\n          addVectorAttribute(gl, wrapper, locs[0], locations, d, obj, name);\n        } else if (type.indexOf('mat') >= 0) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n          }\n\n          addMatrixAttribute(gl, wrapper, locs, locations, d, obj, name);\n        } else {\n          throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type);\n        }\n\n        break;\n    }\n  }\n\n  return obj;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/gl-shader/lib/create-attributes.js"],"names":["module","exports","createAttributeWrapper","GLError","require","ShaderAttribute","gl","wrapper","index","locations","dimension","constFunc","_gl","_wrapper","_index","_locations","_dimension","_constFunc","proto","prototype","pointer","setAttribPointer","type","normalized","stride","offset","self","location","vertexAttribPointer","FLOAT","enableVertexAttribArray","set","x0","x1","x2","x3","Object","defineProperty","get","v","program","allFns","length","undefined","vertexAttrib1f","vertexAttrib1fv","vertexAttrib2f","vertexAttrib2fv","vertexAttrib3f","vertexAttrib3fv","vertexAttrib4f","vertexAttrib4fv","addVectorAttribute","obj","name","attr","x","disableVertexAttribArray","enumerable","addMatrixAttribute","parts","Array","attrs","i","isArray","result","scratch","vertexAttrib","loc","call","j","attributes","n","a","locs","indexOf","d","charCodeAt"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = createAttributeWrapper\n\nvar GLError = require(\"./GLError\")\n\nfunction ShaderAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , constFunc) {\n  this._gl        = gl\n  this._wrapper   = wrapper\n  this._index     = index\n  this._locations = locations\n  this._dimension = dimension\n  this._constFunc = constFunc\n}\n\nvar proto = ShaderAttribute.prototype\n\nproto.pointer = function setAttribPointer(\n    type\n  , normalized\n  , stride\n  , offset) {\n\n  var self      = this\n  var gl        = self._gl\n  var location  = self._locations[self._index]\n\n  gl.vertexAttribPointer(\n      location\n    , self._dimension\n    , type || gl.FLOAT\n    , !!normalized\n    , stride || 0\n    , offset || 0)\n  gl.enableVertexAttribArray(location)\n}\n\nproto.set = function(x0, x1, x2, x3) {\n  return this._constFunc(this._locations[this._index], x0, x1, x2, x3)\n}\n\nObject.defineProperty(proto, 'location', {\n  get: function() {\n    return this._locations[this._index]\n  }\n  , set: function(v) {\n    if(v !== this._locations[this._index]) {\n      this._locations[this._index] = v|0\n      this._wrapper.program = null\n    }\n    return v|0\n  }\n})\n\nvar allFns = [\n  function (gl, v, x0) {\n    if (x0.length === undefined) {\n      return gl.vertexAttrib1f(v, x0)\n    } else {\n      return gl.vertexAttrib1fv(v, x0)\n    }\n  },\n\n  function (gl, v, x0, x1) {\n    if (x0.length === undefined) {\n      return gl.vertexAttrib2f(v, x0, x1)\n    } else {\n      return gl.vertexAttrib2fv(v, x0)\n    }\n  },\n\n  function (gl, v, x0, x1, x2) {\n    if (x0.length === undefined) {\n      return gl.vertexAttrib3f(v, x0, x1, x2)\n    } else {\n      return gl.vertexAttrib3fv(v, x0)\n    }\n  },\n\n  function (gl, v, x0, x1, x2, x3) {\n    if (x0.length === undefined) {\n      return gl.vertexAttrib4f(v, x0, x1, x2, x3)\n    } else {\n      return gl.vertexAttrib4fv(v, x0)\n    }\n  }\n]\n\n//Adds a vector attribute to obj\nfunction addVectorAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , obj\n  , name) {\n\n  var constFunc = allFns[dimension]\n\n  //Create attribute wrapper\n  var attr = new ShaderAttribute(\n      gl\n    , wrapper\n    , index\n    , locations\n    , dimension\n    , constFunc)\n\n  //Create accessor\n  Object.defineProperty(obj, name, {\n    set: function(x) {\n      gl.disableVertexAttribArray(locations[index])\n      constFunc(gl, locations[index], x)\n      return x\n    }\n    , get: function() {\n      return attr\n    }\n    , enumerable: true\n  })\n}\n\nfunction addMatrixAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , obj\n  , name) {\n\n  var parts = new Array(dimension)\n  var attrs = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    addVectorAttribute(\n        gl\n      , wrapper\n      , index[i]\n      , locations\n      , dimension\n      , parts\n      , i)\n    attrs[i] = parts[i]\n  }\n\n  Object.defineProperty(parts, 'location', {\n    set: function(v) {\n      if(Array.isArray(v)) {\n        for(var i=0; i<dimension; ++i) {\n          attrs[i].location = v[i]\n        }\n      } else {\n        for(var i=0; i<dimension; ++i) {\n          attrs[i].location = v + i\n        }\n      }\n      return v\n    }\n    , get: function() {\n      var result = new Array(dimension)\n      for(var i=0; i<dimension; ++i) {\n        result[i] = locations[index[i]]\n      }\n      return result\n    }\n    , enumerable: true\n  })\n\n  parts.pointer = function(type, normalized, stride, offset) {\n    type       = type || gl.FLOAT\n    normalized = !!normalized\n    stride     = stride || (dimension * dimension)\n    offset     = offset || 0\n    for(var i=0; i<dimension; ++i) {\n      var location = locations[index[i]]\n      gl.vertexAttribPointer(\n            location\n          , dimension\n          , type\n          , normalized\n          , stride\n          , offset + i * dimension)\n      gl.enableVertexAttribArray(location)\n    }\n  }\n\n  var scratch = new Array(dimension)\n  var vertexAttrib = gl['vertexAttrib' + dimension + 'fv']\n\n  Object.defineProperty(obj, name, {\n    set: function(x) {\n      for(var i=0; i<dimension; ++i) {\n        var loc = locations[index[i]]\n        gl.disableVertexAttribArray(loc)\n        if(Array.isArray(x[0])) {\n          vertexAttrib.call(gl, loc, x[i])\n        } else {\n          for(var j=0; j<dimension; ++j) {\n            scratch[j] = x[dimension*i + j]\n          }\n          vertexAttrib.call(gl, loc, scratch)\n        }\n      }\n      return x\n    }\n    , get: function() {\n      return parts\n    }\n    , enumerable: true\n  })\n}\n\n//Create shims for attributes\nfunction createAttributeWrapper(\n    gl\n  , wrapper\n  , attributes\n  , locations) {\n\n  var obj = {}\n  for(var i=0, n=attributes.length; i<n; ++i) {\n\n    var a = attributes[i]\n    var name = a.name\n    var type = a.type\n    var locs = a.locations\n\n    switch(type) {\n      case 'bool':\n      case 'int':\n      case 'float':\n        addVectorAttribute(\n            gl\n          , wrapper\n          , locs[0]\n          , locations\n          , 1\n          , obj\n          , name)\n      break\n\n      default:\n        if(type.indexOf('vec') >= 0) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type)\n          }\n          addVectorAttribute(\n              gl\n            , wrapper\n            , locs[0]\n            , locations\n            , d\n            , obj\n            , name)\n        } else if(type.indexOf('mat') >= 0) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type)\n          }\n          addMatrixAttribute(\n              gl\n            , wrapper\n            , locs\n            , locations\n            , d\n            , obj\n            , name)\n        } else {\n          throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type)\n        }\n      break\n    }\n  }\n  return obj\n}\n"]},"metadata":{},"sourceType":"script"}