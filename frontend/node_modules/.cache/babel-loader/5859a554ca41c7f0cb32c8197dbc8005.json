{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar traceIs = require('../../registry').traceIs;\n\nvar handleGroupingDefaults = require('../bar/defaults').handleGroupingDefaults;\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar BINATTRS = [{\n  aStr: {\n    x: 'xbins.start',\n    y: 'ybins.start'\n  },\n  name: 'start'\n}, {\n  aStr: {\n    x: 'xbins.end',\n    y: 'ybins.end'\n  },\n  name: 'end'\n}, {\n  aStr: {\n    x: 'xbins.size',\n    y: 'ybins.size'\n  },\n  name: 'size'\n}, {\n  aStr: {\n    x: 'nbinsx',\n    y: 'nbinsy'\n  },\n  name: 'nbins'\n}];\nvar BINDIRECTIONS = ['x', 'y']; // handle bin attrs and relink auto-determined values so fullData is complete\n\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n  var allBinOpts = fullLayout._histogramBinOpts = {};\n  var histTraces = [];\n  var mustMatchTracesLookup = {};\n  var otherTracesList = [];\n  var traceOut, traces, groupName, binDir;\n  var i, j, k;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr, dflt);\n  }\n\n  function orientation2binDir(traceOut) {\n    return traceOut.orientation === 'v' ? 'x' : 'y';\n  }\n\n  function getAxisType(traceOut, binDir) {\n    var ax = axisIds.getFromTrace({\n      _fullLayout: fullLayout\n    }, traceOut, binDir);\n    return ax.type;\n  }\n\n  function fillBinOpts(traceOut, groupName, binDir) {\n    // N.B. group traces that don't have a bingroup with themselves\n    var fallbackGroupName = traceOut.uid + '__' + binDir;\n    if (!groupName) groupName = fallbackGroupName;\n    var axType = getAxisType(traceOut, binDir);\n    var calendar = traceOut[binDir + 'calendar'] || '';\n    var binOpts = allBinOpts[groupName];\n    var needsNewItem = true;\n\n    if (binOpts) {\n      if (axType === binOpts.axType && calendar === binOpts.calendar) {\n        needsNewItem = false;\n        binOpts.traces.push(traceOut);\n        binOpts.dirs.push(binDir);\n      } else {\n        groupName = fallbackGroupName;\n\n        if (axType !== binOpts.axType) {\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set on a', 'type:' + axType, 'axis', 'with bins on', 'type:' + binOpts.axType, 'axis.'].join(' '));\n        }\n\n        if (calendar !== binOpts.calendar) {\n          // prohibit bingroup for traces using different calendar,\n          // there's probably a way to make this work, but skip for now\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set with a', calendar, 'calendar', 'with bins', binOpts.calendar ? 'on a ' + binOpts.calendar + ' calendar' : 'w/o a set calendar'].join(' '));\n        }\n      }\n    }\n\n    if (needsNewItem) {\n      allBinOpts[groupName] = {\n        traces: [traceOut],\n        dirs: [binDir],\n        axType: axType,\n        calendar: traceOut[binDir + 'calendar'] || ''\n      };\n    }\n\n    traceOut['_' + binDir + 'bingroup'] = groupName;\n  }\n\n  for (i = 0; i < fullData.length; i++) {\n    traceOut = fullData[i];\n\n    if (traceIs(traceOut, 'histogram')) {\n      histTraces.push(traceOut); // TODO: this shouldn't be relinked as it's only used within calc\n      // https://github.com/plotly/plotly.js/issues/749\n\n      delete traceOut._xautoBinFinished;\n      delete traceOut._yautoBinFinished; // N.B. need to coerce *alignmentgroup* before *bingroup*, as traces\n      // in same alignmentgroup \"have to match\"\n\n      if (!traceIs(traceOut, '2dMap')) {\n        handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce);\n      }\n    }\n  }\n\n  var alignmentOpts = fullLayout._alignmentOpts || {}; // Look for traces that \"have to match\", that is:\n  // - 1d histogram traces on the same subplot with same orientation under barmode:stack,\n  // - 1d histogram traces on the same subplot with same orientation under barmode:group\n  // - 1d histogram traces on the same position axis with the same orientation\n  //   and the same *alignmentgroup* (coerced under barmode:group)\n  // - Once `stackgroup` gets implemented (see https://github.com/plotly/plotly.js/issues/3614),\n  //   traces within the same stackgroup will also \"have to match\"\n\n  for (i = 0; i < histTraces.length; i++) {\n    traceOut = histTraces[i];\n    groupName = '';\n\n    if (!traceIs(traceOut, '2dMap')) {\n      binDir = orientation2binDir(traceOut);\n\n      if (fullLayout.barmode === 'group' && traceOut.alignmentgroup) {\n        var pa = traceOut[binDir + 'axis'];\n        var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;\n\n        if ((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {\n          groupName = aGroupId;\n        }\n      }\n\n      if (!groupName && fullLayout.barmode !== 'overlay') {\n        groupName = getAxisGroup(fullLayout, traceOut.xaxis) + getAxisGroup(fullLayout, traceOut.yaxis) + orientation2binDir(traceOut);\n      }\n    }\n\n    if (groupName) {\n      if (!mustMatchTracesLookup[groupName]) {\n        mustMatchTracesLookup[groupName] = [];\n      }\n\n      mustMatchTracesLookup[groupName].push(traceOut);\n    } else {\n      otherTracesList.push(traceOut);\n    }\n  } // Setup binOpts for traces that have to match,\n  // if the traces have a valid bingroup, use that\n  // if not use axis+binDir groupName\n\n\n  for (groupName in mustMatchTracesLookup) {\n    traces = mustMatchTracesLookup[groupName]; // no need to 'force' anything when a single\n    // trace is detected as \"must match\"\n\n    if (traces.length === 1) {\n      otherTracesList.push(traces[0]);\n      continue;\n    }\n\n    var binGroupFound = false;\n\n    if (traces.length) {\n      traceOut = traces[0];\n      binGroupFound = coerce('bingroup');\n    }\n\n    groupName = binGroupFound || groupName;\n\n    for (i = 0; i < traces.length; i++) {\n      traceOut = traces[i];\n      var bingroupIn = traceOut._input.bingroup;\n\n      if (bingroupIn && bingroupIn !== groupName) {\n        Lib.warn(['Trace', traceOut.index, 'must match', 'within bingroup', groupName + '.', 'Ignoring its bingroup:', bingroupIn, 'setting.'].join(' '));\n      }\n\n      traceOut.bingroup = groupName; // N.B. no need to worry about 2dMap case\n      // (where both bin direction are set in each trace)\n      // as 2dMap trace never \"have to match\"\n\n      fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));\n    }\n  } // setup binOpts for traces that can but don't have to match,\n  // notice that these traces can be matched with traces that have to match\n\n\n  for (i = 0; i < otherTracesList.length; i++) {\n    traceOut = otherTracesList[i];\n    var binGroup = coerce('bingroup');\n\n    if (traceIs(traceOut, '2dMap')) {\n      for (k = 0; k < 2; k++) {\n        binDir = BINDIRECTIONS[k];\n        var binGroupInDir = coerce(binDir + 'bingroup', binGroup ? binGroup + '__' + binDir : null);\n        fillBinOpts(traceOut, binGroupInDir, binDir);\n      }\n    } else {\n      fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));\n    }\n  } // coerce bin attrs!\n\n\n  for (groupName in allBinOpts) {\n    var binOpts = allBinOpts[groupName];\n    traces = binOpts.traces;\n\n    for (j = 0; j < BINATTRS.length; j++) {\n      var attrSpec = BINATTRS[j];\n      var attr = attrSpec.name;\n      var aStr;\n      var autoVals; // nbins(x|y) is moot if we have a size. This depends on\n      // nbins coming after size in binAttrs.\n\n      if (attr === 'nbins' && binOpts.sizeFound) continue;\n\n      for (i = 0; i < traces.length; i++) {\n        traceOut = traces[i];\n        binDir = binOpts.dirs[i];\n        aStr = attrSpec.aStr[binDir];\n\n        if (nestedProperty(traceOut._input, aStr).get() !== undefined) {\n          binOpts[attr] = coerce(aStr);\n          binOpts[attr + 'Found'] = true;\n          break;\n        }\n\n        autoVals = (traceOut._autoBin || {})[binDir] || {};\n\n        if (autoVals[attr]) {\n          // if this is the *first* autoval\n          nestedProperty(traceOut, aStr).set(autoVals[attr]);\n        }\n      } // start and end we need to coerce anyway, after having collected the\n      // first of each into binOpts, in case a trace wants to restrict its\n      // data to a certain range\n\n\n      if (attr === 'start' || attr === 'end') {\n        for (; i < traces.length; i++) {\n          traceOut = traces[i];\n\n          if (traceOut['_' + binDir + 'bingroup']) {\n            autoVals = (traceOut._autoBin || {})[binDir] || {};\n            coerce(aStr, autoVals[attr]);\n          }\n        }\n      }\n\n      if (attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n        traceOut = traces[0];\n        binOpts[attr] = coerce(aStr);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/histogram/cross_trace_defaults.js"],"names":["Lib","require","axisIds","traceIs","handleGroupingDefaults","nestedProperty","getAxisGroup","BINATTRS","aStr","x","y","name","BINDIRECTIONS","module","exports","crossTraceDefaults","fullData","fullLayout","allBinOpts","_histogramBinOpts","histTraces","mustMatchTracesLookup","otherTracesList","traceOut","traces","groupName","binDir","i","j","k","coerce","attr","dflt","_input","_module","attributes","orientation2binDir","orientation","getAxisType","ax","getFromTrace","_fullLayout","type","fillBinOpts","fallbackGroupName","uid","axType","calendar","binOpts","needsNewItem","push","dirs","warn","index","join","length","_xautoBinFinished","_yautoBinFinished","alignmentOpts","_alignmentOpts","barmode","alignmentgroup","pa","aGroupId","xaxis","yaxis","binGroupFound","bingroupIn","bingroup","binGroup","binGroupInDir","attrSpec","autoVals","sizeFound","get","undefined","_autoBin","set","nbinsFound"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,gCAAD,CAArB;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAD,CAAP,CAA0BE,OAAxC;;AACA,IAAIC,sBAAsB,GAAGH,OAAO,CAAC,iBAAD,CAAP,CAA2BG,sBAAxD;;AAEA,IAAIC,cAAc,GAAGL,GAAG,CAACK,cAAzB;;AACA,IAAIC,YAAY,GAAGL,OAAO,CAAC,mCAAD,CAAP,CAA6CK,YAAhE;;AAEA,IAAIC,QAAQ,GAAG,CACX;AAACC,EAAAA,IAAI,EAAE;AAACC,IAAAA,CAAC,EAAE,aAAJ;AAAmBC,IAAAA,CAAC,EAAE;AAAtB,GAAP;AAA6CC,EAAAA,IAAI,EAAE;AAAnD,CADW,EAEX;AAACH,EAAAA,IAAI,EAAE;AAACC,IAAAA,CAAC,EAAE,WAAJ;AAAiBC,IAAAA,CAAC,EAAE;AAApB,GAAP;AAAyCC,EAAAA,IAAI,EAAE;AAA/C,CAFW,EAGX;AAACH,EAAAA,IAAI,EAAE;AAACC,IAAAA,CAAC,EAAE,YAAJ;AAAkBC,IAAAA,CAAC,EAAE;AAArB,GAAP;AAA2CC,EAAAA,IAAI,EAAE;AAAjD,CAHW,EAIX;AAACH,EAAAA,IAAI,EAAE;AAACC,IAAAA,CAAC,EAAE,QAAJ;AAAcC,IAAAA,CAAC,EAAE;AAAjB,GAAP;AAAmCC,EAAAA,IAAI,EAAE;AAAzC,CAJW,CAAf;AAOA,IAAIC,aAAa,GAAG,CAAC,GAAD,EAAM,GAAN,CAApB,C,CAEA;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCC,UAAtC,EAAkD;AAC/D,MAAIC,UAAU,GAAGD,UAAU,CAACE,iBAAX,GAA+B,EAAhD;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACA,MAAIC,eAAe,GAAG,EAAtB;AAEA,MAAIC,QAAJ,EAAcC,MAAd,EAAsBC,SAAtB,EAAiCC,MAAjC;AACA,MAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV;;AAEA,WAASC,MAAT,CAAgBC,IAAhB,EAAsBC,IAAtB,EAA4B;AACxB,WAAOhC,GAAG,CAAC8B,MAAJ,CAAWP,QAAQ,CAACU,MAApB,EAA4BV,QAA5B,EAAsCA,QAAQ,CAACW,OAAT,CAAiBC,UAAvD,EAAmEJ,IAAnE,EAAyEC,IAAzE,CAAP;AACH;;AAED,WAASI,kBAAT,CAA4Bb,QAA5B,EAAsC;AAClC,WAAOA,QAAQ,CAACc,WAAT,KAAyB,GAAzB,GAA+B,GAA/B,GAAqC,GAA5C;AACH;;AAED,WAASC,WAAT,CAAqBf,QAArB,EAA+BG,MAA/B,EAAuC;AACnC,QAAIa,EAAE,GAAGrC,OAAO,CAACsC,YAAR,CAAqB;AAACC,MAAAA,WAAW,EAAExB;AAAd,KAArB,EAAgDM,QAAhD,EAA0DG,MAA1D,CAAT;AACA,WAAOa,EAAE,CAACG,IAAV;AACH;;AAED,WAASC,WAAT,CAAqBpB,QAArB,EAA+BE,SAA/B,EAA0CC,MAA1C,EAAkD;AAC9C;AACA,QAAIkB,iBAAiB,GAAGrB,QAAQ,CAACsB,GAAT,GAAe,IAAf,GAAsBnB,MAA9C;AACA,QAAG,CAACD,SAAJ,EAAeA,SAAS,GAAGmB,iBAAZ;AAEf,QAAIE,MAAM,GAAGR,WAAW,CAACf,QAAD,EAAWG,MAAX,CAAxB;AACA,QAAIqB,QAAQ,GAAGxB,QAAQ,CAACG,MAAM,GAAG,UAAV,CAAR,IAAiC,EAAhD;AACA,QAAIsB,OAAO,GAAG9B,UAAU,CAACO,SAAD,CAAxB;AACA,QAAIwB,YAAY,GAAG,IAAnB;;AAEA,QAAGD,OAAH,EAAY;AACR,UAAGF,MAAM,KAAKE,OAAO,CAACF,MAAnB,IAA6BC,QAAQ,KAAKC,OAAO,CAACD,QAArD,EAA+D;AAC3DE,QAAAA,YAAY,GAAG,KAAf;AACAD,QAAAA,OAAO,CAACxB,MAAR,CAAe0B,IAAf,CAAoB3B,QAApB;AACAyB,QAAAA,OAAO,CAACG,IAAR,CAAaD,IAAb,CAAkBxB,MAAlB;AACH,OAJD,MAIO;AACHD,QAAAA,SAAS,GAAGmB,iBAAZ;;AAEA,YAAGE,MAAM,KAAKE,OAAO,CAACF,MAAtB,EAA8B;AAC1B9C,UAAAA,GAAG,CAACoD,IAAJ,CAAS,CACL,sCADK,EACmC7B,QAAQ,CAAC8B,KAD5C,EAEL,UAFK,EAEO,UAAUP,MAFjB,EAEyB,MAFzB,EAGL,cAHK,EAGW,UAAUE,OAAO,CAACF,MAH7B,EAGqC,OAHrC,EAIPQ,IAJO,CAIF,GAJE,CAAT;AAKH;;AACD,YAAGP,QAAQ,KAAKC,OAAO,CAACD,QAAxB,EAAkC;AAC9B;AACA;AACA/C,UAAAA,GAAG,CAACoD,IAAJ,CAAS,CACL,sCADK,EACmC7B,QAAQ,CAAC8B,KAD5C,EAEL,YAFK,EAESN,QAFT,EAEmB,UAFnB,EAGL,WAHK,EAIJC,OAAO,CAACD,QAAR,GAAmB,UAAUC,OAAO,CAACD,QAAlB,GAA6B,WAAhD,GAA8D,oBAJ1D,EAKPO,IALO,CAKF,GALE,CAAT;AAMH;AACJ;AACJ;;AAED,QAAGL,YAAH,EAAiB;AACb/B,MAAAA,UAAU,CAACO,SAAD,CAAV,GAAwB;AACpBD,QAAAA,MAAM,EAAE,CAACD,QAAD,CADY;AAEpB4B,QAAAA,IAAI,EAAE,CAACzB,MAAD,CAFc;AAGpBoB,QAAAA,MAAM,EAAEA,MAHY;AAIpBC,QAAAA,QAAQ,EAAExB,QAAQ,CAACG,MAAM,GAAG,UAAV,CAAR,IAAiC;AAJvB,OAAxB;AAMH;;AACDH,IAAAA,QAAQ,CAAC,MAAMG,MAAN,GAAe,UAAhB,CAAR,GAAsCD,SAAtC;AACH;;AAED,OAAIE,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGX,QAAQ,CAACuC,MAAxB,EAAgC5B,CAAC,EAAjC,EAAqC;AACjCJ,IAAAA,QAAQ,GAAGP,QAAQ,CAACW,CAAD,CAAnB;;AAEA,QAAGxB,OAAO,CAACoB,QAAD,EAAW,WAAX,CAAV,EAAmC;AAC/BH,MAAAA,UAAU,CAAC8B,IAAX,CAAgB3B,QAAhB,EAD+B,CAG/B;AACA;;AACA,aAAOA,QAAQ,CAACiC,iBAAhB;AACA,aAAOjC,QAAQ,CAACkC,iBAAhB,CAN+B,CAQ/B;AACA;;AACA,UAAG,CAACtD,OAAO,CAACoB,QAAD,EAAW,OAAX,CAAX,EAAgC;AAC5BnB,QAAAA,sBAAsB,CAACmB,QAAQ,CAACU,MAAV,EAAkBV,QAAlB,EAA4BN,UAA5B,EAAwCa,MAAxC,CAAtB;AACH;AACJ;AACJ;;AAED,MAAI4B,aAAa,GAAGzC,UAAU,CAAC0C,cAAX,IAA6B,EAAjD,CA1F+D,CA4F/D;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAIhC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGP,UAAU,CAACmC,MAA1B,EAAkC5B,CAAC,EAAnC,EAAuC;AACnCJ,IAAAA,QAAQ,GAAGH,UAAU,CAACO,CAAD,CAArB;AACAF,IAAAA,SAAS,GAAG,EAAZ;;AAEA,QAAG,CAACtB,OAAO,CAACoB,QAAD,EAAW,OAAX,CAAX,EAAgC;AAC5BG,MAAAA,MAAM,GAAGU,kBAAkB,CAACb,QAAD,CAA3B;;AAEA,UAAGN,UAAU,CAAC2C,OAAX,KAAuB,OAAvB,IAAkCrC,QAAQ,CAACsC,cAA9C,EAA8D;AAC1D,YAAIC,EAAE,GAAGvC,QAAQ,CAACG,MAAM,GAAG,MAAV,CAAjB;AACA,YAAIqC,QAAQ,GAAGzD,YAAY,CAACW,UAAD,EAAa6C,EAAb,CAAZ,GAA+BvC,QAAQ,CAACc,WAAvD;;AACA,YAAG,CAACqB,aAAa,CAACK,QAAD,CAAb,IAA2B,EAA5B,EAAgCxC,QAAQ,CAACsC,cAAzC,CAAH,EAA6D;AACzDpC,UAAAA,SAAS,GAAGsC,QAAZ;AACH;AACJ;;AAED,UAAG,CAACtC,SAAD,IAAcR,UAAU,CAAC2C,OAAX,KAAuB,SAAxC,EAAmD;AAC/CnC,QAAAA,SAAS,GACLnB,YAAY,CAACW,UAAD,EAAaM,QAAQ,CAACyC,KAAtB,CAAZ,GACA1D,YAAY,CAACW,UAAD,EAAaM,QAAQ,CAAC0C,KAAtB,CADZ,GAEA7B,kBAAkB,CAACb,QAAD,CAHtB;AAKH;AACJ;;AAED,QAAGE,SAAH,EAAc;AACV,UAAG,CAACJ,qBAAqB,CAACI,SAAD,CAAzB,EAAsC;AAClCJ,QAAAA,qBAAqB,CAACI,SAAD,CAArB,GAAmC,EAAnC;AACH;;AACDJ,MAAAA,qBAAqB,CAACI,SAAD,CAArB,CAAiCyB,IAAjC,CAAsC3B,QAAtC;AACH,KALD,MAKO;AACHD,MAAAA,eAAe,CAAC4B,IAAhB,CAAqB3B,QAArB;AACH;AACJ,GAnI8D,CAqI/D;AACA;AACA;;;AACA,OAAIE,SAAJ,IAAiBJ,qBAAjB,EAAwC;AACpCG,IAAAA,MAAM,GAAGH,qBAAqB,CAACI,SAAD,CAA9B,CADoC,CAGpC;AACA;;AACA,QAAGD,MAAM,CAAC+B,MAAP,KAAkB,CAArB,EAAwB;AACpBjC,MAAAA,eAAe,CAAC4B,IAAhB,CAAqB1B,MAAM,CAAC,CAAD,CAA3B;AACA;AACH;;AAED,QAAI0C,aAAa,GAAG,KAApB;;AACA,QAAG1C,MAAM,CAAC+B,MAAV,EAAkB;AACdhC,MAAAA,QAAQ,GAAGC,MAAM,CAAC,CAAD,CAAjB;AACA0C,MAAAA,aAAa,GAAGpC,MAAM,CAAC,UAAD,CAAtB;AACH;;AAEDL,IAAAA,SAAS,GAAGyC,aAAa,IAAIzC,SAA7B;;AAEA,SAAIE,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGH,MAAM,CAAC+B,MAAtB,EAA8B5B,CAAC,EAA/B,EAAmC;AAC/BJ,MAAAA,QAAQ,GAAGC,MAAM,CAACG,CAAD,CAAjB;AACA,UAAIwC,UAAU,GAAG5C,QAAQ,CAACU,MAAT,CAAgBmC,QAAjC;;AACA,UAAGD,UAAU,IAAIA,UAAU,KAAK1C,SAAhC,EAA2C;AACvCzB,QAAAA,GAAG,CAACoD,IAAJ,CAAS,CACL,OADK,EACI7B,QAAQ,CAAC8B,KADb,EACoB,YADpB,EAEL,iBAFK,EAEc5B,SAAS,GAAG,GAF1B,EAGL,wBAHK,EAGqB0C,UAHrB,EAGiC,UAHjC,EAIPb,IAJO,CAIF,GAJE,CAAT;AAKH;;AACD/B,MAAAA,QAAQ,CAAC6C,QAAT,GAAoB3C,SAApB,CAV+B,CAY/B;AACA;AACA;;AACAkB,MAAAA,WAAW,CAACpB,QAAD,EAAWE,SAAX,EAAsBW,kBAAkB,CAACb,QAAD,CAAxC,CAAX;AACH;AACJ,GA3K8D,CA6K/D;AACA;;;AACA,OAAII,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGL,eAAe,CAACiC,MAA/B,EAAuC5B,CAAC,EAAxC,EAA4C;AACxCJ,IAAAA,QAAQ,GAAGD,eAAe,CAACK,CAAD,CAA1B;AAEA,QAAI0C,QAAQ,GAAGvC,MAAM,CAAC,UAAD,CAArB;;AAEA,QAAG3B,OAAO,CAACoB,QAAD,EAAW,OAAX,CAAV,EAA+B;AAC3B,WAAIM,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG,CAAf,EAAkBA,CAAC,EAAnB,EAAuB;AACnBH,QAAAA,MAAM,GAAGd,aAAa,CAACiB,CAAD,CAAtB;AACA,YAAIyC,aAAa,GAAGxC,MAAM,CAACJ,MAAM,GAAG,UAAV,EACtB2C,QAAQ,GAAGA,QAAQ,GAAG,IAAX,GAAkB3C,MAArB,GAA8B,IADhB,CAA1B;AAGAiB,QAAAA,WAAW,CAACpB,QAAD,EAAW+C,aAAX,EAA0B5C,MAA1B,CAAX;AACH;AACJ,KARD,MAQO;AACHiB,MAAAA,WAAW,CAACpB,QAAD,EAAW8C,QAAX,EAAqBjC,kBAAkB,CAACb,QAAD,CAAvC,CAAX;AACH;AACJ,GA/L8D,CAiM/D;;;AACA,OAAIE,SAAJ,IAAiBP,UAAjB,EAA6B;AACzB,QAAI8B,OAAO,GAAG9B,UAAU,CAACO,SAAD,CAAxB;AACAD,IAAAA,MAAM,GAAGwB,OAAO,CAACxB,MAAjB;;AAEA,SAAII,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGrB,QAAQ,CAACgD,MAAxB,EAAgC3B,CAAC,EAAjC,EAAqC;AACjC,UAAI2C,QAAQ,GAAGhE,QAAQ,CAACqB,CAAD,CAAvB;AACA,UAAIG,IAAI,GAAGwC,QAAQ,CAAC5D,IAApB;AACA,UAAIH,IAAJ;AACA,UAAIgE,QAAJ,CAJiC,CAMjC;AACA;;AACA,UAAGzC,IAAI,KAAK,OAAT,IAAoBiB,OAAO,CAACyB,SAA/B,EAA0C;;AAE1C,WAAI9C,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGH,MAAM,CAAC+B,MAAtB,EAA8B5B,CAAC,EAA/B,EAAmC;AAC/BJ,QAAAA,QAAQ,GAAGC,MAAM,CAACG,CAAD,CAAjB;AACAD,QAAAA,MAAM,GAAGsB,OAAO,CAACG,IAAR,CAAaxB,CAAb,CAAT;AACAnB,QAAAA,IAAI,GAAG+D,QAAQ,CAAC/D,IAAT,CAAckB,MAAd,CAAP;;AAEA,YAAGrB,cAAc,CAACkB,QAAQ,CAACU,MAAV,EAAkBzB,IAAlB,CAAd,CAAsCkE,GAAtC,OAAgDC,SAAnD,EAA8D;AAC1D3B,UAAAA,OAAO,CAACjB,IAAD,CAAP,GAAgBD,MAAM,CAACtB,IAAD,CAAtB;AACAwC,UAAAA,OAAO,CAACjB,IAAI,GAAG,OAAR,CAAP,GAA0B,IAA1B;AACA;AACH;;AAEDyC,QAAAA,QAAQ,GAAG,CAACjD,QAAQ,CAACqD,QAAT,IAAqB,EAAtB,EAA0BlD,MAA1B,KAAqC,EAAhD;;AACA,YAAG8C,QAAQ,CAACzC,IAAD,CAAX,EAAmB;AACf;AACA1B,UAAAA,cAAc,CAACkB,QAAD,EAAWf,IAAX,CAAd,CAA+BqE,GAA/B,CAAmCL,QAAQ,CAACzC,IAAD,CAA3C;AACH;AACJ,OA1BgC,CA4BjC;AACA;AACA;;;AACA,UAAGA,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,KAAhC,EAAuC;AACnC,eAAMJ,CAAC,GAAGH,MAAM,CAAC+B,MAAjB,EAAyB5B,CAAC,EAA1B,EAA8B;AAC1BJ,UAAAA,QAAQ,GAAGC,MAAM,CAACG,CAAD,CAAjB;;AACA,cAAGJ,QAAQ,CAAC,MAAMG,MAAN,GAAe,UAAhB,CAAX,EAAwC;AACpC8C,YAAAA,QAAQ,GAAG,CAACjD,QAAQ,CAACqD,QAAT,IAAqB,EAAtB,EAA0BlD,MAA1B,KAAqC,EAAhD;AACAI,YAAAA,MAAM,CAACtB,IAAD,EAAOgE,QAAQ,CAACzC,IAAD,CAAf,CAAN;AACH;AACJ;AACJ;;AAED,UAAGA,IAAI,KAAK,OAAT,IAAoB,CAACiB,OAAO,CAACyB,SAA7B,IAA0C,CAACzB,OAAO,CAAC8B,UAAtD,EAAkE;AAC9DvD,QAAAA,QAAQ,GAAGC,MAAM,CAAC,CAAD,CAAjB;AACAwB,QAAAA,OAAO,CAACjB,IAAD,CAAP,GAAgBD,MAAM,CAACtB,IAAD,CAAtB;AACH;AACJ;AACJ;AACJ,CArPD","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar traceIs = require('../../registry').traceIs;\nvar handleGroupingDefaults = require('../bar/defaults').handleGroupingDefaults;\n\nvar nestedProperty = Lib.nestedProperty;\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar BINATTRS = [\n    {aStr: {x: 'xbins.start', y: 'ybins.start'}, name: 'start'},\n    {aStr: {x: 'xbins.end', y: 'ybins.end'}, name: 'end'},\n    {aStr: {x: 'xbins.size', y: 'ybins.size'}, name: 'size'},\n    {aStr: {x: 'nbinsx', y: 'nbinsy'}, name: 'nbins'}\n];\n\nvar BINDIRECTIONS = ['x', 'y'];\n\n// handle bin attrs and relink auto-determined values so fullData is complete\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n    var allBinOpts = fullLayout._histogramBinOpts = {};\n    var histTraces = [];\n    var mustMatchTracesLookup = {};\n    var otherTracesList = [];\n\n    var traceOut, traces, groupName, binDir;\n    var i, j, k;\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr, dflt);\n    }\n\n    function orientation2binDir(traceOut) {\n        return traceOut.orientation === 'v' ? 'x' : 'y';\n    }\n\n    function getAxisType(traceOut, binDir) {\n        var ax = axisIds.getFromTrace({_fullLayout: fullLayout}, traceOut, binDir);\n        return ax.type;\n    }\n\n    function fillBinOpts(traceOut, groupName, binDir) {\n        // N.B. group traces that don't have a bingroup with themselves\n        var fallbackGroupName = traceOut.uid + '__' + binDir;\n        if(!groupName) groupName = fallbackGroupName;\n\n        var axType = getAxisType(traceOut, binDir);\n        var calendar = traceOut[binDir + 'calendar'] || '';\n        var binOpts = allBinOpts[groupName];\n        var needsNewItem = true;\n\n        if(binOpts) {\n            if(axType === binOpts.axType && calendar === binOpts.calendar) {\n                needsNewItem = false;\n                binOpts.traces.push(traceOut);\n                binOpts.dirs.push(binDir);\n            } else {\n                groupName = fallbackGroupName;\n\n                if(axType !== binOpts.axType) {\n                    Lib.warn([\n                        'Attempted to group the bins of trace', traceOut.index,\n                        'set on a', 'type:' + axType, 'axis',\n                        'with bins on', 'type:' + binOpts.axType, 'axis.'\n                    ].join(' '));\n                }\n                if(calendar !== binOpts.calendar) {\n                    // prohibit bingroup for traces using different calendar,\n                    // there's probably a way to make this work, but skip for now\n                    Lib.warn([\n                        'Attempted to group the bins of trace', traceOut.index,\n                        'set with a', calendar, 'calendar',\n                        'with bins',\n                        (binOpts.calendar ? 'on a ' + binOpts.calendar + ' calendar' : 'w/o a set calendar')\n                    ].join(' '));\n                }\n            }\n        }\n\n        if(needsNewItem) {\n            allBinOpts[groupName] = {\n                traces: [traceOut],\n                dirs: [binDir],\n                axType: axType,\n                calendar: traceOut[binDir + 'calendar'] || ''\n            };\n        }\n        traceOut['_' + binDir + 'bingroup'] = groupName;\n    }\n\n    for(i = 0; i < fullData.length; i++) {\n        traceOut = fullData[i];\n\n        if(traceIs(traceOut, 'histogram')) {\n            histTraces.push(traceOut);\n\n            // TODO: this shouldn't be relinked as it's only used within calc\n            // https://github.com/plotly/plotly.js/issues/749\n            delete traceOut._xautoBinFinished;\n            delete traceOut._yautoBinFinished;\n\n            // N.B. need to coerce *alignmentgroup* before *bingroup*, as traces\n            // in same alignmentgroup \"have to match\"\n            if(!traceIs(traceOut, '2dMap')) {\n                handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce);\n            }\n        }\n    }\n\n    var alignmentOpts = fullLayout._alignmentOpts || {};\n\n    // Look for traces that \"have to match\", that is:\n    // - 1d histogram traces on the same subplot with same orientation under barmode:stack,\n    // - 1d histogram traces on the same subplot with same orientation under barmode:group\n    // - 1d histogram traces on the same position axis with the same orientation\n    //   and the same *alignmentgroup* (coerced under barmode:group)\n    // - Once `stackgroup` gets implemented (see https://github.com/plotly/plotly.js/issues/3614),\n    //   traces within the same stackgroup will also \"have to match\"\n    for(i = 0; i < histTraces.length; i++) {\n        traceOut = histTraces[i];\n        groupName = '';\n\n        if(!traceIs(traceOut, '2dMap')) {\n            binDir = orientation2binDir(traceOut);\n\n            if(fullLayout.barmode === 'group' && traceOut.alignmentgroup) {\n                var pa = traceOut[binDir + 'axis'];\n                var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;\n                if((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {\n                    groupName = aGroupId;\n                }\n            }\n\n            if(!groupName && fullLayout.barmode !== 'overlay') {\n                groupName = (\n                    getAxisGroup(fullLayout, traceOut.xaxis) +\n                    getAxisGroup(fullLayout, traceOut.yaxis) +\n                    orientation2binDir(traceOut)\n                );\n            }\n        }\n\n        if(groupName) {\n            if(!mustMatchTracesLookup[groupName]) {\n                mustMatchTracesLookup[groupName] = [];\n            }\n            mustMatchTracesLookup[groupName].push(traceOut);\n        } else {\n            otherTracesList.push(traceOut);\n        }\n    }\n\n    // Setup binOpts for traces that have to match,\n    // if the traces have a valid bingroup, use that\n    // if not use axis+binDir groupName\n    for(groupName in mustMatchTracesLookup) {\n        traces = mustMatchTracesLookup[groupName];\n\n        // no need to 'force' anything when a single\n        // trace is detected as \"must match\"\n        if(traces.length === 1) {\n            otherTracesList.push(traces[0]);\n            continue;\n        }\n\n        var binGroupFound = false;\n        if(traces.length) {\n            traceOut = traces[0];\n            binGroupFound = coerce('bingroup');\n        }\n\n        groupName = binGroupFound || groupName;\n\n        for(i = 0; i < traces.length; i++) {\n            traceOut = traces[i];\n            var bingroupIn = traceOut._input.bingroup;\n            if(bingroupIn && bingroupIn !== groupName) {\n                Lib.warn([\n                    'Trace', traceOut.index, 'must match',\n                    'within bingroup', groupName + '.',\n                    'Ignoring its bingroup:', bingroupIn, 'setting.'\n                ].join(' '));\n            }\n            traceOut.bingroup = groupName;\n\n            // N.B. no need to worry about 2dMap case\n            // (where both bin direction are set in each trace)\n            // as 2dMap trace never \"have to match\"\n            fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));\n        }\n    }\n\n    // setup binOpts for traces that can but don't have to match,\n    // notice that these traces can be matched with traces that have to match\n    for(i = 0; i < otherTracesList.length; i++) {\n        traceOut = otherTracesList[i];\n\n        var binGroup = coerce('bingroup');\n\n        if(traceIs(traceOut, '2dMap')) {\n            for(k = 0; k < 2; k++) {\n                binDir = BINDIRECTIONS[k];\n                var binGroupInDir = coerce(binDir + 'bingroup',\n                    binGroup ? binGroup + '__' + binDir : null\n                );\n                fillBinOpts(traceOut, binGroupInDir, binDir);\n            }\n        } else {\n            fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));\n        }\n    }\n\n    // coerce bin attrs!\n    for(groupName in allBinOpts) {\n        var binOpts = allBinOpts[groupName];\n        traces = binOpts.traces;\n\n        for(j = 0; j < BINATTRS.length; j++) {\n            var attrSpec = BINATTRS[j];\n            var attr = attrSpec.name;\n            var aStr;\n            var autoVals;\n\n            // nbins(x|y) is moot if we have a size. This depends on\n            // nbins coming after size in binAttrs.\n            if(attr === 'nbins' && binOpts.sizeFound) continue;\n\n            for(i = 0; i < traces.length; i++) {\n                traceOut = traces[i];\n                binDir = binOpts.dirs[i];\n                aStr = attrSpec.aStr[binDir];\n\n                if(nestedProperty(traceOut._input, aStr).get() !== undefined) {\n                    binOpts[attr] = coerce(aStr);\n                    binOpts[attr + 'Found'] = true;\n                    break;\n                }\n\n                autoVals = (traceOut._autoBin || {})[binDir] || {};\n                if(autoVals[attr]) {\n                    // if this is the *first* autoval\n                    nestedProperty(traceOut, aStr).set(autoVals[attr]);\n                }\n            }\n\n            // start and end we need to coerce anyway, after having collected the\n            // first of each into binOpts, in case a trace wants to restrict its\n            // data to a certain range\n            if(attr === 'start' || attr === 'end') {\n                for(; i < traces.length; i++) {\n                    traceOut = traces[i];\n                    if(traceOut['_' + binDir + 'bingroup']) {\n                        autoVals = (traceOut._autoBin || {})[binDir] || {};\n                        coerce(aStr, autoVals[attr]);\n                    }\n                }\n            }\n\n            if(attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n                traceOut = traces[0];\n                binOpts[attr] = coerce(aStr);\n            }\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}