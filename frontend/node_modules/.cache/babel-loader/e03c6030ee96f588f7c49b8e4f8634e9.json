{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar svgSdf = require('svg-path-sdf');\n\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\n\nvar subTypes = require('../scatter/subtypes');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  if (trace.visible !== true) return opts;\n\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(gd, trace);\n    opts.textSel = convertTextSelection(gd, trace, trace.selected);\n    opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n  }\n\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(trace);\n    opts.markerSel = convertMarkerSelection(trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n    if (!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width * plotGlPixelRatio,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width * plotGlPixelRatio;\n    }\n\n    opts.line.dashes = dashes;\n  }\n\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n  }\n\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n  }\n\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n\n  return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  var texttemplate = trace.texttemplate;\n\n  if (texttemplate) {\n    optsOut.text = [];\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n\n    for (i = 0; i < N; i++) {\n      var d = {\n        i: i\n      };\n\n      var labels = trace._module.formatLabels(d, trace, fullLayout);\n\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, i);\n      var meta = trace._meta || {};\n      optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n    }\n  } else {\n    if (Array.isArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  } // pad text array with empty strings\n\n\n  if (Array.isArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n\n      case 'right':\n        optsOut.align.push('left');\n        break;\n\n      default:\n        optsOut.align.push(tp[1]);\n    }\n\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n\n  if (Array.isArray(tfc)) {\n    optsOut.color = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n\n  if (Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = (Lib.isTypedArray(tfs) ? tfs[i] : Array.isArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs) * plotGlPixelRatio;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs * plotGlPixelRatio,\n      family: tff\n    };\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerStyle(trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n  var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol); // prepare colors\n\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity) {\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n    if (!Array.isArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n\n    if (!Array.isArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        var symbol = optsIn.symbol[i];\n        isOpen = helpers.isOpenSymbol(symbol);\n      }\n\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n\n    optsOut.opacity = trace.opacity;\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n  } // prepare symbols\n\n\n  if (multiSymbol) {\n    optsOut.markers = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n    }\n  } else {\n    optsOut.marker = getSymbolSdf(optsIn.symbol);\n  } // prepare sizes\n\n\n  var sizeFactor = 1;\n  var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n  var s;\n\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    } // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n\n\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i];\n      }\n    } else {\n      s = optsIn.line.width;\n\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n\n  return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      texttemplate: trace.texttemplate,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n\n    optsOut = convertTextStyle(gd, optsIn);\n  }\n\n  return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n  var optsOut = {\n    capSize: target.width * 2 * plotGlPixelRatio,\n    lineWidth: target.thickness * plotGlPixelRatio,\n    color: target.color\n  };\n\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n\n  return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = helpers.isDotSymbol(symbol); // get symbol sdf from cache or generate it\n\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE);\n  }\n\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  } // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n\n\n  var hasNaN = false;\n\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round'; // fill gaps\n\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var count = positions.length / 2;\n  var out = {};\n\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n\n    var opts = trace['error_' + axLetter];\n\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i; // corresponds to textPointPosition from component.drawing\n\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = Array.isArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = Array.isArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/scattergl/convert.js"],"names":["isNumeric","require","svgSdf","rgba","Registry","Lib","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","helpers","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","appendArrayPointValue","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","plotGlPixelRatio","_context","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","isArrayOrTypedArray","opacity","mo","Array","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","fullLayout","_fullLayout","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","isArray","tfc","tfs","size","tff","family","optsOut","texttemplate","d3locale","_d3locale","N","Math","min","txt","d","labels","_module","formatLabels","pointValues","meta","_meta","push","texttemplateString","font","align","baseline","tp","split","fonti","isTypedArray","optsIn","multiSymbol","symbol","multiColor","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","isOpenSymbol","colors","borderColors","borderColor","markers","getSymbolSdf","sizeFactor","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","isDotSymbol","w","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","style","markerStyle","markerSelection","errorBarPositions","textPosition"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(gd, trace);\n        opts.textSel = convertTextSelection(gd, trace, trace.selected);\n        opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(trace);\n        opts.markerSel = convertMarkerSelection(trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n        if(!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width * plotGlPixelRatio,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width * plotGlPixelRatio;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var optsOut = {};\n    var i;\n    var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n\n    var texttemplate = trace.texttemplate;\n    if(texttemplate) {\n        optsOut.text = [];\n\n        var d3locale = fullLayout._d3locale;\n        var isArray = Array.isArray(texttemplate);\n        var N = isArray ? Math.min(texttemplate.length, count) : count;\n        var txt = isArray ?\n            function(i) { return texttemplate[i]; } :\n            function() { return texttemplate; };\n\n        for(i = 0; i < N; i++) {\n            var d = {i: i};\n            var labels = trace._module.formatLabels(d, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, i);\n            var meta = trace._meta || {};\n            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n        }\n    } else {\n        if(Array.isArray(trace.text) && trace.text.length < count) {\n            // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n            optsOut.text = trace.text.slice();\n        } else {\n            optsOut.text = trace.text;\n        }\n    }\n    // pad text array with empty strings\n    if(Array.isArray(optsOut.text)) {\n        for(i = optsOut.text.length; i < count; i++) {\n            optsOut.text[i] = '';\n        }\n    }\n\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(Array.isArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = (\n                Lib.isTypedArray(tfs) ? tfs[i] :\n                Array.isArray(tfs) ? (\n                    isNumeric(tfs[i]) ? tfs[i] : 0\n                ) : tfs\n            ) * plotGlPixelRatio;\n\n            fonti.family = Array.isArray(tff) ? tff[i] : tff;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {size: tfs * plotGlPixelRatio, family: tff};\n    }\n\n    return optsOut;\n}\n\n\nfunction convertMarkerStyle(trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n    var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity) {\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!Array.isArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!Array.isArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                var symbol = optsIn.symbol[i];\n                isOpen = helpers.isOpenSymbol(symbol);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n    }\n\n    // prepare symbols\n    if(multiSymbol) {\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n        }\n    } else {\n        optsOut.marker = getSymbolSdf(optsIn.symbol);\n    }\n\n    // prepare sizes\n    var sizeFactor = 1;\n    var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i];\n            }\n        } else {\n            s = optsIn.line.width;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            texttemplate: trace.texttemplate,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(gd, optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target, plotGlPixelRatio) {\n    var optsOut = {\n        capSize: target.width * 2 * plotGlPixelRatio,\n        lineWidth: target.thickness * plotGlPixelRatio,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = helpers.isDotSymbol(symbol);\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n    } else {\n        symbolPath = symbolFunc(SYMBOL_SIZE);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            } else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis);\n    var ya = AxisIDs.getFromId(gd, trace.yaxis);\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = Array.isArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = Array.isArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"]},"metadata":{},"sourceType":"script"}