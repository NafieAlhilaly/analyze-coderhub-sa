{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n/*\n * Given a 2D array as well as a basis in either direction, this function fills in the\n * 2D array using a combination of smoothing and extrapolation. This is rather important\n * for carpet plots since it's used for layout so that we can't simply omit or blank out\n * points. We need a reasonable guess so that the interpolation puts points somewhere\n * even if we were to somehow represent that the data was missing later on.\n *\n * input:\n *  - data: 2D array of arrays\n *  - a: array such that a.length === data[0].length\n *  - b: array such that b.length === data.length\n */\n\n\nmodule.exports = function smoothFill2dArray(data, a, b) {\n  var i, j, k;\n  var ip = [];\n  var jp = []; // var neighborCnts = [];\n\n  var ni = data[0].length;\n  var nj = data.length;\n\n  function avgSurrounding(i, j) {\n    // As a low-quality start, we can simply average surrounding points (in a not\n    // non-uniform grid aware manner):\n    var sum = 0.0;\n    var val;\n    var cnt = 0;\n\n    if (i > 0 && (val = data[j][i - 1]) !== undefined) {\n      cnt++;\n      sum += val;\n    }\n\n    if (i < ni - 1 && (val = data[j][i + 1]) !== undefined) {\n      cnt++;\n      sum += val;\n    }\n\n    if (j > 0 && (val = data[j - 1][i]) !== undefined) {\n      cnt++;\n      sum += val;\n    }\n\n    if (j < nj - 1 && (val = data[j + 1][i]) !== undefined) {\n      cnt++;\n      sum += val;\n    }\n\n    return sum / Math.max(1, cnt);\n  } // This loop iterates over all cells. Any cells that are null will be noted and those\n  // are the only points we will loop over and update via laplace's equation. Points with\n  // any neighbors will receive the average. If there are no neighboring points, then they\n  // will be set to zero. Also as we go, track the maximum magnitude so that we can scale\n  // our tolerance accordingly.\n\n\n  var dmax = 0.0;\n\n  for (i = 0; i < ni; i++) {\n    for (j = 0; j < nj; j++) {\n      if (data[j][i] === undefined) {\n        ip.push(i);\n        jp.push(j);\n        data[j][i] = avgSurrounding(i, j); // neighborCnts.push(result.neighbors);\n      }\n\n      dmax = Math.max(dmax, Math.abs(data[j][i]));\n    }\n  }\n\n  if (!ip.length) return data; // The tolerance doesn't need to be excessive. It's just for display positioning\n\n  var dxp, dxm, dap, dam, dbp, dbm, c, d, diff, reldiff, overrelaxation;\n  var tol = 1e-5;\n  var resid = 0;\n  var itermax = 100;\n  var iter = 0;\n  var n = ip.length;\n\n  do {\n    resid = 0; // Normally we'd loop in two dimensions, but not all points are blank and need\n    // an update, so we instead loop only over the points that were tabulated above\n\n    for (k = 0; k < n; k++) {\n      i = ip[k];\n      j = jp[k]; // neighborCnt = neighborCnts[k];\n      // Track a counter for how many contributions there are. We'll use this counter\n      // to average at the end, which reduces to laplace's equation with neumann boundary\n      // conditions on the first derivative (second derivative is zero so that we get\n      // a nice linear extrapolation at the boundaries).\n\n      var boundaryCnt = 0;\n      var newVal = 0;\n      var d0, d1, x0, x1, i0, j0;\n\n      if (i === 0) {\n        // If this lies along the i = 0 boundary, extrapolate from the two points\n        // to the right of this point. Note that the finite differences take into\n        // account non-uniform grid spacing:\n        i0 = Math.min(ni - 1, 2);\n        x0 = a[i0];\n        x1 = a[1];\n        d0 = data[j][i0];\n        d1 = data[j][1];\n        newVal += d1 + (d1 - d0) * (a[0] - x1) / (x1 - x0);\n        boundaryCnt++;\n      } else if (i === ni - 1) {\n        // If along the high i boundary, extrapolate from the two points to the\n        // left of this point\n        i0 = Math.max(0, ni - 3);\n        x0 = a[i0];\n        x1 = a[ni - 2];\n        d0 = data[j][i0];\n        d1 = data[j][ni - 2];\n        newVal += d1 + (d1 - d0) * (a[ni - 1] - x1) / (x1 - x0);\n        boundaryCnt++;\n      }\n\n      if ((i === 0 || i === ni - 1) && j > 0 && j < nj - 1) {\n        // If along the min(i) or max(i) boundaries, also smooth vertically as long\n        // as we're not in a corner. Note that the finite differences used here\n        // are also aware of nonuniform grid spacing:\n        dxp = b[j + 1] - b[j];\n        dxm = b[j] - b[j - 1];\n        newVal += (dxm * data[j + 1][i] + dxp * data[j - 1][i]) / (dxm + dxp);\n        boundaryCnt++;\n      }\n\n      if (j === 0) {\n        // If along the j = 0 boundary, extrpolate this point from the two points\n        // above it\n        j0 = Math.min(nj - 1, 2);\n        x0 = b[j0];\n        x1 = b[1];\n        d0 = data[j0][i];\n        d1 = data[1][i];\n        newVal += d1 + (d1 - d0) * (b[0] - x1) / (x1 - x0);\n        boundaryCnt++;\n      } else if (j === nj - 1) {\n        // Same for the max j boundary from the cells below it:\n        j0 = Math.max(0, nj - 3);\n        x0 = b[j0];\n        x1 = b[nj - 2];\n        d0 = data[j0][i];\n        d1 = data[nj - 2][i];\n        newVal += d1 + (d1 - d0) * (b[nj - 1] - x1) / (x1 - x0);\n        boundaryCnt++;\n      }\n\n      if ((j === 0 || j === nj - 1) && i > 0 && i < ni - 1) {\n        // Now average points to the left/right as long as not in a corner:\n        dxp = a[i + 1] - a[i];\n        dxm = a[i] - a[i - 1];\n        newVal += (dxm * data[j][i + 1] + dxp * data[j][i - 1]) / (dxm + dxp);\n        boundaryCnt++;\n      }\n\n      if (!boundaryCnt) {\n        // If none of the above conditions were triggered, then this is an interior\n        // point and we can just do a laplace equation update. As above, these differences\n        // are aware of nonuniform grid spacing:\n        dap = a[i + 1] - a[i];\n        dam = a[i] - a[i - 1];\n        dbp = b[j + 1] - b[j];\n        dbm = b[j] - b[j - 1]; // These are just some useful constants for the iteration, which is perfectly\n        // straightforward but a little long to derive from f_xx + f_yy = 0.\n\n        c = dap * dam * (dap + dam);\n        d = dbp * dbm * (dbp + dbm);\n        newVal = (c * (dbm * data[j + 1][i] + dbp * data[j - 1][i]) + d * (dam * data[j][i + 1] + dap * data[j][i - 1])) / (d * (dam + dap) + c * (dbm + dbp));\n      } else {\n        // If we did have contributions from the boundary conditions, then average\n        // the result from the various contributions:\n        newVal /= boundaryCnt;\n      } // Jacobi updates are ridiculously slow to converge, so this approach uses a\n      // Gauss-seidel iteration which is dramatically faster.\n\n\n      diff = newVal - data[j][i];\n      reldiff = diff / dmax;\n      resid += reldiff * reldiff; // Gauss-Seidel-ish iteration, omega chosen based on heuristics and some\n      // quick tests.\n      //\n      // NB: Don't overrelax the boundarie. Otherwise set an overrelaxation factor\n      // which is a little low but safely optimal-ish:\n\n      overrelaxation = boundaryCnt ? 0 : 0.85; // If there are four non-null neighbors, then we want a simple average without\n      // overrelaxation. If all the surrounding points are null, then we want the full\n      // overrelaxation\n      //\n      // Based on experiments, this actually seems to slow down convergence just a bit.\n      // I'll leave it here for reference in case this needs to be revisited, but\n      // it seems to work just fine without this.\n      // if (overrelaxation) overrelaxation *= (4 - neighborCnt) / 4;\n\n      data[j][i] += diff * (1 + overrelaxation);\n    }\n\n    resid = Math.sqrt(resid);\n  } while (iter++ < itermax && resid > tol);\n\n  Lib.log('Smoother converged to', resid, 'after', iter, 'iterations');\n  return data;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/carpet/smooth_fill_2d_array.js"],"names":["Lib","require","module","exports","smoothFill2dArray","data","a","b","i","j","k","ip","jp","ni","length","nj","avgSurrounding","sum","val","cnt","undefined","Math","max","dmax","push","abs","dxp","dxm","dap","dam","dbp","dbm","c","d","diff","reldiff","overrelaxation","tol","resid","itermax","iter","n","boundaryCnt","newVal","d0","d1","x0","x1","i0","j0","min","sqrt","log"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\n/*\n * Given a 2D array as well as a basis in either direction, this function fills in the\n * 2D array using a combination of smoothing and extrapolation. This is rather important\n * for carpet plots since it's used for layout so that we can't simply omit or blank out\n * points. We need a reasonable guess so that the interpolation puts points somewhere\n * even if we were to somehow represent that the data was missing later on.\n *\n * input:\n *  - data: 2D array of arrays\n *  - a: array such that a.length === data[0].length\n *  - b: array such that b.length === data.length\n */\nmodule.exports = function smoothFill2dArray(data, a, b) {\n    var i, j, k;\n    var ip = [];\n    var jp = [];\n    // var neighborCnts = [];\n\n    var ni = data[0].length;\n    var nj = data.length;\n\n    function avgSurrounding(i, j) {\n        // As a low-quality start, we can simply average surrounding points (in a not\n        // non-uniform grid aware manner):\n        var sum = 0.0;\n        var val;\n        var cnt = 0;\n        if(i > 0 && (val = data[j][i - 1]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(i < ni - 1 && (val = data[j][i + 1]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(j > 0 && (val = data[j - 1][i]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        if(j < nj - 1 && (val = data[j + 1][i]) !== undefined) {\n            cnt++;\n            sum += val;\n        }\n        return sum / Math.max(1, cnt);\n    }\n\n    // This loop iterates over all cells. Any cells that are null will be noted and those\n    // are the only points we will loop over and update via laplace's equation. Points with\n    // any neighbors will receive the average. If there are no neighboring points, then they\n    // will be set to zero. Also as we go, track the maximum magnitude so that we can scale\n    // our tolerance accordingly.\n    var dmax = 0.0;\n    for(i = 0; i < ni; i++) {\n        for(j = 0; j < nj; j++) {\n            if(data[j][i] === undefined) {\n                ip.push(i);\n                jp.push(j);\n\n                data[j][i] = avgSurrounding(i, j);\n                // neighborCnts.push(result.neighbors);\n            }\n            dmax = Math.max(dmax, Math.abs(data[j][i]));\n        }\n    }\n\n    if(!ip.length) return data;\n\n    // The tolerance doesn't need to be excessive. It's just for display positioning\n    var dxp, dxm, dap, dam, dbp, dbm, c, d, diff, reldiff, overrelaxation;\n    var tol = 1e-5;\n    var resid = 0;\n    var itermax = 100;\n    var iter = 0;\n    var n = ip.length;\n    do {\n        resid = 0;\n        // Normally we'd loop in two dimensions, but not all points are blank and need\n        // an update, so we instead loop only over the points that were tabulated above\n        for(k = 0; k < n; k++) {\n            i = ip[k];\n            j = jp[k];\n            // neighborCnt = neighborCnts[k];\n\n            // Track a counter for how many contributions there are. We'll use this counter\n            // to average at the end, which reduces to laplace's equation with neumann boundary\n            // conditions on the first derivative (second derivative is zero so that we get\n            // a nice linear extrapolation at the boundaries).\n            var boundaryCnt = 0;\n            var newVal = 0;\n\n            var d0, d1, x0, x1, i0, j0;\n            if(i === 0) {\n                // If this lies along the i = 0 boundary, extrapolate from the two points\n                // to the right of this point. Note that the finite differences take into\n                // account non-uniform grid spacing:\n                i0 = Math.min(ni - 1, 2);\n                x0 = a[i0];\n                x1 = a[1];\n                d0 = data[j][i0];\n                d1 = data[j][1];\n                newVal += d1 + (d1 - d0) * (a[0] - x1) / (x1 - x0);\n                boundaryCnt++;\n            } else if(i === ni - 1) {\n                // If along the high i boundary, extrapolate from the two points to the\n                // left of this point\n                i0 = Math.max(0, ni - 3);\n                x0 = a[i0];\n                x1 = a[ni - 2];\n                d0 = data[j][i0];\n                d1 = data[j][ni - 2];\n                newVal += d1 + (d1 - d0) * (a[ni - 1] - x1) / (x1 - x0);\n                boundaryCnt++;\n            }\n\n            if((i === 0 || i === ni - 1) && (j > 0 && j < nj - 1)) {\n                // If along the min(i) or max(i) boundaries, also smooth vertically as long\n                // as we're not in a corner. Note that the finite differences used here\n                // are also aware of nonuniform grid spacing:\n                dxp = b[j + 1] - b[j];\n                dxm = b[j] - b[j - 1];\n                newVal += (dxm * data[j + 1][i] + dxp * data[j - 1][i]) / (dxm + dxp);\n                boundaryCnt++;\n            }\n\n            if(j === 0) {\n                // If along the j = 0 boundary, extrpolate this point from the two points\n                // above it\n                j0 = Math.min(nj - 1, 2);\n                x0 = b[j0];\n                x1 = b[1];\n                d0 = data[j0][i];\n                d1 = data[1][i];\n                newVal += d1 + (d1 - d0) * (b[0] - x1) / (x1 - x0);\n                boundaryCnt++;\n            } else if(j === nj - 1) {\n                // Same for the max j boundary from the cells below it:\n                j0 = Math.max(0, nj - 3);\n                x0 = b[j0];\n                x1 = b[nj - 2];\n                d0 = data[j0][i];\n                d1 = data[nj - 2][i];\n                newVal += d1 + (d1 - d0) * (b[nj - 1] - x1) / (x1 - x0);\n                boundaryCnt++;\n            }\n\n            if((j === 0 || j === nj - 1) && (i > 0 && i < ni - 1)) {\n                // Now average points to the left/right as long as not in a corner:\n                dxp = a[i + 1] - a[i];\n                dxm = a[i] - a[i - 1];\n                newVal += (dxm * data[j][i + 1] + dxp * data[j][i - 1]) / (dxm + dxp);\n                boundaryCnt++;\n            }\n\n            if(!boundaryCnt) {\n                // If none of the above conditions were triggered, then this is an interior\n                // point and we can just do a laplace equation update. As above, these differences\n                // are aware of nonuniform grid spacing:\n                dap = a[i + 1] - a[i];\n                dam = a[i] - a[i - 1];\n                dbp = b[j + 1] - b[j];\n                dbm = b[j] - b[j - 1];\n\n                // These are just some useful constants for the iteration, which is perfectly\n                // straightforward but a little long to derive from f_xx + f_yy = 0.\n                c = dap * dam * (dap + dam);\n                d = dbp * dbm * (dbp + dbm);\n\n                newVal = (c * (dbm * data[j + 1][i] + dbp * data[j - 1][i]) +\n                          d * (dam * data[j][i + 1] + dap * data[j][i - 1])) /\n                          (d * (dam + dap) + c * (dbm + dbp));\n            } else {\n                // If we did have contributions from the boundary conditions, then average\n                // the result from the various contributions:\n                newVal /= boundaryCnt;\n            }\n\n            // Jacobi updates are ridiculously slow to converge, so this approach uses a\n            // Gauss-seidel iteration which is dramatically faster.\n            diff = newVal - data[j][i];\n            reldiff = diff / dmax;\n            resid += reldiff * reldiff;\n\n            // Gauss-Seidel-ish iteration, omega chosen based on heuristics and some\n            // quick tests.\n            //\n            // NB: Don't overrelax the boundarie. Otherwise set an overrelaxation factor\n            // which is a little low but safely optimal-ish:\n            overrelaxation = boundaryCnt ? 0 : 0.85;\n\n            // If there are four non-null neighbors, then we want a simple average without\n            // overrelaxation. If all the surrounding points are null, then we want the full\n            // overrelaxation\n            //\n            // Based on experiments, this actually seems to slow down convergence just a bit.\n            // I'll leave it here for reference in case this needs to be revisited, but\n            // it seems to work just fine without this.\n            // if (overrelaxation) overrelaxation *= (4 - neighborCnt) / 4;\n\n            data[j][i] += diff * (1 + overrelaxation);\n        }\n\n        resid = Math.sqrt(resid);\n    } while(iter++ < itermax && resid > tol);\n\n    Lib.log('Smoother converged to', resid, 'after', iter, 'iterations');\n\n    return data;\n};\n"]},"metadata":{},"sourceType":"script"}