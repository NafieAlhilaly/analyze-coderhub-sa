{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar constants = require('../../constants/numerical');\n\nvar ONEDAY = constants.ONEDAY;\nvar ONEWEEK = constants.ONEWEEK;\n/**\n * Return a validated dtick value for this axis\n *\n * @param {any} dtick: the candidate dtick. valid values are numbers and strings,\n *     and further constrained depending on the axis type.\n * @param {string} axType: the axis type\n */\n\nexports.dtick = function (dtick, axType) {\n  var isLog = axType === 'log';\n  var isDate = axType === 'date';\n  var isCat = axType === 'category';\n  var dtickDflt = isDate ? ONEDAY : 1;\n  if (!dtick) return dtickDflt;\n\n  if (isNumeric(dtick)) {\n    dtick = Number(dtick);\n    if (dtick <= 0) return dtickDflt;\n\n    if (isCat) {\n      // category dtick must be positive integers\n      return Math.max(1, Math.round(dtick));\n    }\n\n    if (isDate) {\n      // date dtick must be at least 0.1ms (our current precision)\n      return Math.max(0.1, dtick);\n    }\n\n    return dtick;\n  }\n\n  if (typeof dtick !== 'string' || !(isDate || isLog)) {\n    return dtickDflt;\n  }\n\n  var prefix = dtick.charAt(0);\n  var dtickNum = dtick.substr(1);\n  dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;\n\n  if (dtickNum <= 0 || !( // \"M<n>\" gives ticks every (integer) n months\n  isDate && prefix === 'M' && dtickNum === Math.round(dtickNum) || isLog && prefix === 'L' || isLog && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))) {\n    return dtickDflt;\n  }\n\n  return dtick;\n};\n/**\n * Return a validated tick0 for this axis\n *\n * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,\n *     further constrained depending on the axis type\n * @param {string} axType: the axis type\n * @param {string} calendar: for date axes, the calendar to validate/convert with\n * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,\n *     which do not support tick0 at all.\n */\n\n\nexports.tick0 = function (tick0, axType, calendar, dtick) {\n  if (axType === 'date') {\n    return Lib.cleanDate(tick0, Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0));\n  }\n\n  if (dtick === 'D1' || dtick === 'D2') {\n    // D1 and D2 modes ignore tick0 entirely\n    return undefined;\n  } // Aside from date axes, tick0 must be numeric\n\n\n  return isNumeric(tick0) ? Number(tick0) : 0;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/cartesian/clean_ticks.js"],"names":["isNumeric","require","Lib","constants","ONEDAY","ONEWEEK","exports","dtick","axType","isLog","isDate","isCat","dtickDflt","Number","Math","max","round","prefix","charAt","dtickNum","substr","tick0","calendar","cleanDate","dateTick0","undefined"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAD,CAAvB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,2BAAD,CAAvB;;AACA,IAAIG,MAAM,GAAGD,SAAS,CAACC,MAAvB;AACA,IAAIC,OAAO,GAAGF,SAAS,CAACE,OAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAC,OAAO,CAACC,KAAR,GAAgB,UAASA,KAAT,EAAgBC,MAAhB,EAAwB;AACpC,MAAIC,KAAK,GAAGD,MAAM,KAAK,KAAvB;AACA,MAAIE,MAAM,GAAGF,MAAM,KAAK,MAAxB;AACA,MAAIG,KAAK,GAAGH,MAAM,KAAK,UAAvB;AACA,MAAII,SAAS,GAAGF,MAAM,GAAGN,MAAH,GAAY,CAAlC;AAEA,MAAG,CAACG,KAAJ,EAAW,OAAOK,SAAP;;AAEX,MAAGZ,SAAS,CAACO,KAAD,CAAZ,EAAqB;AACjBA,IAAAA,KAAK,GAAGM,MAAM,CAACN,KAAD,CAAd;AACA,QAAGA,KAAK,IAAI,CAAZ,EAAe,OAAOK,SAAP;;AACf,QAAGD,KAAH,EAAU;AACN;AACA,aAAOG,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,KAAL,CAAWT,KAAX,CAAZ,CAAP;AACH;;AACD,QAAGG,MAAH,EAAW;AACP;AACA,aAAOI,IAAI,CAACC,GAAL,CAAS,GAAT,EAAcR,KAAd,CAAP;AACH;;AACD,WAAOA,KAAP;AACH;;AAED,MAAG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,EAAEG,MAAM,IAAID,KAAZ,CAAhC,EAAoD;AAChD,WAAOG,SAAP;AACH;;AAED,MAAIK,MAAM,GAAGV,KAAK,CAACW,MAAN,CAAa,CAAb,CAAb;AACA,MAAIC,QAAQ,GAAGZ,KAAK,CAACa,MAAN,CAAa,CAAb,CAAf;AACAD,EAAAA,QAAQ,GAAGnB,SAAS,CAACmB,QAAD,CAAT,GAAsBN,MAAM,CAACM,QAAD,CAA5B,GAAyC,CAApD;;AAEA,MAAIA,QAAQ,IAAI,CAAb,IAAmB,GACd;AACCT,EAAAA,MAAM,IAAIO,MAAM,KAAK,GAArB,IAA4BE,QAAQ,KAAKL,IAAI,CAACE,KAAL,CAAWG,QAAX,CAA1C,IAECV,KAAK,IAAIQ,MAAM,KAAK,GAFrB,IAICR,KAAK,IAAIQ,MAAM,KAAK,GAApB,KAA4BE,QAAQ,KAAK,CAAb,IAAkBA,QAAQ,KAAK,CAA3D,CANa,CAAtB,EAOO;AACH,WAAOP,SAAP;AACH;;AAED,SAAOL,KAAP;AACH,CA1CD;AA4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAD,OAAO,CAACe,KAAR,GAAgB,UAASA,KAAT,EAAgBb,MAAhB,EAAwBc,QAAxB,EAAkCf,KAAlC,EAAyC;AACrD,MAAGC,MAAM,KAAK,MAAd,EAAsB;AAClB,WAAON,GAAG,CAACqB,SAAJ,CAAcF,KAAd,EACHnB,GAAG,CAACsB,SAAJ,CAAcF,QAAd,EAAyBf,KAAK,GAAGF,OAAR,KAAoB,CAArB,GAA0B,CAA1B,GAA8B,CAAtD,CADG,CAAP;AAGH;;AACD,MAAGE,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,IAA/B,EAAqC;AACjC;AACA,WAAOkB,SAAP;AACH,GAToD,CAUrD;;;AACA,SAAOzB,SAAS,CAACqB,KAAD,CAAT,GAAmBR,MAAM,CAACQ,KAAD,CAAzB,GAAmC,CAA1C;AACH,CAZD","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar constants = require('../../constants/numerical');\nvar ONEDAY = constants.ONEDAY;\nvar ONEWEEK = constants.ONEWEEK;\n\n/**\n * Return a validated dtick value for this axis\n *\n * @param {any} dtick: the candidate dtick. valid values are numbers and strings,\n *     and further constrained depending on the axis type.\n * @param {string} axType: the axis type\n */\nexports.dtick = function(dtick, axType) {\n    var isLog = axType === 'log';\n    var isDate = axType === 'date';\n    var isCat = axType === 'category';\n    var dtickDflt = isDate ? ONEDAY : 1;\n\n    if(!dtick) return dtickDflt;\n\n    if(isNumeric(dtick)) {\n        dtick = Number(dtick);\n        if(dtick <= 0) return dtickDflt;\n        if(isCat) {\n            // category dtick must be positive integers\n            return Math.max(1, Math.round(dtick));\n        }\n        if(isDate) {\n            // date dtick must be at least 0.1ms (our current precision)\n            return Math.max(0.1, dtick);\n        }\n        return dtick;\n    }\n\n    if(typeof dtick !== 'string' || !(isDate || isLog)) {\n        return dtickDflt;\n    }\n\n    var prefix = dtick.charAt(0);\n    var dtickNum = dtick.substr(1);\n    dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;\n\n    if((dtickNum <= 0) || !(\n            // \"M<n>\" gives ticks every (integer) n months\n            (isDate && prefix === 'M' && dtickNum === Math.round(dtickNum)) ||\n            // \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\n            (isLog && prefix === 'L') ||\n            // \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\n            (isLog && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))\n        )) {\n        return dtickDflt;\n    }\n\n    return dtick;\n};\n\n/**\n * Return a validated tick0 for this axis\n *\n * @param {any} tick0: the candidate tick0. Valid values are numbers and strings,\n *     further constrained depending on the axis type\n * @param {string} axType: the axis type\n * @param {string} calendar: for date axes, the calendar to validate/convert with\n * @param {any} dtick: an already valid dtick. Only used for D1 and D2 log dticks,\n *     which do not support tick0 at all.\n */\nexports.tick0 = function(tick0, axType, calendar, dtick) {\n    if(axType === 'date') {\n        return Lib.cleanDate(tick0,\n            Lib.dateTick0(calendar, (dtick % ONEWEEK === 0) ? 1 : 0)\n        );\n    }\n    if(dtick === 'D1' || dtick === 'D2') {\n        // D1 and D2 modes ignore tick0 entirely\n        return undefined;\n    }\n    // Aside from date axes, tick0 must be numeric\n    return isNumeric(tick0) ? Number(tick0) : 0;\n};\n"]},"metadata":{},"sourceType":"script"}