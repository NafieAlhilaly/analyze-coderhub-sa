{"ast":null,"code":"'use strict';\n/* eslint-disable no-bitwise */\n\n/* eslint-disable consistent-return */\n\nvar str2arr = require('../common').str2arr;\n\nvar sliceEq = require('../common').sliceEq;\n\nvar readUInt16LE = require('../common').readUInt16LE;\n\nvar readUInt32LE = require('../common').readUInt32LE;\n\nvar exif = require('../exif_utils');\n\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\n\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n\n  return {\n    width: readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n  var bits = readUInt32LE(data, offset + 1);\n  return {\n    width: (bits & 0x3FFF) + 1,\n    height: (bits >> 14 & 0x3FFF) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nfunction parseVP8X(data, offset) {\n  return {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width: (data[offset + 6] << 16 | data[offset + 5] << 8 | data[offset + 4]) + 1,\n    height: (data[offset + 9] << offset | data[offset + 8] << 8 | data[offset + 7]) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nmodule.exports = function (data) {\n  if (data.length < 16) return; // check /^RIFF....WEBPVP8([ LX])$/ signature\n\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n  if (fileLength > data.length) return;\n\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length)); // exif is the last chunk we care about, stop after it\n\n      offset = Infinity;\n    }\n\n    offset += 8 + length;\n  }\n\n  if (!result) return;\n\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n\n  return result;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/probe-image-size/lib/parse_sync/webp.js"],"names":["str2arr","require","sliceEq","readUInt16LE","readUInt32LE","exif","SIG_RIFF","SIG_WEBP","parseVP8","data","offset","width","height","type","mime","wUnits","hUnits","parseVP8L","bits","parseVP8X","module","exports","length","result","exif_orientation","fileLength","header","String","fromCharCode","apply","slice","get_orientation","Infinity","orientation"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\n\n\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n\n  return {\n    width:  readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n\n  var bits = readUInt32LE(data, offset + 1);\n\n  return {\n    width:  (bits & 0x3FFF) + 1,\n    height: ((bits >> 14) & 0x3FFF) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8X(data, offset) {\n  return  {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width:  ((data[offset + 6] << 16) | (data[offset + 5] << 8) | data[offset + 4]) + 1,\n    height: ((data[offset + 9] << offset) | (data[offset + 8] << 8) | data[offset + 7]) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nmodule.exports = function (data) {\n  if (data.length < 16) return;\n\n  // check /^RIFF....WEBPVP8([ LX])$/ signature\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n\n  if (fileLength > data.length) return;\n\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length));\n\n      // exif is the last chunk we care about, stop after it\n      offset = Infinity;\n    }\n\n    offset += 8 + length;\n  }\n\n  if (!result) return;\n\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n\n  return result;\n};\n"]},"metadata":{},"sourceType":"script"}