{"ast":null,"code":"'use strict';\n\nvar mouseOffset = require('mouse-event-offset');\n\nvar hasHover = require('has-hover');\n\nvar supportsPassive = require('has-passive-events');\n\nvar removeElement = require('../../lib').removeElement;\n\nvar constants = require('../../plots/cartesian/constants');\n\nvar dragElement = module.exports = {};\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\n\nvar unhover = require('./unhover');\n\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */\n\ndragElement.init = function init(options) {\n  var gd = options.gd;\n  var numClicks = 1;\n  var doubleClickDelay = gd._context.doubleClickDelay;\n  var element = options.element;\n  var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;\n  if (!gd._mouseDownTime) gd._mouseDownTime = 0;\n  element.style.pointerEvents = 'all';\n  element.onmousedown = onStart;\n\n  if (!supportsPassive) {\n    element.ontouchstart = onStart;\n  } else {\n    if (element._ontouchstart) {\n      element.removeEventListener('touchstart', element._ontouchstart);\n    }\n\n    element._ontouchstart = onStart;\n    element.addEventListener('touchstart', onStart, {\n      passive: false\n    });\n  }\n\n  function _clampFn(dx, dy, minDrag) {\n    if (Math.abs(dx) < minDrag) dx = 0;\n    if (Math.abs(dy) < minDrag) dy = 0;\n    return [dx, dy];\n  }\n\n  var clampFn = options.clampFn || _clampFn;\n\n  function onStart(e) {\n    // make dragging and dragged into properties of gd\n    // so that others can look at and modify them\n    gd._dragged = false;\n    gd._dragging = true;\n    var offset = pointerOffset(e);\n    startX = offset[0];\n    startY = offset[1];\n    initialTarget = e.target;\n    initialEvent = e;\n    rightClick = e.buttons === 2 || e.ctrlKey; // fix Fx.hover for touch events\n\n    if (typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {\n      e.clientX = startX;\n      e.clientY = startY;\n    }\n\n    newMouseDownTime = new Date().getTime();\n\n    if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {\n      // in a click train\n      numClicks += 1;\n    } else {\n      // new click train\n      numClicks = 1;\n      gd._mouseDownTime = newMouseDownTime;\n    }\n\n    if (options.prepFn) options.prepFn(e, startX, startY);\n\n    if (hasHover && !rightClick) {\n      dragCover = coverSlip();\n      dragCover.style.cursor = window.getComputedStyle(element).cursor;\n    } else if (!hasHover) {\n      // document acts as a dragcover for mobile, bc we can't create dragcover dynamically\n      dragCover = document;\n      cursor = window.getComputedStyle(document.documentElement).cursor;\n      document.documentElement.style.cursor = window.getComputedStyle(element).cursor;\n    }\n\n    document.addEventListener('mouseup', onDone);\n    document.addEventListener('touchend', onDone);\n\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.addEventListener('mousemove', onMove);\n      document.addEventListener('touchmove', onMove, {\n        passive: false\n      });\n    }\n\n    return;\n  }\n\n  function onMove(e) {\n    e.preventDefault();\n    var offset = pointerOffset(e);\n    var minDrag = options.minDrag || constants.MINDRAG;\n    var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);\n    var dx = dxdy[0];\n    var dy = dxdy[1];\n\n    if (dx || dy) {\n      gd._dragged = true;\n      dragElement.unhover(gd, e);\n    }\n\n    if (gd._dragged && options.moveFn && !rightClick) {\n      gd._dragdata = {\n        element: element,\n        dx: dx,\n        dy: dy\n      };\n      options.moveFn(dx, dy);\n    }\n\n    return;\n  }\n\n  function onDone(e) {\n    delete gd._dragdata;\n\n    if (options.dragmode !== false) {\n      e.preventDefault();\n      document.removeEventListener('mousemove', onMove);\n      document.removeEventListener('touchmove', onMove);\n    }\n\n    document.removeEventListener('mouseup', onDone);\n    document.removeEventListener('touchend', onDone);\n\n    if (hasHover) {\n      removeElement(dragCover);\n    } else if (cursor) {\n      dragCover.documentElement.style.cursor = cursor;\n      cursor = null;\n    }\n\n    if (!gd._dragging) {\n      gd._dragged = false;\n      return;\n    }\n\n    gd._dragging = false; // don't count as a dblClick unless the mouseUp is also within\n    // the dblclick delay\n\n    if (new Date().getTime() - gd._mouseDownTime > doubleClickDelay) {\n      numClicks = Math.max(numClicks - 1, 1);\n    }\n\n    if (gd._dragged) {\n      if (options.doneFn) options.doneFn();\n    } else {\n      if (options.clickFn) options.clickFn(numClicks, initialEvent); // If we haven't dragged, this should be a click. But because of the\n      // coverSlip changing the element, the natural system might not generate one,\n      // so we need to make our own. But right clicks don't normally generate\n      // click events, only contextmenu events, which happen on mousedown.\n\n      if (!rightClick) {\n        var e2;\n\n        try {\n          e2 = new MouseEvent('click', e);\n        } catch (err) {\n          var offset = pointerOffset(e);\n          e2 = document.createEvent('MouseEvents');\n          e2.initMouseEvent('click', e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, offset[0], offset[1], e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);\n        }\n\n        initialTarget.dispatchEvent(e2);\n      }\n    }\n\n    gd._dragging = false;\n    gd._dragged = false;\n    return;\n  }\n};\n\nfunction coverSlip() {\n  var cover = document.createElement('div');\n  cover.className = 'dragcover';\n  var cStyle = cover.style;\n  cStyle.position = 'fixed';\n  cStyle.left = 0;\n  cStyle.right = 0;\n  cStyle.top = 0;\n  cStyle.bottom = 0;\n  cStyle.zIndex = 999999999;\n  cStyle.background = 'none';\n  document.body.appendChild(cover);\n  return cover;\n}\n\ndragElement.coverSlip = coverSlip;\n\nfunction pointerOffset(e) {\n  return mouseOffset(e.changedTouches ? e.changedTouches[0] : e, document.body);\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/dragelement/index.js"],"names":["mouseOffset","require","hasHover","supportsPassive","removeElement","constants","dragElement","module","exports","align","getCursor","unhover","wrapped","unhoverRaw","raw","init","options","gd","numClicks","doubleClickDelay","_context","element","startX","startY","newMouseDownTime","cursor","dragCover","initialEvent","initialTarget","rightClick","_mouseDownTime","style","pointerEvents","onmousedown","onStart","ontouchstart","_ontouchstart","removeEventListener","addEventListener","passive","_clampFn","dx","dy","minDrag","Math","abs","clampFn","e","_dragged","_dragging","offset","pointerOffset","target","buttons","ctrlKey","clientX","clientY","Date","getTime","prepFn","coverSlip","window","getComputedStyle","document","documentElement","onDone","dragmode","preventDefault","onMove","MINDRAG","dxdy","moveFn","_dragdata","max","doneFn","clickFn","e2","MouseEvent","err","createEvent","initMouseEvent","bubbles","cancelable","view","detail","screenX","screenY","altKey","shiftKey","metaKey","button","relatedTarget","dispatchEvent","cover","createElement","className","cStyle","position","left","right","top","bottom","zIndex","background","body","appendChild","changedTouches"],"mappings":"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","sourcesContent":["'use strict';\n\nvar mouseOffset = require('mouse-event-offset');\nvar hasHover = require('has-hover');\nvar supportsPassive = require('has-passive-events');\n\nvar removeElement = require('../../lib').removeElement;\nvar constants = require('../../plots/cartesian/constants');\n\nvar dragElement = module.exports = {};\n\ndragElement.align = require('./align');\ndragElement.getCursor = require('./cursor');\n\nvar unhover = require('./unhover');\ndragElement.unhover = unhover.wrapped;\ndragElement.unhoverRaw = unhover.raw;\n\n/**\n * Abstracts click & drag interactions\n *\n * During the interaction, a \"coverSlip\" element - a transparent\n * div covering the whole page - is created, which has two key effects:\n * - Lets you drag beyond the boundaries of the plot itself without\n *   dropping (but if you drag all the way out of the browser window the\n *   interaction will end)\n * - Freezes the cursor: whatever mouse cursor the drag element had when the\n *   interaction started gets copied to the coverSlip for use until mouseup\n *\n * If the user executes a drag bigger than MINDRAG, callbacks will fire as:\n *      prepFn, moveFn (1 or more times), doneFn\n * If the user does not drag enough, prepFn and clickFn will fire.\n *\n * Note: If you cancel contextmenu, clickFn will fire even with a right click\n * (unlike native events) so you'll get a `plotly_click` event. Cancel context eg:\n *    gd.addEventListener('contextmenu', function(e) { e.preventDefault(); });\n * TODO: we should probably turn this into a `config` parameter, so we can fix it\n * such that if you *don't* cancel contextmenu, we can prevent partial drags, which\n * put you in a weird state.\n *\n * If the user clicks multiple times quickly, clickFn will fire each time\n * but numClicks will increase to help you recognize doubleclicks.\n *\n * @param {object} options with keys:\n *      element (required) the DOM element to drag\n *      prepFn (optional) function(event, startX, startY)\n *          executed on mousedown\n *          startX and startY are the clientX and clientY pixel position\n *          of the mousedown event\n *      moveFn (optional) function(dx, dy)\n *          executed on move, ONLY after we've exceeded MINDRAG\n *          (we keep executing moveFn if you move back to where you started)\n *          dx and dy are the net pixel offset of the drag,\n *          dragged is true/false, has the mouse moved enough to\n *          constitute a drag\n *      doneFn (optional) function(e)\n *          executed on mouseup, ONLY if we exceeded MINDRAG (so you can be\n *          sure that moveFn has been called at least once)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mouseup event\n *      clickFn (optional) function(numClicks, e)\n *          executed on mouseup if we have NOT exceeded MINDRAG (ie moveFn\n *          has not been called at all)\n *          numClicks is how many clicks we've registered within\n *          a doubleclick time\n *          e is the original mousedown event\n *      clampFn (optional, function(dx, dy) return [dx2, dy2])\n *          Provide custom clamping function for small displacements.\n *          By default, clamping is done using `minDrag` to x and y displacements\n *          independently.\n */\ndragElement.init = function init(options) {\n    var gd = options.gd;\n    var numClicks = 1;\n    var doubleClickDelay = gd._context.doubleClickDelay;\n    var element = options.element;\n\n    var startX,\n        startY,\n        newMouseDownTime,\n        cursor,\n        dragCover,\n        initialEvent,\n        initialTarget,\n        rightClick;\n\n    if(!gd._mouseDownTime) gd._mouseDownTime = 0;\n\n    element.style.pointerEvents = 'all';\n\n    element.onmousedown = onStart;\n\n    if(!supportsPassive) {\n        element.ontouchstart = onStart;\n    } else {\n        if(element._ontouchstart) {\n            element.removeEventListener('touchstart', element._ontouchstart);\n        }\n        element._ontouchstart = onStart;\n        element.addEventListener('touchstart', onStart, {passive: false});\n    }\n\n    function _clampFn(dx, dy, minDrag) {\n        if(Math.abs(dx) < minDrag) dx = 0;\n        if(Math.abs(dy) < minDrag) dy = 0;\n        return [dx, dy];\n    }\n\n    var clampFn = options.clampFn || _clampFn;\n\n    function onStart(e) {\n        // make dragging and dragged into properties of gd\n        // so that others can look at and modify them\n        gd._dragged = false;\n        gd._dragging = true;\n        var offset = pointerOffset(e);\n        startX = offset[0];\n        startY = offset[1];\n        initialTarget = e.target;\n        initialEvent = e;\n        rightClick = e.buttons === 2 || e.ctrlKey;\n\n        // fix Fx.hover for touch events\n        if(typeof e.clientX === 'undefined' && typeof e.clientY === 'undefined') {\n            e.clientX = startX;\n            e.clientY = startY;\n        }\n\n        newMouseDownTime = (new Date()).getTime();\n        if(newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {\n            // in a click train\n            numClicks += 1;\n        } else {\n            // new click train\n            numClicks = 1;\n            gd._mouseDownTime = newMouseDownTime;\n        }\n\n        if(options.prepFn) options.prepFn(e, startX, startY);\n\n        if(hasHover && !rightClick) {\n            dragCover = coverSlip();\n            dragCover.style.cursor = window.getComputedStyle(element).cursor;\n        } else if(!hasHover) {\n            // document acts as a dragcover for mobile, bc we can't create dragcover dynamically\n            dragCover = document;\n            cursor = window.getComputedStyle(document.documentElement).cursor;\n            document.documentElement.style.cursor = window.getComputedStyle(element).cursor;\n        }\n\n        document.addEventListener('mouseup', onDone);\n        document.addEventListener('touchend', onDone);\n\n        if(options.dragmode !== false) {\n            e.preventDefault();\n            document.addEventListener('mousemove', onMove);\n            document.addEventListener('touchmove', onMove, {passive: false});\n        }\n\n        return;\n    }\n\n    function onMove(e) {\n        e.preventDefault();\n\n        var offset = pointerOffset(e);\n        var minDrag = options.minDrag || constants.MINDRAG;\n        var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);\n        var dx = dxdy[0];\n        var dy = dxdy[1];\n\n        if(dx || dy) {\n            gd._dragged = true;\n            dragElement.unhover(gd, e);\n        }\n\n        if(gd._dragged && options.moveFn && !rightClick) {\n            gd._dragdata = {\n                element: element,\n                dx: dx,\n                dy: dy\n            };\n            options.moveFn(dx, dy);\n        }\n\n        return;\n    }\n\n    function onDone(e) {\n        delete gd._dragdata;\n\n        if(options.dragmode !== false) {\n            e.preventDefault();\n            document.removeEventListener('mousemove', onMove);\n            document.removeEventListener('touchmove', onMove);\n        }\n\n        document.removeEventListener('mouseup', onDone);\n        document.removeEventListener('touchend', onDone);\n\n        if(hasHover) {\n            removeElement(dragCover);\n        } else if(cursor) {\n            dragCover.documentElement.style.cursor = cursor;\n            cursor = null;\n        }\n\n        if(!gd._dragging) {\n            gd._dragged = false;\n            return;\n        }\n        gd._dragging = false;\n\n        // don't count as a dblClick unless the mouseUp is also within\n        // the dblclick delay\n        if((new Date()).getTime() - gd._mouseDownTime > doubleClickDelay) {\n            numClicks = Math.max(numClicks - 1, 1);\n        }\n\n        if(gd._dragged) {\n            if(options.doneFn) options.doneFn();\n        } else {\n            if(options.clickFn) options.clickFn(numClicks, initialEvent);\n\n            // If we haven't dragged, this should be a click. But because of the\n            // coverSlip changing the element, the natural system might not generate one,\n            // so we need to make our own. But right clicks don't normally generate\n            // click events, only contextmenu events, which happen on mousedown.\n            if(!rightClick) {\n                var e2;\n\n                try {\n                    e2 = new MouseEvent('click', e);\n                } catch(err) {\n                    var offset = pointerOffset(e);\n                    e2 = document.createEvent('MouseEvents');\n                    e2.initMouseEvent('click',\n                        e.bubbles, e.cancelable,\n                        e.view, e.detail,\n                        e.screenX, e.screenY,\n                        offset[0], offset[1],\n                        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n                        e.button, e.relatedTarget);\n                }\n\n                initialTarget.dispatchEvent(e2);\n            }\n        }\n\n        gd._dragging = false;\n        gd._dragged = false;\n        return;\n    }\n};\n\nfunction coverSlip() {\n    var cover = document.createElement('div');\n\n    cover.className = 'dragcover';\n    var cStyle = cover.style;\n    cStyle.position = 'fixed';\n    cStyle.left = 0;\n    cStyle.right = 0;\n    cStyle.top = 0;\n    cStyle.bottom = 0;\n    cStyle.zIndex = 999999999;\n    cStyle.background = 'none';\n\n    document.body.appendChild(cover);\n\n    return cover;\n}\n\ndragElement.coverSlip = coverSlip;\n\nfunction pointerOffset(e) {\n    return mouseOffset(\n        e.changedTouches ? e.changedTouches[0] : e,\n        document.body\n    );\n}\n"]},"metadata":{},"sourceType":"script"}