{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\nfunction Epsilon(eps) {\n  if (typeof eps !== 'number') eps = 0.0000000001; // sane default? sure why not\n\n  var my = {\n    epsilon: function epsilon(v) {\n      if (typeof v === 'number') eps = v;\n      return eps;\n    },\n    pointAboveOrOnLine: function pointAboveOrOnLine(pt, left, right) {\n      var Ax = left[0];\n      var Ay = left[1];\n      var Bx = right[0];\n      var By = right[1];\n      var Cx = pt[0];\n      var Cy = pt[1];\n      return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n    },\n    pointBetween: function pointBetween(p, left, right) {\n      // p must be collinear with left->right\n      // returns false if p == left, p == right, or left == right\n      var d_py_ly = p[1] - left[1];\n      var d_rx_lx = right[0] - left[0];\n      var d_px_lx = p[0] - left[0];\n      var d_ry_ly = right[1] - left[1];\n      var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly; // if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n      // if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\n      if (dot < eps) return false;\n      var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly; // if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n      // therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\n      if (dot - sqlen > -eps) return false;\n      return true;\n    },\n    pointsSameX: function pointsSameX(p1, p2) {\n      return Math.abs(p1[0] - p2[0]) < eps;\n    },\n    pointsSameY: function pointsSameY(p1, p2) {\n      return Math.abs(p1[1] - p2[1]) < eps;\n    },\n    pointsSame: function pointsSame(p1, p2) {\n      return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n    },\n    pointsCompare: function pointsCompare(p1, p2) {\n      // returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n      if (my.pointsSameX(p1, p2)) return my.pointsSameY(p1, p2) ? 0 : p1[1] < p2[1] ? -1 : 1;\n      return p1[0] < p2[0] ? -1 : 1;\n    },\n    pointsCollinear: function pointsCollinear(pt1, pt2, pt3) {\n      // does pt1->pt2->pt3 make a straight line?\n      // essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n      // if slopes are equal, then they must be collinear, because they share pt2\n      var dx1 = pt1[0] - pt2[0];\n      var dy1 = pt1[1] - pt2[1];\n      var dx2 = pt2[0] - pt3[0];\n      var dy2 = pt2[1] - pt3[1];\n      return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n    },\n    linesIntersect: function linesIntersect(a0, a1, b0, b1) {\n      // returns false if the lines are coincident (e.g., parallel or on top of each other)\n      //\n      // returns an object if the lines intersect:\n      //   {\n      //     pt: [x, y],    where the intersection point is at\n      //     alongA: where intersection point is along A,\n      //     alongB: where intersection point is along B\n      //   }\n      //\n      //  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n      //\n      //  with the following meaning:\n      //\n      //    -2   intersection point is before segment's first point\n      //    -1   intersection point is directly on segment's first point\n      //     0   intersection point is between segment's first and second points (exclusive)\n      //     1   intersection point is directly on segment's second point\n      //     2   intersection point is after segment's second point\n      var adx = a1[0] - a0[0];\n      var ady = a1[1] - a0[1];\n      var bdx = b1[0] - b0[0];\n      var bdy = b1[1] - b0[1];\n      var axb = adx * bdy - ady * bdx;\n      if (Math.abs(axb) < eps) return false; // lines are coincident\n\n      var dx = a0[0] - b0[0];\n      var dy = a0[1] - b0[1];\n      var A = (bdx * dy - bdy * dx) / axb;\n      var B = (adx * dy - ady * dx) / axb;\n      var ret = {\n        alongA: 0,\n        alongB: 0,\n        pt: [a0[0] + A * adx, a0[1] + A * ady]\n      }; // categorize where intersection point is along A and B\n\n      if (A <= -eps) ret.alongA = -2;else if (A < eps) ret.alongA = -1;else if (A - 1 <= -eps) ret.alongA = 0;else if (A - 1 < eps) ret.alongA = 1;else ret.alongA = 2;\n      if (B <= -eps) ret.alongB = -2;else if (B < eps) ret.alongB = -1;else if (B - 1 <= -eps) ret.alongB = 0;else if (B - 1 < eps) ret.alongB = 1;else ret.alongB = 2;\n      return ret;\n    },\n    pointInsideRegion: function pointInsideRegion(pt, region) {\n      var x = pt[0];\n      var y = pt[1];\n      var last_x = region[region.length - 1][0];\n      var last_y = region[region.length - 1][1];\n      var inside = false;\n\n      for (var i = 0; i < region.length; i++) {\n        var curr_x = region[i][0];\n        var curr_y = region[i][1]; // if y is between curr_y and last_y, and\n        // x is to the right of the boundary created by the line\n\n        if (curr_y - y > eps != last_y - y > eps && (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps) inside = !inside;\n        last_x = curr_x;\n        last_y = curr_y;\n      }\n\n      return inside;\n    }\n  };\n  return my;\n}\n\nmodule.exports = Epsilon;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/polybooljs/lib/epsilon.js"],"names":["Epsilon","eps","my","epsilon","v","pointAboveOrOnLine","pt","left","right","Ax","Ay","Bx","By","Cx","Cy","pointBetween","p","d_py_ly","d_rx_lx","d_px_lx","d_ry_ly","dot","sqlen","pointsSameX","p1","p2","Math","abs","pointsSameY","pointsSame","pointsCompare","pointsCollinear","pt1","pt2","pt3","dx1","dy1","dx2","dy2","linesIntersect","a0","a1","b0","b1","adx","ady","bdx","bdy","axb","dx","dy","A","B","ret","alongA","alongB","pointInsideRegion","region","x","y","last_x","length","last_y","inside","i","curr_x","curr_y","module","exports"],"mappings":"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","sourcesContent":["// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\n\nfunction Epsilon(eps){\n\tif (typeof eps !== 'number')\n\t\teps = 0.0000000001; // sane default? sure why not\n\tvar my = {\n\t\tepsilon: function(v){\n\t\t\tif (typeof v === 'number')\n\t\t\t\teps = v;\n\t\t\treturn eps;\n\t\t},\n\t\tpointAboveOrOnLine: function(pt, left, right){\n\t\t\tvar Ax = left[0];\n\t\t\tvar Ay = left[1];\n\t\t\tvar Bx = right[0];\n\t\t\tvar By = right[1];\n\t\t\tvar Cx = pt[0];\n\t\t\tvar Cy = pt[1];\n\t\t\treturn (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n\t\t},\n\t\tpointBetween: function(p, left, right){\n\t\t\t// p must be collinear with left->right\n\t\t\t// returns false if p == left, p == right, or left == right\n\t\t\tvar d_py_ly = p[1] - left[1];\n\t\t\tvar d_rx_lx = right[0] - left[0];\n\t\t\tvar d_px_lx = p[0] - left[0];\n\t\t\tvar d_ry_ly = right[1] - left[1];\n\n\t\t\tvar dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;\n\t\t\t// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n\t\t\t// if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\t\t\tif (dot < eps)\n\t\t\t\treturn false;\n\n\t\t\tvar sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;\n\t\t\t// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n\t\t\t// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\t\t\tif (dot - sqlen > -eps)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t},\n\t\tpointsSameX: function(p1, p2){\n\t\t\treturn Math.abs(p1[0] - p2[0]) < eps;\n\t\t},\n\t\tpointsSameY: function(p1, p2){\n\t\t\treturn Math.abs(p1[1] - p2[1]) < eps;\n\t\t},\n\t\tpointsSame: function(p1, p2){\n\t\t\treturn my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n\t\t},\n\t\tpointsCompare: function(p1, p2){\n\t\t\t// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n\t\t\tif (my.pointsSameX(p1, p2))\n\t\t\t\treturn my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);\n\t\t\treturn p1[0] < p2[0] ? -1 : 1;\n\t\t},\n\t\tpointsCollinear: function(pt1, pt2, pt3){\n\t\t\t// does pt1->pt2->pt3 make a straight line?\n\t\t\t// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n\t\t\t// if slopes are equal, then they must be collinear, because they share pt2\n\t\t\tvar dx1 = pt1[0] - pt2[0];\n\t\t\tvar dy1 = pt1[1] - pt2[1];\n\t\t\tvar dx2 = pt2[0] - pt3[0];\n\t\t\tvar dy2 = pt2[1] - pt3[1];\n\t\t\treturn Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n\t\t},\n\t\tlinesIntersect: function(a0, a1, b0, b1){\n\t\t\t// returns false if the lines are coincident (e.g., parallel or on top of each other)\n\t\t\t//\n\t\t\t// returns an object if the lines intersect:\n\t\t\t//   {\n\t\t\t//     pt: [x, y],    where the intersection point is at\n\t\t\t//     alongA: where intersection point is along A,\n\t\t\t//     alongB: where intersection point is along B\n\t\t\t//   }\n\t\t\t//\n\t\t\t//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n\t\t\t//\n\t\t\t//  with the following meaning:\n\t\t\t//\n\t\t\t//    -2   intersection point is before segment's first point\n\t\t\t//    -1   intersection point is directly on segment's first point\n\t\t\t//     0   intersection point is between segment's first and second points (exclusive)\n\t\t\t//     1   intersection point is directly on segment's second point\n\t\t\t//     2   intersection point is after segment's second point\n\t\t\tvar adx = a1[0] - a0[0];\n\t\t\tvar ady = a1[1] - a0[1];\n\t\t\tvar bdx = b1[0] - b0[0];\n\t\t\tvar bdy = b1[1] - b0[1];\n\n\t\t\tvar axb = adx * bdy - ady * bdx;\n\t\t\tif (Math.abs(axb) < eps)\n\t\t\t\treturn false; // lines are coincident\n\n\t\t\tvar dx = a0[0] - b0[0];\n\t\t\tvar dy = a0[1] - b0[1];\n\n\t\t\tvar A = (bdx * dy - bdy * dx) / axb;\n\t\t\tvar B = (adx * dy - ady * dx) / axb;\n\n\t\t\tvar ret = {\n\t\t\t\talongA: 0,\n\t\t\t\talongB: 0,\n\t\t\t\tpt: [\n\t\t\t\t\ta0[0] + A * adx,\n\t\t\t\t\ta0[1] + A * ady\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// categorize where intersection point is along A and B\n\n\t\t\tif (A <= -eps)\n\t\t\t\tret.alongA = -2;\n\t\t\telse if (A < eps)\n\t\t\t\tret.alongA = -1;\n\t\t\telse if (A - 1 <= -eps)\n\t\t\t\tret.alongA = 0;\n\t\t\telse if (A - 1 < eps)\n\t\t\t\tret.alongA = 1;\n\t\t\telse\n\t\t\t\tret.alongA = 2;\n\n\t\t\tif (B <= -eps)\n\t\t\t\tret.alongB = -2;\n\t\t\telse if (B < eps)\n\t\t\t\tret.alongB = -1;\n\t\t\telse if (B - 1 <= -eps)\n\t\t\t\tret.alongB = 0;\n\t\t\telse if (B - 1 < eps)\n\t\t\t\tret.alongB = 1;\n\t\t\telse\n\t\t\t\tret.alongB = 2;\n\n\t\t\treturn ret;\n\t\t},\n\t\tpointInsideRegion: function(pt, region){\n\t\t\tvar x = pt[0];\n\t\t\tvar y = pt[1];\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar inside = false;\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\n\t\t\t\t// if y is between curr_y and last_y, and\n\t\t\t\t// x is to the right of the boundary created by the line\n\t\t\t\tif ((curr_y - y > eps) != (last_y - y > eps) &&\n\t\t\t\t\t(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)\n\t\t\t\t\tinside = !inside\n\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\treturn inside;\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = Epsilon;\n"]},"metadata":{},"sourceType":"script"}