{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// this is the core work-horse\n//\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog) {\n  // selfIntersection is true/false depending on the phase of the overall algorithm\n  //\n  // segment creation\n  //\n  function segmentNew(start, end) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: null,\n        // is there fill above us?\n        below: null // is there fill below us?\n\n      },\n      otherFill: null\n    };\n  }\n\n  function segmentCopy(start, end, seg) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: seg.myFill.above,\n        below: seg.myFill.below\n      },\n      otherFill: null\n    };\n  } //\n  // event logic\n  //\n\n\n  var event_root = LinkedList.create();\n\n  function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {\n    // compare the selected points first\n    var comp = eps.pointsCompare(p1_1, p2_1);\n    if (comp !== 0) return comp; // the selected points are the same\n\n    if (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n      return 0; // then the segments are equal\n\n    if (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n      return p1_isStart ? 1 : -1; // favor the one that isn't the start\n    // otherwise, we'll have to calculate which one is below the other manually\n\n    return eps.pointAboveOrOnLine(p1_2, p2_isStart ? p2_1 : p2_2, // order matters\n    p2_isStart ? p2_2 : p2_1) ? 1 : -1;\n  }\n\n  function eventAdd(ev, other_pt) {\n    event_root.insertBefore(ev, function (here) {\n      // should ev be inserted before here?\n      var comp = eventCompare(ev.isStart, ev.pt, other_pt, here.isStart, here.pt, here.other.pt);\n      return comp < 0;\n    });\n  }\n\n  function eventAddSegmentStart(seg, primary) {\n    var ev_start = LinkedList.node({\n      isStart: true,\n      pt: seg.start,\n      seg: seg,\n      primary: primary,\n      other: null,\n      status: null\n    });\n    eventAdd(ev_start, seg.end);\n    return ev_start;\n  }\n\n  function eventAddSegmentEnd(ev_start, seg, primary) {\n    var ev_end = LinkedList.node({\n      isStart: false,\n      pt: seg.end,\n      seg: seg,\n      primary: primary,\n      other: ev_start,\n      status: null\n    });\n    ev_start.other = ev_end;\n    eventAdd(ev_end, ev_start.pt);\n  }\n\n  function eventAddSegment(seg, primary) {\n    var ev_start = eventAddSegmentStart(seg, primary);\n    eventAddSegmentEnd(ev_start, seg, primary);\n    return ev_start;\n  }\n\n  function eventUpdateEnd(ev, end) {\n    // slides an end backwards\n    //   (start)------------(end)    to:\n    //   (start)---(end)\n    if (buildLog) buildLog.segmentChop(ev.seg, end);\n    ev.other.remove();\n    ev.seg.end = end;\n    ev.other.pt = end;\n    eventAdd(ev.other, ev.pt);\n  }\n\n  function eventDivide(ev, pt) {\n    var ns = segmentCopy(pt, ev.seg.end, ev.seg);\n    eventUpdateEnd(ev, pt);\n    return eventAddSegment(ns, ev.primary);\n  }\n\n  function calculate(primaryPolyInverted, secondaryPolyInverted) {\n    // if selfIntersection is true then there is no secondary polygon, so that isn't used\n    //\n    // status logic\n    //\n    var status_root = LinkedList.create();\n\n    function statusCompare(ev1, ev2) {\n      var a1 = ev1.seg.start;\n      var a2 = ev1.seg.end;\n      var b1 = ev2.seg.start;\n      var b2 = ev2.seg.end;\n\n      if (eps.pointsCollinear(a1, b1, b2)) {\n        if (eps.pointsCollinear(a2, b1, b2)) return 1; //eventCompare(true, a1, a2, true, b1, b2);\n\n        return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n      }\n\n      return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n    }\n\n    function statusFindSurrounding(ev) {\n      return status_root.findTransition(function (here) {\n        var comp = statusCompare(ev, here.ev);\n        return comp > 0;\n      });\n    }\n\n    function checkIntersection(ev1, ev2) {\n      // returns the segment equal to ev1, or false if nothing equal\n      var seg1 = ev1.seg;\n      var seg2 = ev2.seg;\n      var a1 = seg1.start;\n      var a2 = seg1.end;\n      var b1 = seg2.start;\n      var b2 = seg2.end;\n      if (buildLog) buildLog.checkIntersection(seg1, seg2);\n      var i = eps.linesIntersect(a1, a2, b1, b2);\n\n      if (i === false) {\n        // segments are parallel or coincident\n        // if points aren't collinear, then the segments are parallel, so no intersections\n        if (!eps.pointsCollinear(a1, a2, b1)) return false; // otherwise, segments are on top of each other somehow (aka coincident)\n\n        if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1)) return false; // segments touch at endpoints... no intersection\n\n        var a1_equ_b1 = eps.pointsSame(a1, b1);\n        var a2_equ_b2 = eps.pointsSame(a2, b2);\n        if (a1_equ_b1 && a2_equ_b2) return ev2; // segments are exactly equal\n\n        var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n        var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2); // handy for debugging:\n        // buildLog.log({\n        //\ta1_equ_b1: a1_equ_b1,\n        //\ta2_equ_b2: a2_equ_b2,\n        //\ta1_between: a1_between,\n        //\ta2_between: a2_between\n        // });\n\n        if (a1_equ_b1) {\n          if (a2_between) {\n            //  (a1)---(a2)\n            //  (b1)----------(b2)\n            eventDivide(ev2, a2);\n          } else {\n            //  (a1)----------(a2)\n            //  (b1)---(b2)\n            eventDivide(ev1, b2);\n          }\n\n          return ev2;\n        } else if (a1_between) {\n          if (!a2_equ_b2) {\n            // make a2 equal to b2\n            if (a2_between) {\n              //         (a1)---(a2)\n              //  (b1)-----------------(b2)\n              eventDivide(ev2, a2);\n            } else {\n              //         (a1)----------(a2)\n              //  (b1)----------(b2)\n              eventDivide(ev1, b2);\n            }\n          } //         (a1)---(a2)\n          //  (b1)----------(b2)\n\n\n          eventDivide(ev2, a1);\n        }\n      } else {\n        // otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n        // is A divided between its endpoints? (exclusive)\n        if (i.alongA === 0) {\n          if (i.alongB === -1) // yes, at exactly b1\n            eventDivide(ev1, b1);else if (i.alongB === 0) // yes, somewhere between B's endpoints\n            eventDivide(ev1, i.pt);else if (i.alongB === 1) // yes, at exactly b2\n            eventDivide(ev1, b2);\n        } // is B divided between its endpoints? (exclusive)\n\n\n        if (i.alongB === 0) {\n          if (i.alongA === -1) // yes, at exactly a1\n            eventDivide(ev2, a1);else if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n            eventDivide(ev2, i.pt);else if (i.alongA === 1) // yes, at exactly a2\n            eventDivide(ev2, a2);\n        }\n      }\n\n      return false;\n    } //\n    // main event loop\n    //\n\n\n    var segments = [];\n\n    while (!event_root.isEmpty()) {\n      var ev = event_root.getHead();\n      if (buildLog) buildLog.vert(ev.pt[0]);\n\n      if (ev.isStart) {\n        if (buildLog) buildLog.segmentNew(ev.seg, ev.primary);\n        var surrounding = statusFindSurrounding(ev);\n        var above = surrounding.before ? surrounding.before.ev : null;\n        var below = surrounding.after ? surrounding.after.ev : null;\n\n        if (buildLog) {\n          buildLog.tempStatus(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        }\n\n        function checkBothIntersections() {\n          if (above) {\n            var eve = checkIntersection(ev, above);\n            if (eve) return eve;\n          }\n\n          if (below) return checkIntersection(ev, below);\n          return false;\n        }\n\n        var eve = checkBothIntersections();\n\n        if (eve) {\n          // ev and eve are equal\n          // we'll keep eve and throw away ev\n          // merge ev.seg's fill information into eve.seg\n          if (selfIntersection) {\n            var toggle; // are we a toggling edge?\n\n            if (ev.seg.myFill.below === null) toggle = true;else toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // merge two segments that belong to the same polygon\n            // think of this as sandwiching two segments together, where `eve.seg` is\n            // the bottom -- this will cause the above fill flag to toggle\n\n            if (toggle) eve.seg.myFill.above = !eve.seg.myFill.above;\n          } else {\n            // merge two segments that belong to different polygons\n            // each segment has distinct knowledge, so no special logic is needed\n            // note that this can only happen once per segment in this phase, because we\n            // are guaranteed that all self-intersections are gone\n            eve.seg.otherFill = ev.seg.myFill;\n          }\n\n          if (buildLog) buildLog.segmentUpdate(eve.seg);\n          ev.other.remove();\n          ev.remove();\n        }\n\n        if (event_root.getHead() !== ev) {\n          // something was inserted before us in the event queue, so loop back around and\n          // process it before continuing\n          if (buildLog) buildLog.rewind(ev.seg);\n          continue;\n        } //\n        // calculate fill flags\n        //\n\n\n        if (selfIntersection) {\n          var toggle; // are we a toggling edge?\n\n          if (ev.seg.myFill.below === null) // if we are a new segment...\n            toggle = true; // then we toggle\n          else // we are a segment that has previous knowledge from a division\n            toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n          // next, calculate whether we are filled below us\n\n          if (!below) {\n            // if nothing is below us...\n            // we are filled below us if the polygon is inverted\n            ev.seg.myFill.below = primaryPolyInverted;\n          } else {\n            // otherwise, we know the answer -- it's the same if whatever is below\n            // us is filled above it\n            ev.seg.myFill.below = below.seg.myFill.above;\n          } // since now we know if we're filled below us, we can calculate whether\n          // we're filled above us by applying toggle to whatever is below us\n\n\n          if (toggle) ev.seg.myFill.above = !ev.seg.myFill.below;else ev.seg.myFill.above = ev.seg.myFill.below;\n        } else {\n          // now we fill in any missing transition information, since we are all-knowing\n          // at this point\n          if (ev.seg.otherFill === null) {\n            // if we don't have other information, then we need to figure out if we're\n            // inside the other polygon\n            var inside;\n\n            if (!below) {\n              // if nothing is below us, then we're inside if the other polygon is\n              // inverted\n              inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;\n            } else {\n              // otherwise, something is below us\n              // so copy the below segment's other polygon's above\n              if (ev.primary === below.primary) inside = below.seg.otherFill.above;else inside = below.seg.myFill.above;\n            }\n\n            ev.seg.otherFill = {\n              above: inside,\n              below: inside\n            };\n          }\n        }\n\n        if (buildLog) {\n          buildLog.status(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        } // insert the status and remember it for later removal\n\n\n        ev.other.status = surrounding.insert(LinkedList.node({\n          ev: ev\n        }));\n      } else {\n        var st = ev.status;\n\n        if (st === null) {\n          throw new Error('PolyBool: Zero-length segment detected; your epsilon is ' + 'probably too small or too large');\n        } // removing the status will create two new adjacent edges, so we'll need to check\n        // for those\n\n\n        if (status_root.exists(st.prev) && status_root.exists(st.next)) checkIntersection(st.prev.ev, st.next.ev);\n        if (buildLog) buildLog.statusRemove(st.ev.seg); // remove the status\n\n        st.remove(); // if we've reached this point, we've calculated everything there is to know, so\n        // save the segment for reporting\n\n        if (!ev.primary) {\n          // make sure `seg.myFill` actually points to the primary polygon though\n          var s = ev.seg.myFill;\n          ev.seg.myFill = ev.seg.otherFill;\n          ev.seg.otherFill = s;\n        }\n\n        segments.push(ev.seg);\n      } // remove the event and continue\n\n\n      event_root.getHead().remove();\n    }\n\n    if (buildLog) buildLog.done();\n    return segments;\n  } // return the appropriate API depending on what we're doing\n\n\n  if (!selfIntersection) {\n    // performing combination of polygons, so only deal with already-processed segments\n    return {\n      calculate: function (segments1, inverted1, segments2, inverted2) {\n        // segmentsX come from the self-intersection API, or this API\n        // invertedX is whether we treat that list of segments as an inverted polygon or not\n        // returns segments that can be used for further operations\n        segments1.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n        });\n        segments2.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n        });\n        return calculate(inverted1, inverted2);\n      }\n    };\n  } // otherwise, performing self-intersection, so deal with regions\n\n\n  return {\n    addRegion: function (region) {\n      // regions are a list of points:\n      //  [ [0, 0], [100, 0], [50, 100] ]\n      // you can add multiple regions before running calculate\n      var pt1;\n      var pt2 = region[region.length - 1];\n\n      for (var i = 0; i < region.length; i++) {\n        pt1 = pt2;\n        pt2 = region[i];\n        var forward = eps.pointsCompare(pt1, pt2);\n        if (forward === 0) // points are equal, so we have a zero-length segment\n          continue; // just skip it\n\n        eventAddSegment(segmentNew(forward < 0 ? pt1 : pt2, forward < 0 ? pt2 : pt1), true);\n      }\n    },\n    calculate: function (inverted) {\n      // is the polygon inverted?\n      // returns segments\n      return calculate(inverted, false);\n    }\n  };\n}\n\nmodule.exports = Intersecter;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/polybooljs/lib/intersecter.js"],"names":["LinkedList","require","Intersecter","selfIntersection","eps","buildLog","segmentNew","start","end","id","segmentId","myFill","above","below","otherFill","segmentCopy","seg","event_root","create","eventCompare","p1_isStart","p1_1","p1_2","p2_isStart","p2_1","p2_2","comp","pointsCompare","pointsSame","pointAboveOrOnLine","eventAdd","ev","other_pt","insertBefore","here","isStart","pt","other","eventAddSegmentStart","primary","ev_start","node","status","eventAddSegmentEnd","ev_end","eventAddSegment","eventUpdateEnd","segmentChop","remove","eventDivide","ns","calculate","primaryPolyInverted","secondaryPolyInverted","status_root","statusCompare","ev1","ev2","a1","a2","b1","b2","pointsCollinear","statusFindSurrounding","findTransition","checkIntersection","seg1","seg2","i","linesIntersect","a1_equ_b1","a2_equ_b2","a1_between","pointBetween","a2_between","alongA","alongB","segments","isEmpty","getHead","vert","surrounding","before","after","tempStatus","checkBothIntersections","eve","toggle","segmentUpdate","rewind","inside","insert","st","Error","exists","prev","next","statusRemove","s","push","done","segments1","inverted1","segments2","inverted2","forEach","addRegion","region","pt1","pt2","length","forward","inverted","module","exports"],"mappings":"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","sourcesContent":["// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n"]},"metadata":{},"sourceType":"script"}