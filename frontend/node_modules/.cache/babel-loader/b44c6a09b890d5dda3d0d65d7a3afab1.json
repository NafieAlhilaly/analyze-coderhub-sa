{"ast":null,"code":"'use strict';\n/* eslint-disable consistent-return */\n\nvar readUInt16BE = require('../common').readUInt16BE;\n\nvar str2arr = require('../common').str2arr;\n\nvar sliceEq = require('../common').sliceEq;\n\nvar exif = require('../exif_utils');\n\nvar SIG_EXIF = str2arr('Exif\\0\\0');\n\nmodule.exports = function (data) {\n  if (data.length < 2) return; // first marker of the file MUST be 0xFFD8\n\n  if (data[0] !== 0xFF || data[1] !== 0xD8) return;\n  var offset = 2;\n\n  for (;;) {\n    if (data.length - offset < 2) return; // not a JPEG marker\n\n    if (data[offset++] !== 0xFF) return;\n    var code = data[offset++];\n    var length; // skip padding bytes\n\n    while (code === 0xFF) code = data[offset++]; // standalone markers, according to JPEG 1992,\n    // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n\n\n    if (0xD0 <= code && code <= 0xD9 || code === 0x01) {\n      length = 0;\n    } else if (0xC0 <= code && code <= 0xFE) {\n      // the rest of the unreserved markers\n      if (data.length - offset < 2) return;\n      length = readUInt16BE(data, offset) - 2;\n      offset += 2;\n    } else {\n      // unknown markers\n      return;\n    }\n\n    if (code === 0xD9\n    /* EOI */\n    || code === 0xDA\n    /* SOS */\n    ) {\n      // end of the datastream\n      return;\n    }\n\n    var orientation; // try to get orientation from Exif segment\n\n    if (code === 0xE1 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {\n      orientation = exif.get_orientation(data.slice(offset + 6, offset + length));\n    }\n\n    if (length >= 5 && 0xC0 <= code && code <= 0xCF && code !== 0xC4 && code !== 0xC8 && code !== 0xCC) {\n      if (data.length - offset < length) return;\n      var result = {\n        width: readUInt16BE(data, offset + 3),\n        height: readUInt16BE(data, offset + 1),\n        type: 'jpg',\n        mime: 'image/jpeg',\n        wUnits: 'px',\n        hUnits: 'px'\n      };\n\n      if (orientation > 0) {\n        result.orientation = orientation;\n      }\n\n      return result;\n    }\n\n    offset += length;\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/probe-image-size/lib/parse_sync/jpeg.js"],"names":["readUInt16BE","require","str2arr","sliceEq","exif","SIG_EXIF","module","exports","data","length","offset","code","orientation","get_orientation","slice","result","width","height","type","mime","wUnits","hUnits"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable consistent-return */\n\nvar readUInt16BE = require('../common').readUInt16BE;\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_EXIF  = str2arr('Exif\\0\\0');\n\n\nmodule.exports = function (data) {\n  if (data.length < 2) return;\n\n  // first marker of the file MUST be 0xFFD8\n  if (data[0] !== 0xFF || data[1] !== 0xD8) return;\n\n  var offset = 2;\n\n  for (;;) {\n    if (data.length - offset < 2) return;\n    // not a JPEG marker\n    if (data[offset++] !== 0xFF) return;\n\n    var code = data[offset++];\n    var length;\n\n    // skip padding bytes\n    while (code === 0xFF) code = data[offset++];\n\n    // standalone markers, according to JPEG 1992,\n    // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n    if ((0xD0 <= code && code <= 0xD9) || code === 0x01) {\n      length = 0;\n    } else if (0xC0 <= code && code <= 0xFE) {\n      // the rest of the unreserved markers\n      if (data.length - offset < 2) return;\n\n      length = readUInt16BE(data, offset) - 2;\n      offset += 2;\n    } else {\n      // unknown markers\n      return;\n    }\n\n    if (code === 0xD9 /* EOI */ || code === 0xDA /* SOS */) {\n      // end of the datastream\n      return;\n    }\n\n    var orientation;\n\n    // try to get orientation from Exif segment\n    if (code === 0xE1 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {\n      orientation = exif.get_orientation(data.slice(offset + 6, offset + length));\n    }\n\n    if (length >= 5 &&\n        (0xC0 <= code && code <= 0xCF) &&\n        code !== 0xC4 && code !== 0xC8 && code !== 0xCC) {\n\n      if (data.length - offset < length) return;\n\n      var result = {\n        width:  readUInt16BE(data, offset + 3),\n        height: readUInt16BE(data, offset + 1),\n        type:   'jpg',\n        mime:   'image/jpeg',\n        wUnits: 'px',\n        hUnits: 'px'\n      };\n\n      if (orientation > 0) {\n        result.orientation = orientation;\n      }\n\n      return result;\n    }\n\n    offset += length;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}