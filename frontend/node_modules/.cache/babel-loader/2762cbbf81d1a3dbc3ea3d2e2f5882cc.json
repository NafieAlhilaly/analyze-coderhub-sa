{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar boxPlot = require('../box/plot');\n\nvar linePoints = require('../scatter/line_points');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n  var fullLayout = gd._fullLayout;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n\n  function makePath(pts) {\n    var segments = linePoints(pts, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: true,\n      baseTolerance: 0.75,\n      shape: 'spline',\n      simplify: true,\n      linearized: true\n    });\n    return Drawing.smoothopen(segments[0], 1);\n  }\n\n  Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace;\n\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n\n    var bPos = t.bPos;\n    var bdPos = t.bdPos;\n    var valAxis = plotinfo[t.valLetter + 'axis'];\n    var posAxis = plotinfo[t.posLetter + 'axis'];\n    var hasBothSides = trace.side === 'both';\n    var hasPositiveSide = hasBothSides || trace.side === 'positive';\n    var hasNegativeSide = hasBothSides || trace.side === 'negative';\n    var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n    violins.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'violin');\n    violins.exit().remove();\n    violins.each(function (d) {\n      var pathSel = d3.select(this);\n      var density = d.density;\n      var len = density.length;\n      var posCenter = posAxis.c2l(d.pos + bPos, true);\n      var posCenterPx = posAxis.l2p(posCenter);\n      var scale;\n\n      if (trace.width) {\n        scale = t.maxKDE / bdPos;\n      } else {\n        var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n        scale = trace.scalemode === 'count' ? groupStats.maxKDE / bdPos * (groupStats.maxCount / d.pts.length) : groupStats.maxKDE / bdPos;\n      }\n\n      var pathPos, pathNeg, path;\n      var i, k, pts, pt;\n\n      if (hasPositiveSide) {\n        pts = new Array(len);\n\n        for (i = 0; i < len; i++) {\n          pt = pts[i] = {};\n          pt[t.posLetter] = posCenter + density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n\n        pathPos = makePath(pts);\n      }\n\n      if (hasNegativeSide) {\n        pts = new Array(len);\n\n        for (k = 0, i = len - 1; k < len; k++, i--) {\n          pt = pts[k] = {};\n          pt[t.posLetter] = posCenter - density[i].v / scale;\n          pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n        }\n\n        pathNeg = makePath(pts);\n      }\n\n      if (hasBothSides) {\n        path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n      } else {\n        var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n        var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n\n        if (trace.orientation === 'h') {\n          startPt.reverse();\n          endPt.reverse();\n        }\n\n        if (hasPositiveSide) {\n          path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n        } else {\n          path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n        }\n      }\n\n      pathSel.attr('d', path); // save a few things used in getPositionOnKdePath, getKdeValue\n      // on hover and for meanline draw block below\n\n      d.posCenterPx = posCenterPx;\n      d.posDensityScale = scale * bdPos;\n      d.path = pathSel.node();\n      d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n    });\n    var boxAttrs = trace.box;\n    var boxWidth = boxAttrs.width;\n    var boxLineWidth = (boxAttrs.line || {}).width;\n    var bdPosScaled;\n    var bPosPxOffset;\n\n    if (hasBothSides) {\n      bdPosScaled = bdPos * boxWidth;\n      bPosPxOffset = 0;\n    } else if (hasPositiveSide) {\n      bdPosScaled = [0, bdPos * boxWidth / 2];\n      bPosPxOffset = boxLineWidth * {\n        x: 1,\n        y: -1\n      }[t.posLetter];\n    } else {\n      bdPosScaled = [bdPos * boxWidth / 2, 0];\n      bPosPxOffset = boxLineWidth * {\n        x: -1,\n        y: 1\n      }[t.posLetter];\n    } // inner box\n\n\n    boxPlot.plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    }); // meanline insider box\n\n    boxPlot.plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n    var fn;\n\n    if (!trace.box.visible && trace.meanline.visible) {\n      fn = Lib.identity;\n    } // N.B. use different class name than boxPlot.plotBoxMean,\n    // to avoid selectAll conflict\n\n\n    var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n    meanPaths.enter().append('path').attr('class', 'meanline').style('fill', 'none').style('vector-effect', 'non-scaling-stroke');\n    meanPaths.exit().remove();\n    meanPaths.each(function (d) {\n      var v = valAxis.c2p(d.mean, true);\n      var p = helpers.getPositionOnKdePath(d, trace, v);\n      d3.select(this).attr('d', trace.orientation === 'h' ? 'M' + v + ',' + p[0] + 'V' + p[1] : 'M' + p[0] + ',' + v + 'H' + p[1]);\n    });\n    boxPlot.plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/violin/plot.js"],"names":["d3","require","Lib","Drawing","boxPlot","linePoints","helpers","module","exports","plot","gd","plotinfo","cdViolins","violinLayer","fullLayout","_fullLayout","xa","xaxis","ya","yaxis","makePath","pts","segments","connectGaps","baseTolerance","shape","simplify","linearized","smoothopen","makeTraceGroups","each","cd","plotGroup","select","cd0","t","trace","visible","empty","remove","bPos","bdPos","valAxis","valLetter","posAxis","posLetter","hasBothSides","side","hasPositiveSide","hasNegativeSide","violins","selectAll","data","identity","enter","append","style","attr","exit","d","pathSel","density","len","length","posCenter","c2l","pos","posCenterPx","l2p","scale","width","maxKDE","groupStats","_violinScaleGroupStats","scalegroup","scalemode","maxCount","pathPos","pathNeg","path","i","k","pt","Array","v","substr","startPt","c2p","endPt","orientation","reverse","posDensityScale","node","pathLength","getTotalLength","boxAttrs","box","boxWidth","boxLineWidth","line","bdPosScaled","bPosPxOffset","x","y","plotBoxAndWhiskers","val","plotBoxMean","fn","meanline","meanPaths","mean","p","getPositionOnKdePath","plotPoints"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\nvar boxPlot = require('../box/plot');\nvar linePoints = require('../scatter/line_points');\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n    var fullLayout = gd._fullLayout;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    function makePath(pts) {\n        var segments = linePoints(pts, {\n            xaxis: xa,\n            yaxis: ya,\n            connectGaps: true,\n            baseTolerance: 0.75,\n            shape: 'spline',\n            simplify: true,\n            linearized: true\n        });\n        return Drawing.smoothopen(segments[0], 1);\n    }\n\n    Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var bPos = t.bPos;\n        var bdPos = t.bdPos;\n        var valAxis = plotinfo[t.valLetter + 'axis'];\n        var posAxis = plotinfo[t.posLetter + 'axis'];\n        var hasBothSides = trace.side === 'both';\n        var hasPositiveSide = hasBothSides || trace.side === 'positive';\n        var hasNegativeSide = hasBothSides || trace.side === 'negative';\n\n        var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n\n        violins.enter().append('path')\n            .style('vector-effect', 'non-scaling-stroke')\n            .attr('class', 'violin');\n\n        violins.exit().remove();\n\n        violins.each(function(d) {\n            var pathSel = d3.select(this);\n            var density = d.density;\n            var len = density.length;\n            var posCenter = posAxis.c2l(d.pos + bPos, true);\n            var posCenterPx = posAxis.l2p(posCenter);\n\n            var scale;\n            if(trace.width) {\n                scale = t.maxKDE / bdPos;\n            } else {\n                var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n                scale = trace.scalemode === 'count' ?\n                    (groupStats.maxKDE / bdPos) * (groupStats.maxCount / d.pts.length) :\n                    groupStats.maxKDE / bdPos;\n            }\n\n            var pathPos, pathNeg, path;\n            var i, k, pts, pt;\n\n            if(hasPositiveSide) {\n                pts = new Array(len);\n                for(i = 0; i < len; i++) {\n                    pt = pts[i] = {};\n                    pt[t.posLetter] = posCenter + (density[i].v / scale);\n                    pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n                }\n                pathPos = makePath(pts);\n            }\n\n            if(hasNegativeSide) {\n                pts = new Array(len);\n                for(k = 0, i = len - 1; k < len; k++, i--) {\n                    pt = pts[k] = {};\n                    pt[t.posLetter] = posCenter - (density[i].v / scale);\n                    pt[t.valLetter] = valAxis.c2l(density[i].t, true);\n                }\n                pathNeg = makePath(pts);\n            }\n\n            if(hasBothSides) {\n                path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n            } else {\n                var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n                var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n\n                if(trace.orientation === 'h') {\n                    startPt.reverse();\n                    endPt.reverse();\n                }\n\n                if(hasPositiveSide) {\n                    path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n                } else {\n                    path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n                }\n            }\n            pathSel.attr('d', path);\n\n            // save a few things used in getPositionOnKdePath, getKdeValue\n            // on hover and for meanline draw block below\n            d.posCenterPx = posCenterPx;\n            d.posDensityScale = scale * bdPos;\n            d.path = pathSel.node();\n            d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n        });\n\n        var boxAttrs = trace.box;\n        var boxWidth = boxAttrs.width;\n        var boxLineWidth = (boxAttrs.line || {}).width;\n        var bdPosScaled;\n        var bPosPxOffset;\n\n        if(hasBothSides) {\n            bdPosScaled = bdPos * boxWidth;\n            bPosPxOffset = 0;\n        } else if(hasPositiveSide) {\n            bdPosScaled = [0, bdPos * boxWidth / 2];\n            bPosPxOffset = boxLineWidth * {x: 1, y: -1}[t.posLetter];\n        } else {\n            bdPosScaled = [bdPos * boxWidth / 2, 0];\n            bPosPxOffset = boxLineWidth * {x: -1, y: 1}[t.posLetter];\n        }\n\n        // inner box\n        boxPlot.plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        // meanline insider box\n        boxPlot.plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        var fn;\n        if(!trace.box.visible && trace.meanline.visible) {\n            fn = Lib.identity;\n        }\n\n        // N.B. use different class name than boxPlot.plotBoxMean,\n        // to avoid selectAll conflict\n        var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n        meanPaths.enter().append('path')\n            .attr('class', 'meanline')\n            .style('fill', 'none')\n            .style('vector-effect', 'non-scaling-stroke');\n        meanPaths.exit().remove();\n        meanPaths.each(function(d) {\n            var v = valAxis.c2p(d.mean, true);\n            var p = helpers.getPositionOnKdePath(d, trace, v);\n\n            d3.select(this).attr('d',\n                trace.orientation === 'h' ?\n                    'M' + v + ',' + p[0] + 'V' + p[1] :\n                    'M' + p[0] + ',' + v + 'H' + p[1]\n            );\n        });\n\n        boxPlot.plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n    });\n};\n"]},"metadata":{},"sourceType":"script"}