{"ast":null,"code":"'use strict';\n\nvar maxRowLength = require('../../lib').maxRowLength;\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\n\n\nmodule.exports = function findEmpties(z) {\n  var empties = [];\n  var neighborHash = {};\n  var noNeighborList = [];\n  var nextRow = z[0];\n  var row = [];\n  var blank = [0, 0, 0];\n  var rowLength = maxRowLength(z);\n  var prevRow;\n  var i;\n  var j;\n  var thisPt;\n  var p;\n  var neighborCount;\n  var newNeighborHash;\n  var foundNewNeighbors;\n\n  for (i = 0; i < z.length; i++) {\n    prevRow = row;\n    row = nextRow;\n    nextRow = z[i + 1] || [];\n\n    for (j = 0; j < rowLength; j++) {\n      if (row[j] === undefined) {\n        neighborCount = (row[j - 1] !== undefined ? 1 : 0) + (row[j + 1] !== undefined ? 1 : 0) + (prevRow[j] !== undefined ? 1 : 0) + (nextRow[j] !== undefined ? 1 : 0);\n\n        if (neighborCount) {\n          // for this purpose, don't count off-the-edge points\n          // as undefined neighbors\n          if (i === 0) neighborCount++;\n          if (j === 0) neighborCount++;\n          if (i === z.length - 1) neighborCount++;\n          if (j === row.length - 1) neighborCount++; // if all neighbors that could exist do, we don't\n          // need this for finding farther neighbors\n\n          if (neighborCount < 4) {\n            neighborHash[[i, j]] = [i, j, neighborCount];\n          }\n\n          empties.push([i, j, neighborCount]);\n        } else noNeighborList.push([i, j]);\n      }\n    }\n  }\n\n  while (noNeighborList.length) {\n    newNeighborHash = {};\n    foundNewNeighbors = false; // look for cells that now have neighbors but didn't before\n\n    for (p = noNeighborList.length - 1; p >= 0; p--) {\n      thisPt = noNeighborList[p];\n      i = thisPt[0];\n      j = thisPt[1];\n      neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] + (neighborHash[[i + 1, j]] || blank)[2] + (neighborHash[[i, j - 1]] || blank)[2] + (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n\n      if (neighborCount) {\n        newNeighborHash[thisPt] = [i, j, neighborCount];\n        noNeighborList.splice(p, 1);\n        foundNewNeighbors = true;\n      }\n    }\n\n    if (!foundNewNeighbors) {\n      throw 'findEmpties iterated with no new neighbors';\n    } // put these new cells into the main neighbor list\n\n\n    for (thisPt in newNeighborHash) {\n      neighborHash[thisPt] = newNeighborHash[thisPt];\n      empties.push(newNeighborHash[thisPt]);\n    }\n  } // sort the full list in descending order of neighbor count\n\n\n  return empties.sort(function (a, b) {\n    return b[2] - a[2];\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/heatmap/find_empties.js"],"names":["maxRowLength","require","module","exports","findEmpties","z","empties","neighborHash","noNeighborList","nextRow","row","blank","rowLength","prevRow","i","j","thisPt","p","neighborCount","newNeighborHash","foundNewNeighbors","length","undefined","push","splice","sort","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\nvar maxRowLength = require('../../lib').maxRowLength;\n\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\nmodule.exports = function findEmpties(z) {\n    var empties = [];\n    var neighborHash = {};\n    var noNeighborList = [];\n    var nextRow = z[0];\n    var row = [];\n    var blank = [0, 0, 0];\n    var rowLength = maxRowLength(z);\n    var prevRow;\n    var i;\n    var j;\n    var thisPt;\n    var p;\n    var neighborCount;\n    var newNeighborHash;\n    var foundNewNeighbors;\n\n    for(i = 0; i < z.length; i++) {\n        prevRow = row;\n        row = nextRow;\n        nextRow = z[i + 1] || [];\n        for(j = 0; j < rowLength; j++) {\n            if(row[j] === undefined) {\n                neighborCount = (row[j - 1] !== undefined ? 1 : 0) +\n                    (row[j + 1] !== undefined ? 1 : 0) +\n                    (prevRow[j] !== undefined ? 1 : 0) +\n                    (nextRow[j] !== undefined ? 1 : 0);\n\n                if(neighborCount) {\n                    // for this purpose, don't count off-the-edge points\n                    // as undefined neighbors\n                    if(i === 0) neighborCount++;\n                    if(j === 0) neighborCount++;\n                    if(i === z.length - 1) neighborCount++;\n                    if(j === row.length - 1) neighborCount++;\n\n                    // if all neighbors that could exist do, we don't\n                    // need this for finding farther neighbors\n                    if(neighborCount < 4) {\n                        neighborHash[[i, j]] = [i, j, neighborCount];\n                    }\n\n                    empties.push([i, j, neighborCount]);\n                } else noNeighborList.push([i, j]);\n            }\n        }\n    }\n\n    while(noNeighborList.length) {\n        newNeighborHash = {};\n        foundNewNeighbors = false;\n\n        // look for cells that now have neighbors but didn't before\n        for(p = noNeighborList.length - 1; p >= 0; p--) {\n            thisPt = noNeighborList[p];\n            i = thisPt[0];\n            j = thisPt[1];\n\n            neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] +\n                (neighborHash[[i + 1, j]] || blank)[2] +\n                (neighborHash[[i, j - 1]] || blank)[2] +\n                (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n\n            if(neighborCount) {\n                newNeighborHash[thisPt] = [i, j, neighborCount];\n                noNeighborList.splice(p, 1);\n                foundNewNeighbors = true;\n            }\n        }\n\n        if(!foundNewNeighbors) {\n            throw 'findEmpties iterated with no new neighbors';\n        }\n\n        // put these new cells into the main neighbor list\n        for(thisPt in newNeighborHash) {\n            neighborHash[thisPt] = newNeighborHash[thisPt];\n            empties.push(newNeighborHash[thisPt]);\n        }\n    }\n\n    // sort the full list in descending order of neighbor count\n    return empties.sort(function(a, b) { return b[2] - a[2]; });\n};\n"]},"metadata":{},"sourceType":"script"}