{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib'); // make sure scene exists on subplot, return it\n\n\nmodule.exports = function sceneUpdate(gd, subplot) {\n  var scene = subplot._scene;\n  var resetOpts = {\n    // number of traces in subplot, since scene:subplot -> 1:1\n    count: 0,\n    // whether scene requires init hook in plot call (dirty plot call)\n    dirty: true,\n    // last used options\n    lineOptions: [],\n    fillOptions: [],\n    markerOptions: [],\n    markerSelectedOptions: [],\n    markerUnselectedOptions: [],\n    errorXOptions: [],\n    errorYOptions: [],\n    textOptions: [],\n    textSelectedOptions: [],\n    textUnselectedOptions: [],\n    // selection batches\n    selectBatch: [],\n    unselectBatch: []\n  }; // regl- component stubs, initialized in dirty plot call\n\n  var initOpts = {\n    fill2d: false,\n    scatter2d: false,\n    error2d: false,\n    line2d: false,\n    glText: false,\n    select2d: false\n  };\n\n  if (!subplot._scene) {\n    scene = subplot._scene = {};\n\n    scene.init = function init() {\n      Lib.extendFlat(scene, initOpts, resetOpts);\n    };\n\n    scene.init(); // apply new option to all regl components (used on drag)\n\n    scene.update = function update(opt) {\n      var opts = Lib.repeat(opt, scene.count);\n      if (scene.fill2d) scene.fill2d.update(opts);\n      if (scene.scatter2d) scene.scatter2d.update(opts);\n      if (scene.line2d) scene.line2d.update(opts);\n      if (scene.error2d) scene.error2d.update(opts.concat(opts));\n      if (scene.select2d) scene.select2d.update(opts);\n\n      if (scene.glText) {\n        for (var i = 0; i < scene.count; i++) {\n          scene.glText[i].update(opt);\n        }\n      }\n    }; // draw traces in proper order\n\n\n    scene.draw = function draw() {\n      var count = scene.count;\n      var fill2d = scene.fill2d;\n      var error2d = scene.error2d;\n      var line2d = scene.line2d;\n      var scatter2d = scene.scatter2d;\n      var glText = scene.glText;\n      var select2d = scene.select2d;\n      var selectBatch = scene.selectBatch;\n      var unselectBatch = scene.unselectBatch;\n\n      for (var i = 0; i < count; i++) {\n        if (fill2d && scene.fillOrder[i]) {\n          fill2d.draw(scene.fillOrder[i]);\n        }\n\n        if (line2d && scene.lineOptions[i]) {\n          line2d.draw(i);\n        }\n\n        if (error2d) {\n          if (scene.errorXOptions[i]) error2d.draw(i);\n          if (scene.errorYOptions[i]) error2d.draw(i + count);\n        }\n\n        if (scatter2d && scene.markerOptions[i]) {\n          if (unselectBatch[i].length) {\n            var arg = Lib.repeat([], scene.count);\n            arg[i] = unselectBatch[i];\n            scatter2d.draw(arg);\n          } else if (!selectBatch[i].length) {\n            scatter2d.draw(i);\n          }\n        }\n\n        if (glText[i] && scene.textOptions[i]) {\n          glText[i].render();\n        }\n      }\n\n      if (select2d) {\n        select2d.draw(selectBatch);\n      }\n\n      scene.dirty = false;\n    }; // remove scene resources\n\n\n    scene.destroy = function destroy() {\n      if (scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();\n      if (scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();\n      if (scene.error2d && scene.error2d.destroy) scene.error2d.destroy();\n      if (scene.line2d && scene.line2d.destroy) scene.line2d.destroy();\n      if (scene.select2d && scene.select2d.destroy) scene.select2d.destroy();\n\n      if (scene.glText) {\n        scene.glText.forEach(function (text) {\n          if (text.destroy) text.destroy();\n        });\n      }\n\n      scene.lineOptions = null;\n      scene.fillOptions = null;\n      scene.markerOptions = null;\n      scene.markerSelectedOptions = null;\n      scene.markerUnselectedOptions = null;\n      scene.errorXOptions = null;\n      scene.errorYOptions = null;\n      scene.textOptions = null;\n      scene.textSelectedOptions = null;\n      scene.textUnselectedOptions = null;\n      scene.selectBatch = null;\n      scene.unselectBatch = null; // we can't just delete _scene, because `destroy` is called in the\n      // middle of supplyDefaults, before relinkPrivateKeys which will put it back.\n\n      subplot._scene = null;\n    };\n  } // in case if we have scene from the last calc - reset data\n\n\n  if (!scene.dirty) {\n    Lib.extendFlat(scene, resetOpts);\n  }\n\n  return scene;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/scattergl/scene_update.js"],"names":["Lib","require","module","exports","sceneUpdate","gd","subplot","scene","_scene","resetOpts","count","dirty","lineOptions","fillOptions","markerOptions","markerSelectedOptions","markerUnselectedOptions","errorXOptions","errorYOptions","textOptions","textSelectedOptions","textUnselectedOptions","selectBatch","unselectBatch","initOpts","fill2d","scatter2d","error2d","line2d","glText","select2d","init","extendFlat","update","opt","opts","repeat","concat","i","draw","fillOrder","length","arg","render","destroy","forEach","text"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\n// make sure scene exists on subplot, return it\nmodule.exports = function sceneUpdate(gd, subplot) {\n    var scene = subplot._scene;\n\n    var resetOpts = {\n        // number of traces in subplot, since scene:subplot -> 1:1\n        count: 0,\n        // whether scene requires init hook in plot call (dirty plot call)\n        dirty: true,\n        // last used options\n        lineOptions: [],\n        fillOptions: [],\n        markerOptions: [],\n        markerSelectedOptions: [],\n        markerUnselectedOptions: [],\n        errorXOptions: [],\n        errorYOptions: [],\n        textOptions: [],\n        textSelectedOptions: [],\n        textUnselectedOptions: [],\n        // selection batches\n        selectBatch: [],\n        unselectBatch: []\n    };\n\n    // regl- component stubs, initialized in dirty plot call\n    var initOpts = {\n        fill2d: false,\n        scatter2d: false,\n        error2d: false,\n        line2d: false,\n        glText: false,\n        select2d: false\n    };\n\n    if(!subplot._scene) {\n        scene = subplot._scene = {};\n\n        scene.init = function init() {\n            Lib.extendFlat(scene, initOpts, resetOpts);\n        };\n\n        scene.init();\n\n        // apply new option to all regl components (used on drag)\n        scene.update = function update(opt) {\n            var opts = Lib.repeat(opt, scene.count);\n\n            if(scene.fill2d) scene.fill2d.update(opts);\n            if(scene.scatter2d) scene.scatter2d.update(opts);\n            if(scene.line2d) scene.line2d.update(opts);\n            if(scene.error2d) scene.error2d.update(opts.concat(opts));\n            if(scene.select2d) scene.select2d.update(opts);\n            if(scene.glText) {\n                for(var i = 0; i < scene.count; i++) {\n                    scene.glText[i].update(opt);\n                }\n            }\n        };\n\n        // draw traces in proper order\n        scene.draw = function draw() {\n            var count = scene.count;\n            var fill2d = scene.fill2d;\n            var error2d = scene.error2d;\n            var line2d = scene.line2d;\n            var scatter2d = scene.scatter2d;\n            var glText = scene.glText;\n            var select2d = scene.select2d;\n            var selectBatch = scene.selectBatch;\n            var unselectBatch = scene.unselectBatch;\n\n            for(var i = 0; i < count; i++) {\n                if(fill2d && scene.fillOrder[i]) {\n                    fill2d.draw(scene.fillOrder[i]);\n                }\n                if(line2d && scene.lineOptions[i]) {\n                    line2d.draw(i);\n                }\n                if(error2d) {\n                    if(scene.errorXOptions[i]) error2d.draw(i);\n                    if(scene.errorYOptions[i]) error2d.draw(i + count);\n                }\n                if(scatter2d && scene.markerOptions[i]) {\n                    if(unselectBatch[i].length) {\n                        var arg = Lib.repeat([], scene.count);\n                        arg[i] = unselectBatch[i];\n                        scatter2d.draw(arg);\n                    } else if(!selectBatch[i].length) {\n                        scatter2d.draw(i);\n                    }\n                }\n                if(glText[i] && scene.textOptions[i]) {\n                    glText[i].render();\n                }\n            }\n\n            if(select2d) {\n                select2d.draw(selectBatch);\n            }\n\n            scene.dirty = false;\n        };\n\n        // remove scene resources\n        scene.destroy = function destroy() {\n            if(scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();\n            if(scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();\n            if(scene.error2d && scene.error2d.destroy) scene.error2d.destroy();\n            if(scene.line2d && scene.line2d.destroy) scene.line2d.destroy();\n            if(scene.select2d && scene.select2d.destroy) scene.select2d.destroy();\n            if(scene.glText) {\n                scene.glText.forEach(function(text) {\n                    if(text.destroy) text.destroy();\n                });\n            }\n\n            scene.lineOptions = null;\n            scene.fillOptions = null;\n            scene.markerOptions = null;\n            scene.markerSelectedOptions = null;\n            scene.markerUnselectedOptions = null;\n            scene.errorXOptions = null;\n            scene.errorYOptions = null;\n            scene.textOptions = null;\n            scene.textSelectedOptions = null;\n            scene.textUnselectedOptions = null;\n\n            scene.selectBatch = null;\n            scene.unselectBatch = null;\n\n            // we can't just delete _scene, because `destroy` is called in the\n            // middle of supplyDefaults, before relinkPrivateKeys which will put it back.\n            subplot._scene = null;\n        };\n    }\n\n    // in case if we have scene from the last calc - reset data\n    if(!scene.dirty) {\n        Lib.extendFlat(scene, resetOpts);\n    }\n\n    return scene;\n};\n"]},"metadata":{},"sourceType":"script"}