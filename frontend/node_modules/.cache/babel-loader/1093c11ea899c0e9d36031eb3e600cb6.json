{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\n\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTypeDefaults = require('./type_defaults');\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nvar constraints = require('./constraints');\n\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\n\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\n\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var autotypenumbersDflt = layoutOut.autotypenumbers;\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j; // look for axes in the data\n\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n\n    var yaName;\n\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    } // logic for funnels\n\n\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    } // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n\n\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    } // check for default formatting tweaks\n\n\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames); // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n\n  var plotBgColor = Color.background;\n\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor); // name of single axis (e.g. 'xaxis', 'yaxis2')\n\n  var axName; // id of single axis (e.g. 'y', 'x5')\n\n  var axId; // 'x' or 'y'\n\n  var axLetter; // input layout axis container\n\n  var axLayoutIn; // full layout axis container\n\n  var axLayoutOut;\n\n  function newAxLayoutOut() {\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = [];\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    axLayoutOut._id = axId;\n  }\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n\n    return out;\n  } // list of available counter axis names\n\n\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  }; // list of all x AND y axis ids\n\n  var allAxisIds = counterAxes.x.concat(counterAxes.y); // lookup and list of axis ids that axes in axNames have a reference to,\n  // even though they are missing from allAxisIds\n\n  var missingMatchedAxisIdsLookup = {};\n  var missingMatchedAxisIds = []; // fill in 'missing' axis lookup when an axis is set to match an axis\n  // not part of the allAxisIds list, save axis type so that we can propagate\n  // it to the missing axes\n\n  function addMissingMatchedAxis() {\n    var matchesIn = axLayoutIn.matches;\n\n    if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n      missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n      missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n    }\n  }\n\n  var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);\n  var unifiedHover = isUnifiedHover(hovermode); // first pass creates the containers, determines types, and handles most of the settings\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axId = name2id(axName);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: ax2traces[axName] || [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n    var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n    var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n    var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n    var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n    var spikesnap = coerce2('spikesnap');\n    var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('title.standoff');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // coerce the 'missing' axes\n\n\n  i = 0;\n\n  while (i < missingMatchedAxisIds.length) {\n    axId = missingMatchedAxisIds[i++];\n    axName = id2name(axId);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var defaultOptions2 = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: false,\n      reverseDflt: false,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('fixedrange');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // quick second pass for range slider and selector defaults\n\n\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n\n    coerce('fixedrange');\n  }\n\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  } // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n\n\n  constraints.handleDefaults(layoutIn, layoutOut, {\n    axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),\n    axHasImage: axHasImage\n  });\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/layout_defaults.js"],"names":["Lib","require","Color","isUnifiedHover","handleHoverModeDefaults","Template","basePlotLayoutAttributes","layoutAttributes","handleTypeDefaults","handleAxisDefaults","constraints","handlePositionDefaults","axisIds","id2name","name2id","AX_ID_PATTERN","Registry","traceIs","getComponentMethod","appendList","cont","k","item","Array","isArray","push","module","exports","supplyLayoutDefaults","layoutIn","layoutOut","fullData","autotypenumbersDflt","autotypenumbers","ax2traces","xaMayHide","yaMayHide","xaMustDisplay","yaMustDisplay","yaMustNotReverse","yaMayReverse","axHasImage","outerTicks","noGrids","i","j","length","trace","xaName","xaxis","xaxes","yaName","yaxis","yaxes","type","orientation","_cheater","positionAxis","subplots","_subplots","xIds","yIds","xNames","simpleMap","yNames","axNames","concat","plotBgColor","background","coerce","bgColor","combine","paper_bgcolor","axName","axId","axLetter","axLayoutIn","axLayoutOut","newAxLayoutOut","traces","_traceIndices","map","t","_expandedIndex","_annIndices","_shapeIndices","_imgIndices","_subplotsWith","_counterAxes","_name","_attr","_id","attr","dflt","coerce2","getCounterAxes","getOverlayableAxes","list","out","axName2","overlaying","counterAxes","x","y","allAxisIds","missingMatchedAxisIdsLookup","missingMatchedAxisIds","addMissingMatchedAxis","matchesIn","matches","test","indexOf","Object","keys","hovermode","unifiedHover","charAt","isPlainObject","newContainer","visibleDflt","reverseDflt","defaultOptions","letter","font","showGrid","data","calendar","automargin","splomStash","_splomAxes","uirevision","unifiedSpike","spikecolor","color","undefined","spikethickness","spikedash","spikemode","spikesnap","showSpikes","overlayableAxes","grid","_input","defaultOptions2","rangeSliderDefaults","rangeSelectorDefaults","anchoredAxis","anchor","fixedRangeDflt","handleDefaults","axIds","sort","idSort"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,wBAAD,CAAnB;;AACA,IAAIE,cAAc,GAAGF,OAAO,CAAC,6BAAD,CAAP,CAAuCE,cAA5D;;AACA,IAAIC,uBAAuB,GAAGH,OAAO,CAAC,wCAAD,CAArC;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,8BAAD,CAAtB;;AACA,IAAIK,wBAAwB,GAAGL,OAAO,CAAC,sBAAD,CAAtC;;AAEA,IAAIM,gBAAgB,GAAGN,OAAO,CAAC,qBAAD,CAA9B;;AACA,IAAIO,kBAAkB,GAAGP,OAAO,CAAC,iBAAD,CAAhC;;AACA,IAAIQ,kBAAkB,GAAGR,OAAO,CAAC,iBAAD,CAAhC;;AACA,IAAIS,WAAW,GAAGT,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIU,sBAAsB,GAAGV,OAAO,CAAC,qBAAD,CAApC;;AAEA,IAAIW,OAAO,GAAGX,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIY,OAAO,GAAGD,OAAO,CAACC,OAAtB;AACA,IAAIC,OAAO,GAAGF,OAAO,CAACE,OAAtB;;AAEA,IAAIC,aAAa,GAAGd,OAAO,CAAC,aAAD,CAAP,CAAuBc,aAA3C;;AAEA,IAAIC,QAAQ,GAAGf,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIgB,OAAO,GAAGD,QAAQ,CAACC,OAAvB;AACA,IAAIC,kBAAkB,GAAGF,QAAQ,CAACE,kBAAlC;;AAEA,SAASC,UAAT,CAAoBC,IAApB,EAA0BC,CAA1B,EAA6BC,IAA7B,EAAmC;AAC/B,MAAGC,KAAK,CAACC,OAAN,CAAcJ,IAAI,CAACC,CAAD,CAAlB,CAAH,EAA2BD,IAAI,CAACC,CAAD,CAAJ,CAAQI,IAAR,CAAaH,IAAb,EAA3B,KACKF,IAAI,CAACC,CAAD,CAAJ,GAAU,CAACC,IAAD,CAAV;AACR;;AAEDI,MAAM,CAACC,OAAP,GAAiB,SAASC,oBAAT,CAA8BC,QAA9B,EAAwCC,SAAxC,EAAmDC,QAAnD,EAA6D;AAC1E,MAAIC,mBAAmB,GAAGF,SAAS,CAACG,eAApC;AAEA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,aAAa,GAAG,EAApB;AACA,MAAIC,aAAa,GAAG,EAApB;AACA,MAAIC,gBAAgB,GAAG,EAAvB;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,CAAJ,EAAOC,CAAP,CAb0E,CAe1E;;AACA,OAAID,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGb,QAAQ,CAACe,MAAxB,EAAgCF,CAAC,EAAjC,EAAqC;AACjC,QAAIG,KAAK,GAAGhB,QAAQ,CAACa,CAAD,CAApB;AACA,QAAG,CAAC3B,OAAO,CAAC8B,KAAD,EAAQ,WAAR,CAAR,IAAgC,CAAC9B,OAAO,CAAC8B,KAAD,EAAQ,MAAR,CAA3C,EAA4D;AAE5D,QAAIC,MAAJ;;AACA,QAAGD,KAAK,CAACE,KAAT,EAAgB;AACZD,MAAAA,MAAM,GAAGnC,OAAO,CAACkC,KAAK,CAACE,KAAP,CAAhB;AACA9B,MAAAA,UAAU,CAACe,SAAD,EAAYc,MAAZ,EAAoBD,KAApB,CAAV;AACH,KAHD,MAGO,IAAGA,KAAK,CAACG,KAAT,EAAgB;AACnB,WAAIL,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGE,KAAK,CAACG,KAAN,CAAYJ,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC1B,QAAAA,UAAU,CAACe,SAAD,EAAYrB,OAAO,CAACkC,KAAK,CAACG,KAAN,CAAYL,CAAZ,CAAD,CAAnB,EAAqCE,KAArC,CAAV;AACH;AACJ;;AAED,QAAII,MAAJ;;AACA,QAAGJ,KAAK,CAACK,KAAT,EAAgB;AACZD,MAAAA,MAAM,GAAGtC,OAAO,CAACkC,KAAK,CAACK,KAAP,CAAhB;AACAjC,MAAAA,UAAU,CAACe,SAAD,EAAYiB,MAAZ,EAAoBJ,KAApB,CAAV;AACH,KAHD,MAGO,IAAGA,KAAK,CAACM,KAAT,EAAgB;AACnB,WAAIR,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGE,KAAK,CAACM,KAAN,CAAYP,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC1B,QAAAA,UAAU,CAACe,SAAD,EAAYrB,OAAO,CAACkC,KAAK,CAACM,KAAN,CAAYR,CAAZ,CAAD,CAAnB,EAAqCE,KAArC,CAAV;AACH;AACJ,KAtBgC,CAwBjC;;;AACA,QAAGA,KAAK,CAACO,IAAN,KAAe,QAAlB,EAA4B;AACxB,UAAGP,KAAK,CAACQ,WAAN,KAAsB,GAAzB,EAA8B;AAC1B,YAAGP,MAAH,EAAWb,SAAS,CAACa,MAAD,CAAT,GAAoB,IAApB;AACX,YAAGG,MAAH,EAAWX,YAAY,CAACW,MAAD,CAAZ,GAAuB,IAAvB;AACd,OAHD,MAGO;AACH,YAAGA,MAAH,EAAWf,SAAS,CAACe,MAAD,CAAT,GAAoB,IAApB;AACd;AACJ,KAPD,MAOO,IAAGJ,KAAK,CAACO,IAAN,KAAe,OAAlB,EAA2B;AAC9B,UAAGH,MAAH,EAAWV,UAAU,CAACU,MAAD,CAAV,GAAqB,IAArB;AACX,UAAGH,MAAH,EAAWP,UAAU,CAACO,MAAD,CAAV,GAAqB,IAArB;AACd,KAHM,MAGA;AACH,UAAGG,MAAH,EAAW;AACPb,QAAAA,aAAa,CAACa,MAAD,CAAb,GAAwB,IAAxB;AACAZ,QAAAA,gBAAgB,CAACY,MAAD,CAAhB,GAA2B,IAA3B;AACH;;AAED,UAAG,CAAClC,OAAO,CAAC8B,KAAD,EAAQ,QAAR,CAAR,IAA8BA,KAAK,CAACO,IAAN,KAAe,QAAf,IAA2B,CAACP,KAAK,CAACS,QAAnE,EAA8E;AAC1E,YAAGR,MAAH,EAAWX,aAAa,CAACW,MAAD,CAAb,GAAwB,IAAxB;AACd;AACJ,KA5CgC,CA8CjC;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA,QAAGD,KAAK,CAACO,IAAN,KAAe,QAAf,IAA2BP,KAAK,CAACS,QAApC,EAA8C;AAC1C,UAAGR,MAAH,EAAWb,SAAS,CAACa,MAAD,CAAT,GAAoB,IAApB;AACd,KAxDgC,CA0DjC;;;AACA,QAAG/B,OAAO,CAAC8B,KAAD,EAAQ,OAAR,CAAV,EAA4B;AACxBL,MAAAA,UAAU,CAACM,MAAD,CAAV,GAAqB,IAArB;AACAN,MAAAA,UAAU,CAACS,MAAD,CAAV,GAAqB,IAArB;AACH;;AAED,QAAGlC,OAAO,CAAC8B,KAAD,EAAQ,UAAR,CAAV,EAA+B;AAC3B,UAAIU,YAAY,GAAGV,KAAK,CAACQ,WAAN,KAAsB,GAAtB,GAA4BJ,MAA5B,GAAqCH,MAAxD;AACAL,MAAAA,OAAO,CAACc,YAAD,CAAP,GAAwB,IAAxB;AACH;AACJ;;AAED,MAAIC,QAAQ,GAAG5B,SAAS,CAAC6B,SAAzB;AACA,MAAIC,IAAI,GAAGF,QAAQ,CAACT,KAApB;AACA,MAAIY,IAAI,GAAGH,QAAQ,CAACN,KAApB;AACA,MAAIU,MAAM,GAAG9D,GAAG,CAAC+D,SAAJ,CAAcH,IAAd,EAAoB/C,OAApB,CAAb;AACA,MAAImD,MAAM,GAAGhE,GAAG,CAAC+D,SAAJ,CAAcF,IAAd,EAAoBhD,OAApB,CAAb;AACA,MAAIoD,OAAO,GAAGH,MAAM,CAACI,MAAP,CAAcF,MAAd,CAAd,CA3F0E,CA6F1E;AACA;;AACA,MAAIG,WAAW,GAAGjE,KAAK,CAACkE,UAAxB;;AACA,MAAGR,IAAI,CAACd,MAAL,IAAee,IAAI,CAACf,MAAvB,EAA+B;AAC3BqB,IAAAA,WAAW,GAAGnE,GAAG,CAACqE,MAAJ,CAAWxC,QAAX,EAAqBC,SAArB,EAAgCxB,wBAAhC,EAA0D,cAA1D,CAAd;AACH;;AAED,MAAIgE,OAAO,GAAGpE,KAAK,CAACqE,OAAN,CAAcJ,WAAd,EAA2BrC,SAAS,CAAC0C,aAArC,CAAd,CApG0E,CAsG1E;;AACA,MAAIC,MAAJ,CAvG0E,CAwG1E;;AACA,MAAIC,IAAJ,CAzG0E,CA0G1E;;AACA,MAAIC,QAAJ,CA3G0E,CA4G1E;;AACA,MAAIC,UAAJ,CA7G0E,CA8G1E;;AACA,MAAIC,WAAJ;;AAEA,WAASC,cAAT,GAA0B;AACtB,QAAIC,MAAM,GAAG7C,SAAS,CAACuC,MAAD,CAAT,IAAqB,EAAlC;AACAI,IAAAA,WAAW,CAACG,aAAZ,GAA4BD,MAAM,CAACE,GAAP,CAAW,UAASC,CAAT,EAAY;AAAE,aAAOA,CAAC,CAACC,cAAT;AAA0B,KAAnD,CAA5B;AACAN,IAAAA,WAAW,CAACO,WAAZ,GAA0B,EAA1B;AACAP,IAAAA,WAAW,CAACQ,aAAZ,GAA4B,EAA5B;AACAR,IAAAA,WAAW,CAACS,WAAZ,GAA0B,EAA1B;AACAT,IAAAA,WAAW,CAACU,aAAZ,GAA4B,EAA5B;AACAV,IAAAA,WAAW,CAACW,YAAZ,GAA2B,EAA3B;AACAX,IAAAA,WAAW,CAACY,KAAZ,GAAoBZ,WAAW,CAACa,KAAZ,GAAoBjB,MAAxC;AACAI,IAAAA,WAAW,CAACc,GAAZ,GAAkBjB,IAAlB;AACH;;AAED,WAASL,MAAT,CAAgBuB,IAAhB,EAAsBC,IAAtB,EAA4B;AACxB,WAAO7F,GAAG,CAACqE,MAAJ,CAAWO,UAAX,EAAuBC,WAAvB,EAAoCtE,gBAApC,EAAsDqF,IAAtD,EAA4DC,IAA5D,CAAP;AACH;;AAED,WAASC,OAAT,CAAiBF,IAAjB,EAAuBC,IAAvB,EAA6B;AACzB,WAAO7F,GAAG,CAAC8F,OAAJ,CAAYlB,UAAZ,EAAwBC,WAAxB,EAAqCtE,gBAArC,EAAuDqF,IAAvD,EAA6DC,IAA7D,CAAP;AACH;;AAED,WAASE,cAAT,CAAwBpB,QAAxB,EAAkC;AAC9B,WAAQA,QAAQ,KAAK,GAAd,GAAqBd,IAArB,GAA4BD,IAAnC;AACH;;AAED,WAASoC,kBAAT,CAA4BrB,QAA5B,EAAsCF,MAAtC,EAA8C;AAC1C,QAAIwB,IAAI,GAAItB,QAAQ,KAAK,GAAd,GAAqBb,MAArB,GAA8BE,MAAzC;AACA,QAAIkC,GAAG,GAAG,EAAV;;AAEA,SAAI,IAAIrD,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGoD,IAAI,CAACnD,MAAxB,EAAgCD,CAAC,EAAjC,EAAqC;AACjC,UAAIsD,OAAO,GAAGF,IAAI,CAACpD,CAAD,CAAlB;;AAEA,UAAGsD,OAAO,KAAK1B,MAAZ,IAAsB,CAAC,CAAC5C,QAAQ,CAACsE,OAAD,CAAR,IAAqB,EAAtB,EAA0BC,UAApD,EAAgE;AAC5DF,QAAAA,GAAG,CAACzE,IAAJ,CAASX,OAAO,CAACqF,OAAD,CAAhB;AACH;AACJ;;AAED,WAAOD,GAAP;AACH,GAtJyE,CAwJ1E;;;AACA,MAAIG,WAAW,GAAG;AAACC,IAAAA,CAAC,EAAEP,cAAc,CAAC,GAAD,CAAlB;AAAyBQ,IAAAA,CAAC,EAAER,cAAc,CAAC,GAAD;AAA1C,GAAlB,CAzJ0E,CA0J1E;;AACA,MAAIS,UAAU,GAAGH,WAAW,CAACC,CAAZ,CAAcpC,MAAd,CAAqBmC,WAAW,CAACE,CAAjC,CAAjB,CA3J0E,CA4J1E;AACA;;AACA,MAAIE,2BAA2B,GAAG,EAAlC;AACA,MAAIC,qBAAqB,GAAG,EAA5B,CA/J0E,CAiK1E;AACA;AACA;;AACA,WAASC,qBAAT,GAAiC;AAC7B,QAAIC,SAAS,GAAGhC,UAAU,CAACiC,OAA3B;;AACA,QAAG9F,aAAa,CAAC+F,IAAd,CAAmBF,SAAnB,KAAiCJ,UAAU,CAACO,OAAX,CAAmBH,SAAnB,MAAkC,CAAC,CAAvE,EAA0E;AACtEH,MAAAA,2BAA2B,CAACG,SAAD,CAA3B,GAAyChC,UAAU,CAACtB,IAApD;AACAoD,MAAAA,qBAAqB,GAAGM,MAAM,CAACC,IAAP,CAAYR,2BAAZ,CAAxB;AACH;AACJ;;AAED,MAAIS,SAAS,GAAG9G,uBAAuB,CAACyB,QAAD,EAAWC,SAAX,CAAvC;AACA,MAAIqF,YAAY,GAAGhH,cAAc,CAAC+G,SAAD,CAAjC,CA7K0E,CA+K1E;;AACA,OAAItE,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGqB,OAAO,CAACnB,MAAvB,EAA+BF,CAAC,EAAhC,EAAoC;AAChC6B,IAAAA,MAAM,GAAGR,OAAO,CAACrB,CAAD,CAAhB;AACA8B,IAAAA,IAAI,GAAG5D,OAAO,CAAC2D,MAAD,CAAd;AACAE,IAAAA,QAAQ,GAAGF,MAAM,CAAC2C,MAAP,CAAc,CAAd,CAAX;;AAEA,QAAG,CAACpH,GAAG,CAACqH,aAAJ,CAAkBxF,QAAQ,CAAC4C,MAAD,CAA1B,CAAJ,EAAyC;AACrC5C,MAAAA,QAAQ,CAAC4C,MAAD,CAAR,GAAmB,EAAnB;AACH;;AAEDG,IAAAA,UAAU,GAAG/C,QAAQ,CAAC4C,MAAD,CAArB;AACAI,IAAAA,WAAW,GAAGxE,QAAQ,CAACiH,YAAT,CAAsBxF,SAAtB,EAAiC2C,MAAjC,EAAyCE,QAAQ,GAAG,MAApD,CAAd;AACAG,IAAAA,cAAc;AAEd,QAAIyC,WAAW,GACV5C,QAAQ,KAAK,GAAb,IAAoB,CAACtC,aAAa,CAACoC,MAAD,CAAlC,IAA8CtC,SAAS,CAACsC,MAAD,CAAxD,IACCE,QAAQ,KAAK,GAAb,IAAoB,CAACrC,aAAa,CAACmC,MAAD,CAAlC,IAA8CrC,SAAS,CAACqC,MAAD,CAF5D;AAIA,QAAI+C,WAAW,GACV7C,QAAQ,KAAK,GAAb,KAEI,CAACpC,gBAAgB,CAACkC,MAAD,CAAjB,IAA6BjC,YAAY,CAACiC,MAAD,CAA1C,IACAhC,UAAU,CAACgC,MAAD,CAHb,CADL;AAOA,QAAIgD,cAAc,GAAG;AACjBC,MAAAA,MAAM,EAAE/C,QADS;AAEjBgD,MAAAA,IAAI,EAAE7F,SAAS,CAAC6F,IAFC;AAGjBjF,MAAAA,UAAU,EAAEA,UAAU,CAAC+B,MAAD,CAHL;AAIjBmD,MAAAA,QAAQ,EAAE,CAACjF,OAAO,CAAC8B,MAAD,CAJD;AAKjBoD,MAAAA,IAAI,EAAE3F,SAAS,CAACuC,MAAD,CAAT,IAAqB,EALV;AAMjBH,MAAAA,OAAO,EAAEA,OANQ;AAOjBwD,MAAAA,QAAQ,EAAEhG,SAAS,CAACgG,QAPH;AAQjBC,MAAAA,UAAU,EAAE,IARK;AASjBR,MAAAA,WAAW,EAAEA,WATI;AAUjBC,MAAAA,WAAW,EAAEA,WAVI;AAWjBxF,MAAAA,mBAAmB,EAAEA,mBAXJ;AAYjBgG,MAAAA,UAAU,EAAE,CAAC,CAAClG,SAAS,CAACmG,UAAV,IAAwB,EAAzB,EAA6BtD,QAA7B,KAA0C,EAA3C,EAA+CD,IAA/C;AAZK,KAArB;AAeAL,IAAAA,MAAM,CAAC,YAAD,EAAevC,SAAS,CAACoG,UAAzB,CAAN;AAEA1H,IAAAA,kBAAkB,CAACoE,UAAD,EAAaC,WAAb,EAA0BR,MAA1B,EAAkCoD,cAAlC,CAAlB;AACAhH,IAAAA,kBAAkB,CAACmE,UAAD,EAAaC,WAAb,EAA0BR,MAA1B,EAAkCoD,cAAlC,EAAkD3F,SAAlD,CAAlB;AAEA,QAAIqG,YAAY,GAAGhB,YAAY,IAAIxC,QAAQ,KAAKuC,SAAS,CAACE,MAAV,CAAiB,CAAjB,CAAhD;AACA,QAAIgB,UAAU,GAAGtC,OAAO,CAAC,YAAD,EAAeqB,YAAY,GAAGtC,WAAW,CAACwD,KAAf,GAAuBC,SAAlD,CAAxB;AACA,QAAIC,cAAc,GAAGzC,OAAO,CAAC,gBAAD,EAAmBqB,YAAY,GAAG,GAAH,GAASmB,SAAxC,CAA5B;AACA,QAAIE,SAAS,GAAG1C,OAAO,CAAC,WAAD,EAAcqB,YAAY,GAAG,KAAH,GAAWmB,SAArC,CAAvB;AACA,QAAIG,SAAS,GAAG3C,OAAO,CAAC,WAAD,EAAcqB,YAAY,GAAG,QAAH,GAAcmB,SAAxC,CAAvB;AACA,QAAII,SAAS,GAAG5C,OAAO,CAAC,WAAD,CAAvB;AACA,QAAI6C,UAAU,GAAGtE,MAAM,CAAC,YAAD,EAAe,CAAC,CAAC8D,YAAF,IAAkB,CAAC,CAACC,UAApB,IAAkC,CAAC,CAACG,cAApC,IAAsD,CAAC,CAACC,SAAxD,IAAqE,CAAC,CAACC,SAAvE,IAAoF,CAAC,CAACC,SAArG,CAAvB;;AAEA,QAAG,CAACC,UAAJ,EAAgB;AACZ,aAAO9D,WAAW,CAACuD,UAAnB;AACA,aAAOvD,WAAW,CAAC0D,cAAnB;AACA,aAAO1D,WAAW,CAAC2D,SAAnB;AACA,aAAO3D,WAAW,CAAC4D,SAAnB;AACA,aAAO5D,WAAW,CAAC6D,SAAnB;AACH;;AAED/H,IAAAA,sBAAsB,CAACiE,UAAD,EAAaC,WAAb,EAA0BR,MAA1B,EAAkC;AACpDqD,MAAAA,MAAM,EAAE/C,QAD4C;AAEpD0B,MAAAA,WAAW,EAAEA,WAAW,CAAC1B,QAAD,CAF4B;AAGpDiE,MAAAA,eAAe,EAAE5C,kBAAkB,CAACrB,QAAD,EAAWF,MAAX,CAHiB;AAIpDoE,MAAAA,IAAI,EAAE/G,SAAS,CAAC+G;AAJoC,KAAlC,CAAtB;AAOAxE,IAAAA,MAAM,CAAC,gBAAD,CAAN;AAEAsC,IAAAA,qBAAqB;AAErB9B,IAAAA,WAAW,CAACiE,MAAZ,GAAqBlE,UAArB;AACH,GAxPyE,CA0P1E;;;AACAhC,EAAAA,CAAC,GAAG,CAAJ;;AACA,SAAMA,CAAC,GAAG8D,qBAAqB,CAAC5D,MAAhC,EAAwC;AACpC4B,IAAAA,IAAI,GAAGgC,qBAAqB,CAAC9D,CAAC,EAAF,CAA5B;AACA6B,IAAAA,MAAM,GAAG5D,OAAO,CAAC6D,IAAD,CAAhB;AACAC,IAAAA,QAAQ,GAAGF,MAAM,CAAC2C,MAAP,CAAc,CAAd,CAAX;;AAEA,QAAG,CAACpH,GAAG,CAACqH,aAAJ,CAAkBxF,QAAQ,CAAC4C,MAAD,CAA1B,CAAJ,EAAyC;AACrC5C,MAAAA,QAAQ,CAAC4C,MAAD,CAAR,GAAmB,EAAnB;AACH;;AAEDG,IAAAA,UAAU,GAAG/C,QAAQ,CAAC4C,MAAD,CAArB;AACAI,IAAAA,WAAW,GAAGxE,QAAQ,CAACiH,YAAT,CAAsBxF,SAAtB,EAAiC2C,MAAjC,EAAyCE,QAAQ,GAAG,MAApD,CAAd;AACAG,IAAAA,cAAc;AAEd,QAAIiE,eAAe,GAAG;AAClBrB,MAAAA,MAAM,EAAE/C,QADU;AAElBgD,MAAAA,IAAI,EAAE7F,SAAS,CAAC6F,IAFE;AAGlBjF,MAAAA,UAAU,EAAEA,UAAU,CAAC+B,MAAD,CAHJ;AAIlBmD,MAAAA,QAAQ,EAAE,CAACjF,OAAO,CAAC8B,MAAD,CAJA;AAKlBoD,MAAAA,IAAI,EAAE,EALY;AAMlBvD,MAAAA,OAAO,EAAEA,OANS;AAOlBwD,MAAAA,QAAQ,EAAEhG,SAAS,CAACgG,QAPF;AAQlBC,MAAAA,UAAU,EAAE,IARM;AASlBR,MAAAA,WAAW,EAAE,KATK;AAUlBC,MAAAA,WAAW,EAAE,KAVK;AAWlBxF,MAAAA,mBAAmB,EAAEA,mBAXH;AAYlBgG,MAAAA,UAAU,EAAE,CAAC,CAAClG,SAAS,CAACmG,UAAV,IAAwB,EAAzB,EAA6BtD,QAA7B,KAA0C,EAA3C,EAA+CD,IAA/C;AAZM,KAAtB;AAeAL,IAAAA,MAAM,CAAC,YAAD,EAAevC,SAAS,CAACoG,UAAzB,CAAN;AAEArD,IAAAA,WAAW,CAACvB,IAAZ,GAAmBmD,2BAA2B,CAAC/B,IAAD,CAA3B,IAAqC,QAAxD;AAEAjE,IAAAA,kBAAkB,CAACmE,UAAD,EAAaC,WAAb,EAA0BR,MAA1B,EAAkC0E,eAAlC,EAAmDjH,SAAnD,CAAlB;AAEAnB,IAAAA,sBAAsB,CAACiE,UAAD,EAAaC,WAAb,EAA0BR,MAA1B,EAAkC;AACpDqD,MAAAA,MAAM,EAAE/C,QAD4C;AAEpD0B,MAAAA,WAAW,EAAEA,WAAW,CAAC1B,QAAD,CAF4B;AAGpDiE,MAAAA,eAAe,EAAE5C,kBAAkB,CAACrB,QAAD,EAAWF,MAAX,CAHiB;AAIpDoE,MAAAA,IAAI,EAAE/G,SAAS,CAAC+G;AAJoC,KAAlC,CAAtB;AAOAxE,IAAAA,MAAM,CAAC,YAAD,CAAN;AAEAsC,IAAAA,qBAAqB;AAErB9B,IAAAA,WAAW,CAACiE,MAAZ,GAAqBlE,UAArB;AACH,GA1SyE,CA4S1E;;;AACA,MAAIoE,mBAAmB,GAAG9H,kBAAkB,CAAC,aAAD,EAAgB,gBAAhB,CAA5C;AACA,MAAI+H,qBAAqB,GAAG/H,kBAAkB,CAAC,eAAD,EAAkB,gBAAlB,CAA9C;;AAEA,OAAI0B,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGkB,MAAM,CAAChB,MAAtB,EAA8BF,CAAC,EAA/B,EAAmC;AAC/B6B,IAAAA,MAAM,GAAGX,MAAM,CAAClB,CAAD,CAAf;AACAgC,IAAAA,UAAU,GAAG/C,QAAQ,CAAC4C,MAAD,CAArB;AACAI,IAAAA,WAAW,GAAG/C,SAAS,CAAC2C,MAAD,CAAvB;AAEAuE,IAAAA,mBAAmB,CAACnH,QAAD,EAAWC,SAAX,EAAsB2C,MAAtB,CAAnB;;AAEA,QAAGI,WAAW,CAACvB,IAAZ,KAAqB,MAAxB,EAAgC;AAC5B2F,MAAAA,qBAAqB,CACjBrE,UADiB,EAEjBC,WAFiB,EAGjB/C,SAHiB,EAIjBkC,MAJiB,EAKjBa,WAAW,CAACiD,QALK,CAArB;AAOH;;AAEDzD,IAAAA,MAAM,CAAC,YAAD,CAAN;AACH;;AAED,OAAIzB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGoB,MAAM,CAAClB,MAAtB,EAA8BF,CAAC,EAA/B,EAAmC;AAC/B6B,IAAAA,MAAM,GAAGT,MAAM,CAACpB,CAAD,CAAf;AACAgC,IAAAA,UAAU,GAAG/C,QAAQ,CAAC4C,MAAD,CAArB;AACAI,IAAAA,WAAW,GAAG/C,SAAS,CAAC2C,MAAD,CAAvB;AAEA,QAAIyE,YAAY,GAAGpH,SAAS,CAACjB,OAAO,CAACgE,WAAW,CAACsE,MAAb,CAAR,CAA5B;AAEA,QAAIC,cAAc,GAAGlI,kBAAkB,CAAC,aAAD,EAAgB,WAAhB,CAAlB,CAA+CgI,YAA/C,CAArB;AAEA7E,IAAAA,MAAM,CAAC,YAAD,EAAe+E,cAAf,CAAN;AACH,GA9UyE,CAgV1E;AACA;AACA;AACA;AACA;;;AACA1I,EAAAA,WAAW,CAAC2I,cAAZ,CAA2BxH,QAA3B,EAAqCC,SAArC,EAAgD;AAC5CwH,IAAAA,KAAK,EAAE9C,UAAU,CAACtC,MAAX,CAAkBwC,qBAAlB,EAAyC6C,IAAzC,CAA8C3I,OAAO,CAAC4I,MAAtD,CADqC;AAE5C/G,IAAAA,UAAU,EAAEA;AAFgC,GAAhD;AAIH,CAzVD","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\nvar Template = require('../../plot_api/plot_template');\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\nvar handleTypeDefaults = require('./type_defaults');\nvar handleAxisDefaults = require('./axis_defaults');\nvar constraints = require('./constraints');\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n    if(Array.isArray(cont[k])) cont[k].push(item);\n    else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n    var autotypenumbersDflt = layoutOut.autotypenumbers;\n\n    var ax2traces = {};\n    var xaMayHide = {};\n    var yaMayHide = {};\n    var xaMustDisplay = {};\n    var yaMustDisplay = {};\n    var yaMustNotReverse = {};\n    var yaMayReverse = {};\n    var axHasImage = {};\n    var outerTicks = {};\n    var noGrids = {};\n    var i, j;\n\n    // look for axes in the data\n    for(i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n        if(!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n\n        var xaName;\n        if(trace.xaxis) {\n            xaName = id2name(trace.xaxis);\n            appendList(ax2traces, xaName, trace);\n        } else if(trace.xaxes) {\n            for(j = 0; j < trace.xaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n            }\n        }\n\n        var yaName;\n        if(trace.yaxis) {\n            yaName = id2name(trace.yaxis);\n            appendList(ax2traces, yaName, trace);\n        } else if(trace.yaxes) {\n            for(j = 0; j < trace.yaxes.length; j++) {\n                appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n            }\n        }\n\n        // logic for funnels\n        if(trace.type === 'funnel') {\n            if(trace.orientation === 'h') {\n                if(xaName) xaMayHide[xaName] = true;\n                if(yaName) yaMayReverse[yaName] = true;\n            } else {\n                if(yaName) yaMayHide[yaName] = true;\n            }\n        } else if(trace.type === 'image') {\n            if(yaName) axHasImage[yaName] = true;\n            if(xaName) axHasImage[xaName] = true;\n        } else {\n            if(yaName) {\n                yaMustDisplay[yaName] = true;\n                yaMustNotReverse[yaName] = true;\n            }\n\n            if(!traceIs(trace, 'carpet') || (trace.type === 'carpet' && !trace._cheater)) {\n                if(xaName) xaMustDisplay[xaName] = true;\n            }\n        }\n\n        // Two things trigger axis visibility:\n        // 1. is not carpet\n        // 2. carpet that's not cheater\n\n        // The above check for definitely-not-cheater is not adequate. This\n        // second list tracks which axes *could* be a cheater so that the\n        // full condition triggering hiding is:\n        //   *could* be a cheater and *is not definitely visible*\n        if(trace.type === 'carpet' && trace._cheater) {\n            if(xaName) xaMayHide[xaName] = true;\n        }\n\n        // check for default formatting tweaks\n        if(traceIs(trace, '2dMap')) {\n            outerTicks[xaName] = true;\n            outerTicks[yaName] = true;\n        }\n\n        if(traceIs(trace, 'oriented')) {\n            var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n            noGrids[positionAxis] = true;\n        }\n    }\n\n    var subplots = layoutOut._subplots;\n    var xIds = subplots.xaxis;\n    var yIds = subplots.yaxis;\n    var xNames = Lib.simpleMap(xIds, id2name);\n    var yNames = Lib.simpleMap(yIds, id2name);\n    var axNames = xNames.concat(yNames);\n\n    // plot_bgcolor only makes sense if there's a (2D) plot!\n    // TODO: bgcolor for each subplot, to inherit from the main one\n    var plotBgColor = Color.background;\n    if(xIds.length && yIds.length) {\n        plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n    }\n\n    var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);\n\n    // name of single axis (e.g. 'xaxis', 'yaxis2')\n    var axName;\n    // id of single axis (e.g. 'y', 'x5')\n    var axId;\n    // 'x' or 'y'\n    var axLetter;\n    // input layout axis container\n    var axLayoutIn;\n    // full layout axis container\n    var axLayoutOut;\n\n    function newAxLayoutOut() {\n        var traces = ax2traces[axName] || [];\n        axLayoutOut._traceIndices = traces.map(function(t) { return t._expandedIndex; });\n        axLayoutOut._annIndices = [];\n        axLayoutOut._shapeIndices = [];\n        axLayoutOut._imgIndices = [];\n        axLayoutOut._subplotsWith = [];\n        axLayoutOut._counterAxes = [];\n        axLayoutOut._name = axLayoutOut._attr = axName;\n        axLayoutOut._id = axId;\n    }\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function coerce2(attr, dflt) {\n        return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n    }\n\n    function getCounterAxes(axLetter) {\n        return (axLetter === 'x') ? yIds : xIds;\n    }\n\n    function getOverlayableAxes(axLetter, axName) {\n        var list = (axLetter === 'x') ? xNames : yNames;\n        var out = [];\n\n        for(var j = 0; j < list.length; j++) {\n            var axName2 = list[j];\n\n            if(axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n                out.push(name2id(axName2));\n            }\n        }\n\n        return out;\n    }\n\n    // list of available counter axis names\n    var counterAxes = {x: getCounterAxes('x'), y: getCounterAxes('y')};\n    // list of all x AND y axis ids\n    var allAxisIds = counterAxes.x.concat(counterAxes.y);\n    // lookup and list of axis ids that axes in axNames have a reference to,\n    // even though they are missing from allAxisIds\n    var missingMatchedAxisIdsLookup = {};\n    var missingMatchedAxisIds = [];\n\n    // fill in 'missing' axis lookup when an axis is set to match an axis\n    // not part of the allAxisIds list, save axis type so that we can propagate\n    // it to the missing axes\n    function addMissingMatchedAxis() {\n        var matchesIn = axLayoutIn.matches;\n        if(AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n        }\n    }\n\n    var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);\n    var unifiedHover = isUnifiedHover(hovermode);\n\n    // first pass creates the containers, determines types, and handles most of the settings\n    for(i = 0; i < axNames.length; i++) {\n        axName = axNames[i];\n        axId = name2id(axName);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var visibleDflt =\n            (axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName]) ||\n            (axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName]);\n\n        var reverseDflt =\n            (axLetter === 'y' &&\n              (\n                (!yaMustNotReverse[axName] && yaMayReverse[axName]) ||\n                axHasImage[axName]\n              ));\n\n        var defaultOptions = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: ax2traces[axName] || [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: visibleDflt,\n            reverseDflt: reverseDflt,\n            autotypenumbersDflt: autotypenumbersDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n\n        var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n        var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n        var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n        var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n        var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n        var spikesnap = coerce2('spikesnap');\n        var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n        if(!showSpikes) {\n            delete axLayoutOut.spikecolor;\n            delete axLayoutOut.spikethickness;\n            delete axLayoutOut.spikedash;\n            delete axLayoutOut.spikemode;\n            delete axLayoutOut.spikesnap;\n        }\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid\n        });\n\n        coerce('title.standoff');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // coerce the 'missing' axes\n    i = 0;\n    while(i < missingMatchedAxisIds.length) {\n        axId = missingMatchedAxisIds[i++];\n        axName = id2name(axId);\n        axLetter = axName.charAt(0);\n\n        if(!Lib.isPlainObject(layoutIn[axName])) {\n            layoutIn[axName] = {};\n        }\n\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n        newAxLayoutOut();\n\n        var defaultOptions2 = {\n            letter: axLetter,\n            font: layoutOut.font,\n            outerTicks: outerTicks[axName],\n            showGrid: !noGrids[axName],\n            data: [],\n            bgColor: bgColor,\n            calendar: layoutOut.calendar,\n            automargin: true,\n            visibleDflt: false,\n            reverseDflt: false,\n            autotypenumbersDflt: autotypenumbersDflt,\n            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n        };\n\n        coerce('uirevision', layoutOut.uirevision);\n\n        axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n\n        handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n\n        handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n            letter: axLetter,\n            counterAxes: counterAxes[axLetter],\n            overlayableAxes: getOverlayableAxes(axLetter, axName),\n            grid: layoutOut.grid\n        });\n\n        coerce('fixedrange');\n\n        addMissingMatchedAxis();\n\n        axLayoutOut._input = axLayoutIn;\n    }\n\n    // quick second pass for range slider and selector defaults\n    var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n    var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n    for(i = 0; i < xNames.length; i++) {\n        axName = xNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n        if(axLayoutOut.type === 'date') {\n            rangeSelectorDefaults(\n                axLayoutIn,\n                axLayoutOut,\n                layoutOut,\n                yNames,\n                axLayoutOut.calendar\n            );\n        }\n\n        coerce('fixedrange');\n    }\n\n    for(i = 0; i < yNames.length; i++) {\n        axName = yNames[i];\n        axLayoutIn = layoutIn[axName];\n        axLayoutOut = layoutOut[axName];\n\n        var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n\n        var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n\n        coerce('fixedrange', fixedRangeDflt);\n    }\n\n    // Finally, handle scale constraints and matching axes.\n    //\n    // We need to do this after all axes have coerced both `type`\n    // (so we link only axes of the same type) and\n    // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n    constraints.handleDefaults(layoutIn, layoutOut, {\n        axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),\n        axHasImage: axHasImage\n    });\n};\n"]},"metadata":{},"sourceType":"script"}