{"ast":null,"code":"'use strict';\n\nvar constants = require('./constants'); // Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\n\n\nmodule.exports = function makeCrossings(pathinfo) {\n  var z = pathinfo[0].z;\n  var m = z.length;\n  var n = z[0].length; // we already made sure z isn't ragged in interp2d\n\n  var twoWide = m === 2 || n === 2;\n  var xi;\n  var yi;\n  var startIndices;\n  var ystartIndices;\n  var label;\n  var corners;\n  var mi;\n  var pi;\n  var i;\n\n  for (yi = 0; yi < m - 1; yi++) {\n    ystartIndices = [];\n    if (yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n    if (yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n\n    for (xi = 0; xi < n - 1; xi++) {\n      startIndices = ystartIndices.slice();\n      if (xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n      if (xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n      label = xi + ',' + yi;\n      corners = [[z[yi][xi], z[yi][xi + 1]], [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n\n      for (i = 0; i < pathinfo.length; i++) {\n        pi = pathinfo[i];\n        mi = getMarchingIndex(pi.level, corners);\n        if (!mi) continue;\n        pi.crossings[label] = mi;\n\n        if (startIndices.indexOf(mi) !== -1) {\n          pi.starts.push([xi, yi]);\n\n          if (twoWide && startIndices.indexOf(mi, startIndices.indexOf(mi) + 1) !== -1) {\n            // the same square has starts from opposite sides\n            // it's not possible to have starts on opposite edges\n            // of a corner, only a start and an end...\n            // but if the array is only two points wide (either way)\n            // you can have starts on opposite sides.\n            pi.starts.push([xi, yi]);\n          }\n        }\n      }\n    }\n  }\n}; // modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\n\n\nfunction getMarchingIndex(val, corners) {\n  var mi = (corners[0][0] > val ? 0 : 1) + (corners[0][1] > val ? 0 : 2) + (corners[1][1] > val ? 0 : 4) + (corners[1][0] > val ? 0 : 8);\n\n  if (mi === 5 || mi === 10) {\n    var avg = (corners[0][0] + corners[0][1] + corners[1][0] + corners[1][1]) / 4; // two peaks with a big valley\n\n    if (val > avg) return mi === 5 ? 713 : 1114; // two valleys with a big ridge\n\n    return mi === 5 ? 104 : 208;\n  }\n\n  return mi === 15 ? 0 : mi;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/contour/make_crossings.js"],"names":["constants","require","module","exports","makeCrossings","pathinfo","z","m","length","n","twoWide","xi","yi","startIndices","ystartIndices","label","corners","mi","pi","i","concat","BOTTOMSTART","TOPSTART","slice","LEFTSTART","RIGHTSTART","getMarchingIndex","level","crossings","indexOf","starts","push","val","avg"],"mappings":"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","sourcesContent":["'use strict';\n\nvar constants = require('./constants');\n\n// Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\nmodule.exports = function makeCrossings(pathinfo) {\n    var z = pathinfo[0].z;\n    var m = z.length;\n    var n = z[0].length; // we already made sure z isn't ragged in interp2d\n    var twoWide = m === 2 || n === 2;\n    var xi;\n    var yi;\n    var startIndices;\n    var ystartIndices;\n    var label;\n    var corners;\n    var mi;\n    var pi;\n    var i;\n\n    for(yi = 0; yi < m - 1; yi++) {\n        ystartIndices = [];\n        if(yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n        if(yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n\n        for(xi = 0; xi < n - 1; xi++) {\n            startIndices = ystartIndices.slice();\n            if(xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n            if(xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n\n            label = xi + ',' + yi;\n            corners = [[z[yi][xi], z[yi][xi + 1]],\n                       [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n            for(i = 0; i < pathinfo.length; i++) {\n                pi = pathinfo[i];\n                mi = getMarchingIndex(pi.level, corners);\n                if(!mi) continue;\n\n                pi.crossings[label] = mi;\n                if(startIndices.indexOf(mi) !== -1) {\n                    pi.starts.push([xi, yi]);\n                    if(twoWide && startIndices.indexOf(mi,\n                            startIndices.indexOf(mi) + 1) !== -1) {\n                        // the same square has starts from opposite sides\n                        // it's not possible to have starts on opposite edges\n                        // of a corner, only a start and an end...\n                        // but if the array is only two points wide (either way)\n                        // you can have starts on opposite sides.\n                        pi.starts.push([xi, yi]);\n                    }\n                }\n            }\n        }\n    }\n};\n\n// modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\nfunction getMarchingIndex(val, corners) {\n    var mi = (corners[0][0] > val ? 0 : 1) +\n             (corners[0][1] > val ? 0 : 2) +\n             (corners[1][1] > val ? 0 : 4) +\n             (corners[1][0] > val ? 0 : 8);\n    if(mi === 5 || mi === 10) {\n        var avg = (corners[0][0] + corners[0][1] +\n                   corners[1][0] + corners[1][1]) / 4;\n        // two peaks with a big valley\n        if(val > avg) return (mi === 5) ? 713 : 1114;\n        // two valleys with a big ridge\n        return (mi === 5) ? 104 : 208;\n    }\n    return (mi === 15) ? 0 : mi;\n}\n"]},"metadata":{},"sourceType":"script"}