{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar dateTime2ms = Lib.dateTime2ms;\nvar incrementMonth = Lib.incrementMonth;\n\nvar constants = require('../../constants/numerical');\n\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\n\nmodule.exports = function alignPeriod(trace, ax, axLetter, vals) {\n  if (ax.type !== 'date') return {\n    vals: vals\n  };\n  var alignment = trace[axLetter + 'periodalignment'];\n  if (!alignment) return {\n    vals: vals\n  };\n  var period = trace[axLetter + 'period'];\n  var mPeriod;\n\n  if (isNumeric(period)) {\n    period = +period;\n    if (period <= 0) return {\n      vals: vals\n    };\n  } else if (typeof period === 'string' && period.charAt(0) === 'M') {\n    var n = +period.substring(1);\n\n    if (n > 0 && Math.round(n) === n) {\n      mPeriod = n;\n    } else return {\n      vals: vals\n    };\n  }\n\n  var calendar = ax.calendar;\n  var isStart = 'start' === alignment; // var isMiddle = 'middle' === alignment;\n\n  var isEnd = 'end' === alignment;\n  var period0 = trace[axLetter + 'period0'];\n  var base = dateTime2ms(period0, calendar) || 0;\n  var newVals = [];\n  var starts = [];\n  var ends = [];\n  var len = vals.length;\n\n  for (var i = 0; i < len; i++) {\n    var v = vals[i];\n    var nEstimated, startTime, endTime;\n\n    if (mPeriod) {\n      // guess at how many periods away from base we are\n      nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));\n      endTime = incrementMonth(base, mPeriod * nEstimated, calendar); // iterate to get the exact bounds before and after v\n      // there may be ways to make this faster, but most of the time\n      // we'll only execute each loop zero or one time.\n\n      while (endTime > v) {\n        endTime = incrementMonth(endTime, -mPeriod, calendar);\n      }\n\n      while (endTime <= v) {\n        endTime = incrementMonth(endTime, mPeriod, calendar);\n      } // now we know endTime is the boundary immediately after v\n      // so startTime is obtained by incrementing backward one period.\n\n\n      startTime = incrementMonth(endTime, -mPeriod, calendar);\n    } else {\n      // case of ms\n      nEstimated = Math.round((v - base) / period);\n      endTime = base + nEstimated * period;\n\n      while (endTime > v) {\n        endTime -= period;\n      }\n\n      while (endTime <= v) {\n        endTime += period;\n      }\n\n      startTime = endTime - period;\n    }\n\n    newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;\n    starts[i] = startTime;\n    ends[i] = endTime;\n  }\n\n  return {\n    vals: newVals,\n    starts: starts,\n    ends: ends\n  };\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/align_period.js"],"names":["isNumeric","require","Lib","dateTime2ms","incrementMonth","constants","ONEAVGMONTH","module","exports","alignPeriod","trace","ax","axLetter","vals","type","alignment","period","mPeriod","charAt","n","substring","Math","round","calendar","isStart","isEnd","period0","base","newVals","starts","ends","len","length","i","v","nEstimated","startTime","endTime"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar dateTime2ms = Lib.dateTime2ms;\nvar incrementMonth = Lib.incrementMonth;\nvar constants = require('../../constants/numerical');\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\n\nmodule.exports = function alignPeriod(trace, ax, axLetter, vals) {\n    if(ax.type !== 'date') return {vals: vals};\n\n    var alignment = trace[axLetter + 'periodalignment'];\n    if(!alignment) return {vals: vals};\n\n    var period = trace[axLetter + 'period'];\n    var mPeriod;\n    if(isNumeric(period)) {\n        period = +period;\n        if(period <= 0) return {vals: vals};\n    } else if(typeof period === 'string' && period.charAt(0) === 'M') {\n        var n = +(period.substring(1));\n        if(n > 0 && Math.round(n) === n) {\n            mPeriod = n;\n        } else return {vals: vals};\n    }\n\n    var calendar = ax.calendar;\n\n    var isStart = 'start' === alignment;\n    // var isMiddle = 'middle' === alignment;\n    var isEnd = 'end' === alignment;\n\n    var period0 = trace[axLetter + 'period0'];\n    var base = dateTime2ms(period0, calendar) || 0;\n\n    var newVals = [];\n    var starts = [];\n    var ends = [];\n\n    var len = vals.length;\n    for(var i = 0; i < len; i++) {\n        var v = vals[i];\n\n        var nEstimated, startTime, endTime;\n        if(mPeriod) {\n            // guess at how many periods away from base we are\n            nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));\n            endTime = incrementMonth(base, mPeriod * nEstimated, calendar);\n\n            // iterate to get the exact bounds before and after v\n            // there may be ways to make this faster, but most of the time\n            // we'll only execute each loop zero or one time.\n            while(endTime > v) {\n                endTime = incrementMonth(endTime, -mPeriod, calendar);\n            }\n            while(endTime <= v) {\n                endTime = incrementMonth(endTime, mPeriod, calendar);\n            }\n\n            // now we know endTime is the boundary immediately after v\n            // so startTime is obtained by incrementing backward one period.\n            startTime = incrementMonth(endTime, -mPeriod, calendar);\n        } else { // case of ms\n            nEstimated = Math.round((v - base) / period);\n            endTime = base + nEstimated * period;\n\n            while(endTime > v) {\n                endTime -= period;\n            }\n            while(endTime <= v) {\n                endTime += period;\n            }\n\n            startTime = endTime - period;\n        }\n\n        newVals[i] = (\n            isStart ? startTime :\n            isEnd ? endTime :\n            (startTime + endTime) / 2\n        );\n\n        starts[i] = startTime;\n        ends[i] = endTime;\n    }\n\n    return {\n        vals: newVals,\n        starts: starts,\n        ends: ends\n    };\n};\n"]},"metadata":{},"sourceType":"script"}