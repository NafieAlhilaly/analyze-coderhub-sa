{"ast":null,"code":"'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar makeColorScaleFn = require('../../components/colorscale').makeColorScaleFuncFromTrace;\n\nvar makePullColorFn = require('../pie/calc').makePullColorFn;\n\nvar generateExtendedColors = require('../pie/calc').generateExtendedColors;\n\nvar colorscaleCalc = require('../../components/colorscale').calc;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar sunburstExtendedColorWays = {};\nvar treemapExtendedColorWays = {};\nvar icicleExtendedColorWays = {};\n\nexports.calc = function (gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var ids = trace.ids;\n  var hasIds = Lib.isArrayOrTypedArray(ids);\n  var labels = trace.labels;\n  var parents = trace.parents;\n  var values = trace.values;\n  var hasValues = Lib.isArrayOrTypedArray(values);\n  var cd = [];\n  var parent2children = {};\n  var refs = {};\n\n  var addToLookup = function (parent, v) {\n    if (parent2children[parent]) parent2children[parent].push(v);else parent2children[parent] = [v];\n    refs[v] = 1;\n  }; // treat number `0` as valid\n\n\n  var isValidKey = function (k) {\n    return k || typeof k === 'number';\n  };\n\n  var isValidVal = function (i) {\n    return !hasValues || isNumeric(values[i]) && values[i] >= 0;\n  };\n\n  var len;\n  var isValid;\n  var getId;\n\n  if (hasIds) {\n    len = Math.min(ids.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(ids[i]) && isValidVal(i);\n    };\n\n    getId = function (i) {\n      return String(ids[i]);\n    };\n  } else {\n    len = Math.min(labels.length, parents.length);\n\n    isValid = function (i) {\n      return isValidKey(labels[i]) && isValidVal(i);\n    }; // TODO We could allow some label / parent duplication\n    //\n    // From AJ:\n    //  It would work OK for one level\n    //  (multiple rows with the same name and different parents -\n    //  or even the same parent) but if that name is then used as a parent\n    //  which one is it?\n\n\n    getId = function (i) {\n      return String(labels[i]);\n    };\n  }\n\n  if (hasValues) len = Math.min(len, values.length);\n\n  for (var i = 0; i < len; i++) {\n    if (isValid(i)) {\n      var id = getId(i);\n      var pid = isValidKey(parents[i]) ? String(parents[i]) : '';\n      var cdi = {\n        i: i,\n        id: id,\n        pid: pid,\n        label: isValidKey(labels[i]) ? String(labels[i]) : ''\n      };\n      if (hasValues) cdi.v = +values[i];\n      cd.push(cdi);\n      addToLookup(pid, id);\n    }\n  }\n\n  if (!parent2children['']) {\n    var impliedRoots = [];\n    var k;\n\n    for (k in parent2children) {\n      if (!refs[k]) {\n        impliedRoots.push(k);\n      }\n    } // if an `id` has no ref in the `parents` array,\n    // take it as being the root node\n\n\n    if (impliedRoots.length === 1) {\n      k = impliedRoots[0];\n      cd.unshift({\n        hasImpliedRoot: true,\n        id: k,\n        pid: '',\n        label: k\n      });\n    } else {\n      return Lib.warn(['Multiple implied roots, cannot build', trace.type, 'hierarchy of', trace.name + '.', 'These roots include:', impliedRoots.join(', ')].join(' '));\n    }\n  } else if (parent2children[''].length > 1) {\n    var dummyId = Lib.randstr(); // if multiple rows linked to the root node,\n    // add dummy \"root of roots\" node to make d3 build the hierarchy successfully\n\n    for (var j = 0; j < cd.length; j++) {\n      if (cd[j].pid === '') {\n        cd[j].pid = dummyId;\n      }\n    }\n\n    cd.unshift({\n      hasMultipleRoots: true,\n      id: dummyId,\n      pid: '',\n      label: ''\n    });\n  } // TODO might be better to replace stratify() with our own algorithm\n\n\n  var root;\n\n  try {\n    root = d3Hierarchy.stratify().id(function (d) {\n      return d.id;\n    }).parentId(function (d) {\n      return d.pid;\n    })(cd);\n  } catch (e) {\n    return Lib.warn(['Failed to build', trace.type, 'hierarchy of', trace.name + '.', 'Error:', e.message].join(' '));\n  }\n\n  var hierarchy = d3Hierarchy.hierarchy(root);\n  var failed = false;\n\n  if (hasValues) {\n    switch (trace.branchvalues) {\n      case 'remainder':\n        hierarchy.sum(function (d) {\n          return d.data.v;\n        });\n        break;\n\n      case 'total':\n        hierarchy.each(function (d) {\n          var cdi = d.data.data;\n          var v = cdi.v;\n\n          if (d.children) {\n            var partialSum = d.children.reduce(function (a, c) {\n              return a + c.data.data.v;\n            }, 0); // N.B. we must fill in `value` for generated sectors\n            // with the partialSum to compute the correct partition\n\n            if (cdi.hasImpliedRoot || cdi.hasMultipleRoots) {\n              v = partialSum;\n            }\n\n            if (v < partialSum * ALMOST_EQUAL) {\n              failed = true;\n              return Lib.warn(['Total value for node', d.data.data.id, 'of', trace.name, 'is smaller than the sum of its children.', '\\nparent value =', v, '\\nchildren sum =', partialSum].join(' '));\n            }\n          }\n\n          d.value = v;\n        });\n        break;\n    }\n  } else {\n    countDescendants(hierarchy, trace, {\n      branches: trace.count.indexOf('branches') !== -1,\n      leaves: trace.count.indexOf('leaves') !== -1\n    });\n  }\n\n  if (failed) return; // TODO add way to sort by height also?\n\n  if (trace.sort) {\n    hierarchy.sort(function (a, b) {\n      return b.value - a.value;\n    });\n  }\n\n  var pullColor;\n  var scaleColor;\n  var colors = trace.marker.colors || [];\n  var hasColors = !!colors.length;\n\n  if (trace._hasColorscale) {\n    if (!hasColors) {\n      colors = hasValues ? trace.values : trace._values;\n    }\n\n    colorscaleCalc(gd, trace, {\n      vals: colors,\n      containerStr: 'marker',\n      cLetter: 'c'\n    });\n    scaleColor = makeColorScaleFn(trace.marker);\n  } else {\n    pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n  } // TODO keep track of 'root-children' (i.e. branch) for hover info etc.\n\n\n  hierarchy.each(function (d) {\n    var cdi = d.data.data; // N.B. this mutates items in `cd`\n\n    cdi.color = trace._hasColorscale ? scaleColor(colors[cdi.i]) : pullColor(colors[cdi.i], cdi.id);\n  });\n  cd[0].hierarchy = hierarchy;\n  return cd;\n};\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\n\n\nexports._runCrossTraceCalc = function (desiredType, gd) {\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var colorWay = fullLayout[desiredType + 'colorway'];\n  var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n  if (fullLayout['extend' + desiredType + 'colors']) {\n    colorWay = generateExtendedColors(colorWay, desiredType === 'icicle' ? icicleExtendedColorWays : desiredType === 'treemap' ? treemapExtendedColorWays : sunburstExtendedColorWays);\n  }\n\n  var dfltColorCount = 0;\n  var rootColor;\n\n  function pickColor(d) {\n    var cdi = d.data.data;\n    var id = cdi.id;\n\n    if (cdi.color === false) {\n      if (colorMap[id]) {\n        // have we seen this label and assigned a color to it in a previous trace?\n        cdi.color = colorMap[id];\n      } else if (d.parent) {\n        if (d.parent.parent) {\n          // from third-level on, inherit from parent\n          cdi.color = d.parent.data.data.color;\n        } else {\n          // pick new color for second level\n          colorMap[id] = cdi.color = colorWay[dfltColorCount % colorWay.length];\n          dfltColorCount++;\n        }\n      } else {\n        // set root color. no coloring by default.\n        cdi.color = rootColor;\n      }\n    }\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n\n    if (cd0.trace.type === desiredType && cd0.hierarchy) {\n      rootColor = cd0.trace.root.color;\n      cd0.hierarchy.each(pickColor);\n    }\n  }\n};\n\nexports.crossTraceCalc = function (gd) {\n  return exports._runCrossTraceCalc('sunburst', gd);\n};\n\nfunction countDescendants(node, trace, opts) {\n  var nChild = 0;\n  var children = node.children;\n\n  if (children) {\n    var len = children.length;\n\n    for (var i = 0; i < len; i++) {\n      nChild += countDescendants(children[i], trace, opts);\n    }\n\n    if (opts.branches) nChild++; // count this branch\n  } else {\n    if (opts.leaves) nChild++; // count this leaf\n  } // save to the node\n\n\n  node.value = node.data.data.value = nChild; // save to the trace\n\n  if (!trace._values) trace._values = [];\n  trace._values[node.data.data.i] = nChild;\n  return nChild;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/sunburst/calc.js"],"names":["d3Hierarchy","require","isNumeric","Lib","makeColorScaleFn","makeColorScaleFuncFromTrace","makePullColorFn","generateExtendedColors","colorscaleCalc","calc","ALMOST_EQUAL","sunburstExtendedColorWays","treemapExtendedColorWays","icicleExtendedColorWays","exports","gd","trace","fullLayout","_fullLayout","ids","hasIds","isArrayOrTypedArray","labels","parents","values","hasValues","cd","parent2children","refs","addToLookup","parent","v","push","isValidKey","k","isValidVal","i","len","isValid","getId","Math","min","length","String","id","pid","cdi","label","impliedRoots","unshift","hasImpliedRoot","warn","type","name","join","dummyId","randstr","j","hasMultipleRoots","root","stratify","d","parentId","e","message","hierarchy","failed","branchvalues","sum","data","each","children","partialSum","reduce","a","c","value","countDescendants","branches","count","indexOf","leaves","sort","b","pullColor","scaleColor","colors","marker","hasColors","_hasColorscale","_values","vals","containerStr","cLetter","color","_runCrossTraceCalc","desiredType","calcdata","colorWay","colorMap","dfltColorCount","rootColor","pickColor","cd0","crossTraceCalc","node","opts","nChild"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar makeColorScaleFn = require('../../components/colorscale').makeColorScaleFuncFromTrace;\nvar makePullColorFn = require('../pie/calc').makePullColorFn;\nvar generateExtendedColors = require('../pie/calc').generateExtendedColors;\nvar colorscaleCalc = require('../../components/colorscale').calc;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar sunburstExtendedColorWays = {};\nvar treemapExtendedColorWays = {};\nvar icicleExtendedColorWays = {};\n\nexports.calc = function(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var ids = trace.ids;\n    var hasIds = Lib.isArrayOrTypedArray(ids);\n    var labels = trace.labels;\n    var parents = trace.parents;\n    var values = trace.values;\n    var hasValues = Lib.isArrayOrTypedArray(values);\n    var cd = [];\n\n    var parent2children = {};\n    var refs = {};\n    var addToLookup = function(parent, v) {\n        if(parent2children[parent]) parent2children[parent].push(v);\n        else parent2children[parent] = [v];\n        refs[v] = 1;\n    };\n\n    // treat number `0` as valid\n    var isValidKey = function(k) {\n        return k || typeof k === 'number';\n    };\n\n    var isValidVal = function(i) {\n        return !hasValues || (isNumeric(values[i]) && values[i] >= 0);\n    };\n\n    var len;\n    var isValid;\n    var getId;\n\n    if(hasIds) {\n        len = Math.min(ids.length, parents.length);\n        isValid = function(i) { return isValidKey(ids[i]) && isValidVal(i); };\n        getId = function(i) { return String(ids[i]); };\n    } else {\n        len = Math.min(labels.length, parents.length);\n        isValid = function(i) { return isValidKey(labels[i]) && isValidVal(i); };\n        // TODO We could allow some label / parent duplication\n        //\n        // From AJ:\n        //  It would work OK for one level\n        //  (multiple rows with the same name and different parents -\n        //  or even the same parent) but if that name is then used as a parent\n        //  which one is it?\n        getId = function(i) { return String(labels[i]); };\n    }\n\n    if(hasValues) len = Math.min(len, values.length);\n\n    for(var i = 0; i < len; i++) {\n        if(isValid(i)) {\n            var id = getId(i);\n            var pid = isValidKey(parents[i]) ? String(parents[i]) : '';\n\n            var cdi = {\n                i: i,\n                id: id,\n                pid: pid,\n                label: isValidKey(labels[i]) ? String(labels[i]) : ''\n            };\n\n            if(hasValues) cdi.v = +values[i];\n            cd.push(cdi);\n            addToLookup(pid, id);\n        }\n    }\n\n    if(!parent2children['']) {\n        var impliedRoots = [];\n        var k;\n        for(k in parent2children) {\n            if(!refs[k]) {\n                impliedRoots.push(k);\n            }\n        }\n\n        // if an `id` has no ref in the `parents` array,\n        // take it as being the root node\n\n        if(impliedRoots.length === 1) {\n            k = impliedRoots[0];\n            cd.unshift({\n                hasImpliedRoot: true,\n                id: k,\n                pid: '',\n                label: k\n            });\n        } else {\n            return Lib.warn([\n                'Multiple implied roots, cannot build', trace.type, 'hierarchy of', trace.name + '.',\n                'These roots include:', impliedRoots.join(', ')\n            ].join(' '));\n        }\n    } else if(parent2children[''].length > 1) {\n        var dummyId = Lib.randstr();\n\n        // if multiple rows linked to the root node,\n        // add dummy \"root of roots\" node to make d3 build the hierarchy successfully\n\n        for(var j = 0; j < cd.length; j++) {\n            if(cd[j].pid === '') {\n                cd[j].pid = dummyId;\n            }\n        }\n\n        cd.unshift({\n            hasMultipleRoots: true,\n            id: dummyId,\n            pid: '',\n            label: ''\n        });\n    }\n\n    // TODO might be better to replace stratify() with our own algorithm\n    var root;\n    try {\n        root = d3Hierarchy.stratify()\n            .id(function(d) { return d.id; })\n            .parentId(function(d) { return d.pid; })(cd);\n    } catch(e) {\n        return Lib.warn([\n            'Failed to build', trace.type, 'hierarchy of', trace.name + '.',\n            'Error:', e.message\n        ].join(' '));\n    }\n\n    var hierarchy = d3Hierarchy.hierarchy(root);\n    var failed = false;\n\n    if(hasValues) {\n        switch(trace.branchvalues) {\n            case 'remainder':\n                hierarchy.sum(function(d) { return d.data.v; });\n                break;\n            case 'total':\n                hierarchy.each(function(d) {\n                    var cdi = d.data.data;\n                    var v = cdi.v;\n\n                    if(d.children) {\n                        var partialSum = d.children.reduce(function(a, c) {\n                            return a + c.data.data.v;\n                        }, 0);\n\n                        // N.B. we must fill in `value` for generated sectors\n                        // with the partialSum to compute the correct partition\n                        if(cdi.hasImpliedRoot || cdi.hasMultipleRoots) {\n                            v = partialSum;\n                        }\n\n                        if(v < partialSum * ALMOST_EQUAL) {\n                            failed = true;\n                            return Lib.warn([\n                                'Total value for node', d.data.data.id, 'of', trace.name,\n                                'is smaller than the sum of its children.',\n                                '\\nparent value =', v,\n                                '\\nchildren sum =', partialSum\n                            ].join(' '));\n                        }\n                    }\n\n                    d.value = v;\n                });\n                break;\n        }\n    } else {\n        countDescendants(hierarchy, trace, {\n            branches: trace.count.indexOf('branches') !== -1,\n            leaves: trace.count.indexOf('leaves') !== -1\n        });\n    }\n\n    if(failed) return;\n\n    // TODO add way to sort by height also?\n    if(trace.sort) {\n        hierarchy.sort(function(a, b) { return b.value - a.value; });\n    }\n\n    var pullColor;\n    var scaleColor;\n    var colors = trace.marker.colors || [];\n    var hasColors = !!colors.length;\n\n    if(trace._hasColorscale) {\n        if(!hasColors) {\n            colors = hasValues ? trace.values : trace._values;\n        }\n\n        colorscaleCalc(gd, trace, {\n            vals: colors,\n            containerStr: 'marker',\n            cLetter: 'c'\n        });\n\n        scaleColor = makeColorScaleFn(trace.marker);\n    } else {\n        pullColor = makePullColorFn(fullLayout['_' + trace.type + 'colormap']);\n    }\n\n    // TODO keep track of 'root-children' (i.e. branch) for hover info etc.\n\n    hierarchy.each(function(d) {\n        var cdi = d.data.data;\n        // N.B. this mutates items in `cd`\n        cdi.color = trace._hasColorscale ?\n            scaleColor(colors[cdi.i]) :\n            pullColor(colors[cdi.i], cdi.id);\n    });\n\n    cd[0].hierarchy = hierarchy;\n\n    return cd;\n};\n\n/*\n * `calc` filled in (and collated) explicit colors.\n * Now we need to propagate these explicit colors to other traces,\n * and fill in default colors.\n * This is done after sorting, so we pick defaults\n * in the order slices will be displayed\n */\nexports._runCrossTraceCalc = function(desiredType, gd) {\n    var fullLayout = gd._fullLayout;\n    var calcdata = gd.calcdata;\n    var colorWay = fullLayout[desiredType + 'colorway'];\n    var colorMap = fullLayout['_' + desiredType + 'colormap'];\n\n    if(fullLayout['extend' + desiredType + 'colors']) {\n        colorWay = generateExtendedColors(colorWay,\n            desiredType === 'icicle' ? icicleExtendedColorWays :\n            desiredType === 'treemap' ? treemapExtendedColorWays :\n                sunburstExtendedColorWays\n        );\n    }\n    var dfltColorCount = 0;\n\n    var rootColor;\n    function pickColor(d) {\n        var cdi = d.data.data;\n        var id = cdi.id;\n\n        if(cdi.color === false) {\n            if(colorMap[id]) {\n                // have we seen this label and assigned a color to it in a previous trace?\n                cdi.color = colorMap[id];\n            } else if(d.parent) {\n                if(d.parent.parent) {\n                    // from third-level on, inherit from parent\n                    cdi.color = d.parent.data.data.color;\n                } else {\n                    // pick new color for second level\n                    colorMap[id] = cdi.color = colorWay[dfltColorCount % colorWay.length];\n                    dfltColorCount++;\n                }\n            } else {\n                // set root color. no coloring by default.\n                cdi.color = rootColor;\n            }\n        }\n    }\n\n    for(var i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0];\n        if(cd0.trace.type === desiredType && cd0.hierarchy) {\n            rootColor = cd0.trace.root.color;\n            cd0.hierarchy.each(pickColor);\n        }\n    }\n};\n\nexports.crossTraceCalc = function(gd) {\n    return exports._runCrossTraceCalc('sunburst', gd);\n};\n\nfunction countDescendants(node, trace, opts) {\n    var nChild = 0;\n\n    var children = node.children;\n    if(children) {\n        var len = children.length;\n\n        for(var i = 0; i < len; i++) {\n            nChild += countDescendants(children[i], trace, opts);\n        }\n\n        if(opts.branches) nChild++; // count this branch\n    } else {\n        if(opts.leaves) nChild++; // count this leaf\n    }\n\n    // save to the node\n    node.value = node.data.data.value = nChild;\n\n    // save to the trace\n    if(!trace._values) trace._values = [];\n    trace._values[node.data.data.i] = nChild;\n\n    return nChild;\n}\n"]},"metadata":{},"sourceType":"script"}