{"ast":null,"code":"'use strict';\n\nmodule.exports = cleanPSLG;\n\nvar UnionFind = require('union-find');\n\nvar boxIntersect = require('box-intersect');\n\nvar segseg = require('robust-segment-intersect');\n\nvar rat = require('big-rat');\n\nvar ratCmp = require('big-rat/cmp');\n\nvar ratToFloat = require('big-rat/to-float');\n\nvar ratVec = require('rat-vec');\n\nvar nextafter = require('nextafter');\n\nvar solveIntersection = require('./lib/rat-seg-intersect'); // Bounds on a rational number when rounded to a float\n\n\nfunction boundRat(r) {\n  var f = ratToFloat(r);\n  return [nextafter(f, -Infinity), nextafter(f, Infinity)];\n} // Convert a list of edges in a pslg to bounding boxes\n\n\nfunction boundEdges(points, edges) {\n  var bounds = new Array(edges.length);\n\n  for (var i = 0; i < edges.length; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n    bounds[i] = [nextafter(Math.min(a[0], b[0]), -Infinity), nextafter(Math.min(a[1], b[1]), -Infinity), nextafter(Math.max(a[0], b[0]), Infinity), nextafter(Math.max(a[1], b[1]), Infinity)];\n  }\n\n  return bounds;\n} // Convert a list of points into bounding boxes by duplicating coords\n\n\nfunction boundPoints(points) {\n  var bounds = new Array(points.length);\n\n  for (var i = 0; i < points.length; ++i) {\n    var p = points[i];\n    bounds[i] = [nextafter(p[0], -Infinity), nextafter(p[1], -Infinity), nextafter(p[0], Infinity), nextafter(p[1], Infinity)];\n  }\n\n  return bounds;\n} // Find all pairs of crossing edges in a pslg (given edge bounds)\n\n\nfunction getCrossings(points, edges, edgeBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, function (i, j) {\n    var e = edges[i];\n    var f = edges[j];\n\n    if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {\n      return;\n    }\n\n    var a = points[e[0]];\n    var b = points[e[1]];\n    var c = points[f[0]];\n    var d = points[f[1]];\n\n    if (segseg(a, b, c, d)) {\n      result.push([i, j]);\n    }\n  });\n  return result;\n} // Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\n\n\nfunction getTJunctions(points, edges, edgeBounds, vertBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, vertBounds, function (i, v) {\n    var e = edges[i];\n\n    if (e[0] === v || e[1] === v) {\n      return;\n    }\n\n    var p = points[v];\n    var a = points[e[0]];\n    var b = points[e[1]];\n\n    if (segseg(a, b, p, p)) {\n      result.push([i, v]);\n    }\n  });\n  return result;\n} // Cut edges along crossings/tjunctions\n\n\nfunction cutEdges(floatPoints, edges, crossings, junctions, useColor) {\n  var i, e; // Convert crossings into tjunctions by constructing rational points\n\n  var ratPoints = floatPoints.map(function (p) {\n    return [rat(p[0]), rat(p[1])];\n  });\n\n  for (i = 0; i < crossings.length; ++i) {\n    var crossing = crossings[i];\n    e = crossing[0];\n    var f = crossing[1];\n    var ee = edges[e];\n    var ef = edges[f];\n    var x = solveIntersection(ratVec(floatPoints[ee[0]]), ratVec(floatPoints[ee[1]]), ratVec(floatPoints[ef[0]]), ratVec(floatPoints[ef[1]]));\n\n    if (!x) {\n      // Segments are parallel, should already be handled by t-junctions\n      continue;\n    }\n\n    var idx = floatPoints.length;\n    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);\n    ratPoints.push(x);\n    junctions.push([e, idx], [f, idx]);\n  } // Sort tjunctions\n\n\n  junctions.sort(function (a, b) {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0];\n    }\n\n    var u = ratPoints[a[1]];\n    var v = ratPoints[b[1]];\n    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);\n  }); // Split edges along junctions\n\n  for (i = junctions.length - 1; i >= 0; --i) {\n    var junction = junctions[i];\n    e = junction[0];\n    var edge = edges[e];\n    var s = edge[0];\n    var t = edge[1]; // Check if edge is not lexicographically sorted\n\n    var a = floatPoints[s];\n    var b = floatPoints[t];\n\n    if ((a[0] - b[0] || a[1] - b[1]) < 0) {\n      var tmp = s;\n      s = t;\n      t = tmp;\n    } // Split leading edge\n\n\n    edge[0] = s;\n    var last = edge[1] = junction[1]; // If we are grouping edges by color, remember to track data\n\n    var color;\n\n    if (useColor) {\n      color = edge[2];\n    } // Split other edges\n\n\n    while (i > 0 && junctions[i - 1][0] === e) {\n      var junction = junctions[--i];\n      var next = junction[1];\n\n      if (useColor) {\n        edges.push([last, next, color]);\n      } else {\n        edges.push([last, next]);\n      }\n\n      last = next;\n    } // Add final edge\n\n\n    if (useColor) {\n      edges.push([last, t, color]);\n    } else {\n      edges.push([last, t]);\n    }\n  } // Return constructed rational points\n\n\n  return ratPoints;\n} // Merge overlapping points\n\n\nfunction dedupPoints(floatPoints, ratPoints, floatBounds) {\n  var numPoints = ratPoints.length;\n  var uf = new UnionFind(numPoints); // Compute rational bounds\n\n  var bounds = [];\n\n  for (var i = 0; i < ratPoints.length; ++i) {\n    var p = ratPoints[i];\n    var xb = boundRat(p[0]);\n    var yb = boundRat(p[1]);\n    bounds.push([nextafter(xb[0], -Infinity), nextafter(yb[0], -Infinity), nextafter(xb[1], Infinity), nextafter(yb[1], Infinity)]);\n  } // Link all points with over lapping boxes\n\n\n  boxIntersect(bounds, function (i, j) {\n    uf.link(i, j);\n  }); // Do 1 pass over points to combine points in label sets\n\n  var noDupes = true;\n  var labels = new Array(numPoints);\n\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n\n    if (j !== i) {\n      // Clear no-dupes flag, zero out label\n      noDupes = false; // Make each point the top-left point from its cell\n\n      floatPoints[j] = [Math.min(floatPoints[i][0], floatPoints[j][0]), Math.min(floatPoints[i][1], floatPoints[j][1])];\n    }\n  } // If no duplicates, return null to signal termination\n\n\n  if (noDupes) {\n    return null;\n  }\n\n  var ptr = 0;\n\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n\n    if (j === i) {\n      labels[i] = ptr;\n      floatPoints[ptr++] = floatPoints[i];\n    } else {\n      labels[i] = -1;\n    }\n  }\n\n  floatPoints.length = ptr; // Do a second pass to fix up missing labels\n\n  for (var i = 0; i < numPoints; ++i) {\n    if (labels[i] < 0) {\n      labels[i] = labels[uf.find(i)];\n    }\n  } // Return resulting union-find data structure\n\n\n  return labels;\n}\n\nfunction compareLex2(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\nfunction compareLex3(a, b) {\n  var d = a[0] - b[0] || a[1] - b[1];\n\n  if (d) {\n    return d;\n  }\n\n  if (a[2] < b[2]) {\n    return -1;\n  } else if (a[2] > b[2]) {\n    return 1;\n  }\n\n  return 0;\n} // Remove duplicate edge labels\n\n\nfunction dedupEdges(edges, labels, useColor) {\n  if (edges.length === 0) {\n    return;\n  }\n\n  if (labels) {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = labels[e[0]];\n      var b = labels[e[1]];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  } else {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = e[0];\n      var b = e[1];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  }\n\n  if (useColor) {\n    edges.sort(compareLex3);\n  } else {\n    edges.sort(compareLex2);\n  }\n\n  var ptr = 1;\n\n  for (var i = 1; i < edges.length; ++i) {\n    var prev = edges[i - 1];\n    var next = edges[i];\n\n    if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {\n      continue;\n    }\n\n    edges[ptr++] = next;\n  }\n\n  edges.length = ptr;\n}\n\nfunction preRound(points, edges, useColor) {\n  var labels = dedupPoints(points, [], boundPoints(points));\n  dedupEdges(edges, labels, useColor);\n  return !!labels;\n} // Repeat until convergence\n\n\nfunction snapRound(points, edges, useColor) {\n  // 1. find edge crossings\n  var edgeBounds = boundEdges(points, edges);\n  var crossings = getCrossings(points, edges, edgeBounds); // 2. find t-junctions\n\n  var vertBounds = boundPoints(points);\n  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds); // 3. cut edges, construct rational points\n\n  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor); // 4. dedupe verts\n\n  var labels = dedupPoints(points, ratPoints, vertBounds); // 5. dedupe edges\n\n  dedupEdges(edges, labels, useColor); // 6. check termination\n\n  if (!labels) {\n    return crossings.length > 0 || tjunctions.length > 0;\n  } // More iterations necessary\n\n\n  return true;\n} // Main loop, runs PSLG clean up until completion\n\n\nfunction cleanPSLG(points, edges, colors) {\n  // If using colors, augment edges with color data\n  var prevEdges;\n\n  if (colors) {\n    prevEdges = edges;\n    var augEdges = new Array(edges.length);\n\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      augEdges[i] = [e[0], e[1], colors[i]];\n    }\n\n    edges = augEdges;\n  } // First round: remove duplicate edges and points\n\n\n  var modified = preRound(points, edges, !!colors); // Run snap rounding until convergence\n\n  while (snapRound(points, edges, !!colors)) {\n    modified = true;\n  } // Strip color tags\n\n\n  if (!!colors && modified) {\n    prevEdges.length = 0;\n    colors.length = 0;\n\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      prevEdges.push([e[0], e[1]]);\n      colors.push(e[2]);\n    }\n  }\n\n  return modified;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/clean-pslg/clean-pslg.js"],"names":["module","exports","cleanPSLG","UnionFind","require","boxIntersect","segseg","rat","ratCmp","ratToFloat","ratVec","nextafter","solveIntersection","boundRat","r","f","Infinity","boundEdges","points","edges","bounds","Array","length","i","e","a","b","Math","min","max","boundPoints","p","getCrossings","edgeBounds","result","j","c","d","push","getTJunctions","vertBounds","v","cutEdges","floatPoints","crossings","junctions","useColor","ratPoints","map","crossing","ee","ef","x","idx","sort","u","junction","edge","s","t","tmp","last","color","next","dedupPoints","floatBounds","numPoints","uf","xb","yb","link","noDupes","labels","find","ptr","compareLex2","compareLex3","dedupEdges","prev","preRound","snapRound","tjunctions","colors","prevEdges","augEdges","modified"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = cleanPSLG\n\nvar UnionFind = require('union-find')\nvar boxIntersect = require('box-intersect')\nvar segseg = require('robust-segment-intersect')\nvar rat = require('big-rat')\nvar ratCmp = require('big-rat/cmp')\nvar ratToFloat = require('big-rat/to-float')\nvar ratVec = require('rat-vec')\nvar nextafter = require('nextafter')\n\nvar solveIntersection = require('./lib/rat-seg-intersect')\n\n// Bounds on a rational number when rounded to a float\nfunction boundRat (r) {\n  var f = ratToFloat(r)\n  return [\n    nextafter(f, -Infinity),\n    nextafter(f, Infinity)\n  ]\n}\n\n// Convert a list of edges in a pslg to bounding boxes\nfunction boundEdges (points, edges) {\n  var bounds = new Array(edges.length)\n  for (var i = 0; i < edges.length; ++i) {\n    var e = edges[i]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    bounds[i] = [\n      nextafter(Math.min(a[0], b[0]), -Infinity),\n      nextafter(Math.min(a[1], b[1]), -Infinity),\n      nextafter(Math.max(a[0], b[0]), Infinity),\n      nextafter(Math.max(a[1], b[1]), Infinity)\n    ]\n  }\n  return bounds\n}\n\n// Convert a list of points into bounding boxes by duplicating coords\nfunction boundPoints (points) {\n  var bounds = new Array(points.length)\n  for (var i = 0; i < points.length; ++i) {\n    var p = points[i]\n    bounds[i] = [\n      nextafter(p[0], -Infinity),\n      nextafter(p[1], -Infinity),\n      nextafter(p[0], Infinity),\n      nextafter(p[1], Infinity)\n    ]\n  }\n  return bounds\n}\n\n// Find all pairs of crossing edges in a pslg (given edge bounds)\nfunction getCrossings (points, edges, edgeBounds) {\n  var result = []\n  boxIntersect(edgeBounds, function (i, j) {\n    var e = edges[i]\n    var f = edges[j]\n    if (e[0] === f[0] || e[0] === f[1] ||\n      e[1] === f[0] || e[1] === f[1]) {\n      return\n    }\n    var a = points[e[0]]\n    var b = points[e[1]]\n    var c = points[f[0]]\n    var d = points[f[1]]\n    if (segseg(a, b, c, d)) {\n      result.push([i, j])\n    }\n  })\n  return result\n}\n\n// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\nfunction getTJunctions (points, edges, edgeBounds, vertBounds) {\n  var result = []\n  boxIntersect(edgeBounds, vertBounds, function (i, v) {\n    var e = edges[i]\n    if (e[0] === v || e[1] === v) {\n      return\n    }\n    var p = points[v]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    if (segseg(a, b, p, p)) {\n      result.push([i, v])\n    }\n  })\n  return result\n}\n\n// Cut edges along crossings/tjunctions\nfunction cutEdges (floatPoints, edges, crossings, junctions, useColor) {\n  var i, e\n\n  // Convert crossings into tjunctions by constructing rational points\n  var ratPoints = floatPoints.map(function(p) {\n      return [\n          rat(p[0]),\n          rat(p[1])\n      ]\n  })\n  for (i = 0; i < crossings.length; ++i) {\n    var crossing = crossings[i]\n    e = crossing[0]\n    var f = crossing[1]\n    var ee = edges[e]\n    var ef = edges[f]\n    var x = solveIntersection(\n      ratVec(floatPoints[ee[0]]),\n      ratVec(floatPoints[ee[1]]),\n      ratVec(floatPoints[ef[0]]),\n      ratVec(floatPoints[ef[1]]))\n    if (!x) {\n      // Segments are parallel, should already be handled by t-junctions\n      continue\n    }\n    var idx = floatPoints.length\n    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])])\n    ratPoints.push(x)\n    junctions.push([e, idx], [f, idx])\n  }\n\n  // Sort tjunctions\n  junctions.sort(function (a, b) {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0]\n    }\n    var u = ratPoints[a[1]]\n    var v = ratPoints[b[1]]\n    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])\n  })\n\n  // Split edges along junctions\n  for (i = junctions.length - 1; i >= 0; --i) {\n    var junction = junctions[i]\n    e = junction[0]\n\n    var edge = edges[e]\n    var s = edge[0]\n    var t = edge[1]\n\n    // Check if edge is not lexicographically sorted\n    var a = floatPoints[s]\n    var b = floatPoints[t]\n    if (((a[0] - b[0]) || (a[1] - b[1])) < 0) {\n      var tmp = s\n      s = t\n      t = tmp\n    }\n\n    // Split leading edge\n    edge[0] = s\n    var last = edge[1] = junction[1]\n\n    // If we are grouping edges by color, remember to track data\n    var color\n    if (useColor) {\n      color = edge[2]\n    }\n\n    // Split other edges\n    while (i > 0 && junctions[i - 1][0] === e) {\n      var junction = junctions[--i]\n      var next = junction[1]\n      if (useColor) {\n        edges.push([last, next, color])\n      } else {\n        edges.push([last, next])\n      }\n      last = next\n    }\n\n    // Add final edge\n    if (useColor) {\n      edges.push([last, t, color])\n    } else {\n      edges.push([last, t])\n    }\n  }\n\n  // Return constructed rational points\n  return ratPoints\n}\n\n// Merge overlapping points\nfunction dedupPoints (floatPoints, ratPoints, floatBounds) {\n  var numPoints = ratPoints.length\n  var uf = new UnionFind(numPoints)\n\n  // Compute rational bounds\n  var bounds = []\n  for (var i = 0; i < ratPoints.length; ++i) {\n    var p = ratPoints[i]\n    var xb = boundRat(p[0])\n    var yb = boundRat(p[1])\n    bounds.push([\n      nextafter(xb[0], -Infinity),\n      nextafter(yb[0], -Infinity),\n      nextafter(xb[1], Infinity),\n      nextafter(yb[1], Infinity)\n    ])\n  }\n\n  // Link all points with over lapping boxes\n  boxIntersect(bounds, function (i, j) {\n    uf.link(i, j)\n  })\n\n  // Do 1 pass over points to combine points in label sets\n  var noDupes = true\n  var labels = new Array(numPoints)\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i)\n    if (j !== i) {\n      // Clear no-dupes flag, zero out label\n      noDupes = false\n      // Make each point the top-left point from its cell\n      floatPoints[j] = [\n        Math.min(floatPoints[i][0], floatPoints[j][0]),\n        Math.min(floatPoints[i][1], floatPoints[j][1])\n      ]\n    }\n  }\n\n  // If no duplicates, return null to signal termination\n  if (noDupes) {\n    return null\n  }\n\n  var ptr = 0\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i)\n    if (j === i) {\n      labels[i] = ptr\n      floatPoints[ptr++] = floatPoints[i]\n    } else {\n      labels[i] = -1\n    }\n  }\n\n  floatPoints.length = ptr\n\n  // Do a second pass to fix up missing labels\n  for (var i = 0; i < numPoints; ++i) {\n    if (labels[i] < 0) {\n      labels[i] = labels[uf.find(i)]\n    }\n  }\n\n  // Return resulting union-find data structure\n  return labels\n}\n\nfunction compareLex2 (a, b) { return (a[0] - b[0]) || (a[1] - b[1]) }\nfunction compareLex3 (a, b) {\n  var d = (a[0] - b[0]) || (a[1] - b[1])\n  if (d) {\n    return d\n  }\n  if (a[2] < b[2]) {\n    return -1\n  } else if (a[2] > b[2]) {\n    return 1\n  }\n  return 0\n}\n\n// Remove duplicate edge labels\nfunction dedupEdges (edges, labels, useColor) {\n  if (edges.length === 0) {\n    return\n  }\n  if (labels) {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      var a = labels[e[0]]\n      var b = labels[e[1]]\n      e[0] = Math.min(a, b)\n      e[1] = Math.max(a, b)\n    }\n  } else {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      var a = e[0]\n      var b = e[1]\n      e[0] = Math.min(a, b)\n      e[1] = Math.max(a, b)\n    }\n  }\n  if (useColor) {\n    edges.sort(compareLex3)\n  } else {\n    edges.sort(compareLex2)\n  }\n  var ptr = 1\n  for (var i = 1; i < edges.length; ++i) {\n    var prev = edges[i - 1]\n    var next = edges[i]\n    if (next[0] === prev[0] && next[1] === prev[1] &&\n      (!useColor || next[2] === prev[2])) {\n      continue\n    }\n    edges[ptr++] = next\n  }\n  edges.length = ptr\n}\n\nfunction preRound (points, edges, useColor) {\n  var labels = dedupPoints(points, [], boundPoints(points))\n  dedupEdges(edges, labels, useColor)\n  return !!labels\n}\n\n// Repeat until convergence\nfunction snapRound (points, edges, useColor) {\n  // 1. find edge crossings\n  var edgeBounds = boundEdges(points, edges)\n  var crossings = getCrossings(points, edges, edgeBounds)\n\n  // 2. find t-junctions\n  var vertBounds = boundPoints(points)\n  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)\n\n  // 3. cut edges, construct rational points\n  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor)\n\n  // 4. dedupe verts\n  var labels = dedupPoints(points, ratPoints, vertBounds)\n\n  // 5. dedupe edges\n  dedupEdges(edges, labels, useColor)\n\n  // 6. check termination\n  if (!labels) {\n    return (crossings.length > 0 || tjunctions.length > 0)\n  }\n\n  // More iterations necessary\n  return true\n}\n\n// Main loop, runs PSLG clean up until completion\nfunction cleanPSLG (points, edges, colors) {\n  // If using colors, augment edges with color data\n  var prevEdges\n  if (colors) {\n    prevEdges = edges\n    var augEdges = new Array(edges.length)\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      augEdges[i] = [e[0], e[1], colors[i]]\n    }\n    edges = augEdges\n  }\n\n  // First round: remove duplicate edges and points\n  var modified = preRound(points, edges, !!colors)\n\n  // Run snap rounding until convergence\n  while (snapRound(points, edges, !!colors)) {\n    modified = true\n  }\n\n  // Strip color tags\n  if (!!colors && modified) {\n    prevEdges.length = 0\n    colors.length = 0\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      prevEdges.push([e[0], e[1]])\n      colors.push(e[2])\n    }\n  }\n\n  return modified\n}\n"]},"metadata":{},"sourceType":"script"}