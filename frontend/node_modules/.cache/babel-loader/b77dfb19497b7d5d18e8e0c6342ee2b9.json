{"ast":null,"code":"/* eslint-disable no-bitwise */\n\n/* eslint-disable consistent-return */\n'use strict'; //////////////////////////////////////////////////////////////////////////\n// Helpers\n//\n\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n} //////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\n\n\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input = jpeg_bin.subarray(exif_start, exif_end); // offset correction for `on_entry` callback\n\n  this.start = exif_start; // Check TIFF header (includes byte alignment and first IFD offset)\n\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  } // true if motorola (big endian) byte alignment, false if intel\n\n\n  this.big_endian = sig[0] === 'M';\n}\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n  var offset = this.read_uint32(4);\n  this.ifds_to_read = [{\n    id: 0,\n    offset: offset\n  }];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x100 + d[offset + 1] : d[offset] + d[offset + 1] * 0x100;\n};\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] : d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return ifd === 0 && tag === 0x8769 || ifd === 0 && tag === 0x8825 || ifd === 0x8769 && tag === 0xA005; // Interop IFD\n}; // Returns byte length of a single component of a given format\n//\n\n\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n\n    case 2: // ascii\n\n    case 6: // sbyte\n\n    case 7:\n      // undefined\n      return 1;\n\n    case 3: // short\n\n    case 8:\n      // sshort\n      return 2;\n\n    case 4: // long\n\n    case 9: // slong\n\n    case 11:\n      // float\n      return 4;\n\n    case 5: // rational\n\n    case 10: // srational\n\n    case 12:\n      // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n}; // Reads Exif data\n//\n\n\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n\n    case 2:\n      // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6:\n      // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3:\n      // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8:\n      // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4:\n      // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9:\n      // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5: // rational\n\n    case 10: // srational\n\n    case 11: // float\n\n    case 12:\n      // double\n      return null;\n    // not implemented\n\n    case 7:\n      // undefined\n      return null;\n    // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count = this.read_uint32(offset + 4);\n    var comp_length = this.exif_format_length(format);\n    var data_length = count * comp_length;\n    var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n\n      if (item === null) {\n        value = null;\n        break;\n      }\n\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id: tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian: this.big_endian,\n      ifd: ifd_no,\n      tag: tag,\n      format: format,\n      count: count,\n      entry_offset: offset + this.start,\n      data_length: data_length,\n      data_offset: data_offset + this.start,\n      value: value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id: 1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\nmodule.exports.ExifParser = ExifParser; // returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\n\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/probe-image-size/lib/exif_utils.js"],"names":["error","message","code","err","Error","utf8_decode","str","decodeURIComponent","escape","_","ExifParser","jpeg_bin","exif_start","exif_end","input","subarray","start","sig","String","fromCharCode","apply","big_endian","prototype","each","on_entry","aborted","offset","read_uint32","ifds_to_read","id","length","i","shift","scan_ifd","read_uint16","d","is_subifd_link","ifd","tag","exif_format_length","format","exif_format_read","v","ifd_no","entry_count","count","comp_length","data_length","data_offset","value","comp_offset","j","item","push","Array","isArray","slice","Number","isInteger","entry","is_big_endian","entry_offset","module","exports","get_orientation","data","orientation"],"mappings":"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","sourcesContent":["\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\n'use strict';\n\n//////////////////////////////////////////////////////////////////////////\n// Helpers\n//\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input      = jpeg_bin.subarray(exif_start, exif_end);\n\n  // offset correction for `on_entry` callback\n  this.start      = exif_start;\n\n  // Check TIFF header (includes byte alignment and first IFD offset)\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  // true if motorola (big endian) byte alignment, false if intel\n  this.big_endian = sig[0] === 'M';\n}\n\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n\n  var offset = this.read_uint32(4);\n\n  this.ifds_to_read = [ {\n    id:     0,\n    offset: offset\n  } ];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x100 + d[offset + 1] :\n    d[offset] + d[offset + 1] * 0x100;\n};\n\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] :\n    d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return (ifd === 0 && tag === 0x8769) || // SubIFD\n         (ifd === 0 && tag === 0x8825) || // GPS Info\n         (ifd === 0x8769 && tag === 0xA005); // Interop IFD\n};\n\n\n// Returns byte length of a single component of a given format\n//\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7: // undefined\n      return 1;\n\n    case 3: // short\n    case 8: // sshort\n      return 2;\n\n    case 4:  // long\n    case 9:  // slong\n    case 11: // float\n      return 4;\n\n    case 5:  // rational\n    case 10: // srational\n    case 12: // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n};\n\n\n// Reads Exif data\n//\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6: // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3: // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8: // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4: // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9: // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5:  // rational\n    case 10: // srational\n    case 11: // float\n    case 12: // double\n      return null; // not implemented\n\n    case 7: // undefined\n      return null; // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag    = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count  = this.read_uint32(offset + 4);\n\n    var comp_length    = this.exif_format_length(format);\n    var data_length    = count * comp_length;\n    var data_offset    = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n      if (item === null) {\n        value = null;\n        break;\n      }\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id:     tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian:  this.big_endian,\n      ifd:            ifd_no,\n      tag:            tag,\n      format:         format,\n      count:          count,\n      entry_offset:   offset + this.start,\n      data_length:    data_length,\n      data_offset:    data_offset + this.start,\n      value:          value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id:     1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\n\nmodule.exports.ExifParser = ExifParser;\n\n// returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}