{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar axisIds = require('./axis_ids');\n/**\n * Factory function for checking component arrays for subplot references.\n *\n * @param {string} containerArrayName: the top-level array in gd.layout to check\n *   If an item in this container is found that references a cartesian x and/or y axis,\n *   ensure cartesian is marked as a base plot module and record the axes (and subplot\n *   if both refs are axes) in gd._fullLayout\n *\n * @return {function}: with args layoutIn (gd.layout) and layoutOut (gd._fullLayout)\n * as expected of a component includeBasePlot method\n */\n\n\nmodule.exports = function makeIncludeComponents(containerArrayName) {\n  return function includeComponents(layoutIn, layoutOut) {\n    var array = layoutIn[containerArrayName];\n    if (!Array.isArray(array)) return;\n    var Cartesian = Registry.subplotsRegistry.cartesian;\n    var idRegex = Cartesian.idRegex;\n    var subplots = layoutOut._subplots;\n    var xaList = subplots.xaxis;\n    var yaList = subplots.yaxis;\n    var cartesianList = subplots.cartesian;\n\n    var hasCartesianOrGL2D = layoutOut._has('cartesian') || layoutOut._has('gl2d');\n\n    for (var i = 0; i < array.length; i++) {\n      var itemi = array[i];\n      if (!Lib.isPlainObject(itemi)) continue; // call cleanId because if xref, or yref has something appended\n      // (e.g., ' domain') this will get removed.\n\n      var xref = axisIds.cleanId(itemi.xref, 'x', false);\n      var yref = axisIds.cleanId(itemi.yref, 'y', false);\n      var hasXref = idRegex.x.test(xref);\n      var hasYref = idRegex.y.test(yref);\n\n      if (hasXref || hasYref) {\n        if (!hasCartesianOrGL2D) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);\n        var newAxis = false;\n\n        if (hasXref && xaList.indexOf(xref) === -1) {\n          xaList.push(xref);\n          newAxis = true;\n        }\n\n        if (hasYref && yaList.indexOf(yref) === -1) {\n          yaList.push(yref);\n          newAxis = true;\n        }\n        /*\n         * Notice the logic here: only add a subplot for a component if\n         * it's referencing both x and y axes AND it's creating a new axis\n         * so for example if your plot already has xy and x2y2, an annotation\n         * on x2y or xy2 will not create a new subplot.\n         */\n\n\n        if (newAxis && hasXref && hasYref) {\n          cartesianList.push(xref + yref);\n        }\n      }\n    }\n  };\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/cartesian/include_components.js"],"names":["Registry","require","Lib","axisIds","module","exports","makeIncludeComponents","containerArrayName","includeComponents","layoutIn","layoutOut","array","Array","isArray","Cartesian","subplotsRegistry","cartesian","idRegex","subplots","_subplots","xaList","xaxis","yaList","yaxis","cartesianList","hasCartesianOrGL2D","_has","i","length","itemi","isPlainObject","xref","cleanId","yref","hasXref","x","test","hasYref","y","pushUnique","_basePlotModules","newAxis","indexOf","push"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAD,CAArB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiB,SAASC,qBAAT,CAA+BC,kBAA/B,EAAmD;AAChE,SAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,SAArC,EAAgD;AACnD,QAAIC,KAAK,GAAGF,QAAQ,CAACF,kBAAD,CAApB;AACA,QAAG,CAACK,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AAE1B,QAAIG,SAAS,GAAGd,QAAQ,CAACe,gBAAT,CAA0BC,SAA1C;AACA,QAAIC,OAAO,GAAGH,SAAS,CAACG,OAAxB;AACA,QAAIC,QAAQ,GAAGR,SAAS,CAACS,SAAzB;AACA,QAAIC,MAAM,GAAGF,QAAQ,CAACG,KAAtB;AACA,QAAIC,MAAM,GAAGJ,QAAQ,CAACK,KAAtB;AACA,QAAIC,aAAa,GAAGN,QAAQ,CAACF,SAA7B;;AACA,QAAIS,kBAAkB,GAAGf,SAAS,CAACgB,IAAV,CAAe,WAAf,KAA+BhB,SAAS,CAACgB,IAAV,CAAe,MAAf,CAAxD;;AAEA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGhB,KAAK,CAACiB,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AAClC,UAAIE,KAAK,GAAGlB,KAAK,CAACgB,CAAD,CAAjB;AACA,UAAG,CAACzB,GAAG,CAAC4B,aAAJ,CAAkBD,KAAlB,CAAJ,EAA8B,SAFI,CAIlC;AACA;;AACA,UAAIE,IAAI,GAAG5B,OAAO,CAAC6B,OAAR,CAAgBH,KAAK,CAACE,IAAtB,EAA4B,GAA5B,EAAiC,KAAjC,CAAX;AACA,UAAIE,IAAI,GAAG9B,OAAO,CAAC6B,OAAR,CAAgBH,KAAK,CAACI,IAAtB,EAA4B,GAA5B,EAAiC,KAAjC,CAAX;AAEA,UAAIC,OAAO,GAAGjB,OAAO,CAACkB,CAAR,CAAUC,IAAV,CAAeL,IAAf,CAAd;AACA,UAAIM,OAAO,GAAGpB,OAAO,CAACqB,CAAR,CAAUF,IAAV,CAAeH,IAAf,CAAd;;AACA,UAAGC,OAAO,IAAIG,OAAd,EAAuB;AACnB,YAAG,CAACZ,kBAAJ,EAAwBvB,GAAG,CAACqC,UAAJ,CAAe7B,SAAS,CAAC8B,gBAAzB,EAA2C1B,SAA3C;AAExB,YAAI2B,OAAO,GAAG,KAAd;;AACA,YAAGP,OAAO,IAAId,MAAM,CAACsB,OAAP,CAAeX,IAAf,MAAyB,CAAC,CAAxC,EAA2C;AACvCX,UAAAA,MAAM,CAACuB,IAAP,CAAYZ,IAAZ;AACAU,UAAAA,OAAO,GAAG,IAAV;AACH;;AACD,YAAGJ,OAAO,IAAIf,MAAM,CAACoB,OAAP,CAAeT,IAAf,MAAyB,CAAC,CAAxC,EAA2C;AACvCX,UAAAA,MAAM,CAACqB,IAAP,CAAYV,IAAZ;AACAQ,UAAAA,OAAO,GAAG,IAAV;AACH;AAED;AAChB;AACA;AACA;AACA;AACA;;;AACgB,YAAGA,OAAO,IAAIP,OAAX,IAAsBG,OAAzB,EAAkC;AAC9Bb,UAAAA,aAAa,CAACmB,IAAd,CAAmBZ,IAAI,GAAGE,IAA1B;AACH;AACJ;AACJ;AACJ,GA/CD;AAgDH,CAjDD","sourcesContent":["'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar axisIds = require('./axis_ids');\n\n/**\n * Factory function for checking component arrays for subplot references.\n *\n * @param {string} containerArrayName: the top-level array in gd.layout to check\n *   If an item in this container is found that references a cartesian x and/or y axis,\n *   ensure cartesian is marked as a base plot module and record the axes (and subplot\n *   if both refs are axes) in gd._fullLayout\n *\n * @return {function}: with args layoutIn (gd.layout) and layoutOut (gd._fullLayout)\n * as expected of a component includeBasePlot method\n */\nmodule.exports = function makeIncludeComponents(containerArrayName) {\n    return function includeComponents(layoutIn, layoutOut) {\n        var array = layoutIn[containerArrayName];\n        if(!Array.isArray(array)) return;\n\n        var Cartesian = Registry.subplotsRegistry.cartesian;\n        var idRegex = Cartesian.idRegex;\n        var subplots = layoutOut._subplots;\n        var xaList = subplots.xaxis;\n        var yaList = subplots.yaxis;\n        var cartesianList = subplots.cartesian;\n        var hasCartesianOrGL2D = layoutOut._has('cartesian') || layoutOut._has('gl2d');\n\n        for(var i = 0; i < array.length; i++) {\n            var itemi = array[i];\n            if(!Lib.isPlainObject(itemi)) continue;\n\n            // call cleanId because if xref, or yref has something appended\n            // (e.g., ' domain') this will get removed.\n            var xref = axisIds.cleanId(itemi.xref, 'x', false);\n            var yref = axisIds.cleanId(itemi.yref, 'y', false);\n\n            var hasXref = idRegex.x.test(xref);\n            var hasYref = idRegex.y.test(yref);\n            if(hasXref || hasYref) {\n                if(!hasCartesianOrGL2D) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);\n\n                var newAxis = false;\n                if(hasXref && xaList.indexOf(xref) === -1) {\n                    xaList.push(xref);\n                    newAxis = true;\n                }\n                if(hasYref && yaList.indexOf(yref) === -1) {\n                    yaList.push(yref);\n                    newAxis = true;\n                }\n\n                /*\n                 * Notice the logic here: only add a subplot for a component if\n                 * it's referencing both x and y axes AND it's creating a new axis\n                 * so for example if your plot already has xy and x2y2, an annotation\n                 * on x2y or xy2 will not create a new subplot.\n                 */\n                if(newAxis && hasXref && hasYref) {\n                    cartesianList.push(xref + yref);\n                }\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"script"}