{"ast":null,"code":"/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n'use strict';\n\nconst search = require('binary-search-bounds');\n\nconst clamp = require('clamp');\n\nconst rect = require('parse-rect');\n\nconst getBounds = require('array-bounds');\n\nconst pick = require('pick-by-alias');\n\nconst defined = require('defined');\n\nconst flatten = require('flatten-vertex-data');\n\nconst isObj = require('is-obj');\n\nconst dtype = require('dtype');\n\nconst log2 = require('math-log2');\n\nconst MAX_GROUP_ID = 1073741824;\n\nmodule.exports = function cluster(srcPoints, options) {\n  if (!options) options = {};\n  srcPoints = flatten(srcPoints, 'float64');\n  options = pick(options, {\n    bounds: 'range bounds dataBox databox',\n    maxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n    dtype: 'type dtype format out dst output destination' // sort: 'sortBy sortby sort',\n    // pick: 'pick levelPoint',\n    // nodeSize: 'node nodeSize minNodeSize minSize size'\n\n  }); // let nodeSize = defined(options.nodeSize, 1)\n\n  let maxDepth = defined(options.maxDepth, 255);\n  let bounds = defined(options.bounds, getBounds(srcPoints, 2));\n  if (bounds[0] === bounds[2]) bounds[2]++;\n  if (bounds[1] === bounds[3]) bounds[3]++;\n  let points = normalize(srcPoints, bounds); // init variables\n\n  let n = srcPoints.length >>> 1;\n  let ids;\n  if (!options.dtype) options.dtype = 'array';\n\n  if (typeof options.dtype === 'string') {\n    ids = new (dtype(options.dtype))(n);\n  } else if (options.dtype) {\n    ids = options.dtype;\n    if (Array.isArray(ids)) ids.length = n;\n  }\n\n  for (let i = 0; i < n; ++i) {\n    ids[i] = i;\n  } // representative point indexes for levels\n\n\n  let levels = []; // starting indexes of subranges in sub levels, levels.length * 4\n\n  let sublevels = []; // unique group ids, sorted in z-curve fashion within levels by shifting bits\n\n  let groups = []; // level offsets in `ids`\n\n  let offsets = []; // sort points\n\n  sort(0, 0, 1, ids, 0, 1); // return reordered ids with provided methods\n  // save level offsets in output buffer\n\n  let offset = 0;\n\n  for (let level = 0; level < levels.length; level++) {\n    let levelItems = levels[level];\n    if (ids.set) ids.set(levelItems, offset);else {\n      for (let i = 0, l = levelItems.length; i < l; i++) {\n        ids[i + offset] = levelItems[i];\n      }\n    }\n    let nextOffset = offset + levels[level].length;\n    offsets[level] = [offset, nextOffset];\n    offset = nextOffset;\n  }\n\n  ids.range = range;\n  return ids; // FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n\n  function sort(x, y, diam, ids, level, group) {\n    if (!ids.length) return null; // save first point as level representative\n\n    let levelItems = levels[level] || (levels[level] = []);\n    let levelGroups = groups[level] || (groups[level] = []);\n    let sublevel = sublevels[level] || (sublevels[level] = []);\n    let offset = levelItems.length;\n    level++; // max depth reached - put all items into a first group\n    // alternatively - if group id overflow - avoid proceeding\n\n    if (level > maxDepth || group > MAX_GROUP_ID) {\n      for (let i = 0; i < ids.length; i++) {\n        levelItems.push(ids[i]);\n        levelGroups.push(group);\n        sublevel.push(null, null, null, null);\n      }\n\n      return offset;\n    }\n\n    levelItems.push(ids[0]);\n    levelGroups.push(group);\n\n    if (ids.length <= 1) {\n      sublevel.push(null, null, null, null);\n      return offset;\n    }\n\n    let d2 = diam * .5;\n    let cx = x + d2,\n        cy = y + d2; // distribute points by 4 buckets\n\n    let lolo = [],\n        lohi = [],\n        hilo = [],\n        hihi = [];\n\n    for (let i = 1, l = ids.length; i < l; i++) {\n      let idx = ids[i],\n          x = points[idx * 2],\n          y = points[idx * 2 + 1];\n      x < cx ? y < cy ? lolo.push(idx) : lohi.push(idx) : y < cy ? hilo.push(idx) : hihi.push(idx);\n    }\n\n    group <<= 2;\n    sublevel.push(sort(x, y, d2, lolo, level, group), sort(x, cy, d2, lohi, level, group + 1), sort(cx, y, d2, hilo, level, group + 2), sort(cx, cy, d2, hihi, level, group + 3));\n    return offset;\n  } // get all points within the passed range\n\n\n  function range(...args) {\n    let options;\n\n    if (isObj(args[args.length - 1])) {\n      let arg = args.pop(); // detect if that was a rect object\n\n      if (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n        args = [arg];\n        options = {};\n      }\n\n      options = pick(arg, {\n        level: 'level maxLevel',\n        d: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n        lod: 'lod details ranges offsets'\n      });\n    } else {\n      options = {};\n    }\n\n    if (!args.length) args = bounds;\n    let box = rect(...args);\n    let [minX, minY, maxX, maxY] = [Math.min(box.x, box.x + box.width), Math.min(box.y, box.y + box.height), Math.max(box.x, box.x + box.width), Math.max(box.y, box.y + box.height)];\n    let [nminX, nminY, nmaxX, nmaxY] = normalize([minX, minY, maxX, maxY], bounds);\n    let maxLevel = defined(options.level, levels.length); // limit maxLevel by px size\n\n    if (options.d != null) {\n      let d;\n      if (typeof options.d === 'number') d = [options.d, options.d];else if (options.d.length) d = options.d;\n      maxLevel = Math.min(Math.max(Math.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))), Math.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))), maxLevel);\n    }\n\n    maxLevel = Math.min(maxLevel, levels.length); // return levels of details\n\n    if (options.lod) {\n      return lod(nminX, nminY, nmaxX, nmaxY, maxLevel);\n    } // do selection ids\n\n\n    let selection = []; // FIXME: probably we can do LOD here beforehead\n\n    select(0, 0, 1, 0, 0, 1);\n\n    function select(lox, loy, d, level, from, to) {\n      if (from === null || to === null) return;\n      let hix = lox + d;\n      let hiy = loy + d; // if box does not intersect level - ignore\n\n      if (nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy) return;\n      if (level >= maxLevel) return;\n      if (from === to) return; // if points fall into box range - take it\n\n      let levelItems = levels[level];\n      if (to === undefined) to = levelItems.length;\n\n      for (let i = from; i < to; i++) {\n        let id = levelItems[i];\n        let px = srcPoints[id * 2];\n        let py = srcPoints[id * 2 + 1];\n\n        if (px >= minX && px <= maxX && py >= minY && py <= maxY) {\n          selection.push(id);\n        }\n      } // for every subsection do select\n\n\n      let offsets = sublevels[level];\n      let off0 = offsets[from * 4 + 0];\n      let off1 = offsets[from * 4 + 1];\n      let off2 = offsets[from * 4 + 2];\n      let off3 = offsets[from * 4 + 3];\n      let end = nextOffset(offsets, from + 1);\n      let d2 = d * .5;\n      let nextLevel = level + 1;\n      select(lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end);\n      select(lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end);\n      select(lox + d2, loy, d2, nextLevel, off2, off3 || end);\n      select(lox + d2, loy + d2, d2, nextLevel, off3, end);\n    }\n\n    function nextOffset(offsets, from) {\n      let offset = null,\n          i = 0;\n\n      while (offset === null) {\n        offset = offsets[from * 4 + i];\n        i++;\n        if (i > offsets.length) return null;\n      }\n\n      return offset;\n    }\n\n    return selection;\n  } // get range offsets within levels to render lods appropriate for zoom level\n  // TODO: it is possible to store minSize of a point to optimize neede level calc\n\n\n  function lod(lox, loy, hix, hiy, maxLevel) {\n    let ranges = [];\n\n    for (let level = 0; level < maxLevel; level++) {\n      let levelGroups = groups[level];\n      let from = offsets[level][0];\n      let levelGroupStart = group(lox, loy, level);\n      let levelGroupEnd = group(hix, hiy, level); // FIXME: utilize sublevels to speed up search range here\n\n      let startOffset = search.ge(levelGroups, levelGroupStart);\n      let endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1);\n      ranges[level] = [startOffset + from, endOffset + from];\n    }\n\n    return ranges;\n  } // get group id closest to the x,y coordinate, corresponding to a level\n\n\n  function group(x, y, level) {\n    let group = 1;\n    let cx = .5,\n        cy = .5;\n    let diam = .5;\n\n    for (let i = 0; i < level; i++) {\n      group <<= 2;\n      group += x < cx ? y < cy ? 0 : 1 : y < cy ? 2 : 3;\n      diam *= .5;\n      cx += x < cx ? -diam : diam;\n      cy += y < cy ? -diam : diam;\n    }\n\n    return group;\n  }\n}; // normalize points by bounds\n\n\nfunction normalize(pts, bounds) {\n  let [lox, loy, hix, hiy] = bounds;\n  let scaleX = 1.0 / (hix - lox);\n  let scaleY = 1.0 / (hiy - loy);\n  let result = new Array(pts.length);\n\n  for (let i = 0, n = pts.length / 2; i < n; i++) {\n    result[2 * i] = clamp((pts[2 * i] - lox) * scaleX, 0, 1);\n    result[2 * i + 1] = clamp((pts[2 * i + 1] - loy) * scaleY, 0, 1);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/@plotly/point-cluster/quad.js"],"names":["search","require","clamp","rect","getBounds","pick","defined","flatten","isObj","dtype","log2","MAX_GROUP_ID","module","exports","cluster","srcPoints","options","bounds","maxDepth","points","normalize","n","length","ids","Array","isArray","i","levels","sublevels","groups","offsets","sort","offset","level","levelItems","set","l","nextOffset","range","x","y","diam","group","levelGroups","sublevel","push","d2","cx","cy","lolo","lohi","hilo","hihi","idx","args","arg","pop","left","d","lod","box","minX","minY","maxX","maxY","Math","min","width","height","max","nminX","nminY","nmaxX","nmaxY","maxLevel","ceil","abs","selection","select","lox","loy","from","to","hix","hiy","undefined","id","px","py","off0","off1","off2","off3","end","nextLevel","ranges","levelGroupStart","levelGroupEnd","startOffset","ge","endOffset","gt","pts","scaleX","scaleY","result"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,YAAD,CAApB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,eAAD,CAApB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,QAAD,CAArB;;AACA,MAAMQ,KAAK,GAAGR,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMS,IAAI,GAAGT,OAAO,CAAC,WAAD,CAApB;;AAEA,MAAMU,YAAY,GAAG,UAArB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,OAAT,CAAkBC,SAAlB,EAA6BC,OAA7B,EAAsC;AACtD,MAAI,CAACA,OAAL,EAAcA,OAAO,GAAG,EAAV;AAEdD,EAAAA,SAAS,GAAGR,OAAO,CAACQ,SAAD,EAAY,SAAZ,CAAnB;AAEAC,EAAAA,OAAO,GAAGX,IAAI,CAACW,OAAD,EAAU;AACvBC,IAAAA,MAAM,EAAE,8BADe;AAEvBC,IAAAA,QAAQ,EAAE,wDAFa;AAGvBT,IAAAA,KAAK,EAAE,8CAHgB,CAIvB;AACA;AACA;;AANuB,GAAV,CAAd,CALsD,CActD;;AACA,MAAIS,QAAQ,GAAGZ,OAAO,CAACU,OAAO,CAACE,QAAT,EAAmB,GAAnB,CAAtB;AACA,MAAID,MAAM,GAAGX,OAAO,CAACU,OAAO,CAACC,MAAT,EAAiBb,SAAS,CAACW,SAAD,EAAY,CAAZ,CAA1B,CAApB;AACA,MAAIE,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAAxB,EAA6BA,MAAM,CAAC,CAAD,CAAN;AAC7B,MAAIA,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAAxB,EAA6BA,MAAM,CAAC,CAAD,CAAN;AAE7B,MAAIE,MAAM,GAAGC,SAAS,CAACL,SAAD,EAAYE,MAAZ,CAAtB,CApBsD,CAsBtD;;AACA,MAAII,CAAC,GAAGN,SAAS,CAACO,MAAV,KAAqB,CAA7B;AACA,MAAIC,GAAJ;AACA,MAAI,CAACP,OAAO,CAACP,KAAb,EAAoBO,OAAO,CAACP,KAAR,GAAgB,OAAhB;;AAEpB,MAAI,OAAOO,OAAO,CAACP,KAAf,KAAyB,QAA7B,EAAuC;AACtCc,IAAAA,GAAG,GAAG,KAAKd,KAAK,CAACO,OAAO,CAACP,KAAT,CAAV,EAA2BY,CAA3B,CAAN;AACA,GAFD,MAGK,IAAIL,OAAO,CAACP,KAAZ,EAAmB;AACvBc,IAAAA,GAAG,GAAGP,OAAO,CAACP,KAAd;AACA,QAAIe,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAJ,EAAwBA,GAAG,CAACD,MAAJ,GAAaD,CAAb;AACxB;;AACD,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuB,EAAEK,CAAzB,EAA4B;AAC3BH,IAAAA,GAAG,CAACG,CAAD,CAAH,GAASA,CAAT;AACA,GApCqD,CAsCtD;;;AACA,MAAIC,MAAM,GAAG,EAAb,CAvCsD,CAyCtD;;AACA,MAAIC,SAAS,GAAG,EAAhB,CA1CsD,CA4CtD;;AACA,MAAIC,MAAM,GAAG,EAAb,CA7CsD,CA+CtD;;AACA,MAAIC,OAAO,GAAG,EAAd,CAhDsD,CAmDtD;;AACAC,EAAAA,IAAI,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAUR,GAAV,EAAe,CAAf,EAAkB,CAAlB,CAAJ,CApDsD,CAuDtD;AACA;;AACA,MAAIS,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGN,MAAM,CAACL,MAAnC,EAA2CW,KAAK,EAAhD,EAAoD;AACnD,QAAIC,UAAU,GAAGP,MAAM,CAACM,KAAD,CAAvB;AACA,QAAIV,GAAG,CAACY,GAAR,EAAaZ,GAAG,CAACY,GAAJ,CAAQD,UAAR,EAAoBF,MAApB,EAAb,KACK;AACJ,WAAK,IAAIN,CAAC,GAAG,CAAR,EAAWU,CAAC,GAAGF,UAAU,CAACZ,MAA/B,EAAuCI,CAAC,GAAGU,CAA3C,EAA8CV,CAAC,EAA/C,EAAmD;AAClDH,QAAAA,GAAG,CAACG,CAAC,GAAGM,MAAL,CAAH,GAAkBE,UAAU,CAACR,CAAD,CAA5B;AACA;AACD;AACD,QAAIW,UAAU,GAAGL,MAAM,GAAGL,MAAM,CAACM,KAAD,CAAN,CAAcX,MAAxC;AACAQ,IAAAA,OAAO,CAACG,KAAD,CAAP,GAAiB,CAACD,MAAD,EAASK,UAAT,CAAjB;AACAL,IAAAA,MAAM,GAAGK,UAAT;AACA;;AAEDd,EAAAA,GAAG,CAACe,KAAJ,GAAYA,KAAZ;AAEA,SAAOf,GAAP,CAzEsD,CA6EtD;;AACA,WAASQ,IAAT,CAAeQ,CAAf,EAAkBC,CAAlB,EAAqBC,IAArB,EAA2BlB,GAA3B,EAAgCU,KAAhC,EAAuCS,KAAvC,EAA8C;AAC7C,QAAI,CAACnB,GAAG,CAACD,MAAT,EAAiB,OAAO,IAAP,CAD4B,CAG7C;;AACA,QAAIY,UAAU,GAAGP,MAAM,CAACM,KAAD,CAAN,KAAkBN,MAAM,CAACM,KAAD,CAAN,GAAgB,EAAlC,CAAjB;AACA,QAAIU,WAAW,GAAGd,MAAM,CAACI,KAAD,CAAN,KAAkBJ,MAAM,CAACI,KAAD,CAAN,GAAgB,EAAlC,CAAlB;AACA,QAAIW,QAAQ,GAAGhB,SAAS,CAACK,KAAD,CAAT,KAAqBL,SAAS,CAACK,KAAD,CAAT,GAAmB,EAAxC,CAAf;AACA,QAAID,MAAM,GAAGE,UAAU,CAACZ,MAAxB;AAEAW,IAAAA,KAAK,GATwC,CAW7C;AACA;;AACA,QAAIA,KAAK,GAAGf,QAAR,IAAoBwB,KAAK,GAAG/B,YAAhC,EAA8C;AAC7C,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAAG,CAACD,MAAxB,EAAgCI,CAAC,EAAjC,EAAqC;AACpCQ,QAAAA,UAAU,CAACW,IAAX,CAAgBtB,GAAG,CAACG,CAAD,CAAnB;AACAiB,QAAAA,WAAW,CAACE,IAAZ,CAAiBH,KAAjB;AACAE,QAAAA,QAAQ,CAACC,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC;AACA;;AAED,aAAOb,MAAP;AACA;;AAEDE,IAAAA,UAAU,CAACW,IAAX,CAAgBtB,GAAG,CAAC,CAAD,CAAnB;AACAoB,IAAAA,WAAW,CAACE,IAAZ,CAAiBH,KAAjB;;AAEA,QAAInB,GAAG,CAACD,MAAJ,IAAc,CAAlB,EAAqB;AACpBsB,MAAAA,QAAQ,CAACC,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC;AACA,aAAOb,MAAP;AACA;;AAGD,QAAIc,EAAE,GAAGL,IAAI,GAAG,EAAhB;AACA,QAAIM,EAAE,GAAGR,CAAC,GAAGO,EAAb;AAAA,QAAiBE,EAAE,GAAGR,CAAC,GAAGM,EAA1B,CAjC6C,CAmC7C;;AACA,QAAIG,IAAI,GAAG,EAAX;AAAA,QAAeC,IAAI,GAAG,EAAtB;AAAA,QAA0BC,IAAI,GAAG,EAAjC;AAAA,QAAqCC,IAAI,GAAG,EAA5C;;AAEA,SAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWU,CAAC,GAAGb,GAAG,CAACD,MAAxB,EAAgCI,CAAC,GAAGU,CAApC,EAAuCV,CAAC,EAAxC,EAA4C;AAC3C,UAAI2B,GAAG,GAAG9B,GAAG,CAACG,CAAD,CAAb;AAAA,UACCa,CAAC,GAAGpB,MAAM,CAACkC,GAAG,GAAG,CAAP,CADX;AAAA,UAECb,CAAC,GAAGrB,MAAM,CAACkC,GAAG,GAAG,CAAN,GAAU,CAAX,CAFX;AAGAd,MAAAA,CAAC,GAAGQ,EAAJ,GAAUP,CAAC,GAAGQ,EAAJ,GAASC,IAAI,CAACJ,IAAL,CAAUQ,GAAV,CAAT,GAA0BH,IAAI,CAACL,IAAL,CAAUQ,GAAV,CAApC,GAAuDb,CAAC,GAAGQ,EAAJ,GAASG,IAAI,CAACN,IAAL,CAAUQ,GAAV,CAAT,GAA0BD,IAAI,CAACP,IAAL,CAAUQ,GAAV,CAAjF;AACA;;AAEDX,IAAAA,KAAK,KAAK,CAAV;AAEAE,IAAAA,QAAQ,CAACC,IAAT,CACCd,IAAI,CAACQ,CAAD,EAAIC,CAAJ,EAAOM,EAAP,EAAWG,IAAX,EAAiBhB,KAAjB,EAAwBS,KAAxB,CADL,EAECX,IAAI,CAACQ,CAAD,EAAIS,EAAJ,EAAQF,EAAR,EAAYI,IAAZ,EAAkBjB,KAAlB,EAAyBS,KAAK,GAAG,CAAjC,CAFL,EAGCX,IAAI,CAACgB,EAAD,EAAKP,CAAL,EAAQM,EAAR,EAAYK,IAAZ,EAAkBlB,KAAlB,EAAyBS,KAAK,GAAG,CAAjC,CAHL,EAICX,IAAI,CAACgB,EAAD,EAAKC,EAAL,EAASF,EAAT,EAAaM,IAAb,EAAmBnB,KAAnB,EAA0BS,KAAK,GAAG,CAAlC,CAJL;AAOA,WAAOV,MAAP;AACA,GArIqD,CAuItD;;;AACA,WAASM,KAAT,CAAiB,GAAGgB,IAApB,EAA2B;AAC1B,QAAItC,OAAJ;;AAEA,QAAIR,KAAK,CAAC8C,IAAI,CAACA,IAAI,CAAChC,MAAL,GAAc,CAAf,CAAL,CAAT,EAAkC;AACjC,UAAIiC,GAAG,GAAGD,IAAI,CAACE,GAAL,EAAV,CADiC,CAGjC;;AACA,UAAI,CAACF,IAAI,CAAChC,MAAN,KAAiBiC,GAAG,CAAChB,CAAJ,IAAS,IAAT,IAAiBgB,GAAG,CAACnB,CAAJ,IAAS,IAA1B,IAAkCmB,GAAG,CAACE,IAAJ,IAAY,IAA/D,CAAJ,EAA0E;AACzEH,QAAAA,IAAI,GAAG,CAACC,GAAD,CAAP;AACAvC,QAAAA,OAAO,GAAG,EAAV;AACA;;AAEDA,MAAAA,OAAO,GAAGX,IAAI,CAACkD,GAAD,EAAM;AACnBtB,QAAAA,KAAK,EAAE,gBADY;AAEnByB,QAAAA,CAAC,EAAE,sEAFgB;AAGnBC,QAAAA,GAAG,EAAE;AAHc,OAAN,CAAd;AAKA,KAdD,MAeK;AACJ3C,MAAAA,OAAO,GAAG,EAAV;AACA;;AAED,QAAI,CAACsC,IAAI,CAAChC,MAAV,EAAkBgC,IAAI,GAAGrC,MAAP;AAElB,QAAI2C,GAAG,GAAGzD,IAAI,CAAE,GAAGmD,IAAL,CAAd;AAEA,QAAI,CAACO,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,IAAnB,IAA2B,CAC9BC,IAAI,CAACC,GAAL,CAASN,GAAG,CAACrB,CAAb,EAAgBqB,GAAG,CAACrB,CAAJ,GAAQqB,GAAG,CAACO,KAA5B,CAD8B,EAE9BF,IAAI,CAACC,GAAL,CAASN,GAAG,CAACpB,CAAb,EAAgBoB,GAAG,CAACpB,CAAJ,GAAQoB,GAAG,CAACQ,MAA5B,CAF8B,EAG9BH,IAAI,CAACI,GAAL,CAAST,GAAG,CAACrB,CAAb,EAAgBqB,GAAG,CAACrB,CAAJ,GAAQqB,GAAG,CAACO,KAA5B,CAH8B,EAI9BF,IAAI,CAACI,GAAL,CAAST,GAAG,CAACpB,CAAb,EAAgBoB,GAAG,CAACpB,CAAJ,GAAQoB,GAAG,CAACQ,MAA5B,CAJ8B,CAA/B;AAOA,QAAI,CAACE,KAAD,EAAQC,KAAR,EAAeC,KAAf,EAAsBC,KAAtB,IAA+BrD,SAAS,CAAC,CAACyC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmBC,IAAnB,CAAD,EAA2B/C,MAA3B,CAA5C;AAEA,QAAIyD,QAAQ,GAAGpE,OAAO,CAACU,OAAO,CAACiB,KAAT,EAAgBN,MAAM,CAACL,MAAvB,CAAtB,CAnC0B,CAqC1B;;AACA,QAAIN,OAAO,CAAC0C,CAAR,IAAa,IAAjB,EAAuB;AACtB,UAAIA,CAAJ;AACA,UAAI,OAAO1C,OAAO,CAAC0C,CAAf,KAAqB,QAAzB,EAAmCA,CAAC,GAAG,CAAC1C,OAAO,CAAC0C,CAAT,EAAY1C,OAAO,CAAC0C,CAApB,CAAJ,CAAnC,KACK,IAAI1C,OAAO,CAAC0C,CAAR,CAAUpC,MAAd,EAAsBoC,CAAC,GAAG1C,OAAO,CAAC0C,CAAZ;AAE3BgB,MAAAA,QAAQ,GAAGT,IAAI,CAACC,GAAL,CACVD,IAAI,CAACI,GAAL,CACCJ,IAAI,CAACU,IAAL,CAAU,CAACjE,IAAI,CAACuD,IAAI,CAACW,GAAL,CAASlB,CAAC,CAAC,CAAD,CAAV,KAAkBzC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAApC,CAAD,CAAf,CADD,EAECgD,IAAI,CAACU,IAAL,CAAU,CAACjE,IAAI,CAACuD,IAAI,CAACW,GAAL,CAASlB,CAAC,CAAC,CAAD,CAAV,KAAkBzC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAApC,CAAD,CAAf,CAFD,CADU,EAKVyD,QALU,CAAX;AAOA;;AACDA,IAAAA,QAAQ,GAAGT,IAAI,CAACC,GAAL,CAASQ,QAAT,EAAmB/C,MAAM,CAACL,MAA1B,CAAX,CAnD0B,CAqD1B;;AACA,QAAIN,OAAO,CAAC2C,GAAZ,EAAiB;AAChB,aAAOA,GAAG,CAACW,KAAD,EAAQC,KAAR,EAAeC,KAAf,EAAsBC,KAAtB,EAA6BC,QAA7B,CAAV;AACA,KAxDyB,CA4D1B;;;AACA,QAAIG,SAAS,GAAG,EAAhB,CA7D0B,CA+D1B;;AACAC,IAAAA,MAAM,CAAE,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,CAAN;;AAEA,aAASA,MAAT,CAAkBC,GAAlB,EAAuBC,GAAvB,EAA4BtB,CAA5B,EAA+BzB,KAA/B,EAAsCgD,IAAtC,EAA4CC,EAA5C,EAAiD;AAChD,UAAID,IAAI,KAAK,IAAT,IAAiBC,EAAE,KAAK,IAA5B,EAAkC;AAElC,UAAIC,GAAG,GAAGJ,GAAG,GAAGrB,CAAhB;AACA,UAAI0B,GAAG,GAAGJ,GAAG,GAAGtB,CAAhB,CAJgD,CAMhD;;AACA,UAAKY,KAAK,GAAGa,GAAR,IAAeZ,KAAK,GAAGa,GAAvB,IAA8BZ,KAAK,GAAGO,GAAtC,IAA6CN,KAAK,GAAGO,GAA1D,EAAgE;AAChE,UAAK/C,KAAK,IAAIyC,QAAd,EAAyB;AACzB,UAAKO,IAAI,KAAKC,EAAd,EAAmB,OAT6B,CAWhD;;AACA,UAAIhD,UAAU,GAAGP,MAAM,CAACM,KAAD,CAAvB;AAEA,UAAIiD,EAAE,KAAKG,SAAX,EAAsBH,EAAE,GAAGhD,UAAU,CAACZ,MAAhB;;AAEtB,WAAK,IAAII,CAAC,GAAGuD,IAAb,EAAmBvD,CAAC,GAAGwD,EAAvB,EAA2BxD,CAAC,EAA5B,EAAgC;AAC/B,YAAI4D,EAAE,GAAGpD,UAAU,CAACR,CAAD,CAAnB;AAEA,YAAI6D,EAAE,GAAGxE,SAAS,CAAEuE,EAAE,GAAG,CAAP,CAAlB;AACA,YAAIE,EAAE,GAAGzE,SAAS,CAAEuE,EAAE,GAAG,CAAL,GAAS,CAAX,CAAlB;;AAEA,YAAKC,EAAE,IAAI1B,IAAN,IAAc0B,EAAE,IAAIxB,IAApB,IAA4ByB,EAAE,IAAI1B,IAAlC,IAA0C0B,EAAE,IAAIxB,IAArD,EAA4D;AAACa,UAAAA,SAAS,CAAChC,IAAV,CAAeyC,EAAf;AAC5D;AACD,OAxB+C,CA0BhD;;;AACA,UAAIxD,OAAO,GAAGF,SAAS,CAAEK,KAAF,CAAvB;AACA,UAAIwD,IAAI,GAAG3D,OAAO,CAAEmD,IAAI,GAAG,CAAP,GAAW,CAAb,CAAlB;AACA,UAAIS,IAAI,GAAG5D,OAAO,CAAEmD,IAAI,GAAG,CAAP,GAAW,CAAb,CAAlB;AACA,UAAIU,IAAI,GAAG7D,OAAO,CAAEmD,IAAI,GAAG,CAAP,GAAW,CAAb,CAAlB;AACA,UAAIW,IAAI,GAAG9D,OAAO,CAAEmD,IAAI,GAAG,CAAP,GAAW,CAAb,CAAlB;AACA,UAAIY,GAAG,GAAGxD,UAAU,CAACP,OAAD,EAAUmD,IAAI,GAAG,CAAjB,CAApB;AAEA,UAAInC,EAAE,GAAGY,CAAC,GAAG,EAAb;AACA,UAAIoC,SAAS,GAAG7D,KAAK,GAAG,CAAxB;AACA6C,MAAAA,MAAM,CAAEC,GAAF,EAAOC,GAAP,EAAYlC,EAAZ,EAAgBgD,SAAhB,EAA2BL,IAA3B,EAAiCC,IAAI,IAAIC,IAAR,IAAgBC,IAAhB,IAAwBC,GAAzD,CAAN;AACAf,MAAAA,MAAM,CAAEC,GAAF,EAAOC,GAAG,GAAGlC,EAAb,EAAiBA,EAAjB,EAAqBgD,SAArB,EAAgCJ,IAAhC,EAAsCC,IAAI,IAAIC,IAAR,IAAgBC,GAAtD,CAAN;AACAf,MAAAA,MAAM,CAAEC,GAAG,GAAGjC,EAAR,EAAYkC,GAAZ,EAAiBlC,EAAjB,EAAqBgD,SAArB,EAAgCH,IAAhC,EAAsCC,IAAI,IAAIC,GAA9C,CAAN;AACAf,MAAAA,MAAM,CAAEC,GAAG,GAAGjC,EAAR,EAAYkC,GAAG,GAAGlC,EAAlB,EAAsBA,EAAtB,EAA0BgD,SAA1B,EAAqCF,IAArC,EAA2CC,GAA3C,CAAN;AACA;;AAED,aAASxD,UAAT,CAAoBP,OAApB,EAA6BmD,IAA7B,EAAmC;AAClC,UAAIjD,MAAM,GAAG,IAAb;AAAA,UAAmBN,CAAC,GAAG,CAAvB;;AACA,aAAMM,MAAM,KAAK,IAAjB,EAAuB;AACtBA,QAAAA,MAAM,GAAGF,OAAO,CAAEmD,IAAI,GAAG,CAAP,GAAWvD,CAAb,CAAhB;AACAA,QAAAA,CAAC;AACD,YAAIA,CAAC,GAAGI,OAAO,CAACR,MAAhB,EAAwB,OAAO,IAAP;AACxB;;AACD,aAAOU,MAAP;AACA;;AAED,WAAO6C,SAAP;AACA,GA/PqD,CAiQtD;AACA;;;AACA,WAASlB,GAAT,CAAcoB,GAAd,EAAmBC,GAAnB,EAAwBG,GAAxB,EAA6BC,GAA7B,EAAkCV,QAAlC,EAA4C;AAC3C,QAAIqB,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAI9D,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGyC,QAA5B,EAAsCzC,KAAK,EAA3C,EAA+C;AAC9C,UAAIU,WAAW,GAAGd,MAAM,CAACI,KAAD,CAAxB;AACA,UAAIgD,IAAI,GAAGnD,OAAO,CAACG,KAAD,CAAP,CAAe,CAAf,CAAX;AAEA,UAAI+D,eAAe,GAAGtD,KAAK,CAACqC,GAAD,EAAMC,GAAN,EAAW/C,KAAX,CAA3B;AACA,UAAIgE,aAAa,GAAGvD,KAAK,CAACyC,GAAD,EAAMC,GAAN,EAAWnD,KAAX,CAAzB,CAL8C,CAO9C;;AACA,UAAIiE,WAAW,GAAGlG,MAAM,CAACmG,EAAP,CAAUxD,WAAV,EAAuBqD,eAAvB,CAAlB;AACA,UAAII,SAAS,GAAGpG,MAAM,CAACqG,EAAP,CAAU1D,WAAV,EAAuBsD,aAAvB,EAAsCC,WAAtC,EAAmDvD,WAAW,CAACrB,MAAZ,GAAqB,CAAxE,CAAhB;AAEAyE,MAAAA,MAAM,CAAC9D,KAAD,CAAN,GAAgB,CAACiE,WAAW,GAAGjB,IAAf,EAAqBmB,SAAS,GAAGnB,IAAjC,CAAhB;AACA;;AAED,WAAOc,MAAP;AACA,GArRqD,CAuRtD;;;AACA,WAASrD,KAAT,CAAgBH,CAAhB,EAAmBC,CAAnB,EAAsBP,KAAtB,EAA6B;AAC5B,QAAIS,KAAK,GAAG,CAAZ;AAEA,QAAIK,EAAE,GAAG,EAAT;AAAA,QAAaC,EAAE,GAAG,EAAlB;AACA,QAAIP,IAAI,GAAG,EAAX;;AAEA,SAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,KAApB,EAA2BP,CAAC,EAA5B,EAAgC;AAC/BgB,MAAAA,KAAK,KAAK,CAAV;AAEAA,MAAAA,KAAK,IAAIH,CAAC,GAAGQ,EAAJ,GAAUP,CAAC,GAAGQ,EAAJ,GAAS,CAAT,GAAa,CAAvB,GAA6BR,CAAC,GAAGQ,EAAJ,GAAS,CAAT,GAAa,CAAnD;AAEAP,MAAAA,IAAI,IAAI,EAAR;AAEAM,MAAAA,EAAE,IAAIR,CAAC,GAAGQ,EAAJ,GAAS,CAACN,IAAV,GAAiBA,IAAvB;AACAO,MAAAA,EAAE,IAAIR,CAAC,GAAGQ,EAAJ,GAAS,CAACP,IAAV,GAAiBA,IAAvB;AACA;;AAED,WAAOC,KAAP;AACA;AACD,CA3SD,C,CA8SA;;;AACA,SAAStB,SAAT,CAAoBkF,GAApB,EAAyBrF,MAAzB,EAAiC;AAChC,MAAI,CAAC8D,GAAD,EAAMC,GAAN,EAAWG,GAAX,EAAgBC,GAAhB,IAAuBnE,MAA3B;AACA,MAAIsF,MAAM,GAAG,OAAOpB,GAAG,GAAGJ,GAAb,CAAb;AACA,MAAIyB,MAAM,GAAG,OAAOpB,GAAG,GAAGJ,GAAb,CAAb;AACA,MAAIyB,MAAM,GAAG,IAAIjF,KAAJ,CAAU8E,GAAG,CAAChF,MAAd,CAAb;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWL,CAAC,GAAGiF,GAAG,CAAChF,MAAJ,GAAa,CAAjC,EAAoCI,CAAC,GAAGL,CAAxC,EAA2CK,CAAC,EAA5C,EAAgD;AAC/C+E,IAAAA,MAAM,CAAC,IAAE/E,CAAH,CAAN,GAAcxB,KAAK,CAAC,CAACoG,GAAG,CAAC,IAAE5E,CAAH,CAAH,GAAWqD,GAAZ,IAAmBwB,MAApB,EAA4B,CAA5B,EAA+B,CAA/B,CAAnB;AACAE,IAAAA,MAAM,CAAC,IAAE/E,CAAF,GAAI,CAAL,CAAN,GAAgBxB,KAAK,CAAC,CAACoG,GAAG,CAAC,IAAE5E,CAAF,GAAI,CAAL,CAAH,GAAasD,GAAd,IAAqBwB,MAAtB,EAA8B,CAA9B,EAAiC,CAAjC,CAArB;AACA;;AAED,SAAOC,MAAP;AACA","sourcesContent":["/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n\n'use strict'\n\nconst search = require('binary-search-bounds')\nconst clamp = require('clamp')\nconst rect = require('parse-rect')\nconst getBounds = require('array-bounds')\nconst pick = require('pick-by-alias')\nconst defined = require('defined')\nconst flatten = require('flatten-vertex-data')\nconst isObj = require('is-obj')\nconst dtype = require('dtype')\nconst log2 = require('math-log2')\n\nconst MAX_GROUP_ID = 1073741824\n\nmodule.exports = function cluster (srcPoints, options) {\n\tif (!options) options = {}\n\n\tsrcPoints = flatten(srcPoints, 'float64')\n\n\toptions = pick(options, {\n\t\tbounds: 'range bounds dataBox databox',\n\t\tmaxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n\t\tdtype: 'type dtype format out dst output destination'\n\t\t// sort: 'sortBy sortby sort',\n\t\t// pick: 'pick levelPoint',\n\t\t// nodeSize: 'node nodeSize minNodeSize minSize size'\n\t})\n\n\t// let nodeSize = defined(options.nodeSize, 1)\n\tlet maxDepth = defined(options.maxDepth, 255)\n\tlet bounds = defined(options.bounds, getBounds(srcPoints, 2))\n\tif (bounds[0] === bounds[2]) bounds[2]++\n\tif (bounds[1] === bounds[3]) bounds[3]++\n\n\tlet points = normalize(srcPoints, bounds)\n\n\t// init variables\n\tlet n = srcPoints.length >>> 1\n\tlet ids\n\tif (!options.dtype) options.dtype = 'array'\n\n\tif (typeof options.dtype === 'string') {\n\t\tids = new (dtype(options.dtype))(n)\n\t}\n\telse if (options.dtype) {\n\t\tids = options.dtype\n\t\tif (Array.isArray(ids)) ids.length = n\n\t}\n\tfor (let i = 0; i < n; ++i) {\n\t\tids[i] = i\n\t}\n\n\t// representative point indexes for levels\n\tlet levels = []\n\n\t// starting indexes of subranges in sub levels, levels.length * 4\n\tlet sublevels = []\n\n\t// unique group ids, sorted in z-curve fashion within levels by shifting bits\n\tlet groups = []\n\n\t// level offsets in `ids`\n\tlet offsets = []\n\n\n\t// sort points\n\tsort(0, 0, 1, ids, 0, 1)\n\n\n\t// return reordered ids with provided methods\n\t// save level offsets in output buffer\n\tlet offset = 0\n\tfor (let level = 0; level < levels.length; level++) {\n\t\tlet levelItems = levels[level]\n\t\tif (ids.set) ids.set(levelItems, offset)\n\t\telse {\n\t\t\tfor (let i = 0, l = levelItems.length; i < l; i++) {\n\t\t\t\tids[i + offset] = levelItems[i]\n\t\t\t}\n\t\t}\n\t\tlet nextOffset = offset + levels[level].length\n\t\toffsets[level] = [offset, nextOffset]\n\t\toffset = nextOffset\n\t}\n\n\tids.range = range\n\n\treturn ids\n\n\n\n\t// FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n\tfunction sort (x, y, diam, ids, level, group) {\n\t\tif (!ids.length) return null\n\n\t\t// save first point as level representative\n\t\tlet levelItems = levels[level] || (levels[level] = [])\n\t\tlet levelGroups = groups[level] || (groups[level] = [])\n\t\tlet sublevel = sublevels[level] || (sublevels[level] = [])\n\t\tlet offset = levelItems.length\n\n\t\tlevel++\n\n\t\t// max depth reached - put all items into a first group\n\t\t// alternatively - if group id overflow - avoid proceeding\n\t\tif (level > maxDepth || group > MAX_GROUP_ID) {\n\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\tlevelItems.push(ids[i])\n\t\t\t\tlevelGroups.push(group)\n\t\t\t\tsublevel.push(null, null, null, null)\n\t\t\t}\n\n\t\t\treturn offset\n\t\t}\n\n\t\tlevelItems.push(ids[0])\n\t\tlevelGroups.push(group)\n\n\t\tif (ids.length <= 1) {\n\t\t\tsublevel.push(null, null, null, null)\n\t\t\treturn offset\n\t\t}\n\n\n\t\tlet d2 = diam * .5\n\t\tlet cx = x + d2, cy = y + d2\n\n\t\t// distribute points by 4 buckets\n\t\tlet lolo = [], lohi = [], hilo = [], hihi = []\n\n\t\tfor (let i = 1, l = ids.length; i < l; i++) {\n\t\t\tlet idx = ids[i],\n\t\t\t\tx = points[idx * 2],\n\t\t\t\ty = points[idx * 2 + 1]\n\t\t\tx < cx ? (y < cy ? lolo.push(idx) : lohi.push(idx)) : (y < cy ? hilo.push(idx) : hihi.push(idx))\n\t\t}\n\n\t\tgroup <<= 2\n\n\t\tsublevel.push(\n\t\t\tsort(x, y, d2, lolo, level, group),\n\t\t\tsort(x, cy, d2, lohi, level, group + 1),\n\t\t\tsort(cx, y, d2, hilo, level, group + 2),\n\t\t\tsort(cx, cy, d2, hihi, level, group + 3)\n\t\t)\n\n\t\treturn offset\n\t}\n\n\t// get all points within the passed range\n\tfunction range ( ...args ) {\n\t\tlet options\n\n\t\tif (isObj(args[args.length - 1])) {\n\t\t\tlet arg = args.pop()\n\n\t\t\t// detect if that was a rect object\n\t\t\tif (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n\t\t\t\targs = [arg]\n\t\t\t\toptions = {}\n\t\t\t}\n\n\t\t\toptions = pick(arg, {\n\t\t\t\tlevel: 'level maxLevel',\n\t\t\t\td: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n\t\t\t\tlod: 'lod details ranges offsets'\n\t\t\t})\n\t\t}\n\t\telse {\n\t\t\toptions = {}\n\t\t}\n\n\t\tif (!args.length) args = bounds\n\n\t\tlet box = rect( ...args )\n\n\t\tlet [minX, minY, maxX, maxY] = [\n\t\t\tMath.min(box.x, box.x + box.width),\n\t\t\tMath.min(box.y, box.y + box.height),\n\t\t\tMath.max(box.x, box.x + box.width),\n\t\t\tMath.max(box.y, box.y + box.height)\n\t\t]\n\n\t\tlet [nminX, nminY, nmaxX, nmaxY] = normalize([minX, minY, maxX, maxY], bounds )\n\n\t\tlet maxLevel = defined(options.level, levels.length)\n\n\t\t// limit maxLevel by px size\n\t\tif (options.d != null) {\n\t\t\tlet d\n\t\t\tif (typeof options.d === 'number') d = [options.d, options.d]\n\t\t\telse if (options.d.length) d = options.d\n\n\t\t\tmaxLevel = Math.min(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))),\n\t\t\t\t\tMath.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))\n\t\t\t\t),\n\t\t\t\tmaxLevel\n\t\t\t)\n\t\t}\n\t\tmaxLevel = Math.min(maxLevel, levels.length)\n\n\t\t// return levels of details\n\t\tif (options.lod) {\n\t\t\treturn lod(nminX, nminY, nmaxX, nmaxY, maxLevel)\n\t\t}\n\n\n\n\t\t// do selection ids\n\t\tlet selection = []\n\n\t\t// FIXME: probably we can do LOD here beforehead\n\t\tselect( 0, 0, 1, 0, 0, 1)\n\n\t\tfunction select ( lox, loy, d, level, from, to ) {\n\t\t\tif (from === null || to === null) return\n\n\t\t\tlet hix = lox + d\n\t\t\tlet hiy = loy + d\n\n\t\t\t// if box does not intersect level - ignore\n\t\t\tif ( nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy ) return\n\t\t\tif ( level >= maxLevel ) return\n\t\t\tif ( from === to ) return\n\n\t\t\t// if points fall into box range - take it\n\t\t\tlet levelItems = levels[level]\n\n\t\t\tif (to === undefined) to = levelItems.length\n\n\t\t\tfor (let i = from; i < to; i++) {\n\t\t\t\tlet id = levelItems[i]\n\n\t\t\t\tlet px = srcPoints[ id * 2 ]\n\t\t\t\tlet py = srcPoints[ id * 2 + 1 ]\n\n\t\t\t\tif ( px >= minX && px <= maxX && py >= minY && py <= maxY ) {selection.push(id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for every subsection do select\n\t\t\tlet offsets = sublevels[ level ]\n\t\t\tlet off0 = offsets[ from * 4 + 0 ]\n\t\t\tlet off1 = offsets[ from * 4 + 1 ]\n\t\t\tlet off2 = offsets[ from * 4 + 2 ]\n\t\t\tlet off3 = offsets[ from * 4 + 3 ]\n\t\t\tlet end = nextOffset(offsets, from + 1)\n\n\t\t\tlet d2 = d * .5\n\t\t\tlet nextLevel = level + 1\n\t\t\tselect( lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end)\n\t\t\tselect( lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end)\n\t\t\tselect( lox + d2, loy, d2, nextLevel, off2, off3 || end)\n\t\t\tselect( lox + d2, loy + d2, d2, nextLevel, off3, end)\n\t\t}\n\n\t\tfunction nextOffset(offsets, from) {\n\t\t\tlet offset = null, i = 0\n\t\t\twhile(offset === null) {\n\t\t\t\toffset = offsets[ from * 4 + i ]\n\t\t\t\ti++\n\t\t\t\tif (i > offsets.length) return null\n\t\t\t}\n\t\t\treturn offset\n\t\t}\n\n\t\treturn selection\n\t}\n\n\t// get range offsets within levels to render lods appropriate for zoom level\n\t// TODO: it is possible to store minSize of a point to optimize neede level calc\n\tfunction lod (lox, loy, hix, hiy, maxLevel) {\n\t\tlet ranges = []\n\n\t\tfor (let level = 0; level < maxLevel; level++) {\n\t\t\tlet levelGroups = groups[level]\n\t\t\tlet from = offsets[level][0]\n\n\t\t\tlet levelGroupStart = group(lox, loy, level)\n\t\t\tlet levelGroupEnd = group(hix, hiy, level)\n\n\t\t\t// FIXME: utilize sublevels to speed up search range here\n\t\t\tlet startOffset = search.ge(levelGroups, levelGroupStart)\n\t\t\tlet endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1)\n\n\t\t\tranges[level] = [startOffset + from, endOffset + from]\n\t\t}\n\n\t\treturn ranges\n\t}\n\n\t// get group id closest to the x,y coordinate, corresponding to a level\n\tfunction group (x, y, level) {\n\t\tlet group = 1\n\n\t\tlet cx = .5, cy = .5\n\t\tlet diam = .5\n\n\t\tfor (let i = 0; i < level; i++) {\n\t\t\tgroup <<= 2\n\n\t\t\tgroup += x < cx ? (y < cy ? 0 : 1) : (y < cy ? 2 : 3)\n\n\t\t\tdiam *= .5\n\n\t\t\tcx += x < cx ? -diam : diam\n\t\t\tcy += y < cy ? -diam : diam\n\t\t}\n\n\t\treturn group\n\t}\n}\n\n\n// normalize points by bounds\nfunction normalize (pts, bounds) {\n\tlet [lox, loy, hix, hiy] = bounds\n\tlet scaleX = 1.0 / (hix - lox)\n\tlet scaleY = 1.0 / (hiy - loy)\n\tlet result = new Array(pts.length)\n\n\tfor (let i = 0, n = pts.length / 2; i < n; i++) {\n\t\tresult[2*i] = clamp((pts[2*i] - lox) * scaleX, 0, 1)\n\t\tresult[2*i+1] = clamp((pts[2*i+1] - loy) * scaleY, 0, 1)\n\t}\n\n\treturn result\n}\n"]},"metadata":{},"sourceType":"script"}