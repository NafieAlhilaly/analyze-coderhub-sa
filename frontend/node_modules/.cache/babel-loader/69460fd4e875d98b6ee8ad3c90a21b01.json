{"ast":null,"code":"'use strict';\n\nvar Registry = require('../registry');\n\nvar Lib = require('../lib');\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\n\n\nexports.manageCommandObserver = function (gd, container, commandList, onchange) {\n  var ret = {};\n  var enabled = true;\n\n  if (container && container._commandObserver) {\n    ret = container._commandObserver;\n  }\n\n  if (!ret.cache) {\n    ret.cache = {};\n  } // Either create or just recompute this:\n\n\n  ret.lookupTable = {};\n  var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n  if (container && container._commandObserver) {\n    if (!binding) {\n      // If container exists and there are no longer any bindings,\n      // remove existing:\n      if (container._commandObserver.remove) {\n        container._commandObserver.remove();\n\n        container._commandObserver = null;\n        return ret;\n      }\n    } else {\n      // If container exists and there *are* bindings, then the lookup\n      // table should have been updated and check is already attached,\n      // so there's nothing to be done:\n      return ret;\n    }\n  } // Determine whether there's anything to do for this binding:\n\n\n  if (binding) {\n    // Build the cache:\n    bindingValueHasChanged(gd, binding, ret.cache);\n\n    ret.check = function check() {\n      if (!enabled) return;\n      var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n      if (update.changed && onchange) {\n        // Disable checks for the duration of this command in order to avoid\n        // infinite loops:\n        if (ret.lookupTable[update.value] !== undefined) {\n          ret.disable();\n          Promise.resolve(onchange({\n            value: update.value,\n            type: binding.type,\n            prop: binding.prop,\n            traces: binding.traces,\n            index: ret.lookupTable[update.value]\n          })).then(ret.enable, ret.enable);\n        }\n      }\n\n      return update.changed;\n    };\n\n    var checkEvents = ['plotly_relayout', 'plotly_redraw', 'plotly_restyle', 'plotly_update', 'plotly_animatingframe', 'plotly_afterplot'];\n\n    for (var i = 0; i < checkEvents.length; i++) {\n      gd._internalOn(checkEvents[i], ret.check);\n    }\n\n    ret.remove = function () {\n      for (var i = 0; i < checkEvents.length; i++) {\n        gd._removeInternalListener(checkEvents[i], ret.check);\n      }\n    };\n  } else {\n    // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n    // is a start\n    Lib.log('Unable to automatically bind plot updates to API command');\n    ret.lookupTable = {};\n\n    ret.remove = function () {};\n  }\n\n  ret.disable = function disable() {\n    enabled = false;\n  };\n\n  ret.enable = function enable() {\n    enabled = true;\n  };\n\n  if (container) {\n    container._commandObserver = ret;\n  }\n\n  return ret;\n};\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\n\n\nexports.hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {\n  var i;\n  var n = commandList.length;\n  var refBinding;\n\n  for (i = 0; i < n; i++) {\n    var binding;\n    var command = commandList[i];\n    var method = command.method;\n    var args = command.args;\n    if (!Array.isArray(args)) args = []; // If any command has no method, refuse to bind:\n\n    if (!method) {\n      return false;\n    }\n\n    var bindings = exports.computeAPICommandBindings(gd, method, args); // Right now, handle one and *only* one property being set:\n\n    if (bindings.length !== 1) {\n      return false;\n    }\n\n    if (!refBinding) {\n      refBinding = bindings[0];\n\n      if (Array.isArray(refBinding.traces)) {\n        refBinding.traces.sort();\n      }\n    } else {\n      binding = bindings[0];\n\n      if (binding.type !== refBinding.type) {\n        return false;\n      }\n\n      if (binding.prop !== refBinding.prop) {\n        return false;\n      }\n\n      if (Array.isArray(refBinding.traces)) {\n        if (Array.isArray(binding.traces)) {\n          binding.traces.sort();\n\n          for (var j = 0; j < refBinding.traces.length; j++) {\n            if (refBinding.traces[j] !== binding.traces[j]) {\n              return false;\n            }\n          }\n        } else {\n          return false;\n        }\n      } else {\n        if (binding.prop !== refBinding.prop) {\n          return false;\n        }\n      }\n    }\n\n    binding = bindings[0];\n    var value = binding.value;\n\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        value = value[0];\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingsByValue) {\n      bindingsByValue[value] = i;\n    }\n  }\n\n  return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n  var container, value, obj;\n  var changed = false;\n\n  if (binding.type === 'data') {\n    // If it's data, we need to get a trace. Based on the limited scope\n    // of what we cover, we can just take the first trace from the list,\n    // or otherwise just the first trace:\n    container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n  } else if (binding.type === 'layout') {\n    container = gd._fullLayout;\n  } else {\n    return false;\n  }\n\n  value = Lib.nestedProperty(container, binding.prop).get();\n  obj = cache[binding.type] = cache[binding.type] || {};\n\n  if (obj.hasOwnProperty(binding.prop)) {\n    if (obj[binding.prop] !== value) {\n      changed = true;\n    }\n  }\n\n  obj[binding.prop] = value;\n  return {\n    changed: changed,\n    value: value\n  };\n}\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\n\n\nexports.executeAPICommand = function (gd, method, args) {\n  if (method === 'skip') return Promise.resolve();\n  var _method = Registry.apiMethodRegistry[method];\n  var allArgs = [gd];\n  if (!Array.isArray(args)) args = [];\n\n  for (var i = 0; i < args.length; i++) {\n    allArgs.push(args[i]);\n  }\n\n  return _method.apply(null, allArgs).catch(function (err) {\n    Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n    return Promise.reject(err);\n  });\n};\n\nexports.computeAPICommandBindings = function (gd, method, args) {\n  var bindings;\n  if (!Array.isArray(args)) args = [];\n\n  switch (method) {\n    case 'restyle':\n      bindings = computeDataBindings(gd, args);\n      break;\n\n    case 'relayout':\n      bindings = computeLayoutBindings(gd, args);\n      break;\n\n    case 'update':\n      bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));\n      break;\n\n    case 'animate':\n      bindings = computeAnimateBindings(gd, args);\n      break;\n\n    default:\n      // This is the case where intelligent logic about what affects\n      // this command is not implemented. It causes no ill effects.\n      // For example, addFrames simply won't bind to a control component.\n      bindings = [];\n  }\n\n  return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n  // We'll assume that the only relevant modification an animation\n  // makes that's meaningfully tracked is the frame:\n  if (Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n    return [{\n      type: 'layout',\n      prop: '_currentFrame',\n      value: args[0][0].toString()\n    }];\n  } else {\n    return [];\n  }\n}\n\nfunction computeLayoutBindings(gd, args) {\n  var bindings = [];\n  var astr = args[0];\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = args[1];\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = astr;\n  } else {\n    return bindings;\n  }\n\n  crawl(aobj, function (path, attrName, attr) {\n    bindings.push({\n      type: 'layout',\n      prop: path,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n  var traces, astr, val, aobj;\n  var bindings = []; // Logic copied from Plotly.restyle:\n\n  astr = args[0];\n  val = args[1];\n  traces = args[2];\n  aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = astr;\n\n    if (traces === undefined) {\n      traces = val;\n    }\n  } else {\n    return bindings;\n  }\n\n  if (traces === undefined) {\n    // Explicitly assign this to null instead of undefined:\n    traces = null;\n  }\n\n  crawl(aobj, function (path, attrName, _attr) {\n    var thisTraces;\n    var attr;\n\n    if (Array.isArray(_attr)) {\n      attr = _attr.slice();\n      var nAttr = Math.min(attr.length, gd.data.length);\n\n      if (traces) {\n        nAttr = Math.min(nAttr, traces.length);\n      }\n\n      thisTraces = [];\n\n      for (var j = 0; j < nAttr; j++) {\n        thisTraces[j] = traces ? traces[j] : j;\n      }\n    } else {\n      attr = _attr;\n      thisTraces = traces ? traces.slice() : null;\n    } // Convert [7] to just 7 when traces is null:\n\n\n    if (thisTraces === null) {\n      if (Array.isArray(attr)) {\n        attr = attr[0];\n      }\n    } else if (Array.isArray(thisTraces)) {\n      if (!Array.isArray(attr)) {\n        var tmp = attr;\n        attr = [];\n\n        for (var i = 0; i < thisTraces.length; i++) {\n          attr[i] = tmp;\n        }\n      }\n\n      attr.length = Math.min(thisTraces.length, attr.length);\n    }\n\n    bindings.push({\n      type: 'data',\n      prop: path,\n      traces: thisTraces,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n  Object.keys(attrs).forEach(function (attrName) {\n    var attr = attrs[attrName];\n    if (attrName[0] === '_') return;\n    var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n    if (Lib.isPlainObject(attr)) {\n      crawl(attr, callback, thisPath, depth + 1);\n    } else {\n      // Only execute the callback on leaf nodes:\n      callback(thisPath, attrName, attr);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/plots/command.js"],"names":["Registry","require","Lib","exports","manageCommandObserver","gd","container","commandList","onchange","ret","enabled","_commandObserver","cache","lookupTable","binding","hasSimpleAPICommandBindings","remove","bindingValueHasChanged","check","update","changed","value","undefined","disable","Promise","resolve","type","prop","traces","index","then","enable","checkEvents","i","length","_internalOn","_removeInternalListener","log","bindingsByValue","n","refBinding","command","method","args","Array","isArray","bindings","computeAPICommandBindings","sort","j","obj","_fullData","_fullLayout","nestedProperty","get","hasOwnProperty","executeAPICommand","_method","apiMethodRegistry","allArgs","push","apply","catch","err","warn","reject","computeDataBindings","computeLayoutBindings","concat","computeAnimateBindings","indexOf","toString","astr","aobj","isPlainObject","crawl","path","attrName","attr","val","_attr","thisTraces","slice","nAttr","Math","min","data","tmp","attrs","callback","depth","Object","keys","forEach","thisPath"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function(gd, container, commandList, onchange) {\n    var ret = {};\n    var enabled = true;\n\n    if(container && container._commandObserver) {\n        ret = container._commandObserver;\n    }\n\n    if(!ret.cache) {\n        ret.cache = {};\n    }\n\n    // Either create or just recompute this:\n    ret.lookupTable = {};\n\n    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n    if(container && container._commandObserver) {\n        if(!binding) {\n            // If container exists and there are no longer any bindings,\n            // remove existing:\n            if(container._commandObserver.remove) {\n                container._commandObserver.remove();\n                container._commandObserver = null;\n                return ret;\n            }\n        } else {\n            // If container exists and there *are* bindings, then the lookup\n            // table should have been updated and check is already attached,\n            // so there's nothing to be done:\n            return ret;\n        }\n    }\n\n    // Determine whether there's anything to do for this binding:\n\n    if(binding) {\n        // Build the cache:\n        bindingValueHasChanged(gd, binding, ret.cache);\n\n        ret.check = function check() {\n            if(!enabled) return;\n\n            var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n            if(update.changed && onchange) {\n                // Disable checks for the duration of this command in order to avoid\n                // infinite loops:\n                if(ret.lookupTable[update.value] !== undefined) {\n                    ret.disable();\n                    Promise.resolve(onchange({\n                        value: update.value,\n                        type: binding.type,\n                        prop: binding.prop,\n                        traces: binding.traces,\n                        index: ret.lookupTable[update.value]\n                    })).then(ret.enable, ret.enable);\n                }\n            }\n\n            return update.changed;\n        };\n\n        var checkEvents = [\n            'plotly_relayout',\n            'plotly_redraw',\n            'plotly_restyle',\n            'plotly_update',\n            'plotly_animatingframe',\n            'plotly_afterplot'\n        ];\n\n        for(var i = 0; i < checkEvents.length; i++) {\n            gd._internalOn(checkEvents[i], ret.check);\n        }\n\n        ret.remove = function() {\n            for(var i = 0; i < checkEvents.length; i++) {\n                gd._removeInternalListener(checkEvents[i], ret.check);\n            }\n        };\n    } else {\n        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n        // is a start\n        Lib.log('Unable to automatically bind plot updates to API command');\n\n        ret.lookupTable = {};\n        ret.remove = function() {};\n    }\n\n    ret.disable = function disable() {\n        enabled = false;\n    };\n\n    ret.enable = function enable() {\n        enabled = true;\n    };\n\n    if(container) {\n        container._commandObserver = ret;\n    }\n\n    return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {\n    var i;\n    var n = commandList.length;\n\n    var refBinding;\n\n    for(i = 0; i < n; i++) {\n        var binding;\n        var command = commandList[i];\n        var method = command.method;\n        var args = command.args;\n\n        if(!Array.isArray(args)) args = [];\n\n        // If any command has no method, refuse to bind:\n        if(!method) {\n            return false;\n        }\n        var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n        // Right now, handle one and *only* one property being set:\n        if(bindings.length !== 1) {\n            return false;\n        }\n\n        if(!refBinding) {\n            refBinding = bindings[0];\n            if(Array.isArray(refBinding.traces)) {\n                refBinding.traces.sort();\n            }\n        } else {\n            binding = bindings[0];\n            if(binding.type !== refBinding.type) {\n                return false;\n            }\n            if(binding.prop !== refBinding.prop) {\n                return false;\n            }\n            if(Array.isArray(refBinding.traces)) {\n                if(Array.isArray(binding.traces)) {\n                    binding.traces.sort();\n                    for(var j = 0; j < refBinding.traces.length; j++) {\n                        if(refBinding.traces[j] !== binding.traces[j]) {\n                            return false;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                if(binding.prop !== refBinding.prop) {\n                    return false;\n                }\n            }\n        }\n\n        binding = bindings[0];\n        var value = binding.value;\n        if(Array.isArray(value)) {\n            if(value.length === 1) {\n                value = value[0];\n            } else {\n                return false;\n            }\n        }\n        if(bindingsByValue) {\n            bindingsByValue[value] = i;\n        }\n    }\n\n    return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n    var container, value, obj;\n    var changed = false;\n\n    if(binding.type === 'data') {\n        // If it's data, we need to get a trace. Based on the limited scope\n        // of what we cover, we can just take the first trace from the list,\n        // or otherwise just the first trace:\n        container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n    } else if(binding.type === 'layout') {\n        container = gd._fullLayout;\n    } else {\n        return false;\n    }\n\n    value = Lib.nestedProperty(container, binding.prop).get();\n\n    obj = cache[binding.type] = cache[binding.type] || {};\n\n    if(obj.hasOwnProperty(binding.prop)) {\n        if(obj[binding.prop] !== value) {\n            changed = true;\n        }\n    }\n\n    obj[binding.prop] = value;\n\n    return {\n        changed: changed,\n        value: value\n    };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function(gd, method, args) {\n    if(method === 'skip') return Promise.resolve();\n\n    var _method = Registry.apiMethodRegistry[method];\n    var allArgs = [gd];\n    if(!Array.isArray(args)) args = [];\n\n    for(var i = 0; i < args.length; i++) {\n        allArgs.push(args[i]);\n    }\n\n    return _method.apply(null, allArgs).catch(function(err) {\n        Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n        return Promise.reject(err);\n    });\n};\n\nexports.computeAPICommandBindings = function(gd, method, args) {\n    var bindings;\n\n    if(!Array.isArray(args)) args = [];\n\n    switch(method) {\n        case 'restyle':\n            bindings = computeDataBindings(gd, args);\n            break;\n        case 'relayout':\n            bindings = computeLayoutBindings(gd, args);\n            break;\n        case 'update':\n            bindings = computeDataBindings(gd, [args[0], args[2]])\n                .concat(computeLayoutBindings(gd, [args[1]]));\n            break;\n        case 'animate':\n            bindings = computeAnimateBindings(gd, args);\n            break;\n        default:\n            // This is the case where intelligent logic about what affects\n            // this command is not implemented. It causes no ill effects.\n            // For example, addFrames simply won't bind to a control component.\n            bindings = [];\n    }\n    return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n    // We'll assume that the only relevant modification an animation\n    // makes that's meaningfully tracked is the frame:\n    if(Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n        return [{type: 'layout', prop: '_currentFrame', value: args[0][0].toString()}];\n    } else {\n        return [];\n    }\n}\n\nfunction computeLayoutBindings(gd, args) {\n    var bindings = [];\n\n    var astr = args[0];\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = args[1];\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = astr;\n    } else {\n        return bindings;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        bindings.push({type: 'layout', prop: path, value: attr});\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n    var traces, astr, val, aobj;\n    var bindings = [];\n\n    // Logic copied from Plotly.restyle:\n    astr = args[0];\n    val = args[1];\n    traces = args[2];\n    aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = astr;\n\n        if(traces === undefined) {\n            traces = val;\n        }\n    } else {\n        return bindings;\n    }\n\n    if(traces === undefined) {\n        // Explicitly assign this to null instead of undefined:\n        traces = null;\n    }\n\n    crawl(aobj, function(path, attrName, _attr) {\n        var thisTraces;\n        var attr;\n\n        if(Array.isArray(_attr)) {\n            attr = _attr.slice();\n\n            var nAttr = Math.min(attr.length, gd.data.length);\n            if(traces) {\n                nAttr = Math.min(nAttr, traces.length);\n            }\n            thisTraces = [];\n            for(var j = 0; j < nAttr; j++) {\n                thisTraces[j] = traces ? traces[j] : j;\n            }\n        } else {\n            attr = _attr;\n            thisTraces = traces ? traces.slice() : null;\n        }\n\n        // Convert [7] to just 7 when traces is null:\n        if(thisTraces === null) {\n            if(Array.isArray(attr)) {\n                attr = attr[0];\n            }\n        } else if(Array.isArray(thisTraces)) {\n            if(!Array.isArray(attr)) {\n                var tmp = attr;\n                attr = [];\n                for(var i = 0; i < thisTraces.length; i++) {\n                    attr[i] = tmp;\n                }\n            }\n            attr.length = Math.min(thisTraces.length, attr.length);\n        }\n\n        bindings.push({\n            type: 'data',\n            prop: path,\n            traces: thisTraces,\n            value: attr\n        });\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(attrName[0] === '_') return;\n\n        var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n        if(Lib.isPlainObject(attr)) {\n            crawl(attr, callback, thisPath, depth + 1);\n        } else {\n            // Only execute the callback on leaf nodes:\n            callback(thisPath, attrName, attr);\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"script"}