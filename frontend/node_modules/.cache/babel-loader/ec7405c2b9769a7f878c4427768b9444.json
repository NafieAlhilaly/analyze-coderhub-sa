{"ast":null,"code":"'use strict';\n\nvar createPointCloudRenderer = require('gl-pointcloud2d');\n\nvar str2RGBArray = require('../../lib/str2rgbarray');\n\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction Pointcloud(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.type = 'pointcloud';\n  this.pickXData = [];\n  this.pickYData = [];\n  this.xData = [];\n  this.yData = [];\n  this.textLabels = [];\n  this.color = 'rgb(0, 0, 0)';\n  this.name = '';\n  this.hoverinfo = 'all';\n  this.idToIndex = new Int32Array(0);\n  this.bounds = [0, 0, 0, 0];\n  this.pointcloudOptions = {\n    positions: new Float32Array(0),\n    idToIndex: this.idToIndex,\n    sizemin: 0.5,\n    sizemax: 12,\n    color: [0, 0, 0, 1],\n    areaRatio: 1,\n    borderColor: [0, 0, 0, 1]\n  };\n  this.pointcloud = createPointCloudRenderer(scene.glplot, this.pointcloudOptions);\n  this.pointcloud._trace = this; // scene2d requires this prop\n}\n\nvar proto = Pointcloud.prototype;\n\nproto.handlePick = function (pickResult) {\n  var index = this.idToIndex[pickResult.pointId]; // prefer the readout from XY, if present\n\n  return {\n    trace: this,\n    dataCoord: pickResult.dataCoord,\n    traceCoord: this.pickXYData ? [this.pickXYData[index * 2], this.pickXYData[index * 2 + 1]] : [this.pickXData[index], this.pickYData[index]],\n    textLabel: Array.isArray(this.textLabels) ? this.textLabels[index] : this.textLabels,\n    color: this.color,\n    name: this.name,\n    pointIndex: index,\n    hoverinfo: this.hoverinfo\n  };\n};\n\nproto.update = function (options) {\n  this.index = options.index;\n  this.textLabels = options.text;\n  this.name = options.name;\n  this.hoverinfo = options.hoverinfo;\n  this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  this.updateFast(options);\n  this.color = getTraceColor(options, {});\n};\n\nproto.updateFast = function (options) {\n  var x = this.xData = this.pickXData = options.x;\n  var y = this.yData = this.pickYData = options.y;\n  var xy = this.pickXYData = options.xy;\n  var userBounds = options.xbounds && options.ybounds;\n  var index = options.indices;\n  var len;\n  var idToIndex;\n  var positions;\n  var bounds = this.bounds;\n  var xx, yy, i;\n\n  if (xy) {\n    positions = xy; // dividing xy.length by 2 and truncating to integer if xy.length was not even\n\n    len = xy.length >>> 1;\n\n    if (userBounds) {\n      bounds[0] = options.xbounds[0];\n      bounds[2] = options.xbounds[1];\n      bounds[1] = options.ybounds[0];\n      bounds[3] = options.ybounds[1];\n    } else {\n      for (i = 0; i < len; i++) {\n        xx = positions[i * 2];\n        yy = positions[i * 2 + 1];\n        if (xx < bounds[0]) bounds[0] = xx;\n        if (xx > bounds[2]) bounds[2] = xx;\n        if (yy < bounds[1]) bounds[1] = yy;\n        if (yy > bounds[3]) bounds[3] = yy;\n      }\n    }\n\n    if (index) {\n      idToIndex = index;\n    } else {\n      idToIndex = new Int32Array(len);\n\n      for (i = 0; i < len; i++) {\n        idToIndex[i] = i;\n      }\n    }\n  } else {\n    len = x.length;\n    positions = new Float32Array(2 * len);\n    idToIndex = new Int32Array(len);\n\n    for (i = 0; i < len; i++) {\n      xx = x[i];\n      yy = y[i];\n      idToIndex[i] = i;\n      positions[i * 2] = xx;\n      positions[i * 2 + 1] = yy;\n      if (xx < bounds[0]) bounds[0] = xx;\n      if (xx > bounds[2]) bounds[2] = xx;\n      if (yy < bounds[1]) bounds[1] = yy;\n      if (yy > bounds[3]) bounds[3] = yy;\n    }\n  }\n\n  this.idToIndex = idToIndex;\n  this.pointcloudOptions.idToIndex = idToIndex;\n  this.pointcloudOptions.positions = positions;\n  var markerColor = str2RGBArray(options.marker.color);\n  var borderColor = str2RGBArray(options.marker.border.color);\n  var opacity = options.opacity * options.marker.opacity;\n  markerColor[3] *= opacity;\n  this.pointcloudOptions.color = markerColor; // detect blending from the number of points, if undefined\n  // because large data with blending hits performance\n\n  var blend = options.marker.blend;\n\n  if (blend === null) {\n    var maxPoints = 100;\n    blend = x.length < maxPoints || y.length < maxPoints;\n  }\n\n  this.pointcloudOptions.blend = blend;\n  borderColor[3] *= opacity;\n  this.pointcloudOptions.borderColor = borderColor;\n  var markerSizeMin = options.marker.sizemin;\n  var markerSizeMax = Math.max(options.marker.sizemax, options.marker.sizemin);\n  this.pointcloudOptions.sizeMin = markerSizeMin;\n  this.pointcloudOptions.sizeMax = markerSizeMax;\n  this.pointcloudOptions.areaRatio = options.marker.border.arearatio;\n  this.pointcloud.update(this.pointcloudOptions); // add item for autorange routine\n\n  var xa = this.scene.xaxis;\n  var ya = this.scene.yaxis;\n  var pad = markerSizeMax / 2 || 0.5;\n  options._extremes[xa._id] = findExtremes(xa, [bounds[0], bounds[2]], {\n    ppad: pad\n  });\n  options._extremes[ya._id] = findExtremes(ya, [bounds[1], bounds[3]], {\n    ppad: pad\n  });\n};\n\nproto.dispose = function () {\n  this.pointcloud.dispose();\n};\n\nfunction createPointcloud(scene, data) {\n  var plot = new Pointcloud(scene, data.uid);\n  plot.update(data);\n  return plot;\n}\n\nmodule.exports = createPointcloud;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/pointcloud/convert.js"],"names":["createPointCloudRenderer","require","str2RGBArray","findExtremes","getTraceColor","Pointcloud","scene","uid","type","pickXData","pickYData","xData","yData","textLabels","color","name","hoverinfo","idToIndex","Int32Array","bounds","pointcloudOptions","positions","Float32Array","sizemin","sizemax","areaRatio","borderColor","pointcloud","glplot","_trace","proto","prototype","handlePick","pickResult","index","pointId","trace","dataCoord","traceCoord","pickXYData","textLabel","Array","isArray","pointIndex","update","options","text","Infinity","updateFast","x","y","xy","userBounds","xbounds","ybounds","indices","len","xx","yy","i","length","markerColor","marker","border","opacity","blend","maxPoints","markerSizeMin","markerSizeMax","Math","max","sizeMin","sizeMax","arearatio","xa","xaxis","ya","yaxis","pad","_extremes","_id","ppad","dispose","createPointcloud","data","plot","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar createPointCloudRenderer = require('gl-pointcloud2d');\n\nvar str2RGBArray = require('../../lib/str2rgbarray');\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction Pointcloud(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.type = 'pointcloud';\n\n    this.pickXData = [];\n    this.pickYData = [];\n    this.xData = [];\n    this.yData = [];\n    this.textLabels = [];\n    this.color = 'rgb(0, 0, 0)';\n    this.name = '';\n    this.hoverinfo = 'all';\n\n    this.idToIndex = new Int32Array(0);\n    this.bounds = [0, 0, 0, 0];\n\n    this.pointcloudOptions = {\n        positions: new Float32Array(0),\n        idToIndex: this.idToIndex,\n        sizemin: 0.5,\n        sizemax: 12,\n        color: [0, 0, 0, 1],\n        areaRatio: 1,\n        borderColor: [0, 0, 0, 1]\n    };\n    this.pointcloud = createPointCloudRenderer(scene.glplot, this.pointcloudOptions);\n    this.pointcloud._trace = this; // scene2d requires this prop\n}\n\nvar proto = Pointcloud.prototype;\n\nproto.handlePick = function(pickResult) {\n    var index = this.idToIndex[pickResult.pointId];\n\n    // prefer the readout from XY, if present\n    return {\n        trace: this,\n        dataCoord: pickResult.dataCoord,\n        traceCoord: this.pickXYData ?\n            [this.pickXYData[index * 2], this.pickXYData[index * 2 + 1]] :\n            [this.pickXData[index], this.pickYData[index]],\n        textLabel: Array.isArray(this.textLabels) ?\n            this.textLabels[index] :\n            this.textLabels,\n        color: this.color,\n        name: this.name,\n        pointIndex: index,\n        hoverinfo: this.hoverinfo\n    };\n};\n\nproto.update = function(options) {\n    this.index = options.index;\n    this.textLabels = options.text;\n    this.name = options.name;\n    this.hoverinfo = options.hoverinfo;\n    this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n    this.updateFast(options);\n\n    this.color = getTraceColor(options, {});\n};\n\nproto.updateFast = function(options) {\n    var x = this.xData = this.pickXData = options.x;\n    var y = this.yData = this.pickYData = options.y;\n    var xy = this.pickXYData = options.xy;\n\n    var userBounds = options.xbounds && options.ybounds;\n    var index = options.indices;\n\n    var len;\n    var idToIndex;\n    var positions;\n    var bounds = this.bounds;\n\n    var xx, yy, i;\n\n    if(xy) {\n        positions = xy;\n\n        // dividing xy.length by 2 and truncating to integer if xy.length was not even\n        len = xy.length >>> 1;\n\n        if(userBounds) {\n            bounds[0] = options.xbounds[0];\n            bounds[2] = options.xbounds[1];\n            bounds[1] = options.ybounds[0];\n            bounds[3] = options.ybounds[1];\n        } else {\n            for(i = 0; i < len; i++) {\n                xx = positions[i * 2];\n                yy = positions[i * 2 + 1];\n\n                if(xx < bounds[0]) bounds[0] = xx;\n                if(xx > bounds[2]) bounds[2] = xx;\n                if(yy < bounds[1]) bounds[1] = yy;\n                if(yy > bounds[3]) bounds[3] = yy;\n            }\n        }\n\n        if(index) {\n            idToIndex = index;\n        } else {\n            idToIndex = new Int32Array(len);\n\n            for(i = 0; i < len; i++) {\n                idToIndex[i] = i;\n            }\n        }\n    } else {\n        len = x.length;\n\n        positions = new Float32Array(2 * len);\n        idToIndex = new Int32Array(len);\n\n        for(i = 0; i < len; i++) {\n            xx = x[i];\n            yy = y[i];\n\n            idToIndex[i] = i;\n\n            positions[i * 2] = xx;\n            positions[i * 2 + 1] = yy;\n\n            if(xx < bounds[0]) bounds[0] = xx;\n            if(xx > bounds[2]) bounds[2] = xx;\n            if(yy < bounds[1]) bounds[1] = yy;\n            if(yy > bounds[3]) bounds[3] = yy;\n        }\n    }\n\n    this.idToIndex = idToIndex;\n    this.pointcloudOptions.idToIndex = idToIndex;\n\n    this.pointcloudOptions.positions = positions;\n\n    var markerColor = str2RGBArray(options.marker.color);\n    var borderColor = str2RGBArray(options.marker.border.color);\n    var opacity = options.opacity * options.marker.opacity;\n\n    markerColor[3] *= opacity;\n    this.pointcloudOptions.color = markerColor;\n\n    // detect blending from the number of points, if undefined\n    // because large data with blending hits performance\n    var blend = options.marker.blend;\n    if(blend === null) {\n        var maxPoints = 100;\n        blend = x.length < maxPoints || y.length < maxPoints;\n    }\n    this.pointcloudOptions.blend = blend;\n\n    borderColor[3] *= opacity;\n    this.pointcloudOptions.borderColor = borderColor;\n\n    var markerSizeMin = options.marker.sizemin;\n    var markerSizeMax = Math.max(options.marker.sizemax, options.marker.sizemin);\n    this.pointcloudOptions.sizeMin = markerSizeMin;\n    this.pointcloudOptions.sizeMax = markerSizeMax;\n    this.pointcloudOptions.areaRatio = options.marker.border.arearatio;\n\n    this.pointcloud.update(this.pointcloudOptions);\n\n    // add item for autorange routine\n    var xa = this.scene.xaxis;\n    var ya = this.scene.yaxis;\n    var pad = markerSizeMax / 2 || 0.5;\n    options._extremes[xa._id] = findExtremes(xa, [bounds[0], bounds[2]], {ppad: pad});\n    options._extremes[ya._id] = findExtremes(ya, [bounds[1], bounds[3]], {ppad: pad});\n};\n\nproto.dispose = function() {\n    this.pointcloud.dispose();\n};\n\nfunction createPointcloud(scene, data) {\n    var plot = new Pointcloud(scene, data.uid);\n    plot.update(data);\n    return plot;\n}\n\nmodule.exports = createPointcloud;\n"]},"metadata":{},"sourceType":"script"}