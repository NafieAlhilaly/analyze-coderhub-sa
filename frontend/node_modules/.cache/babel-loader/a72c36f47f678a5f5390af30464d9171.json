{"ast":null,"code":"'use strict';\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\n\nmodule.exports = function makeComputeError(opts) {\n  var type = opts.type;\n  var symmetric = opts.symmetric;\n\n  if (type === 'data') {\n    var array = opts.array || [];\n\n    if (symmetric) {\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        return [val, val];\n      };\n    } else {\n      var arrayminus = opts.arrayminus || [];\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        var valMinus = +arrayminus[index]; // in case one is present and the other is missing, fill in 0\n        // so we still see the present one. Mostly useful during manual\n        // data entry.\n\n        if (!isNaN(val) || !isNaN(valMinus)) {\n          return [valMinus || 0, val || 0];\n        }\n\n        return [NaN, NaN];\n      };\n    }\n  } else {\n    var computeErrorValue = makeComputeErrorValue(type, opts.value);\n    var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n    if (symmetric || opts.valueminus === undefined) {\n      return function computeError(dataPt) {\n        var val = computeErrorValue(dataPt);\n        return [val, val];\n      };\n    } else {\n      return function computeError(dataPt) {\n        return [computeErrorValueMinus(dataPt), computeErrorValue(dataPt)];\n      };\n    }\n  }\n};\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\n\n\nfunction makeComputeErrorValue(type, value) {\n  if (type === 'percent') {\n    return function (dataPt) {\n      return Math.abs(dataPt * value / 100);\n    };\n  }\n\n  if (type === 'constant') {\n    return function () {\n      return Math.abs(value);\n    };\n  }\n\n  if (type === 'sqrt') {\n    return function (dataPt) {\n      return Math.sqrt(Math.abs(dataPt));\n    };\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/errorbars/compute_error.js"],"names":["module","exports","makeComputeError","opts","type","symmetric","array","computeError","dataPt","index","val","arrayminus","valMinus","isNaN","NaN","computeErrorValue","makeComputeErrorValue","value","computeErrorValueMinus","valueminus","undefined","Math","abs","sqrt"],"mappings":"AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,OAAP,GAAiB,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC7C,MAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AACA,MAAIC,SAAS,GAAGF,IAAI,CAACE,SAArB;;AAEA,MAAGD,IAAI,KAAK,MAAZ,EAAoB;AAChB,QAAIE,KAAK,GAAGH,IAAI,CAACG,KAAL,IAAc,EAA1B;;AAEA,QAAGD,SAAH,EAAc;AACV,aAAO,SAASE,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACxC,YAAIC,GAAG,GAAG,CAAEJ,KAAK,CAACG,KAAD,CAAjB;AACA,eAAO,CAACC,GAAD,EAAMA,GAAN,CAAP;AACH,OAHD;AAIH,KALD,MAKO;AACH,UAAIC,UAAU,GAAGR,IAAI,CAACQ,UAAL,IAAmB,EAApC;AACA,aAAO,SAASJ,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACxC,YAAIC,GAAG,GAAG,CAACJ,KAAK,CAACG,KAAD,CAAhB;AACA,YAAIG,QAAQ,GAAG,CAACD,UAAU,CAACF,KAAD,CAA1B,CAFwC,CAGxC;AACA;AACA;;AACA,YAAG,CAACI,KAAK,CAACH,GAAD,CAAN,IAAe,CAACG,KAAK,CAACD,QAAD,CAAxB,EAAoC;AAChC,iBAAO,CAACA,QAAQ,IAAI,CAAb,EAAgBF,GAAG,IAAI,CAAvB,CAAP;AACH;;AACD,eAAO,CAACI,GAAD,EAAMA,GAAN,CAAP;AACH,OAVD;AAWH;AACJ,GAtBD,MAsBO;AACH,QAAIC,iBAAiB,GAAGC,qBAAqB,CAACZ,IAAD,EAAOD,IAAI,CAACc,KAAZ,CAA7C;AACA,QAAIC,sBAAsB,GAAGF,qBAAqB,CAACZ,IAAD,EAAOD,IAAI,CAACgB,UAAZ,CAAlD;;AAEA,QAAGd,SAAS,IAAIF,IAAI,CAACgB,UAAL,KAAoBC,SAApC,EAA+C;AAC3C,aAAO,SAASb,YAAT,CAAsBC,MAAtB,EAA8B;AACjC,YAAIE,GAAG,GAAGK,iBAAiB,CAACP,MAAD,CAA3B;AACA,eAAO,CAACE,GAAD,EAAMA,GAAN,CAAP;AACH,OAHD;AAIH,KALD,MAKO;AACH,aAAO,SAASH,YAAT,CAAsBC,MAAtB,EAA8B;AACjC,eAAO,CACHU,sBAAsB,CAACV,MAAD,CADnB,EAEHO,iBAAiB,CAACP,MAAD,CAFd,CAAP;AAIH,OALD;AAMH;AACJ;AACJ,CA5CD;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,qBAAT,CAA+BZ,IAA/B,EAAqCa,KAArC,EAA4C;AACxC,MAAGb,IAAI,KAAK,SAAZ,EAAuB;AACnB,WAAO,UAASI,MAAT,EAAiB;AACpB,aAAOa,IAAI,CAACC,GAAL,CAASd,MAAM,GAAGS,KAAT,GAAiB,GAA1B,CAAP;AACH,KAFD;AAGH;;AACD,MAAGb,IAAI,KAAK,UAAZ,EAAwB;AACpB,WAAO,YAAW;AACd,aAAOiB,IAAI,CAACC,GAAL,CAASL,KAAT,CAAP;AACH,KAFD;AAGH;;AACD,MAAGb,IAAI,KAAK,MAAZ,EAAoB;AAChB,WAAO,UAASI,MAAT,EAAiB;AACpB,aAAOa,IAAI,CAACE,IAAL,CAAUF,IAAI,CAACC,GAAL,CAASd,MAAT,CAAV,CAAP;AACH,KAFD;AAGH;AACJ","sourcesContent":["'use strict';\n\n\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\nmodule.exports = function makeComputeError(opts) {\n    var type = opts.type;\n    var symmetric = opts.symmetric;\n\n    if(type === 'data') {\n        var array = opts.array || [];\n\n        if(symmetric) {\n            return function computeError(dataPt, index) {\n                var val = +(array[index]);\n                return [val, val];\n            };\n        } else {\n            var arrayminus = opts.arrayminus || [];\n            return function computeError(dataPt, index) {\n                var val = +array[index];\n                var valMinus = +arrayminus[index];\n                // in case one is present and the other is missing, fill in 0\n                // so we still see the present one. Mostly useful during manual\n                // data entry.\n                if(!isNaN(val) || !isNaN(valMinus)) {\n                    return [valMinus || 0, val || 0];\n                }\n                return [NaN, NaN];\n            };\n        }\n    } else {\n        var computeErrorValue = makeComputeErrorValue(type, opts.value);\n        var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n        if(symmetric || opts.valueminus === undefined) {\n            return function computeError(dataPt) {\n                var val = computeErrorValue(dataPt);\n                return [val, val];\n            };\n        } else {\n            return function computeError(dataPt) {\n                return [\n                    computeErrorValueMinus(dataPt),\n                    computeErrorValue(dataPt)\n                ];\n            };\n        }\n    }\n};\n\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\nfunction makeComputeErrorValue(type, value) {\n    if(type === 'percent') {\n        return function(dataPt) {\n            return Math.abs(dataPt * value / 100);\n        };\n    }\n    if(type === 'constant') {\n        return function() {\n            return Math.abs(value);\n        };\n    }\n    if(type === 'sqrt') {\n        return function(dataPt) {\n            return Math.sqrt(Math.abs(dataPt));\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"script"}