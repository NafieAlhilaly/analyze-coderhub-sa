{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../bar/hover').getTraceColor;\n\nvar fillText = Lib.fillText;\n\nvar makeHoverPointText = require('../scatterpolar/hover').makeHoverPointText;\n\nvar isPtInsidePolygon = require('../../plots/polar/helpers').isPtInsidePolygon;\n\nmodule.exports = function hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var subplot = pointData.subplot;\n  var radialAxis = subplot.radialAxis;\n  var angularAxis = subplot.angularAxis;\n  var vangles = subplot.vangles;\n  var inboxFn = vangles ? isPtInsidePolygon : Lib.isPtInsideSector;\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var period = angularAxis._period || 2 * Math.PI;\n  var rVal = Math.abs(radialAxis.g2p(Math.sqrt(xval * xval + yval * yval)));\n  var thetaVal = Math.atan2(yval, xval); // polar.(x|y)axis.p2c doesn't get the reversed radial axis range case right\n\n  if (radialAxis.range[0] > radialAxis.range[1]) {\n    thetaVal += Math.PI;\n  }\n\n  var distFn = function (di) {\n    if (inboxFn(rVal, thetaVal, [di.rp0, di.rp1], [di.thetag0, di.thetag1], vangles)) {\n      return maxHoverDistance + // add a little to the pseudo-distance for wider bars, so that like scatter,\n      // if you are over two overlapping bars, the narrower one wins.\n      Math.min(1, Math.abs(di.thetag1 - di.thetag0) / period) - 1 + // add a gradient so hovering near the end of a\n      // bar makes it a little closer match\n      (di.rp1 - rVal) / (di.rp1 - di.rp0) - 1;\n    } else {\n      return Infinity;\n    }\n  };\n\n  Fx.getClosest(cd, distFn, pointData);\n  if (pointData.index === false) return;\n  var index = pointData.index;\n  var cdi = cd[index];\n  pointData.x0 = pointData.x1 = cdi.ct[0];\n  pointData.y0 = pointData.y1 = cdi.ct[1];\n\n  var _cdi = Lib.extendFlat({}, cdi, {\n    r: cdi.s,\n    theta: cdi.p\n  });\n\n  fillText(cdi, trace, pointData);\n  makeHoverPointText(_cdi, trace, subplot, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  pointData.color = getTraceColor(trace, cdi);\n  pointData.xLabelVal = pointData.yLabelVal = undefined;\n\n  if (cdi.s < 0) {\n    pointData.idealAlign = 'left';\n  }\n\n  return [pointData];\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/barpolar/hover.js"],"names":["Fx","require","Lib","getTraceColor","fillText","makeHoverPointText","isPtInsidePolygon","module","exports","hoverPoints","pointData","xval","yval","cd","trace","subplot","radialAxis","angularAxis","vangles","inboxFn","isPtInsideSector","maxHoverDistance","period","_period","Math","PI","rVal","abs","g2p","sqrt","thetaVal","atan2","range","distFn","di","rp0","rp1","thetag0","thetag1","min","Infinity","getClosest","index","cdi","x0","x1","ct","y0","y1","_cdi","extendFlat","r","s","theta","p","hovertemplate","color","xLabelVal","yLabelVal","undefined","idealAlign"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Fx = require('../../components/fx');\nvar Lib = require('../../lib');\nvar getTraceColor = require('../bar/hover').getTraceColor;\nvar fillText = Lib.fillText;\nvar makeHoverPointText = require('../scatterpolar/hover').makeHoverPointText;\nvar isPtInsidePolygon = require('../../plots/polar/helpers').isPtInsidePolygon;\n\nmodule.exports = function hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n\n    var subplot = pointData.subplot;\n    var radialAxis = subplot.radialAxis;\n    var angularAxis = subplot.angularAxis;\n    var vangles = subplot.vangles;\n    var inboxFn = vangles ? isPtInsidePolygon : Lib.isPtInsideSector;\n    var maxHoverDistance = pointData.maxHoverDistance;\n    var period = angularAxis._period || 2 * Math.PI;\n\n    var rVal = Math.abs(radialAxis.g2p(Math.sqrt(xval * xval + yval * yval)));\n    var thetaVal = Math.atan2(yval, xval);\n\n    // polar.(x|y)axis.p2c doesn't get the reversed radial axis range case right\n    if(radialAxis.range[0] > radialAxis.range[1]) {\n        thetaVal += Math.PI;\n    }\n\n    var distFn = function(di) {\n        if(inboxFn(rVal, thetaVal, [di.rp0, di.rp1], [di.thetag0, di.thetag1], vangles)) {\n            return maxHoverDistance +\n                // add a little to the pseudo-distance for wider bars, so that like scatter,\n                // if you are over two overlapping bars, the narrower one wins.\n                Math.min(1, Math.abs(di.thetag1 - di.thetag0) / period) - 1 +\n                // add a gradient so hovering near the end of a\n                // bar makes it a little closer match\n                (di.rp1 - rVal) / (di.rp1 - di.rp0) - 1;\n        } else {\n            return Infinity;\n        }\n    };\n\n    Fx.getClosest(cd, distFn, pointData);\n    if(pointData.index === false) return;\n\n    var index = pointData.index;\n    var cdi = cd[index];\n\n    pointData.x0 = pointData.x1 = cdi.ct[0];\n    pointData.y0 = pointData.y1 = cdi.ct[1];\n\n    var _cdi = Lib.extendFlat({}, cdi, {r: cdi.s, theta: cdi.p});\n    fillText(cdi, trace, pointData);\n    makeHoverPointText(_cdi, trace, subplot, pointData);\n    pointData.hovertemplate = trace.hovertemplate;\n    pointData.color = getTraceColor(trace, cdi);\n    pointData.xLabelVal = pointData.yLabelVal = undefined;\n\n    if(cdi.s < 0) {\n        pointData.idealAlign = 'left';\n    }\n\n    return [pointData];\n};\n"]},"metadata":{},"sourceType":"script"}