{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\n\nvar binFunctions = require('./bin_functions');\n\nvar normFunctions = require('./norm_functions');\n\nvar doAvg = require('./average');\n\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n  var pos = [];\n  var size = [];\n  var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis : trace.xaxis);\n  var mainData = trace.orientation === 'h' ? 'y' : 'x';\n  var counterData = {\n    x: 'y',\n    y: 'x'\n  }[mainData];\n  var calendar = trace[mainData + 'calendar'];\n  var cumulativeSpec = trace.cumulative;\n  var i;\n  var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n  var binSpec = binsAndPos[0];\n  var pos0 = binsAndPos[1];\n  var nonuniformBins = typeof binSpec.size === 'string';\n  var binEdges = [];\n  var bins = nonuniformBins ? binEdges : binSpec; // make the empty bin array\n\n  var inc = [];\n  var counts = [];\n  var inputPoints = [];\n  var total = 0;\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densityNorm = norm.indexOf('density') !== -1;\n  var i2, binEnd, n;\n\n  if (cumulativeSpec.enabled && densityNorm) {\n    // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n    // which in the end means it's the same as without \"density\"\n    norm = norm.replace(/ ?density$/, '');\n    densityNorm = false;\n  }\n\n  var extremeFunc = func === 'max' || func === 'min';\n  var sizeInit = extremeFunc ? null : 0;\n  var binFunc = binFunctions.count;\n  var normFunc = normFunctions[norm];\n  var isAvg = false;\n\n  var pr2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var rawCounterData;\n\n  if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n    rawCounterData = trace[counterData];\n    isAvg = func === 'avg';\n    binFunc = binFunctions[func];\n  } // create the bins (and any extra arrays needed)\n  // assume more than 1e6 bins is an error, so we don't crash the browser\n\n\n  i = pr2c(binSpec.start); // decrease end a little in case of rounding errors\n\n  binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n  while (i < binEnd && pos.length < 1e6) {\n    i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n    pos.push((i + i2) / 2);\n    size.push(sizeInit);\n    inputPoints.push([]); // nonuniform bins (like months) we need to search,\n    // rather than straight calculate the bin we're in\n\n    binEdges.push(i); // nonuniform bins also need nonuniform normalization factors\n\n    if (densityNorm) inc.push(1 / (i2 - i));\n    if (isAvg) counts.push(0); // break to avoid infinite loops\n\n    if (i2 <= i) break;\n    i = i2;\n  }\n\n  binEdges.push(i); // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n\n  if (!nonuniformBins && pa.type === 'date') {\n    bins = {\n      start: pr2c(bins.start),\n      end: pr2c(bins.end),\n      size: bins.size\n    };\n  } // stash left and right gaps by group\n\n\n  if (!gd._fullLayout._roundFnOpts) gd._fullLayout._roundFnOpts = {};\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var roundFnOpts = {\n    leftGap: Infinity,\n    rightGap: Infinity\n  };\n\n  if (groupName) {\n    if (!gd._fullLayout._roundFnOpts[groupName]) gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;\n    roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n  } // bin the data\n  // and make histogram-specific pt-number-to-cd-index map object\n\n\n  var nMax = size.length;\n  var uniqueValsPerBin = true;\n  var leftGap = roundFnOpts.leftGap;\n  var rightGap = roundFnOpts.rightGap;\n  var ptNumber2cdIndex = {};\n\n  for (i = 0; i < pos0.length; i++) {\n    var posi = pos0[i];\n    n = Lib.findBin(posi, bins);\n\n    if (n >= 0 && n < nMax) {\n      total += binFunc(n, i, size, rawCounterData, counts);\n\n      if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n        uniqueValsPerBin = false;\n      }\n\n      inputPoints[n].push(i);\n      ptNumber2cdIndex[i] = n;\n      leftGap = Math.min(leftGap, posi - binEdges[n]);\n      rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n    }\n  }\n\n  roundFnOpts.leftGap = leftGap;\n  roundFnOpts.rightGap = rightGap;\n  var roundFn;\n\n  if (!uniqueValsPerBin) {\n    roundFn = function (v, isRightEdge) {\n      return function () {\n        var roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n        return getBinSpanLabelRound(roundFnOpts.leftGap, roundFnOpts.rightGap, binEdges, pa, calendar)(v, isRightEdge);\n      };\n    };\n  } // average and/or normalize the data, if needed\n\n\n  if (isAvg) total = doAvg(size, counts);\n  if (normFunc) normFunc(size, total, inc); // after all normalization etc, now we can accumulate if desired\n\n  if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n  var seriesLen = Math.min(pos.length, size.length);\n  var cd = [];\n  var firstNonzero = 0;\n  var lastNonzero = seriesLen - 1; // look for empty bins at the ends to remove, so autoscale omits them\n\n  for (i = 0; i < seriesLen; i++) {\n    if (size[i]) {\n      firstNonzero = i;\n      break;\n    }\n  }\n\n  for (i = seriesLen - 1; i >= firstNonzero; i--) {\n    if (size[i]) {\n      lastNonzero = i;\n      break;\n    }\n  } // create the \"calculated data\" to plot\n\n\n  for (i = firstNonzero; i <= lastNonzero; i++) {\n    if (isNumeric(pos[i]) && isNumeric(size[i])) {\n      var cdi = {\n        p: pos[i],\n        s: size[i],\n        b: 0\n      }; // setup hover and event data fields,\n      // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n      // for cumulative distributions\n\n      if (!cumulativeSpec.enabled) {\n        cdi.pts = inputPoints[i];\n\n        if (uniqueValsPerBin) {\n          cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];\n        } else {\n          // Defer evaluation of ph(0|1) in crossTraceCalc\n          trace._computePh = true;\n          cdi.ph0 = roundFn(binEdges[i]);\n          cdi.ph1 = roundFn(binEdges[i + 1], true);\n        }\n      }\n\n      cd.push(cdi);\n    }\n  }\n\n  if (cd.length === 1) {\n    // when we collapse to a single bin, calcdata no longer describes bin size\n    // so we need to explicitly specify it\n    cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n  }\n\n  arraysToCalcdata(cd, trace);\n\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n  }\n\n  return cd;\n}\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\n\n\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n  var binAttr = mainData + 'bins';\n  var fullLayout = gd._fullLayout;\n  var groupName = trace['_' + mainData + 'bingroup'];\n  var binOpts = fullLayout._histogramBinOpts[groupName];\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n  var r2c = function (v) {\n    return pa.r2c(v, 0, calendar);\n  };\n\n  var c2r = function (v) {\n    return pa.c2r(v, 0, calendar);\n  };\n\n  var cleanBound = pa.type === 'date' ? function (v) {\n    return v || v === 0 ? Lib.cleanDate(v, null, calendar) : null;\n  } : function (v) {\n    return isNumeric(v) ? Number(v) : null;\n  };\n\n  function setBound(attr, bins, newBins) {\n    if (bins[attr + 'Found']) {\n      bins[attr] = cleanBound(bins[attr]);\n      if (bins[attr] === null) bins[attr] = newBins[attr];\n    } else {\n      autoVals[attr] = bins[attr] = newBins[attr];\n      Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n    }\n  } // all but the first trace in this group has already been marked finished\n  // clear this flag, so next time we run calc we will run autobin again\n\n\n  if (trace['_' + mainData + 'autoBinFinished']) {\n    delete trace['_' + mainData + 'autoBinFinished'];\n  } else {\n    traces = binOpts.traces;\n    var allPos = []; // Note: we're including `legendonly` traces here for autobin purposes,\n    // so that showing & hiding from the legend won't affect bins.\n    // But this complicates things a bit since those traces don't `calc`,\n    // hence `isFirstVisible`.\n\n    var isFirstVisible = true;\n    var has2dMap = false;\n    var hasHist2dContour = false;\n\n    for (i = 0; i < traces.length; i++) {\n      tracei = traces[i];\n\n      if (tracei.visible) {\n        var mainDatai = binOpts.dirs[i];\n        pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n        allPos = Lib.concat(allPos, pos0);\n        delete tracei['_' + mainData + 'autoBinFinished'];\n\n        if (trace.visible === true) {\n          if (isFirstVisible) {\n            isFirstVisible = false;\n          } else {\n            delete tracei._autoBin;\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n          }\n\n          if (Registry.traceIs(tracei, '2dMap')) {\n            has2dMap = true;\n          }\n\n          if (tracei.type === 'histogram2dcontour') {\n            hasHist2dContour = true;\n          }\n        }\n      }\n    }\n\n    calendar = traces[0][mainData + 'calendar'];\n    var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n    var autoBin = traces[0]._autoBin = {};\n    autoVals = autoBin[binOpts.dirs[0]] = {};\n\n    if (hasHist2dContour) {\n      // the \"true\" 2nd argument reverses the tick direction (which we can't\n      // just do with a minus sign because of month bins)\n      if (!binOpts.size) {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      }\n\n      if (binOpts.end === undefined) {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    } // Edge case: single-valued histogram overlaying others\n    // Use them all together to calculate the bin size for the single-valued one\n\n\n    if (isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 && pa.type !== 'category' && pa.type !== 'multicategory') {\n      // Several single-valued histograms! Stop infinite recursion,\n      // just return an extra flag that tells handleSingleValueOverlays\n      // to sort out this trace too\n      if (_overlayEdgeCase) return [newBinSpec, pos0, true];\n      newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n    } // adjust for CDF edge cases\n\n\n    cumulativeSpec = tracei.cumulative || {};\n\n    if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== 'include') {\n      if (cumulativeSpec.direction === 'decreasing') {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      } else {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n\n    binOpts.size = newBinSpec.size;\n\n    if (!binOpts.sizeFound) {\n      autoVals.size = newBinSpec.size;\n      Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n    }\n\n    setBound('start', binOpts, newBinSpec);\n    setBound('end', binOpts, newBinSpec);\n  }\n\n  pos0 = trace['_' + mainData + 'pos0'];\n  delete trace['_' + mainData + 'pos0']; // Each trace can specify its own start/end, or if omitted\n  // we ensure they're beyond the bounds of this trace's data,\n  // and we need to make sure start is aligned with the main start\n\n  var traceInputBins = trace._input[binAttr] || {};\n  var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n  var mainStart = binOpts.start;\n  var startIn = pa.r2l(traceInputBins.start);\n  var hasStart = startIn !== undefined;\n\n  if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n    // We have an explicit start to reconcile across traces\n    // if this trace has an explicit start, shift it down to a bin edge\n    // if another trace had an explicit start, shift it down to a\n    // bin edge past our data\n    var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);\n    var dummyAx = {\n      type: pa.type === 'category' || pa.type === 'multicategory' ? 'linear' : pa.type,\n      r2l: pa.r2l,\n      dtick: binOpts.size,\n      tick0: mainStart,\n      calendar: calendar,\n      range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)\n    };\n    var newStart = Axes.tickFirst(dummyAx);\n\n    if (newStart > pa.r2l(traceStart)) {\n      newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n    }\n\n    traceBinOptsCalc.start = pa.l2r(newStart);\n    if (!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n  }\n\n  var mainEnd = binOpts.end;\n  var endIn = pa.r2l(traceInputBins.end);\n  var hasEnd = endIn !== undefined;\n\n  if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n    // Reconciling an explicit end is easier, as it doesn't need to\n    // match bin edges\n    var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);\n    traceBinOptsCalc.end = pa.l2r(traceEnd);\n    if (!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n  } // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n\n\n  var autoBinAttr = 'autobin' + mainData;\n\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n\n  return [traceBinOptsCalc, pos0];\n}\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\n\n\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n  var fullLayout = gd._fullLayout;\n  var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n  var pastThisTrace = false;\n  var minSize = Infinity;\n  var singleValuedTraces = [trace];\n  var i, tracei, binOpts; // first collect all the:\n  // - min bin size from all multi-valued traces\n  // - single-valued traces\n\n  for (i = 0; i < overlaidTraceGroup.length; i++) {\n    tracei = overlaidTraceGroup[i];\n\n    if (tracei === trace) {\n      pastThisTrace = true;\n    } else if (!pastThisTrace) {\n      // This trace has already had its autobins calculated, so either:\n      // - it is part of a bingroup\n      // - it is NOT a single-valued trace\n      binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n      minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n    } else {\n      var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n      var binSpeci = resulti[0];\n      var isSingleValued = resulti[2]; // so we can use this result when we get to tracei in the normal\n      // course of events, mark it as done and put _pos0 back\n\n      tracei['_' + mainData + 'autoBinFinished'] = 1;\n      tracei['_' + mainData + 'pos0'] = resulti[1];\n\n      if (isSingleValued) {\n        singleValuedTraces.push(tracei);\n      } else {\n        minSize = Math.min(minSize, binSpeci.size);\n      }\n    }\n  } // find the real data values for each single-valued trace\n  // hunt through pos0 for the first valid value\n\n\n  var dataVals = new Array(singleValuedTraces.length);\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n\n    for (var j = 0; j < pos0.length; j++) {\n      if (pos0[j] !== undefined) {\n        dataVals[i] = pos0[j];\n        break;\n      }\n    }\n  } // are ALL traces are single-valued? use the min difference between\n  // all of their values (which defaults to 1 if there's still only one)\n\n\n  if (!isFinite(minSize)) {\n    minSize = Lib.distinctVals(dataVals).minDiff;\n  } // now apply the min size we found to all single-valued traces\n\n\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    tracei = singleValuedTraces[i];\n    var calendar = tracei[mainData + 'calendar'];\n    var newBins = {\n      start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n      end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n      size: minSize\n    };\n    tracei._input[binAttr] = tracei[binAttr] = newBins;\n    binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n    if (binOpts) Lib.extendFlat(binOpts, newBins);\n  }\n\n  return trace[binAttr];\n}\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\n\n\nfunction getConnectedHistograms(gd, trace) {\n  var xid = trace.xaxis;\n  var yid = trace.yaxis;\n  var orientation = trace.orientation;\n  var out = [];\n  var fullData = gd._fullData;\n\n  for (var i = 0; i < fullData.length; i++) {\n    var tracei = fullData[i];\n\n    if (tracei.type === 'histogram' && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {\n      out.push(tracei);\n    }\n  }\n\n  return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n  var i, vi, prevSum;\n\n  function firstHalfPoint(i) {\n    prevSum = size[i];\n    size[i] /= 2;\n  }\n\n  function nextHalfPoint(i) {\n    vi = size[i];\n    size[i] = prevSum + vi / 2;\n    prevSum += vi;\n  }\n\n  if (currentBin === 'half') {\n    if (direction === 'increasing') {\n      firstHalfPoint(0);\n\n      for (i = 1; i < size.length; i++) {\n        nextHalfPoint(i);\n      }\n    } else {\n      firstHalfPoint(size.length - 1);\n\n      for (i = size.length - 2; i >= 0; i--) {\n        nextHalfPoint(i);\n      }\n    }\n  } else if (direction === 'increasing') {\n    for (i = 1; i < size.length; i++) {\n      size[i] += size[i - 1];\n    } // 'exclude' is identical to 'include' just shifted one bin over\n\n\n    if (currentBin === 'exclude') {\n      size.unshift(0);\n      size.pop();\n    }\n  } else {\n    for (i = size.length - 2; i >= 0; i--) {\n      size[i] += size[i + 1];\n    }\n\n    if (currentBin === 'exclude') {\n      size.push(0);\n      size.shift();\n    }\n  }\n}\n\nmodule.exports = {\n  calc: calc,\n  calcAllAutoBins: calcAllAutoBins\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/histogram/calc.js"],"names":["isNumeric","require","Lib","Registry","Axes","arraysToCalcdata","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","calc","gd","trace","pos","size","pa","getFromId","orientation","yaxis","xaxis","mainData","counterData","x","y","calendar","cumulativeSpec","cumulative","i","binsAndPos","calcAllAutoBins","binSpec","pos0","nonuniformBins","binEdges","bins","inc","counts","inputPoints","total","norm","histnorm","func","histfunc","densityNorm","indexOf","i2","binEnd","n","enabled","replace","extremeFunc","sizeInit","binFunc","count","normFunc","isAvg","pr2c","v","r2c","rawCounterData","isArrayOrTypedArray","start","end","tickIncrement","length","push","type","_fullLayout","_roundFnOpts","groupName","roundFnOpts","leftGap","Infinity","rightGap","nMax","uniqueValsPerBin","ptNumber2cdIndex","posi","findBin","Math","min","roundFn","isRightEdge","cdf","direction","currentbin","seriesLen","cd","firstNonzero","lastNonzero","cdi","p","s","b","pts","ph0","ph1","_computePh","width1","selectedpoints","tagSelected","_overlayEdgeCase","binAttr","fullLayout","binOpts","_histogramBinOpts","isOverlay","barmode","traces","tracei","autoVals","c2r","cleanBound","cleanDate","Number","setBound","attr","newBins","nestedProperty","set","allPos","isFirstVisible","has2dMap","hasHist2dContour","visible","mainDatai","dirs","makeCalcdata","concat","_autoBin","traceIs","newBinSpec","autoBin","nbins","sizeFound","undefined","_dataSpan","handleSingleValueOverlays","traceInputBins","_input","traceBinOptsCalc","extendFlat","mainStart","startIn","r2l","hasStart","startFound","traceStart","aggNums","dummyAx","dtick","tick0","range","map","l2r","newStart","tickFirst","mainEnd","endIn","hasEnd","endFound","traceEnd","max","autoBinAttr","overlaidTraceGroup","getConnectedHistograms","pastThisTrace","minSize","singleValuedTraces","resulti","binSpeci","isSingleValued","dataVals","Array","j","isFinite","distinctVals","minDiff","xid","yid","out","fullData","_fullData","currentBin","vi","prevSum","firstHalfPoint","nextHalfPoint","unshift","pop","shift","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nfunction calc(gd, trace) {\n    var pos = [];\n    var size = [];\n    var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis : trace.xaxis);\n    var mainData = trace.orientation === 'h' ? 'y' : 'x';\n    var counterData = {x: 'y', y: 'x'}[mainData];\n    var calendar = trace[mainData + 'calendar'];\n    var cumulativeSpec = trace.cumulative;\n    var i;\n\n    var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n    var binSpec = binsAndPos[0];\n    var pos0 = binsAndPos[1];\n\n    var nonuniformBins = typeof binSpec.size === 'string';\n    var binEdges = [];\n    var bins = nonuniformBins ? binEdges : binSpec;\n    // make the empty bin array\n    var inc = [];\n    var counts = [];\n    var inputPoints = [];\n    var total = 0;\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densityNorm = norm.indexOf('density') !== -1;\n    var i2, binEnd, n;\n\n    if(cumulativeSpec.enabled && densityNorm) {\n        // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n        // which in the end means it's the same as without \"density\"\n        norm = norm.replace(/ ?density$/, '');\n        densityNorm = false;\n    }\n\n    var extremeFunc = func === 'max' || func === 'min';\n    var sizeInit = extremeFunc ? null : 0;\n    var binFunc = binFunctions.count;\n    var normFunc = normFunctions[norm];\n    var isAvg = false;\n    var pr2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var rawCounterData;\n\n    if(Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n        rawCounterData = trace[counterData];\n        isAvg = func === 'avg';\n        binFunc = binFunctions[func];\n    }\n\n    // create the bins (and any extra arrays needed)\n    // assume more than 1e6 bins is an error, so we don't crash the browser\n    i = pr2c(binSpec.start);\n\n    // decrease end a little in case of rounding errors\n    binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n    while(i < binEnd && pos.length < 1e6) {\n        i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n        pos.push((i + i2) / 2);\n        size.push(sizeInit);\n        inputPoints.push([]);\n        // nonuniform bins (like months) we need to search,\n        // rather than straight calculate the bin we're in\n        binEdges.push(i);\n        // nonuniform bins also need nonuniform normalization factors\n        if(densityNorm) inc.push(1 / (i2 - i));\n        if(isAvg) counts.push(0);\n        // break to avoid infinite loops\n        if(i2 <= i) break;\n        i = i2;\n    }\n    binEdges.push(i);\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBins && pa.type === 'date') {\n        bins = {\n            start: pr2c(bins.start),\n            end: pr2c(bins.end),\n            size: bins.size\n        };\n    }\n\n    // stash left and right gaps by group\n    if(!gd._fullLayout._roundFnOpts) gd._fullLayout._roundFnOpts = {};\n    var groupName = trace['_' + mainData + 'bingroup'];\n    var roundFnOpts = {leftGap: Infinity, rightGap: Infinity};\n    if(groupName) {\n        if(!gd._fullLayout._roundFnOpts[groupName]) gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;\n        roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n    }\n\n    // bin the data\n    // and make histogram-specific pt-number-to-cd-index map object\n    var nMax = size.length;\n    var uniqueValsPerBin = true;\n    var leftGap = roundFnOpts.leftGap;\n    var rightGap = roundFnOpts.rightGap;\n    var ptNumber2cdIndex = {};\n    for(i = 0; i < pos0.length; i++) {\n        var posi = pos0[i];\n        n = Lib.findBin(posi, bins);\n        if(n >= 0 && n < nMax) {\n            total += binFunc(n, i, size, rawCounterData, counts);\n            if(uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n                uniqueValsPerBin = false;\n            }\n            inputPoints[n].push(i);\n            ptNumber2cdIndex[i] = n;\n\n            leftGap = Math.min(leftGap, posi - binEdges[n]);\n            rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n        }\n    }\n    roundFnOpts.leftGap = leftGap;\n    roundFnOpts.rightGap = rightGap;\n\n    var roundFn;\n    if(!uniqueValsPerBin) {\n        roundFn = function(v, isRightEdge) {\n            return function() {\n                var roundFnOpts = gd._fullLayout._roundFnOpts[groupName];\n                return getBinSpanLabelRound(\n                    roundFnOpts.leftGap,\n                    roundFnOpts.rightGap,\n                    binEdges, pa, calendar\n                )(v, isRightEdge);\n            };\n        };\n    }\n\n    // average and/or normalize the data, if needed\n    if(isAvg) total = doAvg(size, counts);\n    if(normFunc) normFunc(size, total, inc);\n\n    // after all normalization etc, now we can accumulate if desired\n    if(cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n\n    var seriesLen = Math.min(pos.length, size.length);\n    var cd = [];\n    var firstNonzero = 0;\n    var lastNonzero = seriesLen - 1;\n\n    // look for empty bins at the ends to remove, so autoscale omits them\n    for(i = 0; i < seriesLen; i++) {\n        if(size[i]) {\n            firstNonzero = i;\n            break;\n        }\n    }\n    for(i = seriesLen - 1; i >= firstNonzero; i--) {\n        if(size[i]) {\n            lastNonzero = i;\n            break;\n        }\n    }\n\n    // create the \"calculated data\" to plot\n    for(i = firstNonzero; i <= lastNonzero; i++) {\n        if((isNumeric(pos[i]) && isNumeric(size[i]))) {\n            var cdi = {\n                p: pos[i],\n                s: size[i],\n                b: 0\n            };\n\n            // setup hover and event data fields,\n            // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n            // for cumulative distributions\n            if(!cumulativeSpec.enabled) {\n                cdi.pts = inputPoints[i];\n                if(uniqueValsPerBin) {\n                    cdi.ph0 = cdi.ph1 = (inputPoints[i].length) ? pos0[inputPoints[i][0]] : pos[i];\n                } else {\n                    // Defer evaluation of ph(0|1) in crossTraceCalc\n                    trace._computePh = true;\n                    cdi.ph0 = roundFn(binEdges[i]);\n                    cdi.ph1 = roundFn(binEdges[i + 1], true);\n                }\n            }\n            cd.push(cdi);\n        }\n    }\n\n    if(cd.length === 1) {\n        // when we collapse to a single bin, calcdata no longer describes bin size\n        // so we need to explicitly specify it\n        cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n    }\n\n    arraysToCalcdata(cd, trace);\n\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n    }\n\n    return cd;\n}\n\n/*\n * calcAllAutoBins: we want all histograms inside the same bingroup\n * (see logic in Histogram.crossTraceDefaults) to share bin specs\n *\n * If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms inside the same\n * bingroup.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n    var binAttr = mainData + 'bins';\n    var fullLayout = gd._fullLayout;\n    var groupName = trace['_' + mainData + 'bingroup'];\n    var binOpts = fullLayout._histogramBinOpts[groupName];\n    var isOverlay = fullLayout.barmode === 'overlay';\n    var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n    var r2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var c2r = function(v) { return pa.c2r(v, 0, calendar); };\n\n    var cleanBound = pa.type === 'date' ?\n        function(v) { return (v || v === 0) ? Lib.cleanDate(v, null, calendar) : null; } :\n        function(v) { return isNumeric(v) ? Number(v) : null; };\n\n    function setBound(attr, bins, newBins) {\n        if(bins[attr + 'Found']) {\n            bins[attr] = cleanBound(bins[attr]);\n            if(bins[attr] === null) bins[attr] = newBins[attr];\n        } else {\n            autoVals[attr] = bins[attr] = newBins[attr];\n            Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n        }\n    }\n\n    // all but the first trace in this group has already been marked finished\n    // clear this flag, so next time we run calc we will run autobin again\n    if(trace['_' + mainData + 'autoBinFinished']) {\n        delete trace['_' + mainData + 'autoBinFinished'];\n    } else {\n        traces = binOpts.traces;\n        var allPos = [];\n\n        // Note: we're including `legendonly` traces here for autobin purposes,\n        // so that showing & hiding from the legend won't affect bins.\n        // But this complicates things a bit since those traces don't `calc`,\n        // hence `isFirstVisible`.\n        var isFirstVisible = true;\n        var has2dMap = false;\n        var hasHist2dContour = false;\n        for(i = 0; i < traces.length; i++) {\n            tracei = traces[i];\n\n            if(tracei.visible) {\n                var mainDatai = binOpts.dirs[i];\n                pos0 = tracei['_' + mainDatai + 'pos0'] = pa.makeCalcdata(tracei, mainDatai);\n\n                allPos = Lib.concat(allPos, pos0);\n                delete tracei['_' + mainData + 'autoBinFinished'];\n\n                if(trace.visible === true) {\n                    if(isFirstVisible) {\n                        isFirstVisible = false;\n                    } else {\n                        delete tracei._autoBin;\n                        tracei['_' + mainData + 'autoBinFinished'] = 1;\n                    }\n                    if(Registry.traceIs(tracei, '2dMap')) {\n                        has2dMap = true;\n                    }\n                    if(tracei.type === 'histogram2dcontour') {\n                        hasHist2dContour = true;\n                    }\n                }\n            }\n        }\n\n        calendar = traces[0][mainData + 'calendar'];\n        var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);\n\n        var autoBin = traces[0]._autoBin = {};\n        autoVals = autoBin[binOpts.dirs[0]] = {};\n\n        if(hasHist2dContour) {\n            // the \"true\" 2nd argument reverses the tick direction (which we can't\n            // just do with a minus sign because of month bins)\n            if(!binOpts.size) {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            }\n            if(binOpts.end === undefined) {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        // Edge case: single-valued histogram overlaying others\n        // Use them all together to calculate the bin size for the single-valued one\n        if(isOverlay && !Registry.traceIs(trace, '2dMap') && newBinSpec._dataSpan === 0 &&\n            pa.type !== 'category' && pa.type !== 'multicategory') {\n            // Several single-valued histograms! Stop infinite recursion,\n            // just return an extra flag that tells handleSingleValueOverlays\n            // to sort out this trace too\n            if(_overlayEdgeCase) return [newBinSpec, pos0, true];\n\n            newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n        }\n\n        // adjust for CDF edge cases\n        cumulativeSpec = tracei.cumulative || {};\n        if(cumulativeSpec.enabled && (cumulativeSpec.currentbin !== 'include')) {\n            if(cumulativeSpec.direction === 'decreasing') {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            } else {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n\n        binOpts.size = newBinSpec.size;\n        if(!binOpts.sizeFound) {\n            autoVals.size = newBinSpec.size;\n            Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n        }\n\n        setBound('start', binOpts, newBinSpec);\n        setBound('end', binOpts, newBinSpec);\n    }\n\n    pos0 = trace['_' + mainData + 'pos0'];\n    delete trace['_' + mainData + 'pos0'];\n\n    // Each trace can specify its own start/end, or if omitted\n    // we ensure they're beyond the bounds of this trace's data,\n    // and we need to make sure start is aligned with the main start\n    var traceInputBins = trace._input[binAttr] || {};\n    var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n    var mainStart = binOpts.start;\n    var startIn = pa.r2l(traceInputBins.start);\n    var hasStart = startIn !== undefined;\n    if((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n        // We have an explicit start to reconcile across traces\n        // if this trace has an explicit start, shift it down to a bin edge\n        // if another trace had an explicit start, shift it down to a\n        // bin edge past our data\n        var traceStart = hasStart ?\n            startIn :\n            Lib.aggNums(Math.min, null, pos0);\n\n        var dummyAx = {\n            type: (pa.type === 'category' || pa.type === 'multicategory') ? 'linear' : pa.type,\n            r2l: pa.r2l,\n            dtick: binOpts.size,\n            tick0: mainStart,\n            calendar: calendar,\n            range: ([traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)]).map(pa.l2r)\n        };\n        var newStart = Axes.tickFirst(dummyAx);\n        if(newStart > pa.r2l(traceStart)) {\n            newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n        }\n        traceBinOptsCalc.start = pa.l2r(newStart);\n        if(!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n    }\n\n    var mainEnd = binOpts.end;\n    var endIn = pa.r2l(traceInputBins.end);\n    var hasEnd = endIn !== undefined;\n    if((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n        // Reconciling an explicit end is easier, as it doesn't need to\n        // match bin edges\n        var traceEnd = hasEnd ?\n            endIn :\n            Lib.aggNums(Math.max, null, pos0);\n\n        traceBinOptsCalc.end = pa.l2r(traceEnd);\n        if(!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n    }\n\n    // Backward compatibility for one-time autobinning.\n    // autobin: true is handled in cleanData, but autobin: false\n    // needs to be here where we have determined the values.\n    var autoBinAttr = 'autobin' + mainData;\n    if(trace._input[autoBinAttr] === false) {\n        trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n        delete trace._input[autoBinAttr];\n        delete trace[autoBinAttr];\n    }\n\n    return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n    var fullLayout = gd._fullLayout;\n    var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n    var pastThisTrace = false;\n    var minSize = Infinity;\n    var singleValuedTraces = [trace];\n    var i, tracei, binOpts;\n\n    // first collect all the:\n    // - min bin size from all multi-valued traces\n    // - single-valued traces\n    for(i = 0; i < overlaidTraceGroup.length; i++) {\n        tracei = overlaidTraceGroup[i];\n\n        if(tracei === trace) {\n            pastThisTrace = true;\n        } else if(!pastThisTrace) {\n            // This trace has already had its autobins calculated, so either:\n            // - it is part of a bingroup\n            // - it is NOT a single-valued trace\n            binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n            minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);\n        } else {\n            var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n            var binSpeci = resulti[0];\n            var isSingleValued = resulti[2];\n\n            // so we can use this result when we get to tracei in the normal\n            // course of events, mark it as done and put _pos0 back\n            tracei['_' + mainData + 'autoBinFinished'] = 1;\n            tracei['_' + mainData + 'pos0'] = resulti[1];\n\n            if(isSingleValued) {\n                singleValuedTraces.push(tracei);\n            } else {\n                minSize = Math.min(minSize, binSpeci.size);\n            }\n        }\n    }\n\n    // find the real data values for each single-valued trace\n    // hunt through pos0 for the first valid value\n    var dataVals = new Array(singleValuedTraces.length);\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        var pos0 = singleValuedTraces[i]['_' + mainData + 'pos0'];\n        for(var j = 0; j < pos0.length; j++) {\n            if(pos0[j] !== undefined) {\n                dataVals[i] = pos0[j];\n                break;\n            }\n        }\n    }\n\n    // are ALL traces are single-valued? use the min difference between\n    // all of their values (which defaults to 1 if there's still only one)\n    if(!isFinite(minSize)) {\n        minSize = Lib.distinctVals(dataVals).minDiff;\n    }\n\n    // now apply the min size we found to all single-valued traces\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        tracei = singleValuedTraces[i];\n        var calendar = tracei[mainData + 'calendar'];\n\n        var newBins = {\n            start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n            end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n            size: minSize\n        };\n\n        tracei._input[binAttr] = tracei[binAttr] = newBins;\n\n        binOpts = fullLayout._histogramBinOpts[tracei['_' + mainData + 'bingroup']];\n        if(binOpts) Lib.extendFlat(binOpts, newBins);\n    }\n\n    return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n    var xid = trace.xaxis;\n    var yid = trace.yaxis;\n    var orientation = trace.orientation;\n\n    var out = [];\n    var fullData = gd._fullData;\n    for(var i = 0; i < fullData.length; i++) {\n        var tracei = fullData[i];\n        if(tracei.type === 'histogram' &&\n            tracei.visible === true &&\n            tracei.orientation === orientation &&\n            tracei.xaxis === xid && tracei.yaxis === yid\n        ) {\n            out.push(tracei);\n        }\n    }\n\n    return out;\n}\n\nfunction cdf(size, direction, currentBin) {\n    var i, vi, prevSum;\n\n    function firstHalfPoint(i) {\n        prevSum = size[i];\n        size[i] /= 2;\n    }\n\n    function nextHalfPoint(i) {\n        vi = size[i];\n        size[i] = prevSum + vi / 2;\n        prevSum += vi;\n    }\n\n    if(currentBin === 'half') {\n        if(direction === 'increasing') {\n            firstHalfPoint(0);\n            for(i = 1; i < size.length; i++) {\n                nextHalfPoint(i);\n            }\n        } else {\n            firstHalfPoint(size.length - 1);\n            for(i = size.length - 2; i >= 0; i--) {\n                nextHalfPoint(i);\n            }\n        }\n    } else if(direction === 'increasing') {\n        for(i = 1; i < size.length; i++) {\n            size[i] += size[i - 1];\n        }\n\n        // 'exclude' is identical to 'include' just shifted one bin over\n        if(currentBin === 'exclude') {\n            size.unshift(0);\n            size.pop();\n        }\n    } else {\n        for(i = size.length - 2; i >= 0; i--) {\n            size[i] += size[i + 1];\n        }\n\n        if(currentBin === 'exclude') {\n            size.push(0);\n            size.shift();\n        }\n    }\n}\n\nmodule.exports = {\n    calc: calc,\n    calcAllAutoBins: calcAllAutoBins\n};\n"]},"metadata":{},"sourceType":"script"}