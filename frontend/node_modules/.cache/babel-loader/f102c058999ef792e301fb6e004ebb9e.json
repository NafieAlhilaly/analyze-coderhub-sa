{"ast":null,"code":"'use strict';\n\nfunction findCategories(ax, opts) {\n  var dataAttr = opts.dataAttr || ax._id.charAt(0);\n\n  var lookup = {};\n  var axData;\n  var i, j;\n\n  if (opts.axData) {\n    // non-x/y case\n    axData = opts.axData;\n  } else {\n    // x/y case\n    axData = [];\n\n    for (i = 0; i < opts.data.length; i++) {\n      var trace = opts.data[i];\n\n      if (trace[dataAttr + 'axis'] === ax._id) {\n        axData.push(trace);\n      }\n    }\n  }\n\n  for (i = 0; i < axData.length; i++) {\n    var vals = axData[i][dataAttr];\n\n    for (j = 0; j < vals.length; j++) {\n      var v = vals[j];\n\n      if (v !== null && v !== undefined) {\n        lookup[v] = 1;\n      }\n    }\n  }\n\n  return Object.keys(lookup);\n}\n/**\n * Fills in category* default and initial categories.\n *\n * @param {object} containerIn : input axis object\n * @param {object} containerOut : full axis object\n * @param {function} coerce : Lib.coerce fn wrapper\n * @param {object} opts :\n *   - data {array} : (full) data trace\n * OR\n *   - axData {array} : (full) data associated with axis being coerced here\n *   - dataAttr {string} : attribute name corresponding to coordinate array\n */\n\n\nmodule.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {\n  if (containerOut.type !== 'category') return;\n  var arrayIn = containerIn.categoryarray;\n  var isValidArray = Array.isArray(arrayIn) && arrayIn.length > 0; // override default 'categoryorder' value when non-empty array is supplied\n\n  var orderDefault;\n  if (isValidArray) orderDefault = 'array';\n  var order = coerce('categoryorder', orderDefault);\n  var array; // coerce 'categoryarray' only in array order case\n\n  if (order === 'array') {\n    array = coerce('categoryarray');\n  } // cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'\n\n\n  if (!isValidArray && order === 'array') {\n    order = containerOut.categoryorder = 'trace';\n  } // set up things for makeCalcdata\n\n\n  if (order === 'trace') {\n    containerOut._initialCategories = [];\n  } else if (order === 'array') {\n    containerOut._initialCategories = array.slice();\n  } else {\n    array = findCategories(containerOut, opts).sort();\n\n    if (order === 'category ascending') {\n      containerOut._initialCategories = array;\n    } else if (order === 'category descending') {\n      containerOut._initialCategories = array.reverse();\n    }\n  }\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/category_order_defaults.js"],"names":["findCategories","ax","opts","dataAttr","_id","charAt","lookup","axData","i","j","data","length","trace","push","vals","v","undefined","Object","keys","module","exports","handleCategoryOrderDefaults","containerIn","containerOut","coerce","type","arrayIn","categoryarray","isValidArray","Array","isArray","orderDefault","order","array","categoryorder","_initialCategories","slice","sort","reverse"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction findCategories(ax, opts) {\n    var dataAttr = opts.dataAttr || ax._id.charAt(0);\n    var lookup = {};\n    var axData;\n    var i, j;\n\n    if(opts.axData) {\n        // non-x/y case\n        axData = opts.axData;\n    } else {\n        // x/y case\n        axData = [];\n        for(i = 0; i < opts.data.length; i++) {\n            var trace = opts.data[i];\n            if(trace[dataAttr + 'axis'] === ax._id) {\n                axData.push(trace);\n            }\n        }\n    }\n\n    for(i = 0; i < axData.length; i++) {\n        var vals = axData[i][dataAttr];\n        for(j = 0; j < vals.length; j++) {\n            var v = vals[j];\n            if(v !== null && v !== undefined) {\n                lookup[v] = 1;\n            }\n        }\n    }\n\n    return Object.keys(lookup);\n}\n\n/**\n * Fills in category* default and initial categories.\n *\n * @param {object} containerIn : input axis object\n * @param {object} containerOut : full axis object\n * @param {function} coerce : Lib.coerce fn wrapper\n * @param {object} opts :\n *   - data {array} : (full) data trace\n * OR\n *   - axData {array} : (full) data associated with axis being coerced here\n *   - dataAttr {string} : attribute name corresponding to coordinate array\n */\nmodule.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {\n    if(containerOut.type !== 'category') return;\n\n    var arrayIn = containerIn.categoryarray;\n    var isValidArray = (Array.isArray(arrayIn) && arrayIn.length > 0);\n\n    // override default 'categoryorder' value when non-empty array is supplied\n    var orderDefault;\n    if(isValidArray) orderDefault = 'array';\n\n    var order = coerce('categoryorder', orderDefault);\n    var array;\n\n    // coerce 'categoryarray' only in array order case\n    if(order === 'array') {\n        array = coerce('categoryarray');\n    }\n\n    // cannot set 'categoryorder' to 'array' with an invalid 'categoryarray'\n    if(!isValidArray && order === 'array') {\n        order = containerOut.categoryorder = 'trace';\n    }\n\n    // set up things for makeCalcdata\n    if(order === 'trace') {\n        containerOut._initialCategories = [];\n    } else if(order === 'array') {\n        containerOut._initialCategories = array.slice();\n    } else {\n        array = findCategories(containerOut, opts).sort();\n        if(order === 'category ascending') {\n            containerOut._initialCategories = array;\n        } else if(order === 'category descending') {\n            containerOut._initialCategories = array.reverse();\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}