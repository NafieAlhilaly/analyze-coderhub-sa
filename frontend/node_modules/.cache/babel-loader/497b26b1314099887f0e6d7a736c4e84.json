{"ast":null,"code":"'use strict';\n\nvar createMesh = require('gl-mesh3d');\n\nvar triangulate = require('delaunay-triangulate');\n\nvar alphaShape = require('alpha-shape');\n\nvar convexHull = require('convex-hull');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nfunction Mesh3DTrace(scene, mesh, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = mesh;\n  this.name = '';\n  this.color = '#fff';\n  this.data = null;\n  this.showContour = false;\n}\n\nvar proto = Mesh3DTrace.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.mesh) {\n    var selectIndex = selection.index = selection.data.index;\n\n    if (selection.data._cellCenter) {\n      selection.traceCoordinate = selection.data.dataCoordinate;\n    } else {\n      selection.traceCoordinate = [this.data.x[selectIndex], this.data.y[selectIndex], this.data.z[selectIndex]];\n    }\n\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[selectIndex] !== undefined) {\n      selection.textLabel = text[selectIndex];\n    } else if (text) {\n      selection.textLabel = text;\n    }\n\n    return true;\n  }\n};\n\nfunction parseColorArray(colors) {\n  var b = [];\n  var len = colors.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = str2RgbaArray(colors[i]);\n  }\n\n  return b;\n} // Unpack position data\n\n\nfunction toDataCoords(axis, coord, scale, calendar) {\n  var b = [];\n  var len = coord.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = axis.d2l(coord[i], 0, calendar) * scale;\n  }\n\n  return b;\n} // Round indices if passed as floats\n\n\nfunction toRoundIndex(a) {\n  var b = [];\n  var len = a.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = Math.round(a[i]);\n  }\n\n  return b;\n}\n\nfunction delaunayCells(delaunayaxis, positions) {\n  var d = ['x', 'y', 'z'].indexOf(delaunayaxis);\n  var b = [];\n  var len = positions.length;\n\n  for (var i = 0; i < len; i++) {\n    b[i] = [positions[i][(d + 1) % 3], positions[i][(d + 2) % 3]];\n  }\n\n  return triangulate(b);\n} // Validate indices\n\n\nfunction hasValidIndices(list, numVertices) {\n  var len = list.length;\n\n  for (var i = 0; i < len; i++) {\n    if (list[i] <= -0.5 || list[i] >= numVertices - 0.5) {\n      // Note: the indices would be rounded -0.49 is valid.\n      return false;\n    }\n  }\n\n  return true;\n}\n\nproto.update = function (data) {\n  var scene = this.scene;\n  var layout = scene.fullSceneLayout;\n  this.data = data;\n  var numVertices = data.x.length;\n  var positions = zip3(toDataCoords(layout.xaxis, data.x, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data.y, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data.z, scene.dataScale[2], data.zcalendar));\n  var cells;\n\n  if (data.i && data.j && data.k) {\n    if (data.i.length !== data.j.length || data.j.length !== data.k.length || !hasValidIndices(data.i, numVertices) || !hasValidIndices(data.j, numVertices) || !hasValidIndices(data.k, numVertices)) {\n      return;\n    }\n\n    cells = zip3(toRoundIndex(data.i), toRoundIndex(data.j), toRoundIndex(data.k));\n  } else if (data.alphahull === 0) {\n    cells = convexHull(positions);\n  } else if (data.alphahull > 0) {\n    cells = alphaShape(data.alphahull, positions);\n  } else {\n    cells = delaunayCells(data.delaunayaxis, positions);\n  }\n\n  var config = {\n    positions: positions,\n    cells: cells,\n    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n    ambient: data.lighting.ambient,\n    diffuse: data.lighting.diffuse,\n    specular: data.lighting.specular,\n    roughness: data.lighting.roughness,\n    fresnel: data.lighting.fresnel,\n    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n    faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n    opacity: data.opacity,\n    contourEnable: data.contour.show,\n    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n    contourWidth: data.contour.width,\n    useFacetNormals: data.flatshading\n  };\n\n  if (data.intensity) {\n    var cOpts = extractOpts(data);\n    this.color = '#fff';\n    var mode = data.intensitymode;\n    config[mode + 'Intensity'] = data.intensity;\n    config[mode + 'IntensityBounds'] = [cOpts.min, cOpts.max];\n    config.colormap = parseColorScale(data);\n  } else if (data.vertexcolor) {\n    this.color = data.vertexcolor[0];\n    config.vertexColors = parseColorArray(data.vertexcolor);\n  } else if (data.facecolor) {\n    this.color = data.facecolor[0];\n    config.cellColors = parseColorArray(data.facecolor);\n  } else {\n    this.color = data.color;\n    config.meshColor = str2RgbaArray(data.color);\n  } // Update mesh\n\n\n  this.mesh.update(config);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createMesh3DTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var mesh = createMesh({\n    gl: gl\n  });\n  var result = new Mesh3DTrace(scene, mesh, data.uid);\n  mesh._trace = result;\n  result.update(data);\n  scene.glplot.add(mesh);\n  return result;\n}\n\nmodule.exports = createMesh3DTrace;","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/mesh3d/convert.js"],"names":["createMesh","require","triangulate","alphaShape","convexHull","parseColorScale","str2RgbaArray","extractOpts","zip3","Mesh3DTrace","scene","mesh","uid","name","color","data","showContour","proto","prototype","handlePick","selection","object","selectIndex","index","_cellCenter","traceCoordinate","dataCoordinate","x","y","z","text","hovertext","Array","isArray","undefined","textLabel","parseColorArray","colors","b","len","length","i","toDataCoords","axis","coord","scale","calendar","d2l","toRoundIndex","a","Math","round","delaunayCells","delaunayaxis","positions","d","indexOf","hasValidIndices","list","numVertices","update","layout","fullSceneLayout","xaxis","dataScale","xcalendar","yaxis","ycalendar","zaxis","zcalendar","cells","j","k","alphahull","config","lightPosition","lightposition","ambient","lighting","diffuse","specular","roughness","fresnel","vertexNormalsEpsilon","vertexnormalsepsilon","faceNormalsEpsilon","facenormalsepsilon","opacity","contourEnable","contour","show","contourColor","slice","contourWidth","width","useFacetNormals","flatshading","intensity","cOpts","mode","intensitymode","min","max","colormap","vertexcolor","vertexColors","facecolor","cellColors","meshColor","dispose","glplot","remove","createMesh3DTrace","gl","result","_trace","add","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar createMesh = require('gl-mesh3d');\nvar triangulate = require('delaunay-triangulate');\nvar alphaShape = require('alpha-shape');\nvar convexHull = require('convex-hull');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\nvar str2RgbaArray = require('../../lib/str2rgbarray');\nvar extractOpts = require('../../components/colorscale').extractOpts;\nvar zip3 = require('../../plots/gl3d/zip3');\n\nfunction Mesh3DTrace(scene, mesh, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.mesh = mesh;\n    this.name = '';\n    this.color = '#fff';\n    this.data = null;\n    this.showContour = false;\n}\n\nvar proto = Mesh3DTrace.prototype;\n\nproto.handlePick = function(selection) {\n    if(selection.object === this.mesh) {\n        var selectIndex = selection.index = selection.data.index;\n\n        if(selection.data._cellCenter) {\n            selection.traceCoordinate = selection.data.dataCoordinate;\n        } else {\n            selection.traceCoordinate = [\n                this.data.x[selectIndex],\n                this.data.y[selectIndex],\n                this.data.z[selectIndex]\n            ];\n        }\n\n        var text = this.data.hovertext || this.data.text;\n        if(Array.isArray(text) && text[selectIndex] !== undefined) {\n            selection.textLabel = text[selectIndex];\n        } else if(text) {\n            selection.textLabel = text;\n        }\n\n        return true;\n    }\n};\n\nfunction parseColorArray(colors) {\n    var b = [];\n    var len = colors.length;\n    for(var i = 0; i < len; i++) {\n        b[i] = str2RgbaArray(colors[i]);\n    }\n    return b;\n}\n\n// Unpack position data\nfunction toDataCoords(axis, coord, scale, calendar) {\n    var b = [];\n    var len = coord.length;\n    for(var i = 0; i < len; i++) {\n        b[i] = axis.d2l(coord[i], 0, calendar) * scale;\n    }\n    return b;\n}\n\n// Round indices if passed as floats\nfunction toRoundIndex(a) {\n    var b = [];\n    var len = a.length;\n    for(var i = 0; i < len; i++) {\n        b[i] = Math.round(a[i]);\n    }\n    return b;\n}\n\nfunction delaunayCells(delaunayaxis, positions) {\n    var d = ['x', 'y', 'z'].indexOf(delaunayaxis);\n    var b = [];\n    var len = positions.length;\n    for(var i = 0; i < len; i++) {\n        b[i] = [positions[i][(d + 1) % 3], positions[i][(d + 2) % 3]];\n    }\n    return triangulate(b);\n}\n\n// Validate indices\nfunction hasValidIndices(list, numVertices) {\n    var len = list.length;\n    for(var i = 0; i < len; i++) {\n        if(list[i] <= -0.5 || list[i] >= numVertices - 0.5) { // Note: the indices would be rounded -0.49 is valid.\n            return false;\n        }\n    }\n    return true;\n}\n\nproto.update = function(data) {\n    var scene = this.scene;\n    var layout = scene.fullSceneLayout;\n\n    this.data = data;\n\n    var numVertices = data.x.length;\n\n    var positions = zip3(\n        toDataCoords(layout.xaxis, data.x, scene.dataScale[0], data.xcalendar),\n        toDataCoords(layout.yaxis, data.y, scene.dataScale[1], data.ycalendar),\n        toDataCoords(layout.zaxis, data.z, scene.dataScale[2], data.zcalendar)\n    );\n\n    var cells;\n    if(data.i && data.j && data.k) {\n        if(\n            data.i.length !== data.j.length ||\n            data.j.length !== data.k.length ||\n            !hasValidIndices(data.i, numVertices) ||\n            !hasValidIndices(data.j, numVertices) ||\n            !hasValidIndices(data.k, numVertices)\n        ) {\n            return;\n        }\n        cells = zip3(\n            toRoundIndex(data.i),\n            toRoundIndex(data.j),\n            toRoundIndex(data.k)\n        );\n    } else if(data.alphahull === 0) {\n        cells = convexHull(positions);\n    } else if(data.alphahull > 0) {\n        cells = alphaShape(data.alphahull, positions);\n    } else {\n        cells = delaunayCells(data.delaunayaxis, positions);\n    }\n\n    var config = {\n        positions: positions,\n        cells: cells,\n        lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n        ambient: data.lighting.ambient,\n        diffuse: data.lighting.diffuse,\n        specular: data.lighting.specular,\n        roughness: data.lighting.roughness,\n        fresnel: data.lighting.fresnel,\n        vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n        faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n        opacity: data.opacity,\n        contourEnable: data.contour.show,\n        contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n        contourWidth: data.contour.width,\n        useFacetNormals: data.flatshading\n    };\n\n    if(data.intensity) {\n        var cOpts = extractOpts(data);\n        this.color = '#fff';\n        var mode = data.intensitymode;\n        config[mode + 'Intensity'] = data.intensity;\n        config[mode + 'IntensityBounds'] = [cOpts.min, cOpts.max];\n        config.colormap = parseColorScale(data);\n    } else if(data.vertexcolor) {\n        this.color = data.vertexcolor[0];\n        config.vertexColors = parseColorArray(data.vertexcolor);\n    } else if(data.facecolor) {\n        this.color = data.facecolor[0];\n        config.cellColors = parseColorArray(data.facecolor);\n    } else {\n        this.color = data.color;\n        config.meshColor = str2RgbaArray(data.color);\n    }\n\n    // Update mesh\n    this.mesh.update(config);\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.mesh);\n    this.mesh.dispose();\n};\n\nfunction createMesh3DTrace(scene, data) {\n    var gl = scene.glplot.gl;\n    var mesh = createMesh({gl: gl});\n    var result = new Mesh3DTrace(scene, mesh, data.uid);\n    mesh._trace = result;\n    result.update(data);\n    scene.glplot.add(mesh);\n    return result;\n}\n\nmodule.exports = createMesh3DTrace;\n"]},"metadata":{},"sourceType":"script"}