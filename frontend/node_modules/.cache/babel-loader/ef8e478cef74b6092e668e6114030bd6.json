{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar orientations = ['v', 'h'];\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var calcdata = gd.calcdata;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n\n  for (var i = 0; i < orientations.length; i++) {\n    var orientation = orientations[i];\n    var posAxis = orientation === 'h' ? ya : xa;\n    var boxList = []; // make list of boxes / candlesticks\n    // For backward compatibility, candlesticks are treated as if they *are* box traces here\n\n    for (var j = 0; j < calcdata.length; j++) {\n      var cd = calcdata[j];\n      var t = cd[0].t;\n      var trace = cd[0].trace;\n\n      if (trace.visible === true && (trace.type === 'box' || trace.type === 'candlestick') && !t.empty && (trace.orientation || 'v') === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {\n        boxList.push(j);\n      }\n    }\n\n    setPositionOffset('box', gd, boxList, posAxis);\n  }\n}\n\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n  var calcdata = gd.calcdata;\n  var fullLayout = gd._fullLayout;\n  var axId = posAxis._id;\n  var axLetter = axId.charAt(0);\n  var i, j, calcTrace;\n  var pointList = [];\n  var shownPts = 0; // make list of box points\n\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n\n    for (j = 0; j < calcTrace.length; j++) {\n      pointList.push(posAxis.c2l(calcTrace[j].pos, true));\n      shownPts += (calcTrace[j].pts2 || []).length;\n    }\n  }\n\n  if (!pointList.length) return; // box plots - update dPos based on multiple traces\n\n  var boxdv = Lib.distinctVals(pointList);\n\n  if (posAxis.type === 'category' || posAxis.type === 'multicategory') {\n    boxdv.minDiff = 1;\n  }\n\n  var dPos0 = boxdv.minDiff / 2; // check for forced minimum dtick\n\n  Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n  var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n  var numTotal = fullLayout[numKey];\n  var group = fullLayout[traceType + 'mode'] === 'group' && numTotal > 1;\n  var groupFraction = 1 - fullLayout[traceType + 'gap'];\n  var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    var trace = calcTrace[0].trace;\n    var t = calcTrace[0].t;\n    var width = trace.width;\n    var side = trace.side; // position coordinate delta\n\n    var dPos; // box half width;\n\n    var bdPos; // box center offset\n\n    var bPos; // half-width within which to accept hover for this box/violin\n    // always split the distance to the closest box/violin\n\n    var wHover;\n\n    if (width) {\n      dPos = bdPos = wHover = width / 2;\n      bPos = 0;\n    } else {\n      dPos = dPos0;\n\n      if (group) {\n        var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;\n        var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n        var num = nOffsetGroups || numTotal;\n        var shift = nOffsetGroups ? trace._offsetIndex : t.num;\n        bdPos = dPos * groupFraction * groupGapFraction / num;\n        bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;\n        wHover = dPos * groupFraction / num;\n      } else {\n        bdPos = dPos * groupFraction * groupGapFraction;\n        bPos = 0;\n        wHover = dPos;\n      }\n    }\n\n    t.dPos = dPos;\n    t.bPos = bPos;\n    t.bdPos = bdPos;\n    t.wHover = wHover; // box/violin-only value-space push value\n\n    var pushplus;\n    var pushminus; // edge of box/violin\n\n    var edge = bPos + bdPos;\n    var edgeplus;\n    var edgeminus; // value-space padding\n\n    var vpadplus;\n    var vpadminus; // pixel-space padding\n\n    var ppadplus;\n    var ppadminus; // do we add 5% of both sides (more logic for points beyond box/violin below)\n\n    var padded = Boolean(width); // does this trace show points?\n\n    var hasPts = (trace.boxpoints || trace.points) && shownPts > 0;\n\n    if (side === 'positive') {\n      pushplus = dPos * (width ? 1 : 0.5);\n      edgeplus = edge;\n      pushminus = edgeplus = bPos;\n    } else if (side === 'negative') {\n      pushplus = edgeplus = bPos;\n      pushminus = dPos * (width ? 1 : 0.5);\n      edgeminus = edge;\n    } else {\n      pushplus = pushminus = dPos;\n      edgeplus = edgeminus = edge;\n    }\n\n    if (hasPts) {\n      var pointpos = trace.pointpos;\n      var jitter = trace.jitter;\n      var ms = trace.marker.size / 2;\n      var pp = 0;\n\n      if (pointpos + jitter >= 0) {\n        pp = edge * (pointpos + jitter);\n\n        if (pp > pushplus) {\n          // (++) beyond plus-value, use pp\n          padded = true;\n          ppadplus = ms;\n          vpadplus = pp;\n        } else if (pp > edgeplus) {\n          // (+), use push-value (it's bigger), but add px-pad\n          ppadplus = ms;\n          vpadplus = pushplus;\n        }\n      }\n\n      if (pp <= pushplus) {\n        // (->) fallback to push value\n        vpadplus = pushplus;\n      }\n\n      var pm = 0;\n\n      if (pointpos - jitter <= 0) {\n        pm = -edge * (pointpos - jitter);\n\n        if (pm > pushminus) {\n          // (--) beyond plus-value, use pp\n          padded = true;\n          ppadminus = ms;\n          vpadminus = pm;\n        } else if (pm > edgeminus) {\n          // (-), use push-value (it's bigger), but add px-pad\n          ppadminus = ms;\n          vpadminus = pushminus;\n        }\n      }\n\n      if (pm <= pushminus) {\n        // (<-) fallback to push value\n        vpadminus = pushminus;\n      }\n    } else {\n      vpadplus = pushplus;\n      vpadminus = pushminus;\n    }\n\n    var pos = new Array(calcTrace.length);\n\n    for (j = 0; j < calcTrace.length; j++) {\n      pos[j] = calcTrace[j].pos;\n    }\n\n    trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {\n      padded: padded,\n      vpadminus: vpadminus,\n      vpadplus: vpadplus,\n      vpadLinearized: true,\n      // N.B. SVG px-space positive/negative\n      ppadminus: {\n        x: ppadminus,\n        y: ppadplus\n      }[axLetter],\n      ppadplus: {\n        x: ppadplus,\n        y: ppadminus\n      }[axLetter]\n    });\n  }\n}\n\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setPositionOffset: setPositionOffset\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/box/cross_trace_calc.js"],"names":["Axes","require","Lib","getAxisGroup","orientations","crossTraceCalc","gd","plotinfo","calcdata","xa","xaxis","ya","yaxis","i","length","orientation","posAxis","boxList","j","cd","t","trace","visible","type","empty","_id","push","setPositionOffset","traceType","fullLayout","_fullLayout","axId","axLetter","charAt","calcTrace","pointList","shownPts","c2l","pos","pts2","boxdv","distinctVals","minDiff","dPos0","minDtick","vals","numKey","numTotal","group","groupFraction","groupGapFraction","width","side","dPos","bdPos","bPos","wHover","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","num","shift","_offsetIndex","pushplus","pushminus","edge","edgeplus","edgeminus","vpadplus","vpadminus","ppadplus","ppadminus","padded","Boolean","hasPts","boxpoints","points","pointpos","jitter","ms","marker","size","pp","pm","Array","_extremes","findExtremes","vpadLinearized","x","y","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar orientations = ['v', 'h'];\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var calcdata = gd.calcdata;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    for(var i = 0; i < orientations.length; i++) {\n        var orientation = orientations[i];\n        var posAxis = orientation === 'h' ? ya : xa;\n        var boxList = [];\n\n        // make list of boxes / candlesticks\n        // For backward compatibility, candlesticks are treated as if they *are* box traces here\n        for(var j = 0; j < calcdata.length; j++) {\n            var cd = calcdata[j];\n            var t = cd[0].t;\n            var trace = cd[0].trace;\n\n            if(trace.visible === true &&\n                    (trace.type === 'box' || trace.type === 'candlestick') &&\n                    !t.empty &&\n                    (trace.orientation || 'v') === orientation &&\n                    trace.xaxis === xa._id &&\n                    trace.yaxis === ya._id\n              ) {\n                boxList.push(j);\n            }\n        }\n\n        setPositionOffset('box', gd, boxList, posAxis);\n    }\n}\n\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n    var calcdata = gd.calcdata;\n    var fullLayout = gd._fullLayout;\n    var axId = posAxis._id;\n    var axLetter = axId.charAt(0);\n\n    var i, j, calcTrace;\n    var pointList = [];\n    var shownPts = 0;\n\n    // make list of box points\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n        for(j = 0; j < calcTrace.length; j++) {\n            pointList.push(posAxis.c2l(calcTrace[j].pos, true));\n            shownPts += (calcTrace[j].pts2 || []).length;\n        }\n    }\n\n    if(!pointList.length) return;\n\n    // box plots - update dPos based on multiple traces\n    var boxdv = Lib.distinctVals(pointList);\n    if(posAxis.type === 'category' || posAxis.type === 'multicategory') {\n        boxdv.minDiff = 1;\n    }\n\n    var dPos0 = boxdv.minDiff / 2;\n\n    // check for forced minimum dtick\n    Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n\n    var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n    var numTotal = fullLayout[numKey];\n    var group = fullLayout[traceType + 'mode'] === 'group' && numTotal > 1;\n    var groupFraction = 1 - fullLayout[traceType + 'gap'];\n    var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n\n        var trace = calcTrace[0].trace;\n        var t = calcTrace[0].t;\n        var width = trace.width;\n        var side = trace.side;\n\n        // position coordinate delta\n        var dPos;\n        // box half width;\n        var bdPos;\n        // box center offset\n        var bPos;\n        // half-width within which to accept hover for this box/violin\n        // always split the distance to the closest box/violin\n        var wHover;\n\n        if(width) {\n            dPos = bdPos = wHover = width / 2;\n            bPos = 0;\n        } else {\n            dPos = dPos0;\n\n            if(group) {\n                var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;\n                var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n                var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n                var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n                var num = nOffsetGroups || numTotal;\n                var shift = nOffsetGroups ? trace._offsetIndex : t.num;\n\n                bdPos = dPos * groupFraction * groupGapFraction / num;\n                bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;\n                wHover = dPos * groupFraction / num;\n            } else {\n                bdPos = dPos * groupFraction * groupGapFraction;\n                bPos = 0;\n                wHover = dPos;\n            }\n        }\n        t.dPos = dPos;\n        t.bPos = bPos;\n        t.bdPos = bdPos;\n        t.wHover = wHover;\n\n        // box/violin-only value-space push value\n        var pushplus;\n        var pushminus;\n        // edge of box/violin\n        var edge = bPos + bdPos;\n        var edgeplus;\n        var edgeminus;\n        // value-space padding\n        var vpadplus;\n        var vpadminus;\n        // pixel-space padding\n        var ppadplus;\n        var ppadminus;\n        // do we add 5% of both sides (more logic for points beyond box/violin below)\n        var padded = Boolean(width);\n        // does this trace show points?\n        var hasPts = (trace.boxpoints || trace.points) && (shownPts > 0);\n\n        if(side === 'positive') {\n            pushplus = dPos * (width ? 1 : 0.5);\n            edgeplus = edge;\n            pushminus = edgeplus = bPos;\n        } else if(side === 'negative') {\n            pushplus = edgeplus = bPos;\n            pushminus = dPos * (width ? 1 : 0.5);\n            edgeminus = edge;\n        } else {\n            pushplus = pushminus = dPos;\n            edgeplus = edgeminus = edge;\n        }\n\n        if(hasPts) {\n            var pointpos = trace.pointpos;\n            var jitter = trace.jitter;\n            var ms = trace.marker.size / 2;\n\n            var pp = 0;\n            if((pointpos + jitter) >= 0) {\n                pp = edge * (pointpos + jitter);\n                if(pp > pushplus) {\n                    // (++) beyond plus-value, use pp\n                    padded = true;\n                    ppadplus = ms;\n                    vpadplus = pp;\n                } else if(pp > edgeplus) {\n                    // (+), use push-value (it's bigger), but add px-pad\n                    ppadplus = ms;\n                    vpadplus = pushplus;\n                }\n            }\n            if(pp <= pushplus) {\n                // (->) fallback to push value\n                vpadplus = pushplus;\n            }\n\n            var pm = 0;\n            if((pointpos - jitter) <= 0) {\n                pm = -edge * (pointpos - jitter);\n                if(pm > pushminus) {\n                    // (--) beyond plus-value, use pp\n                    padded = true;\n                    ppadminus = ms;\n                    vpadminus = pm;\n                } else if(pm > edgeminus) {\n                    // (-), use push-value (it's bigger), but add px-pad\n                    ppadminus = ms;\n                    vpadminus = pushminus;\n                }\n            }\n            if(pm <= pushminus) {\n                // (<-) fallback to push value\n                vpadminus = pushminus;\n            }\n        } else {\n            vpadplus = pushplus;\n            vpadminus = pushminus;\n        }\n\n        var pos = new Array(calcTrace.length);\n        for(j = 0; j < calcTrace.length; j++) {\n            pos[j] = calcTrace[j].pos;\n        }\n\n        trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {\n            padded: padded,\n            vpadminus: vpadminus,\n            vpadplus: vpadplus,\n            vpadLinearized: true,\n            // N.B. SVG px-space positive/negative\n            ppadminus: {x: ppadminus, y: ppadplus}[axLetter],\n            ppadplus: {x: ppadplus, y: ppadminus}[axLetter],\n        });\n    }\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setPositionOffset: setPositionOffset\n};\n"]},"metadata":{},"sourceType":"script"}