{"ast":null,"code":"'use strict';\n\nvar createShader = require('gl-shader');\n\nvar createBuffer = require('gl-buffer');\n\nvar pool = require('typedarray-pool');\n\nvar SHADERS = require('./lib/shader');\n\nmodule.exports = createPointcloud2D;\n\nfunction Pointcloud2D(plot, offsetBuffer, pickBuffer, shader, pickShader) {\n  this.plot = plot;\n  this.offsetBuffer = offsetBuffer;\n  this.pickBuffer = pickBuffer;\n  this.shader = shader;\n  this.pickShader = pickShader;\n  this.sizeMin = 0.5;\n  this.sizeMinCap = 2;\n  this.sizeMax = 20;\n  this.areaRatio = 1.0;\n  this.pointCount = 0;\n  this.color = [1, 0, 0, 1];\n  this.borderColor = [0, 0, 0, 1];\n  this.blend = false;\n  this.pickOffset = 0;\n  this.points = null;\n}\n\nvar proto = Pointcloud2D.prototype;\n\nproto.dispose = function () {\n  this.shader.dispose();\n  this.pickShader.dispose();\n  this.offsetBuffer.dispose();\n  this.pickBuffer.dispose();\n  this.plot.removeObject(this);\n};\n\nproto.update = function (options) {\n  var i;\n  options = options || {};\n\n  function dflt(opt, value) {\n    if (opt in options) {\n      return options[opt];\n    }\n\n    return value;\n  }\n\n  this.sizeMin = dflt('sizeMin', 0.5); // this.sizeMinCap      = dflt('sizeMinCap', 2)\n\n  this.sizeMax = dflt('sizeMax', 20);\n  this.color = dflt('color', [1, 0, 0, 1]).slice();\n  this.areaRatio = dflt('areaRatio', 1);\n  this.borderColor = dflt('borderColor', [0, 0, 0, 1]).slice();\n  this.blend = dflt('blend', false); //Update point data\n  // Attempt straight-through processing (STP) to avoid allocation and copy\n  // TODO eventually abstract out STP logic, maybe into `pool` or a layer above\n\n  var pointCount = options.positions.length >>> 1;\n  var dataStraightThrough = options.positions instanceof Float32Array;\n  var idStraightThrough = options.idToIndex instanceof Int32Array && options.idToIndex.length >= pointCount; // permit larger to help reuse\n\n  var data = options.positions;\n  var packed = dataStraightThrough ? data : pool.mallocFloat32(data.length);\n  var packedId = idStraightThrough ? options.idToIndex : pool.mallocInt32(pointCount);\n\n  if (!dataStraightThrough) {\n    packed.set(data);\n  }\n\n  if (!idStraightThrough) {\n    packed.set(data);\n\n    for (i = 0; i < pointCount; i++) {\n      packedId[i] = i;\n    }\n  }\n\n  this.points = data;\n  this.offsetBuffer.update(packed);\n  this.pickBuffer.update(packedId);\n\n  if (!dataStraightThrough) {\n    pool.free(packed);\n  }\n\n  if (!idStraightThrough) {\n    pool.free(packedId);\n  }\n\n  this.pointCount = pointCount;\n  this.pickOffset = 0;\n};\n\nfunction count(points, dataBox) {\n  var visiblePointCountEstimate = 0;\n  var length = points.length >>> 1;\n  var i;\n\n  for (i = 0; i < length; i++) {\n    var x = points[i * 2];\n    var y = points[i * 2 + 1];\n    if (x >= dataBox[0] && x <= dataBox[2] && y >= dataBox[1] && y <= dataBox[3]) visiblePointCountEstimate++;\n  }\n\n  return visiblePointCountEstimate;\n}\n\nproto.unifiedDraw = function () {\n  var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var PICK_VEC4 = [0, 0, 0, 0];\n  return function (pickOffset) {\n    var pick = pickOffset !== void 0;\n    var shader = pick ? this.pickShader : this.shader;\n    var gl = this.plot.gl;\n    var dataBox = this.plot.dataBox;\n\n    if (this.pointCount === 0) {\n      return pickOffset;\n    }\n\n    var dataX = dataBox[2] - dataBox[0];\n    var dataY = dataBox[3] - dataBox[1];\n    var visiblePointCountEstimate = count(this.points, dataBox);\n    var basicPointSize = this.plot.pickPixelRatio * Math.max(Math.min(this.sizeMinCap, this.sizeMin), Math.min(this.sizeMax, this.sizeMax / Math.pow(visiblePointCountEstimate, 0.33333)));\n    MATRIX[0] = 2.0 / dataX;\n    MATRIX[4] = 2.0 / dataY;\n    MATRIX[6] = -2.0 * dataBox[0] / dataX - 1.0;\n    MATRIX[7] = -2.0 * dataBox[1] / dataY - 1.0;\n    this.offsetBuffer.bind();\n    shader.bind();\n    shader.attributes.position.pointer();\n    shader.uniforms.matrix = MATRIX;\n    shader.uniforms.color = this.color;\n    shader.uniforms.borderColor = this.borderColor;\n    shader.uniforms.pointCloud = basicPointSize < 5;\n    shader.uniforms.pointSize = basicPointSize;\n    shader.uniforms.centerFraction = Math.min(1, Math.max(0, Math.sqrt(1 - this.areaRatio)));\n\n    if (pick) {\n      PICK_VEC4[0] = pickOffset & 0xff;\n      PICK_VEC4[1] = pickOffset >> 8 & 0xff;\n      PICK_VEC4[2] = pickOffset >> 16 & 0xff;\n      PICK_VEC4[3] = pickOffset >> 24 & 0xff;\n      this.pickBuffer.bind();\n      shader.attributes.pickId.pointer(gl.UNSIGNED_BYTE);\n      shader.uniforms.pickOffset = PICK_VEC4;\n      this.pickOffset = pickOffset;\n    } // Worth switching these off, but we can't make assumptions about other\n    // renderers, so let's restore it after each draw\n\n\n    var blend = gl.getParameter(gl.BLEND);\n    var dither = gl.getParameter(gl.DITHER);\n    if (blend && !this.blend) gl.disable(gl.BLEND);\n    if (dither) gl.disable(gl.DITHER);\n    gl.drawArrays(gl.POINTS, 0, this.pointCount);\n    if (blend && !this.blend) gl.enable(gl.BLEND);\n    if (dither) gl.enable(gl.DITHER);\n    return pickOffset + this.pointCount;\n  };\n}();\n\nproto.draw = proto.unifiedDraw;\nproto.drawPick = proto.unifiedDraw;\n\nproto.pick = function (x, y, value) {\n  var pickOffset = this.pickOffset;\n  var pointCount = this.pointCount;\n\n  if (value < pickOffset || value >= pickOffset + pointCount) {\n    return null;\n  }\n\n  var pointId = value - pickOffset;\n  var points = this.points;\n  return {\n    object: this,\n    pointId: pointId,\n    dataCoord: [points[2 * pointId], points[2 * pointId + 1]]\n  };\n};\n\nfunction createPointcloud2D(plot, options) {\n  var gl = plot.gl;\n  var buffer = createBuffer(gl);\n  var pickBuffer = createBuffer(gl);\n  var shader = createShader(gl, SHADERS.pointVertex, SHADERS.pointFragment);\n  var pickShader = createShader(gl, SHADERS.pickVertex, SHADERS.pickFragment);\n  var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader);\n  result.update(options); //Register with plot\n\n  plot.addObject(result);\n  return result;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/gl-pointcloud2d/pointcloud2d.js"],"names":["createShader","require","createBuffer","pool","SHADERS","module","exports","createPointcloud2D","Pointcloud2D","plot","offsetBuffer","pickBuffer","shader","pickShader","sizeMin","sizeMinCap","sizeMax","areaRatio","pointCount","color","borderColor","blend","pickOffset","points","proto","prototype","dispose","removeObject","update","options","i","dflt","opt","value","slice","positions","length","dataStraightThrough","Float32Array","idStraightThrough","idToIndex","Int32Array","data","packed","mallocFloat32","packedId","mallocInt32","set","free","count","dataBox","visiblePointCountEstimate","x","y","unifiedDraw","MATRIX","PICK_VEC4","pick","gl","dataX","dataY","basicPointSize","pickPixelRatio","Math","max","min","pow","bind","attributes","position","pointer","uniforms","matrix","pointCloud","pointSize","centerFraction","sqrt","pickId","UNSIGNED_BYTE","getParameter","BLEND","dither","DITHER","disable","drawArrays","POINTS","enable","draw","drawPick","pointId","object","dataCoord","buffer","pointVertex","pointFragment","pickVertex","pickFragment","result","addObject"],"mappings":"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","sourcesContent":["'use strict'\n\nvar createShader = require('gl-shader')\nvar createBuffer = require('gl-buffer')\n\nvar pool = require('typedarray-pool')\n\nvar SHADERS = require('./lib/shader')\n\nmodule.exports = createPointcloud2D\n\nfunction Pointcloud2D(plot, offsetBuffer, pickBuffer, shader, pickShader) {\n  this.plot           = plot\n  this.offsetBuffer   = offsetBuffer\n  this.pickBuffer     = pickBuffer\n  this.shader         = shader\n  this.pickShader     = pickShader\n  this.sizeMin        = 0.5\n  this.sizeMinCap     = 2\n  this.sizeMax        = 20\n  this.areaRatio      = 1.0\n  this.pointCount     = 0\n  this.color          = [1, 0, 0, 1]\n  this.borderColor    = [0, 0, 0, 1]\n  this.blend          = false\n  this.pickOffset     = 0\n  this.points         = null\n}\n\nvar proto = Pointcloud2D.prototype\n\nproto.dispose = function() {\n  this.shader.dispose()\n  this.pickShader.dispose()\n  this.offsetBuffer.dispose()\n  this.pickBuffer.dispose()\n  this.plot.removeObject(this)\n}\n\nproto.update = function(options) {\n\n  var i\n\n  options = options || {}\n\n  function dflt(opt, value) {\n    if(opt in options) {\n      return options[opt]\n    }\n    return value\n  }\n\n  this.sizeMin      = dflt('sizeMin', 0.5)\n  // this.sizeMinCap      = dflt('sizeMinCap', 2)\n  this.sizeMax      = dflt('sizeMax', 20)\n  this.color        = dflt('color', [1, 0, 0, 1]).slice()\n  this.areaRatio    = dflt('areaRatio', 1)\n  this.borderColor  = dflt('borderColor', [0, 0, 0, 1]).slice()\n  this.blend        = dflt('blend', false)\n\n  //Update point data\n\n  // Attempt straight-through processing (STP) to avoid allocation and copy\n  // TODO eventually abstract out STP logic, maybe into `pool` or a layer above\n  var pointCount = options.positions.length >>> 1\n  var dataStraightThrough = options.positions instanceof Float32Array\n  var idStraightThrough = options.idToIndex instanceof Int32Array && options.idToIndex.length >= pointCount // permit larger to help reuse\n\n  var data          = options.positions\n  var packed        = dataStraightThrough ? data : pool.mallocFloat32(data.length)\n  var packedId      = idStraightThrough ? options.idToIndex : pool.mallocInt32(pointCount)\n\n  if(!dataStraightThrough) {\n    packed.set(data)\n  }\n\n  if(!idStraightThrough) {\n    packed.set(data)\n    for(i = 0; i < pointCount; i++) {\n      packedId[i] = i\n    }\n  }\n\n  this.points       = data\n\n  this.offsetBuffer.update(packed)\n  this.pickBuffer.update(packedId)\n\n  if(!dataStraightThrough) {\n    pool.free(packed)\n  }\n\n  if(!idStraightThrough) {\n    pool.free(packedId)\n  }\n\n  this.pointCount = pointCount\n  this.pickOffset = 0\n}\n\nfunction count(points, dataBox) {\n  var visiblePointCountEstimate = 0\n  var length = points.length >>> 1\n  var i\n  for(i = 0; i < length; i++) {\n    var x = points[i * 2]\n    var y = points[i * 2 + 1]\n    if(x >= dataBox[0] && x <= dataBox[2] && y >= dataBox[1] && y <= dataBox[3])\n      visiblePointCountEstimate++\n  }\n  return visiblePointCountEstimate\n}\n\nproto.unifiedDraw = (function() {\n  var MATRIX = [1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]\n  var PICK_VEC4 = [0, 0, 0, 0]\nreturn function(pickOffset) {\n  var pick = pickOffset !== void(0)\n\n  var shader        = pick ? this.pickShader : this.shader\n  var gl            = this.plot.gl\n  var dataBox       = this.plot.dataBox\n\n  if(this.pointCount === 0) {\n    return pickOffset\n  }\n\n  var dataX   = dataBox[2] - dataBox[0]\n  var dataY   = dataBox[3] - dataBox[1]\n\n  var visiblePointCountEstimate = count(this.points, dataBox)\n  var basicPointSize =  this.plot.pickPixelRatio * Math.max(Math.min(this.sizeMinCap, this.sizeMin), Math.min(this.sizeMax, this.sizeMax / Math.pow(visiblePointCountEstimate, 0.33333)))\n\n  MATRIX[0] = 2.0 / dataX\n  MATRIX[4] = 2.0 / dataY\n  MATRIX[6] = -2.0 * dataBox[0] / dataX - 1.0\n  MATRIX[7] = -2.0 * dataBox[1] / dataY - 1.0\n\n  this.offsetBuffer.bind()\n\n  shader.bind()\n  shader.attributes.position.pointer()\n  shader.uniforms.matrix      = MATRIX\n  shader.uniforms.color       = this.color\n  shader.uniforms.borderColor = this.borderColor\n  shader.uniforms.pointCloud = basicPointSize < 5\n  shader.uniforms.pointSize = basicPointSize\n  shader.uniforms.centerFraction = Math.min(1, Math.max(0, Math.sqrt(1 - this.areaRatio)))\n\n  if(pick) {\n\n    PICK_VEC4[0] = ( pickOffset        & 0xff)\n    PICK_VEC4[1] = ((pickOffset >> 8)  & 0xff)\n    PICK_VEC4[2] = ((pickOffset >> 16) & 0xff)\n    PICK_VEC4[3] = ((pickOffset >> 24) & 0xff)\n\n    this.pickBuffer.bind()\n    shader.attributes.pickId.pointer(gl.UNSIGNED_BYTE)\n    shader.uniforms.pickOffset = PICK_VEC4\n    this.pickOffset = pickOffset\n  }\n\n  // Worth switching these off, but we can't make assumptions about other\n  // renderers, so let's restore it after each draw\n  var blend = gl.getParameter(gl.BLEND)\n  var dither = gl.getParameter(gl.DITHER)\n\n  if(blend && !this.blend)\n    gl.disable(gl.BLEND)\n  if(dither)\n    gl.disable(gl.DITHER)\n\n  gl.drawArrays(gl.POINTS, 0, this.pointCount)\n\n  if(blend && !this.blend)\n    gl.enable(gl.BLEND)\n  if(dither)\n    gl.enable(gl.DITHER)\n\n  return pickOffset + this.pointCount\n}\n})()\n\nproto.draw = proto.unifiedDraw\nproto.drawPick = proto.unifiedDraw\n\nproto.pick = function(x, y, value) {\n  var pickOffset = this.pickOffset\n  var pointCount = this.pointCount\n  if(value < pickOffset || value >= pickOffset + pointCount) {\n    return null\n  }\n  var pointId = value - pickOffset\n  var points = this.points\n  return {\n    object: this,\n    pointId: pointId,\n    dataCoord: [points[2 * pointId], points[2 * pointId + 1] ]\n  }\n}\n\nfunction createPointcloud2D(plot, options) {\n  var gl = plot.gl\n  var buffer = createBuffer(gl)\n  var pickBuffer = createBuffer(gl)\n  var shader = createShader(gl, SHADERS.pointVertex, SHADERS.pointFragment)\n  var pickShader = createShader(gl, SHADERS.pickVertex, SHADERS.pickFragment)\n\n  var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader)\n  result.update(options)\n\n  //Register with plot\n  plot.addObject(result)\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}