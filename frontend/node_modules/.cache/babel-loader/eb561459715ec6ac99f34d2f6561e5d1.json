{"ast":null,"code":"// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n'use strict';\n/* eslint-disable consistent-return */\n\n/* eslint-disable no-bitwise */\n\nvar readUInt16BE = require('./common').readUInt16BE;\n\nvar readUInt32BE = require('./common').readUInt32BE;\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\n\n\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n  var size = readUInt32BE(data, offset); // size includes first 4 bytes (length)\n\n  if (data.length < size + offset || size < 8) return null; // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data: data.slice(offset + 8, offset + size),\n    end: offset + size\n  };\n}\n\nmodule.exports.unbox = unbox; // parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\n\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width: readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n\n    offset = box.end;\n  }\n}\n\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n\n  return result;\n} // parses `meta` -> `iloc` box\n\n\nfunction scan_iloc(data, sandbox) {\n  var offset_size = data[4] >> 4 & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = data[5] >> 4 & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = {\n        length: first_extent_length,\n        offset: first_extent_offset + base_offset\n      };\n    }\n\n    offset += extent_count * (offset_size + length_size);\n  }\n} // parses `meta` -> `iinf` box\n\n\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n\n      sandbox.item_inf[item_name] = item_id;\n    }\n\n    offset = box.end;\n  }\n} // parses `meta` -> `iprp` box\n\n\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n} // parses `meta` box\n\n\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n} // get image with largest single dimension as base\n\n\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || a.width === b.width && a.height > b.height ? a : b;\n  });\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || a.height === b.height && a.width > b.width ? a : b;\n  });\n  var maxSize;\n\n  if (maxWidthSize.width > maxHeightSize.height || maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n\n  return maxSize;\n}\n\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n  scan_meta(data, sandbox);\n  if (!sandbox.sizes.length) return;\n  var maxSize = getMaxSize(sandbox.sizes);\n  var orientation = 1; // convert imir/irot to exif orientation\n\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw = {\n      1: 6,\n      2: 5,\n      3: 8,\n      4: 7,\n      5: 4,\n      6: 3,\n      7: 2,\n      8: 1\n    };\n    var mirror_vert = {\n      1: 4,\n      2: 3,\n      3: 2,\n      4: 1,\n      5: 6,\n      6: 5,\n      7: 8,\n      8: 7\n    };\n\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n  var exif_location = null;\n\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\n\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n  compat[brand] = true;\n\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  } // heic and avif are superset of miaf, so they should all list mif1 as compatible\n\n\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  } // https://nokiatech.github.io/heif/technical.html\n\n\n  if (brand === 'heic' || brand === 'heix') {\n    return {\n      type: 'heic',\n      mime: 'image/heic'\n    };\n  }\n\n  if (brand === 'hevc' || brand === 'hevx') {\n    return {\n      type: 'heic',\n      mime: 'image/heic-sequence'\n    };\n  }\n\n  if (compat.avif || compat.avis) {\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  }\n\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return {\n        type: 'heif',\n        mime: 'image/heif-sequence'\n      };\n    }\n\n    return {\n      type: 'heif',\n      mime: 'image/heif'\n    };\n  }\n\n  return {\n    type: 'avif',\n    mime: 'image/avif'\n  };\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/probe-image-size/lib/miaf_utils.js"],"names":["readUInt16BE","require","readUInt32BE","unbox","data","offset","length","size","boxtype","String","fromCharCode","apply","slice","end","module","exports","scan_ipco","sandbox","box","sizes","push","width","height","transforms","type","value","readUIntBE","result","i","scan_iloc","offset_size","length_size","base_offset_size","item_count","item_ID","data_reference_index","base_offset","extent_count","first_extent_offset","first_extent_length","item_loc","scan_iinf","item_id","item_name","pos","item_inf","scan_iprp","scan_meta","getMaxSize","maxWidthSize","reduce","a","b","maxHeightSize","maxSize","readSizeFromMeta","orientation","forEach","transform","rotate_ccw","mirror_vert","exif_location","Exif","variants","getMimeType","brand","compat","mif1","msf1","miaf","mime","avif","avis","heic","heix","hevc","hevx","heis"],"mappings":"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","sourcesContent":["// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n\n'use strict';\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-bitwise */\n\nvar readUInt16BE = require('./common').readUInt16BE;\nvar readUInt32BE = require('./common').readUInt32BE;\n\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n\n  var size = readUInt32BE(data, offset);\n\n  // size includes first 4 bytes (length)\n  if (data.length < size + offset || size < 8) return null;\n\n  // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data:    data.slice(offset + 8, offset + size),\n    end:     offset + size\n  };\n}\n\n\nmodule.exports.unbox = unbox;\n\n\n// parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width:  readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n\n    offset = box.end;\n  }\n}\n\n\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n\n  return result;\n}\n\n\n// parses `meta` -> `iloc` box\nfunction scan_iloc(data, sandbox) {\n  var offset_size = (data[4] >> 4) & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = (data[5] >> 4) & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = { length: first_extent_length, offset: first_extent_offset + base_offset };\n    }\n\n    offset += extent_count * (offset_size + length_size);\n  }\n}\n\n\n// parses `meta` -> `iinf` box\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n\n      sandbox.item_inf[item_name] = item_id;\n    }\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` -> `iprp` box\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` box\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// get image with largest single dimension as base\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || (a.width === b.width && a.height > b.height) ? a : b;\n  });\n\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || (a.height === b.height && a.width > b.width) ? a : b;\n  });\n\n  var maxSize;\n\n  if (maxWidthSize.width > maxHeightSize.height ||\n      (maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width)) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n\n  return maxSize;\n}\n\n\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n\n  scan_meta(data, sandbox);\n\n  if (!sandbox.sizes.length) return;\n\n  var maxSize = getMaxSize(sandbox.sizes);\n\n  var orientation = 1;\n\n  // convert imir/irot to exif orientation\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw  = { 1: 6, 2: 5, 3: 8, 4: 7, 5: 4, 6: 3, 7: 2, 8: 1 };\n    var mirror_vert = { 1: 4, 2: 3, 3: 2, 4: 1, 5: 6, 6: 5, 7: 8, 8: 7 };\n\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n\n  var exif_location = null;\n\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\n\n\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n\n  compat[brand] = true;\n\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  }\n\n  // heic and avif are superset of miaf, so they should all list mif1 as compatible\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  // https://nokiatech.github.io/heif/technical.html\n  if (brand === 'heic' || brand === 'heix') {\n    return { type: 'heic', mime: 'image/heic' };\n  }\n\n  if (brand === 'hevc' || brand === 'hevx') {\n    return { type: 'heic', mime: 'image/heic-sequence' };\n  }\n\n  if (compat.avif || compat.avis) {\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return { type: 'heif', mime: 'image/heif-sequence' };\n    }\n    return { type: 'heif', mime: 'image/heif' };\n  }\n\n  return { type: 'avif', mime: 'image/avif' };\n};\n"]},"metadata":{},"sourceType":"script"}