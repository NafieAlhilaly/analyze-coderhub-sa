{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar counterRegex = require('../../lib/regex').counter;\n\nvar domainAttrs = require('../../plots/domain').attributes;\n\nvar cartesianIdRegex = require('../../plots/cartesian/constants').idRegex;\n\nvar Template = require('../../plot_api/plot_template');\n\nvar gridAttrs = {\n  rows: {\n    valType: 'integer',\n    min: 1,\n    editType: 'plot',\n    description: ['The number of rows in the grid. If you provide a 2D `subplots`', 'array or a `yaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  roworder: {\n    valType: 'enumerated',\n    values: ['top to bottom', 'bottom to top'],\n    dflt: 'top to bottom',\n    editType: 'plot',\n    description: ['Is the first row the top or the bottom? Note that columns', 'are always enumerated from left to right.'].join(' ')\n  },\n  columns: {\n    valType: 'integer',\n    min: 1,\n    editType: 'plot',\n    description: ['The number of columns in the grid. If you provide a 2D `subplots`', 'array, the length of its longest row is used as the default.', 'If you give an `xaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  subplots: {\n    valType: 'info_array',\n    freeLength: true,\n    dimensions: 2,\n    items: {\n      valType: 'enumerated',\n      values: [counterRegex('xy').toString(), ''],\n      editType: 'plot'\n    },\n    editType: 'plot',\n    description: ['Used for freeform grids, where some axes may be shared across subplots', 'but others are not. Each entry should be a cartesian subplot id, like', '*xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes', 'within the same column, and y axes within the same row.', 'Non-cartesian subplots and traces that support `domain` can place themselves', 'in this grid separately using the `gridcell` attribute.'].join(' ')\n  },\n  xaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.x.toString(), ''],\n      editType: 'plot'\n    },\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an x axis id like *x*, *x2*, etc., or ** to', 'not put an x axis in that column. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `yaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  yaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.y.toString(), ''],\n      editType: 'plot'\n    },\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an y axis id like *y*, *y2*, etc., or ** to', 'not put a y axis in that row. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `xaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  pattern: {\n    valType: 'enumerated',\n    values: ['independent', 'coupled'],\n    dflt: 'coupled',\n    editType: 'plot',\n    description: ['If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,', 'we can generate defaults using consecutive axis IDs, in two ways:', '*coupled* gives one x axis per column and one y axis per row.', '*independent* uses a new xy pair for each cell, left-to-right across each row', 'then iterating rows according to `roworder`.'].join(' ')\n  },\n  xgap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    editType: 'plot',\n    description: ['Horizontal space between grid cells, expressed as a fraction', 'of the total width available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.2 for independent grids.'].join(' ')\n  },\n  ygap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    editType: 'plot',\n    description: ['Vertical space between grid cells, expressed as a fraction', 'of the total height available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.3 for independent grids.'].join(' ')\n  },\n  domain: domainAttrs({\n    name: 'grid',\n    editType: 'plot',\n    noGridCell: true\n  }, {\n    description: ['The first and last cells end exactly at the domain', 'edges, with no grout around the edges.'].join(' ')\n  }),\n  xside: {\n    valType: 'enumerated',\n    values: ['bottom', 'bottom plot', 'top plot', 'top'],\n    dflt: 'bottom plot',\n    editType: 'plot',\n    description: ['Sets where the x axis labels and titles go. *bottom* means', 'the very bottom of the grid. *bottom plot* is the lowest plot', 'that each x axis is used in. *top* and *top plot* are similar.'].join(' ')\n  },\n  yside: {\n    valType: 'enumerated',\n    values: ['left', 'left plot', 'right plot', 'right'],\n    dflt: 'left plot',\n    editType: 'plot',\n    description: ['Sets where the y axis labels and titles go. *left* means', 'the very left edge of the grid. *left plot* is the leftmost plot', 'that each y axis is used in. *right* and *right plot* are similar.'].join(' ')\n  },\n  editType: 'plot'\n};\n\nfunction getAxes(layout, grid, axLetter) {\n  var gridVal = grid[axLetter + 'axes'];\n  var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});\n  if (Array.isArray(gridVal)) return gridVal;\n  if (splomVal.length) return splomVal;\n} // the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\n\n\nfunction sizeDefaults(layoutIn, layoutOut) {\n  var gridIn = layoutIn.grid || {};\n  var xAxes = getAxes(layoutOut, gridIn, 'x');\n  var yAxes = getAxes(layoutOut, gridIn, 'y');\n  if (!layoutIn.grid && !xAxes && !yAxes) return;\n  var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);\n  var hasXaxes = Array.isArray(xAxes);\n  var hasYaxes = Array.isArray(yAxes);\n  var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;\n  var dfltRows, dfltColumns;\n\n  if (hasSubplotGrid) {\n    dfltRows = gridIn.subplots.length;\n    dfltColumns = gridIn.subplots[0].length;\n  } else {\n    if (hasYaxes) dfltRows = yAxes.length;\n    if (hasXaxes) dfltColumns = xAxes.length;\n  }\n\n  var gridOut = Template.newContainer(layoutOut, 'grid');\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);\n  }\n\n  var rows = coerce('rows', dfltRows);\n  var columns = coerce('columns', dfltColumns);\n\n  if (!(rows * columns > 1)) {\n    delete layoutOut.grid;\n    return;\n  }\n\n  if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {\n    var useDefaultSubplots = coerce('pattern') === 'independent';\n    if (useDefaultSubplots) hasSubplotGrid = true;\n  }\n\n  gridOut._hasSubplotGrid = hasSubplotGrid;\n  var rowOrder = coerce('roworder');\n  var reversed = rowOrder === 'top to bottom';\n  var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;\n  var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;\n  var dfltSideX, dfltSideY;\n\n  if (isSplomGenerated && layoutOut._splomGridDflt) {\n    dfltSideX = layoutOut._splomGridDflt.xside;\n    dfltSideY = layoutOut._splomGridDflt.yside;\n  }\n\n  gridOut._domains = {\n    x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),\n    y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)\n  };\n} // coerce x or y sizing attributes and return an array of domains for this direction\n\n\nfunction fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {\n  var dirGap = coerce(axLetter + 'gap', dfltGap);\n  var domain = coerce('domain.' + axLetter);\n  coerce(axLetter + 'side', dfltSide);\n  var out = new Array(len);\n  var start = domain[0];\n  var step = (domain[1] - start) / (len - dirGap);\n  var cellDomain = step * (1 - dirGap);\n\n  for (var i = 0; i < len; i++) {\n    var cellStart = start + step * i;\n    out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];\n  }\n\n  return out;\n} // the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\n\n\nfunction contentDefaults(layoutIn, layoutOut) {\n  var gridOut = layoutOut.grid; // make sure we got to the end of handleGridSizing\n\n  if (!gridOut || !gridOut._domains) return;\n  var gridIn = layoutIn.grid || {};\n  var subplots = layoutOut._subplots;\n  var hasSubplotGrid = gridOut._hasSubplotGrid;\n  var rows = gridOut.rows;\n  var columns = gridOut.columns;\n  var useDefaultSubplots = gridOut.pattern === 'independent';\n  var i, j, xId, yId, subplotId, subplotsOut, yPos;\n  var axisMap = gridOut._axisMap = {};\n\n  if (hasSubplotGrid) {\n    var subplotsIn = gridIn.subplots || [];\n    subplotsOut = gridOut.subplots = new Array(rows);\n    var index = 1;\n\n    for (i = 0; i < rows; i++) {\n      var rowOut = subplotsOut[i] = new Array(columns);\n      var rowIn = subplotsIn[i] || [];\n\n      for (j = 0; j < columns; j++) {\n        if (useDefaultSubplots) {\n          subplotId = index === 1 ? 'xy' : 'x' + index + 'y' + index;\n          index++;\n        } else subplotId = rowIn[j];\n\n        rowOut[j] = '';\n\n        if (subplots.cartesian.indexOf(subplotId) !== -1) {\n          yPos = subplotId.indexOf('y');\n          xId = subplotId.slice(0, yPos);\n          yId = subplotId.slice(yPos);\n\n          if (axisMap[xId] !== undefined && axisMap[xId] !== j || axisMap[yId] !== undefined && axisMap[yId] !== i) {\n            continue;\n          }\n\n          rowOut[j] = subplotId;\n          axisMap[xId] = j;\n          axisMap[yId] = i;\n        }\n      }\n    }\n  } else {\n    var xAxes = getAxes(layoutOut, gridIn, 'x');\n    var yAxes = getAxes(layoutOut, gridIn, 'y');\n    gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');\n    gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');\n  }\n\n  var anchors = gridOut._anchors = {};\n  var reversed = gridOut.roworder === 'top to bottom';\n\n  for (var axisId in axisMap) {\n    var axLetter = axisId.charAt(0);\n    var side = gridOut[axLetter + 'side'];\n    var i0, inc, iFinal;\n\n    if (side.length < 8) {\n      // grid edge -  ie not \"* plot\" - make these as free axes\n      // since we're not guaranteed to have a subplot there at all\n      anchors[axisId] = 'free';\n    } else if (axLetter === 'x') {\n      if (side.charAt(0) === 't' === reversed) {\n        i0 = 0;\n        inc = 1;\n        iFinal = rows;\n      } else {\n        i0 = rows - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n\n      if (hasSubplotGrid) {\n        var column = axisMap[axisId];\n\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[i][column];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n\n          if (subplotId.slice(0, yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          yId = gridOut.yaxes[i];\n\n          if (subplots.cartesian.indexOf(axisId + yId) !== -1) {\n            anchors[axisId] = yId;\n            break;\n          }\n        }\n      }\n    } else {\n      if (side.charAt(0) === 'l') {\n        i0 = 0;\n        inc = 1;\n        iFinal = columns;\n      } else {\n        i0 = columns - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n\n      if (hasSubplotGrid) {\n        var row = axisMap[axisId];\n\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[row][i];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n\n          if (subplotId.slice(yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(0, yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          xId = gridOut.xaxes[i];\n\n          if (subplots.cartesian.indexOf(xId + axisId) !== -1) {\n            anchors[axisId] = xId;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {\n  var out = new Array(len);\n  var i;\n\n  function fillOneAxis(i, axisId) {\n    if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {\n      out[i] = axisId;\n      axisMap[axisId] = i;\n    } else out[i] = '';\n  }\n\n  if (Array.isArray(axesIn)) {\n    for (i = 0; i < len; i++) {\n      fillOneAxis(i, axesIn[i]);\n    }\n  } else {\n    // default axis list is the first `len` axis ids\n    fillOneAxis(0, axLetter);\n\n    for (i = 1; i < len; i++) {\n      fillOneAxis(i, axLetter + (i + 1));\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = {\n  moduleType: 'component',\n  name: 'grid',\n  schema: {\n    layout: {\n      grid: gridAttrs\n    }\n  },\n  layoutAttributes: gridAttrs,\n  sizeDefaults: sizeDefaults,\n  contentDefaults: contentDefaults\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/components/grid/index.js"],"names":["Lib","require","counterRegex","counter","domainAttrs","attributes","cartesianIdRegex","idRegex","Template","gridAttrs","rows","valType","min","editType","description","join","roworder","values","dflt","columns","subplots","freeLength","dimensions","items","toString","xaxes","x","yaxes","y","pattern","xgap","max","ygap","domain","name","noGridCell","xside","yside","getAxes","layout","grid","axLetter","gridVal","splomVal","Object","keys","_splomAxes","Array","isArray","length","sizeDefaults","layoutIn","layoutOut","gridIn","xAxes","yAxes","hasSubplotGrid","hasXaxes","hasYaxes","isSplomGenerated","dfltRows","dfltColumns","gridOut","newContainer","coerce","attr","useDefaultSubplots","_hasSubplotGrid","rowOrder","reversed","dfltGapX","dfltGapY","dfltSideX","dfltSideY","_splomGridDflt","_domains","fillGridPositions","dfltGap","dfltSide","len","dirGap","out","start","step","cellDomain","i","cellStart","contentDefaults","_subplots","j","xId","yId","subplotId","subplotsOut","yPos","axisMap","_axisMap","subplotsIn","index","rowOut","rowIn","cartesian","indexOf","slice","undefined","fillGridAxes","xaxis","yaxis","anchors","_anchors","axisId","charAt","side","i0","inc","iFinal","column","row","axesIn","axesAllowed","fillOneAxis","module","exports","moduleType","schema","layoutAttributes"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\nvar counterRegex = require('../../lib/regex').counter;\nvar domainAttrs = require('../../plots/domain').attributes;\nvar cartesianIdRegex = require('../../plots/cartesian/constants').idRegex;\nvar Template = require('../../plot_api/plot_template');\n\nvar gridAttrs = {\n    rows: {\n        valType: 'integer',\n        min: 1,\n        editType: 'plot',\n        description: [\n            'The number of rows in the grid. If you provide a 2D `subplots`',\n            'array or a `yaxes` array, its length is used as the default.',\n            'But it\\'s also possible to have a different length, if you',\n            'want to leave a row at the end for non-cartesian subplots.'\n        ].join(' ')\n    },\n    roworder: {\n        valType: 'enumerated',\n        values: ['top to bottom', 'bottom to top'],\n        dflt: 'top to bottom',\n        editType: 'plot',\n        description: [\n            'Is the first row the top or the bottom? Note that columns',\n            'are always enumerated from left to right.'\n        ].join(' ')\n    },\n    columns: {\n        valType: 'integer',\n        min: 1,\n        editType: 'plot',\n        description: [\n            'The number of columns in the grid. If you provide a 2D `subplots`',\n            'array, the length of its longest row is used as the default.',\n            'If you give an `xaxes` array, its length is used as the default.',\n            'But it\\'s also possible to have a different length, if you',\n            'want to leave a row at the end for non-cartesian subplots.'\n        ].join(' ')\n    },\n    subplots: {\n        valType: 'info_array',\n        freeLength: true,\n        dimensions: 2,\n        items: {valType: 'enumerated', values: [counterRegex('xy').toString(), ''], editType: 'plot'},\n        editType: 'plot',\n        description: [\n            'Used for freeform grids, where some axes may be shared across subplots',\n            'but others are not. Each entry should be a cartesian subplot id, like',\n            '*xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes',\n            'within the same column, and y axes within the same row.',\n            'Non-cartesian subplots and traces that support `domain` can place themselves',\n            'in this grid separately using the `gridcell` attribute.'\n        ].join(' ')\n    },\n    xaxes: {\n        valType: 'info_array',\n        freeLength: true,\n        items: {valType: 'enumerated', values: [cartesianIdRegex.x.toString(), ''], editType: 'plot'},\n        editType: 'plot',\n        description: [\n            'Used with `yaxes` when the x and y axes are shared across columns and rows.',\n            'Each entry should be an x axis id like *x*, *x2*, etc., or ** to',\n            'not put an x axis in that column. Entries other than ** must be unique.',\n            'Ignored if `subplots` is present. If missing but `yaxes` is present,',\n            'will generate consecutive IDs.'\n        ].join(' ')\n    },\n    yaxes: {\n        valType: 'info_array',\n        freeLength: true,\n        items: {valType: 'enumerated', values: [cartesianIdRegex.y.toString(), ''], editType: 'plot'},\n        editType: 'plot',\n        description: [\n            'Used with `yaxes` when the x and y axes are shared across columns and rows.',\n            'Each entry should be an y axis id like *y*, *y2*, etc., or ** to',\n            'not put a y axis in that row. Entries other than ** must be unique.',\n            'Ignored if `subplots` is present. If missing but `xaxes` is present,',\n            'will generate consecutive IDs.'\n        ].join(' ')\n    },\n    pattern: {\n        valType: 'enumerated',\n        values: ['independent', 'coupled'],\n        dflt: 'coupled',\n        editType: 'plot',\n        description: [\n            'If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,',\n            'we can generate defaults using consecutive axis IDs, in two ways:',\n            '*coupled* gives one x axis per column and one y axis per row.',\n            '*independent* uses a new xy pair for each cell, left-to-right across each row',\n            'then iterating rows according to `roworder`.'\n        ].join(' ')\n    },\n    xgap: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        editType: 'plot',\n        description: [\n            'Horizontal space between grid cells, expressed as a fraction',\n            'of the total width available to one cell. Defaults to 0.1',\n            'for coupled-axes grids and 0.2 for independent grids.'\n        ].join(' ')\n    },\n    ygap: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        editType: 'plot',\n        description: [\n            'Vertical space between grid cells, expressed as a fraction',\n            'of the total height available to one cell. Defaults to 0.1',\n            'for coupled-axes grids and 0.3 for independent grids.'\n        ].join(' ')\n    },\n    domain: domainAttrs({name: 'grid', editType: 'plot', noGridCell: true}, {\n        description: [\n            'The first and last cells end exactly at the domain',\n            'edges, with no grout around the edges.'\n        ].join(' ')\n    }),\n    xside: {\n        valType: 'enumerated',\n        values: ['bottom', 'bottom plot', 'top plot', 'top'],\n        dflt: 'bottom plot',\n        editType: 'plot',\n        description: [\n            'Sets where the x axis labels and titles go. *bottom* means',\n            'the very bottom of the grid. *bottom plot* is the lowest plot',\n            'that each x axis is used in. *top* and *top plot* are similar.'\n        ].join(' ')\n    },\n    yside: {\n        valType: 'enumerated',\n        values: ['left', 'left plot', 'right plot', 'right'],\n        dflt: 'left plot',\n        editType: 'plot',\n        description: [\n            'Sets where the y axis labels and titles go. *left* means',\n            'the very left edge of the grid. *left plot* is the leftmost plot',\n            'that each y axis is used in. *right* and *right plot* are similar.'\n        ].join(' ')\n    },\n    editType: 'plot'\n};\n\nfunction getAxes(layout, grid, axLetter) {\n    var gridVal = grid[axLetter + 'axes'];\n    var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});\n\n    if(Array.isArray(gridVal)) return gridVal;\n    if(splomVal.length) return splomVal;\n}\n\n// the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\nfunction sizeDefaults(layoutIn, layoutOut) {\n    var gridIn = layoutIn.grid || {};\n    var xAxes = getAxes(layoutOut, gridIn, 'x');\n    var yAxes = getAxes(layoutOut, gridIn, 'y');\n\n    if(!layoutIn.grid && !xAxes && !yAxes) return;\n\n    var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);\n    var hasXaxes = Array.isArray(xAxes);\n    var hasYaxes = Array.isArray(yAxes);\n    var isSplomGenerated = (\n        hasXaxes && xAxes !== gridIn.xaxes &&\n        hasYaxes && yAxes !== gridIn.yaxes\n    );\n\n    var dfltRows, dfltColumns;\n\n    if(hasSubplotGrid) {\n        dfltRows = gridIn.subplots.length;\n        dfltColumns = gridIn.subplots[0].length;\n    } else {\n        if(hasYaxes) dfltRows = yAxes.length;\n        if(hasXaxes) dfltColumns = xAxes.length;\n    }\n\n    var gridOut = Template.newContainer(layoutOut, 'grid');\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);\n    }\n\n    var rows = coerce('rows', dfltRows);\n    var columns = coerce('columns', dfltColumns);\n\n    if(!(rows * columns > 1)) {\n        delete layoutOut.grid;\n        return;\n    }\n\n    if(!hasSubplotGrid && !hasXaxes && !hasYaxes) {\n        var useDefaultSubplots = coerce('pattern') === 'independent';\n        if(useDefaultSubplots) hasSubplotGrid = true;\n    }\n    gridOut._hasSubplotGrid = hasSubplotGrid;\n\n    var rowOrder = coerce('roworder');\n    var reversed = rowOrder === 'top to bottom';\n\n    var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;\n    var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;\n\n    var dfltSideX, dfltSideY;\n    if(isSplomGenerated && layoutOut._splomGridDflt) {\n        dfltSideX = layoutOut._splomGridDflt.xside;\n        dfltSideY = layoutOut._splomGridDflt.yside;\n    }\n\n    gridOut._domains = {\n        x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),\n        y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)\n    };\n}\n\n// coerce x or y sizing attributes and return an array of domains for this direction\nfunction fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {\n    var dirGap = coerce(axLetter + 'gap', dfltGap);\n    var domain = coerce('domain.' + axLetter);\n    coerce(axLetter + 'side', dfltSide);\n\n    var out = new Array(len);\n    var start = domain[0];\n    var step = (domain[1] - start) / (len - dirGap);\n    var cellDomain = step * (1 - dirGap);\n    for(var i = 0; i < len; i++) {\n        var cellStart = start + step * i;\n        out[reversed ? (len - 1 - i) : i] = [cellStart, cellStart + cellDomain];\n    }\n    return out;\n}\n\n// the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\nfunction contentDefaults(layoutIn, layoutOut) {\n    var gridOut = layoutOut.grid;\n    // make sure we got to the end of handleGridSizing\n    if(!gridOut || !gridOut._domains) return;\n\n    var gridIn = layoutIn.grid || {};\n    var subplots = layoutOut._subplots;\n    var hasSubplotGrid = gridOut._hasSubplotGrid;\n    var rows = gridOut.rows;\n    var columns = gridOut.columns;\n    var useDefaultSubplots = gridOut.pattern === 'independent';\n\n    var i, j, xId, yId, subplotId, subplotsOut, yPos;\n\n    var axisMap = gridOut._axisMap = {};\n\n    if(hasSubplotGrid) {\n        var subplotsIn = gridIn.subplots || [];\n        subplotsOut = gridOut.subplots = new Array(rows);\n        var index = 1;\n\n        for(i = 0; i < rows; i++) {\n            var rowOut = subplotsOut[i] = new Array(columns);\n            var rowIn = subplotsIn[i] || [];\n            for(j = 0; j < columns; j++) {\n                if(useDefaultSubplots) {\n                    subplotId = (index === 1) ? 'xy' : ('x' + index + 'y' + index);\n                    index++;\n                } else subplotId = rowIn[j];\n\n                rowOut[j] = '';\n\n                if(subplots.cartesian.indexOf(subplotId) !== -1) {\n                    yPos = subplotId.indexOf('y');\n                    xId = subplotId.slice(0, yPos);\n                    yId = subplotId.slice(yPos);\n                    if((axisMap[xId] !== undefined && axisMap[xId] !== j) ||\n                        (axisMap[yId] !== undefined && axisMap[yId] !== i)\n                    ) {\n                        continue;\n                    }\n\n                    rowOut[j] = subplotId;\n                    axisMap[xId] = j;\n                    axisMap[yId] = i;\n                }\n            }\n        }\n    } else {\n        var xAxes = getAxes(layoutOut, gridIn, 'x');\n        var yAxes = getAxes(layoutOut, gridIn, 'y');\n        gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');\n        gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');\n    }\n\n    var anchors = gridOut._anchors = {};\n    var reversed = gridOut.roworder === 'top to bottom';\n\n    for(var axisId in axisMap) {\n        var axLetter = axisId.charAt(0);\n        var side = gridOut[axLetter + 'side'];\n\n        var i0, inc, iFinal;\n\n        if(side.length < 8) {\n            // grid edge -  ie not \"* plot\" - make these as free axes\n            // since we're not guaranteed to have a subplot there at all\n            anchors[axisId] = 'free';\n        } else if(axLetter === 'x') {\n            if((side.charAt(0) === 't') === reversed) {\n                i0 = 0;\n                inc = 1;\n                iFinal = rows;\n            } else {\n                i0 = rows - 1;\n                inc = -1;\n                iFinal = -1;\n            }\n            if(hasSubplotGrid) {\n                var column = axisMap[axisId];\n                for(i = i0; i !== iFinal; i += inc) {\n                    subplotId = subplotsOut[i][column];\n                    if(!subplotId) continue;\n                    yPos = subplotId.indexOf('y');\n                    if(subplotId.slice(0, yPos) === axisId) {\n                        anchors[axisId] = subplotId.slice(yPos);\n                        break;\n                    }\n                }\n            } else {\n                for(i = i0; i !== iFinal; i += inc) {\n                    yId = gridOut.yaxes[i];\n                    if(subplots.cartesian.indexOf(axisId + yId) !== -1) {\n                        anchors[axisId] = yId;\n                        break;\n                    }\n                }\n            }\n        } else {\n            if((side.charAt(0) === 'l')) {\n                i0 = 0;\n                inc = 1;\n                iFinal = columns;\n            } else {\n                i0 = columns - 1;\n                inc = -1;\n                iFinal = -1;\n            }\n            if(hasSubplotGrid) {\n                var row = axisMap[axisId];\n                for(i = i0; i !== iFinal; i += inc) {\n                    subplotId = subplotsOut[row][i];\n                    if(!subplotId) continue;\n                    yPos = subplotId.indexOf('y');\n                    if(subplotId.slice(yPos) === axisId) {\n                        anchors[axisId] = subplotId.slice(0, yPos);\n                        break;\n                    }\n                }\n            } else {\n                for(i = i0; i !== iFinal; i += inc) {\n                    xId = gridOut.xaxes[i];\n                    if(subplots.cartesian.indexOf(xId + axisId) !== -1) {\n                        anchors[axisId] = xId;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {\n    var out = new Array(len);\n    var i;\n\n    function fillOneAxis(i, axisId) {\n        if(axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {\n            out[i] = axisId;\n            axisMap[axisId] = i;\n        } else out[i] = '';\n    }\n\n    if(Array.isArray(axesIn)) {\n        for(i = 0; i < len; i++) {\n            fillOneAxis(i, axesIn[i]);\n        }\n    } else {\n        // default axis list is the first `len` axis ids\n        fillOneAxis(0, axLetter);\n        for(i = 1; i < len; i++) {\n            fillOneAxis(i, axLetter + (i + 1));\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    moduleType: 'component',\n    name: 'grid',\n\n    schema: {\n        layout: {grid: gridAttrs}\n    },\n\n    layoutAttributes: gridAttrs,\n    sizeDefaults: sizeDefaults,\n    contentDefaults: contentDefaults\n};\n"]},"metadata":{},"sourceType":"script"}