{"ast":null,"code":"'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\n\n\nmodule.exports = function (carpet, carpetcd, a, b) {\n  var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n  var p0, p1, v0, v1, start, end, range;\n  var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n  var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n  var smoothing = ax.smoothing;\n  var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n  var pt = axis === 'a' ? a : b;\n  var iso = axis === 'a' ? b : a;\n  var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n  var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n  var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n  var xy = axis === 'a' ? function (value) {\n    return carpet.evalxy([], value, isoIdx);\n  } : function (value) {\n    return carpet.evalxy([], isoIdx, value);\n  };\n\n  if (smoothing) {\n    tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n    tanIsoPar = isoIdx - tanIsoIdx;\n    tangent = axis === 'a' ? function (i, ti) {\n      return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n    } : function (j, tj) {\n      return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n    };\n  }\n\n  var vstart = toIdx(pt[0]);\n  var vend = toIdx(pt[1]); // So that we can make this work in two directions, flip all of the\n  // math functions if the direction is from higher to lower indices:\n  //\n  // Note that the tolerance is directional!\n\n  var dir = vstart < vend ? 1 : -1;\n  var tol = (vend - vstart) * 1e-8;\n  var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n  var dirceil = dir > 0 ? Math.ceil : Math.floor;\n  var dirmin = dir > 0 ? Math.min : Math.max;\n  var dirmax = dir > 0 ? Math.max : Math.min;\n  var idx0 = dirfloor(vstart + tol);\n  var idx1 = dirceil(vend - tol);\n  p0 = xy(vstart);\n  var segments = [[p0]];\n\n  for (idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n    segment = [];\n    start = dirmax(vstart, idx);\n    end = dirmin(vend, idx + dir);\n    range = end - start; // In order to figure out which cell we're in for the derivative (remember,\n    // the derivatives are *not* constant across grid lines), let's just average\n    // the start and end points. This cuts out just a tiny bit of logic and\n    // there's really no computational difference:\n\n    refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n    p1 = xy(end);\n\n    if (smoothing) {\n      v0 = tangent(refidx, start - refidx);\n      v1 = tangent(refidx, end - refidx);\n      segment.push([p0[0] + v0[0] / 3 * range, p0[1] + v0[1] / 3 * range]);\n      segment.push([p1[0] - v1[0] / 3 * range, p1[1] - v1[1] / 3 * range]);\n    }\n\n    segment.push(p1);\n    segments.push(segment);\n    p0 = p1;\n  }\n\n  return segments;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/carpet/axis_aligned_line.js"],"names":["isArrayOrTypedArray","require","module","exports","carpet","carpetcd","a","b","idx","tangent","tanIsoIdx","tanIsoPar","segment","refidx","p0","p1","v0","v1","start","end","range","axis","ax","aaxis","baxis","smoothing","toIdx","a2i","b2j","pt","iso","n","length","m","isoIdx","Math","floor","xy","value","evalxy","max","min","i","ti","dxydi","j","tj","dxydj","vstart","vend","dir","tol","dirfloor","ceil","dirceil","dirmin","dirmax","idx0","idx1","segments","push"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\nmodule.exports = function(carpet, carpetcd, a, b) {\n    var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n    var p0, p1, v0, v1, start, end, range;\n\n    var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n    var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n    var smoothing = ax.smoothing;\n    var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n    var pt = axis === 'a' ? a : b;\n    var iso = axis === 'a' ? b : a;\n    var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n    var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n    var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n\n    var xy = axis === 'a' ? function(value) {\n        return carpet.evalxy([], value, isoIdx);\n    } : function(value) {\n        return carpet.evalxy([], isoIdx, value);\n    };\n\n    if(smoothing) {\n        tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n        tanIsoPar = isoIdx - tanIsoIdx;\n        tangent = axis === 'a' ? function(i, ti) {\n            return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n        } : function(j, tj) {\n            return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n        };\n    }\n\n    var vstart = toIdx(pt[0]);\n    var vend = toIdx(pt[1]);\n\n    // So that we can make this work in two directions, flip all of the\n    // math functions if the direction is from higher to lower indices:\n    //\n    // Note that the tolerance is directional!\n    var dir = vstart < vend ? 1 : -1;\n    var tol = (vend - vstart) * 1e-8;\n    var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n    var dirceil = dir > 0 ? Math.ceil : Math.floor;\n    var dirmin = dir > 0 ? Math.min : Math.max;\n    var dirmax = dir > 0 ? Math.max : Math.min;\n\n    var idx0 = dirfloor(vstart + tol);\n    var idx1 = dirceil(vend - tol);\n\n    p0 = xy(vstart);\n    var segments = [[p0]];\n\n    for(idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n        segment = [];\n        start = dirmax(vstart, idx);\n        end = dirmin(vend, idx + dir);\n        range = end - start;\n\n        // In order to figure out which cell we're in for the derivative (remember,\n        // the derivatives are *not* constant across grid lines), let's just average\n        // the start and end points. This cuts out just a tiny bit of logic and\n        // there's really no computational difference:\n        refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n\n        p1 = xy(end);\n        if(smoothing) {\n            v0 = tangent(refidx, start - refidx);\n            v1 = tangent(refidx, end - refidx);\n\n            segment.push([\n                p0[0] + v0[0] / 3 * range,\n                p0[1] + v0[1] / 3 * range\n            ]);\n\n            segment.push([\n                p1[0] - v1[0] / 3 * range,\n                p1[1] - v1[1] / 3 * range\n            ]);\n        }\n\n        segment.push(p1);\n\n        segments.push(segment);\n        p0 = p1;\n    }\n\n    return segments;\n};\n"]},"metadata":{},"sourceType":"script"}