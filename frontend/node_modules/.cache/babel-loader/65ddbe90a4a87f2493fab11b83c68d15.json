{"ast":null,"code":"'use strict';\n\nvar parseSvgPath = require('parse-svg-path');\n\nvar constants = require('./constants');\n\nvar CIRCLE_SIDES = constants.CIRCLE_SIDES;\nvar SQRT2 = constants.SQRT2;\n\nvar cartesianHelpers = require('../../../plots/cartesian/helpers');\n\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\nvar iC = [0, 3, 4, 5, 6, 1, 2];\nvar iQS = [0, 3, 4, 1, 2];\n\nexports.writePaths = function (polygons) {\n  var nI = polygons.length;\n  if (!nI) return 'M0,0Z';\n  var str = '';\n\n  for (var i = 0; i < nI; i++) {\n    var nJ = polygons[i].length;\n\n    for (var j = 0; j < nJ; j++) {\n      var w = polygons[i][j][0];\n\n      if (w === 'Z') {\n        str += 'Z';\n      } else {\n        var nK = polygons[i][j].length;\n\n        for (var k = 0; k < nK; k++) {\n          var realK = k;\n\n          if (w === 'Q' || w === 'S') {\n            realK = iQS[k];\n          } else if (w === 'C') {\n            realK = iC[k];\n          }\n\n          str += polygons[i][j][realK];\n\n          if (k > 0 && k < nK - 1) {\n            str += ',';\n          }\n        }\n      }\n    }\n  }\n\n  return str;\n};\n\nexports.readPaths = function (str, gd, plotinfo, isActiveShape) {\n  var cmd = parseSvgPath(str);\n  var polys = [];\n  var n = -1;\n\n  var newPoly = function () {\n    n++;\n    polys[n] = [];\n  };\n\n  var k;\n  var x = 0;\n  var y = 0;\n  var initX;\n  var initY;\n\n  var recStart = function () {\n    initX = x;\n    initY = y;\n  };\n\n  recStart();\n\n  for (var i = 0; i < cmd.length; i++) {\n    var newPos = [];\n    var x1, x2, y1, y2; // i.e. extra params for curves\n\n    var c = cmd[i][0];\n    var w = c;\n\n    switch (c) {\n      case 'M':\n        newPoly();\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        recStart();\n        break;\n\n      case 'Q':\n      case 'S':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x = +cmd[i][3];\n        y = +cmd[i][4];\n        newPos.push([w, x, y, x1, y1]); // -> iQS order\n\n        break;\n\n      case 'C':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x2 = +cmd[i][3];\n        y2 = +cmd[i][4];\n        x = +cmd[i][5];\n        y = +cmd[i][6];\n        newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order\n\n        break;\n\n      case 'T':\n      case 'L':\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'H':\n        w = 'L'; // convert to line (for now)\n\n        x = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'V':\n        w = 'L'; // convert to line (for now)\n\n        y = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'A':\n        w = 'L'; // convert to line to handle circle\n\n        var rx = +cmd[i][1];\n        var ry = +cmd[i][2];\n\n        if (!+cmd[i][4]) {\n          rx = -rx;\n          ry = -ry;\n        }\n\n        var cenX = x - rx;\n        var cenY = y;\n\n        for (k = 1; k <= CIRCLE_SIDES / 2; k++) {\n          var t = 2 * Math.PI * k / CIRCLE_SIDES;\n          newPos.push([w, cenX + rx * Math.cos(t), cenY + ry * Math.sin(t)]);\n        }\n\n        break;\n\n      case 'Z':\n        if (x !== initX || y !== initY) {\n          x = initX;\n          y = initY;\n          newPos.push([w, x, y]);\n        }\n\n        break;\n    }\n\n    var domain = (plotinfo || {}).domain;\n    var size = gd._fullLayout._size;\n    var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';\n    var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';\n    var noOffset = isActiveShape === false;\n\n    for (var j = 0; j < newPos.length; j++) {\n      for (k = 0; k + 2 < 7; k += 2) {\n        var _x = newPos[j][k + 1];\n        var _y = newPos[j][k + 2];\n        if (_x === undefined || _y === undefined) continue; // keep track of end point for Z\n\n        x = _x;\n        y = _y;\n\n        if (plotinfo) {\n          if (plotinfo.xaxis && plotinfo.xaxis.p2r) {\n            if (noOffset) _x -= plotinfo.xaxis._offset;\n\n            if (xPixelSized) {\n              _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;\n            } else {\n              _x = p2r(plotinfo.xaxis, _x);\n            }\n          } else {\n            if (noOffset) _x -= size.l;\n            if (domain) _x = domain.x[0] + _x / size.w;else _x = _x / size.w;\n          }\n\n          if (plotinfo.yaxis && plotinfo.yaxis.p2r) {\n            if (noOffset) _y -= plotinfo.yaxis._offset;\n\n            if (yPixelSized) {\n              _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;\n            } else {\n              _y = p2r(plotinfo.yaxis, _y);\n            }\n          } else {\n            if (noOffset) _y -= size.t;\n            if (domain) _y = domain.y[1] - _y / size.h;else _y = 1 - _y / size.h;\n          }\n        }\n\n        newPos[j][k + 1] = _x;\n        newPos[j][k + 2] = _y;\n      }\n\n      polys[n].push(newPos[j].slice());\n    }\n  }\n\n  return polys;\n};\n\nfunction almostEq(a, b) {\n  return Math.abs(a - b) <= 1e-6;\n}\n\nfunction dist(a, b) {\n  var dx = b[1] - a[1];\n  var dy = b[2] - a[2];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexports.pointsShapeRectangle = function (cell) {\n  var len = cell.length;\n  if (len !== 5) return false;\n\n  for (var j = 1; j < 3; j++) {\n    var e01 = cell[0][j] - cell[1][j];\n    var e32 = cell[3][j] - cell[2][j];\n    if (!almostEq(e01, e32)) return false;\n    var e03 = cell[0][j] - cell[3][j];\n    var e12 = cell[1][j] - cell[2][j];\n    if (!almostEq(e03, e12)) return false;\n  } // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.\n\n\n  if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false; // reject cases with zero area\n\n  return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));\n};\n\nexports.pointsShapeEllipse = function (cell) {\n  var len = cell.length;\n  if (len !== CIRCLE_SIDES + 1) return false; // opposite diagonals should be the same\n\n  len = CIRCLE_SIDES;\n\n  for (var i = 0; i < len; i++) {\n    var k = (len * 2 - i) % len;\n    var k2 = (len / 2 + k) % len;\n    var i2 = (len / 2 + i) % len;\n    if (!almostEq(dist(cell[i], cell[i2]), dist(cell[k], cell[k2]))) return false;\n  }\n\n  return true;\n};\n\nexports.handleEllipse = function (isEllipse, start, end) {\n  if (!isEllipse) return [start, end]; // i.e. case of line\n\n  var pos = exports.ellipseOver({\n    x0: start[0],\n    y0: start[1],\n    x1: end[0],\n    y1: end[1]\n  });\n  var cx = (pos.x1 + pos.x0) / 2;\n  var cy = (pos.y1 + pos.y0) / 2;\n  var rx = (pos.x1 - pos.x0) / 2;\n  var ry = (pos.y1 - pos.y0) / 2; // make a circle when one dimension is zero\n\n  if (!rx) rx = ry = ry / SQRT2;\n  if (!ry) ry = rx = rx / SQRT2;\n  var cell = [];\n\n  for (var i = 0; i < CIRCLE_SIDES; i++) {\n    var t = i * 2 * Math.PI / CIRCLE_SIDES;\n    cell.push([cx + rx * Math.cos(t), cy + ry * Math.sin(t)]);\n  }\n\n  return cell;\n};\n\nexports.ellipseOver = function (pos) {\n  var x0 = pos.x0;\n  var y0 = pos.y0;\n  var x1 = pos.x1;\n  var y1 = pos.y1;\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n  x0 -= dx;\n  y0 -= dy;\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var scale = SQRT2;\n  dx *= scale;\n  dy *= scale;\n  return {\n    x0: cx - dx,\n    y0: cy - dy,\n    x1: cx + dx,\n    y1: cy + dy\n  };\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/components/shapes/draw_newshape/helpers.js"],"names":["parseSvgPath","require","constants","CIRCLE_SIDES","SQRT2","cartesianHelpers","p2r","r2p","iC","iQS","exports","writePaths","polygons","nI","length","str","i","nJ","j","w","nK","k","realK","readPaths","gd","plotinfo","isActiveShape","cmd","polys","n","newPoly","x","y","initX","initY","recStart","newPos","x1","x2","y1","y2","c","push","rx","ry","cenX","cenY","t","Math","PI","cos","sin","domain","size","_fullLayout","_size","xPixelSized","xsizemode","yPixelSized","ysizemode","noOffset","_x","_y","undefined","xaxis","_offset","xanchor","l","yaxis","yanchor","h","slice","almostEq","a","b","abs","dist","dx","dy","sqrt","pointsShapeRectangle","cell","len","e01","e32","e03","e12","pointsShapeEllipse","k2","i2","handleEllipse","isEllipse","start","end","pos","ellipseOver","x0","y0","cx","cy","scale"],"mappings":"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","sourcesContent":["'use strict';\n\nvar parseSvgPath = require('parse-svg-path');\n\nvar constants = require('./constants');\nvar CIRCLE_SIDES = constants.CIRCLE_SIDES;\nvar SQRT2 = constants.SQRT2;\n\nvar cartesianHelpers = require('../../../plots/cartesian/helpers');\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\n\nvar iC = [0, 3, 4, 5, 6, 1, 2];\nvar iQS = [0, 3, 4, 1, 2];\n\nexports.writePaths = function(polygons) {\n    var nI = polygons.length;\n    if(!nI) return 'M0,0Z';\n\n    var str = '';\n    for(var i = 0; i < nI; i++) {\n        var nJ = polygons[i].length;\n        for(var j = 0; j < nJ; j++) {\n            var w = polygons[i][j][0];\n            if(w === 'Z') {\n                str += 'Z';\n            } else {\n                var nK = polygons[i][j].length;\n                for(var k = 0; k < nK; k++) {\n                    var realK = k;\n                    if(w === 'Q' || w === 'S') {\n                        realK = iQS[k];\n                    } else if(w === 'C') {\n                        realK = iC[k];\n                    }\n\n                    str += polygons[i][j][realK];\n                    if(k > 0 && k < nK - 1) {\n                        str += ',';\n                    }\n                }\n            }\n        }\n    }\n\n    return str;\n};\n\nexports.readPaths = function(str, gd, plotinfo, isActiveShape) {\n    var cmd = parseSvgPath(str);\n\n    var polys = [];\n    var n = -1;\n    var newPoly = function() {\n        n++;\n        polys[n] = [];\n    };\n\n    var k;\n    var x = 0;\n    var y = 0;\n    var initX;\n    var initY;\n    var recStart = function() {\n        initX = x;\n        initY = y;\n    };\n\n    recStart();\n    for(var i = 0; i < cmd.length; i++) {\n        var newPos = [];\n\n        var x1, x2, y1, y2; // i.e. extra params for curves\n\n        var c = cmd[i][0];\n        var w = c;\n        switch(c) {\n            case 'M':\n                newPoly();\n                x = +cmd[i][1];\n                y = +cmd[i][2];\n                newPos.push([w, x, y]);\n\n                recStart();\n                break;\n\n            case 'Q':\n            case 'S':\n                x1 = +cmd[i][1];\n                y1 = +cmd[i][2];\n                x = +cmd[i][3];\n                y = +cmd[i][4];\n                newPos.push([w, x, y, x1, y1]); // -> iQS order\n                break;\n\n            case 'C':\n                x1 = +cmd[i][1];\n                y1 = +cmd[i][2];\n                x2 = +cmd[i][3];\n                y2 = +cmd[i][4];\n                x = +cmd[i][5];\n                y = +cmd[i][6];\n                newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order\n                break;\n\n            case 'T':\n            case 'L':\n                x = +cmd[i][1];\n                y = +cmd[i][2];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'H':\n                w = 'L'; // convert to line (for now)\n                x = +cmd[i][1];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'V':\n                w = 'L'; // convert to line (for now)\n                y = +cmd[i][1];\n                newPos.push([w, x, y]);\n                break;\n\n            case 'A':\n                w = 'L'; // convert to line to handle circle\n                var rx = +cmd[i][1];\n                var ry = +cmd[i][2];\n                if(!+cmd[i][4]) {\n                    rx = -rx;\n                    ry = -ry;\n                }\n\n                var cenX = x - rx;\n                var cenY = y;\n                for(k = 1; k <= CIRCLE_SIDES / 2; k++) {\n                    var t = 2 * Math.PI * k / CIRCLE_SIDES;\n                    newPos.push([\n                        w,\n                        cenX + rx * Math.cos(t),\n                        cenY + ry * Math.sin(t)\n                    ]);\n                }\n                break;\n\n            case 'Z':\n                if(x !== initX || y !== initY) {\n                    x = initX;\n                    y = initY;\n                    newPos.push([w, x, y]);\n                }\n                break;\n        }\n\n        var domain = (plotinfo || {}).domain;\n        var size = gd._fullLayout._size;\n        var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';\n        var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';\n        var noOffset = isActiveShape === false;\n\n        for(var j = 0; j < newPos.length; j++) {\n            for(k = 0; k + 2 < 7; k += 2) {\n                var _x = newPos[j][k + 1];\n                var _y = newPos[j][k + 2];\n\n                if(_x === undefined || _y === undefined) continue;\n                // keep track of end point for Z\n                x = _x;\n                y = _y;\n\n                if(plotinfo) {\n                    if(plotinfo.xaxis && plotinfo.xaxis.p2r) {\n                        if(noOffset) _x -= plotinfo.xaxis._offset;\n                        if(xPixelSized) {\n                            _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;\n                        } else {\n                            _x = p2r(plotinfo.xaxis, _x);\n                        }\n                    } else {\n                        if(noOffset) _x -= size.l;\n                        if(domain) _x = domain.x[0] + _x / size.w;\n                        else _x = _x / size.w;\n                    }\n\n                    if(plotinfo.yaxis && plotinfo.yaxis.p2r) {\n                        if(noOffset) _y -= plotinfo.yaxis._offset;\n                        if(yPixelSized) {\n                            _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;\n                        } else {\n                            _y = p2r(plotinfo.yaxis, _y);\n                        }\n                    } else {\n                        if(noOffset) _y -= size.t;\n                        if(domain) _y = domain.y[1] - _y / size.h;\n                        else _y = 1 - _y / size.h;\n                    }\n                }\n\n                newPos[j][k + 1] = _x;\n                newPos[j][k + 2] = _y;\n            }\n            polys[n].push(\n                newPos[j].slice()\n            );\n        }\n    }\n\n    return polys;\n};\n\nfunction almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n}\n\nfunction dist(a, b) {\n    var dx = b[1] - a[1];\n    var dy = b[2] - a[2];\n    return Math.sqrt(\n        dx * dx +\n        dy * dy\n    );\n}\n\nexports.pointsShapeRectangle = function(cell) {\n    var len = cell.length;\n    if(len !== 5) return false;\n\n    for(var j = 1; j < 3; j++) {\n        var e01 = cell[0][j] - cell[1][j];\n        var e32 = cell[3][j] - cell[2][j];\n\n        if(!almostEq(e01, e32)) return false;\n\n        var e03 = cell[0][j] - cell[3][j];\n        var e12 = cell[1][j] - cell[2][j];\n        if(!almostEq(e03, e12)) return false;\n    }\n\n    // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.\n    if(\n        !almostEq(cell[0][1], cell[1][1]) &&\n        !almostEq(cell[0][1], cell[3][1])\n    ) return false;\n\n    // reject cases with zero area\n    return !!(\n        dist(cell[0], cell[1]) *\n        dist(cell[0], cell[3])\n    );\n};\n\nexports.pointsShapeEllipse = function(cell) {\n    var len = cell.length;\n    if(len !== CIRCLE_SIDES + 1) return false;\n\n    // opposite diagonals should be the same\n    len = CIRCLE_SIDES;\n    for(var i = 0; i < len; i++) {\n        var k = (len * 2 - i) % len;\n\n        var k2 = (len / 2 + k) % len;\n        var i2 = (len / 2 + i) % len;\n\n        if(!almostEq(\n            dist(cell[i], cell[i2]),\n            dist(cell[k], cell[k2])\n        )) return false;\n    }\n    return true;\n};\n\nexports.handleEllipse = function(isEllipse, start, end) {\n    if(!isEllipse) return [start, end]; // i.e. case of line\n\n    var pos = exports.ellipseOver({\n        x0: start[0],\n        y0: start[1],\n        x1: end[0],\n        y1: end[1]\n    });\n\n    var cx = (pos.x1 + pos.x0) / 2;\n    var cy = (pos.y1 + pos.y0) / 2;\n    var rx = (pos.x1 - pos.x0) / 2;\n    var ry = (pos.y1 - pos.y0) / 2;\n\n    // make a circle when one dimension is zero\n    if(!rx) rx = ry = ry / SQRT2;\n    if(!ry) ry = rx = rx / SQRT2;\n\n    var cell = [];\n    for(var i = 0; i < CIRCLE_SIDES; i++) {\n        var t = i * 2 * Math.PI / CIRCLE_SIDES;\n        cell.push([\n            cx + rx * Math.cos(t),\n            cy + ry * Math.sin(t),\n        ]);\n    }\n    return cell;\n};\n\nexports.ellipseOver = function(pos) {\n    var x0 = pos.x0;\n    var y0 = pos.y0;\n    var x1 = pos.x1;\n    var y1 = pos.y1;\n\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n\n    x0 -= dx;\n    y0 -= dy;\n\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n\n    var scale = SQRT2;\n    dx *= scale;\n    dy *= scale;\n\n    return {\n        x0: cx - dx,\n        y0: cy - dy,\n        x1: cx + dx,\n        y1: cy + dy\n    };\n};\n"]},"metadata":{},"sourceType":"script"}