{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2;\nvar NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n  // start with less overshoot, until we know it's converging,\n  // then ramp up the overshoot for faster convergence\n  return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n/*\n * interp2d: Fill in missing data from a 2D array using an iterative\n *   poisson equation solver with zero-derivative BC at edges.\n *   Amazingly, this just amounts to repeatedly averaging all the existing\n *   nearest neighbors, at least if we don't take x/y scaling into account,\n *   which is the right approach here where x and y may not even have the\n *   same units.\n *\n * @param {array of arrays} z\n *      The 2D array to fill in. Will be mutated here. Assumed to already be\n *      cleaned, so all entries are numbers except gaps, which are `undefined`.\n * @param {array of arrays} emptyPoints\n *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number\n *      of neighbors that are *not* missing. Assumed to be sorted from most to\n *      least neighbors, as produced by heatmap/find_empties.\n */\n\n\nmodule.exports = function interp2d(z, emptyPoints) {\n  var maxFractionalChange = 1;\n  var i; // one pass to fill in a starting value for all the empties\n\n  iterateInterp2d(z, emptyPoints); // we're don't need to iterate lone empties - remove them\n\n  for (i = 0; i < emptyPoints.length; i++) {\n    if (emptyPoints[i][2] < 4) break;\n  } // but don't remove these points from the original array,\n  // we'll use them for masking, so make a copy.\n\n\n  emptyPoints = emptyPoints.slice(i);\n\n  for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n    maxFractionalChange = iterateInterp2d(z, emptyPoints, correctionOvershoot(maxFractionalChange));\n  }\n\n  if (maxFractionalChange > INTERPTHRESHOLD) {\n    Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n  }\n\n  return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n  var maxFractionalChange = 0;\n  var thisPt;\n  var i;\n  var j;\n  var p;\n  var q;\n  var neighborShift;\n  var neighborRow;\n  var neighborVal;\n  var neighborCount;\n  var neighborSum;\n  var initialVal;\n  var minNeighbor;\n  var maxNeighbor;\n\n  for (p = 0; p < emptyPoints.length; p++) {\n    thisPt = emptyPoints[p];\n    i = thisPt[0];\n    j = thisPt[1];\n    initialVal = z[i][j];\n    neighborSum = 0;\n    neighborCount = 0;\n\n    for (q = 0; q < 4; q++) {\n      neighborShift = NEIGHBORSHIFTS[q];\n      neighborRow = z[i + neighborShift[0]];\n      if (!neighborRow) continue;\n      neighborVal = neighborRow[j + neighborShift[1]];\n\n      if (neighborVal !== undefined) {\n        if (neighborSum === 0) {\n          minNeighbor = maxNeighbor = neighborVal;\n        } else {\n          minNeighbor = Math.min(minNeighbor, neighborVal);\n          maxNeighbor = Math.max(maxNeighbor, neighborVal);\n        }\n\n        neighborCount++;\n        neighborSum += neighborVal;\n      }\n    }\n\n    if (neighborCount === 0) {\n      throw 'iterateInterp2d order is wrong: no defined neighbors';\n    } // this is the laplace equation interpolation:\n    // each point is just the average of its neighbors\n    // note that this ignores differential x/y scaling\n    // which I think is the right approach, since we\n    // don't know what that scaling means\n\n\n    z[i][j] = neighborSum / neighborCount;\n\n    if (initialVal === undefined) {\n      if (neighborCount < 4) maxFractionalChange = 1;\n    } else {\n      // we can make large empty regions converge faster\n      // if we overshoot the change vs the previous value\n      z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n      if (maxNeighbor > minNeighbor) {\n        maxFractionalChange = Math.max(maxFractionalChange, Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n      }\n    }\n  }\n\n  return maxFractionalChange;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/heatmap/interp2d.js"],"names":["Lib","require","INTERPTHRESHOLD","NEIGHBORSHIFTS","correctionOvershoot","maxFractionalChange","Math","min","module","exports","interp2d","z","emptyPoints","i","iterateInterp2d","length","slice","log","overshoot","thisPt","j","p","q","neighborShift","neighborRow","neighborVal","neighborCount","neighborSum","initialVal","minNeighbor","maxNeighbor","undefined","max","abs"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2;\nvar NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n    // start with less overshoot, until we know it's converging,\n    // then ramp up the overshoot for faster convergence\n    return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n\n/*\n * interp2d: Fill in missing data from a 2D array using an iterative\n *   poisson equation solver with zero-derivative BC at edges.\n *   Amazingly, this just amounts to repeatedly averaging all the existing\n *   nearest neighbors, at least if we don't take x/y scaling into account,\n *   which is the right approach here where x and y may not even have the\n *   same units.\n *\n * @param {array of arrays} z\n *      The 2D array to fill in. Will be mutated here. Assumed to already be\n *      cleaned, so all entries are numbers except gaps, which are `undefined`.\n * @param {array of arrays} emptyPoints\n *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number\n *      of neighbors that are *not* missing. Assumed to be sorted from most to\n *      least neighbors, as produced by heatmap/find_empties.\n */\nmodule.exports = function interp2d(z, emptyPoints) {\n    var maxFractionalChange = 1;\n    var i;\n\n    // one pass to fill in a starting value for all the empties\n    iterateInterp2d(z, emptyPoints);\n\n    // we're don't need to iterate lone empties - remove them\n    for(i = 0; i < emptyPoints.length; i++) {\n        if(emptyPoints[i][2] < 4) break;\n    }\n    // but don't remove these points from the original array,\n    // we'll use them for masking, so make a copy.\n    emptyPoints = emptyPoints.slice(i);\n\n    for(i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n        maxFractionalChange = iterateInterp2d(z, emptyPoints,\n            correctionOvershoot(maxFractionalChange));\n    }\n    if(maxFractionalChange > INTERPTHRESHOLD) {\n        Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n    }\n\n    return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n    var maxFractionalChange = 0;\n    var thisPt;\n    var i;\n    var j;\n    var p;\n    var q;\n    var neighborShift;\n    var neighborRow;\n    var neighborVal;\n    var neighborCount;\n    var neighborSum;\n    var initialVal;\n    var minNeighbor;\n    var maxNeighbor;\n\n    for(p = 0; p < emptyPoints.length; p++) {\n        thisPt = emptyPoints[p];\n        i = thisPt[0];\n        j = thisPt[1];\n        initialVal = z[i][j];\n        neighborSum = 0;\n        neighborCount = 0;\n\n        for(q = 0; q < 4; q++) {\n            neighborShift = NEIGHBORSHIFTS[q];\n            neighborRow = z[i + neighborShift[0]];\n            if(!neighborRow) continue;\n            neighborVal = neighborRow[j + neighborShift[1]];\n            if(neighborVal !== undefined) {\n                if(neighborSum === 0) {\n                    minNeighbor = maxNeighbor = neighborVal;\n                } else {\n                    minNeighbor = Math.min(minNeighbor, neighborVal);\n                    maxNeighbor = Math.max(maxNeighbor, neighborVal);\n                }\n                neighborCount++;\n                neighborSum += neighborVal;\n            }\n        }\n\n        if(neighborCount === 0) {\n            throw 'iterateInterp2d order is wrong: no defined neighbors';\n        }\n\n        // this is the laplace equation interpolation:\n        // each point is just the average of its neighbors\n        // note that this ignores differential x/y scaling\n        // which I think is the right approach, since we\n        // don't know what that scaling means\n        z[i][j] = neighborSum / neighborCount;\n\n        if(initialVal === undefined) {\n            if(neighborCount < 4) maxFractionalChange = 1;\n        } else {\n            // we can make large empty regions converge faster\n            // if we overshoot the change vs the previous value\n            z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n            if(maxNeighbor > minNeighbor) {\n                maxFractionalChange = Math.max(maxFractionalChange,\n                    Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n            }\n        }\n    }\n\n    return maxFractionalChange;\n}\n"]},"metadata":{},"sourceType":"script"}