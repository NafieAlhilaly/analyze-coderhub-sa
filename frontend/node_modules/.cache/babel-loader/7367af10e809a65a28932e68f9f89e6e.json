{"ast":null,"code":"'use strict';\n\nvar polybool = require('polybooljs');\n\nvar Registry = require('../../registry');\n\nvar dashStyle = require('../../components/drawing').dashStyle;\n\nvar Color = require('../../components/color');\n\nvar Fx = require('../../components/fx');\n\nvar makeEventData = require('../../components/fx/helpers').makeEventData;\n\nvar dragHelpers = require('../../components/dragelement/helpers');\n\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar displayOutlines = require('../../components/shapes/draw_newshape/display_outlines');\n\nvar handleEllipse = require('../../components/shapes/draw_newshape/helpers').handleEllipse;\n\nvar newShapes = require('../../components/shapes/draw_newshape/newshapes');\n\nvar Lib = require('../../lib');\n\nvar polygon = require('../../lib/polygon');\n\nvar throttle = require('../../lib/throttle');\n\nvar getFromId = require('./axis_ids').getFromId;\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\n\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\n\nvar clearSelect = require('./handle_outline').clearSelect;\n\nvar helpers = require('./helpers');\n\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction prepSelect(e, startX, startY, dragOptions, mode) {\n  var isFreeMode = freeMode(mode);\n  var isRectMode = rectMode(mode);\n  var isOpenMode = openMode(mode);\n  var isDrawMode = drawMode(mode);\n  var isSelectMode = selectMode(mode);\n  var isLine = mode === 'drawline';\n  var isEllipse = mode === 'drawcircle';\n  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var transform = getTransform(plotinfo);\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n\n  fullLayout._calcInverseTransform(gd);\n\n  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  x0 = transformedCoords[0];\n  y0 = transformedCoords[1];\n  var scaleX = fullLayout._invScaleX;\n  var scaleY = fullLayout._invScaleY;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var pw = dragOptions.xaxes[0]._length;\n  var ph = dragOptions.yaxes[0]._length;\n  var allAxes = dragOptions.xaxes.concat(dragOptions.yaxes);\n  var subtract = e.altKey && !(drawMode(mode) && isOpenMode);\n  var filterPoly, selectionTester, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(e, gd, dragOptions);\n\n  if (isFreeMode) {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data(isDrawMode ? [0] : [1, 2]);\n  var drwStyle = fullLayout.newshape;\n  outlines.enter().append('path').attr('class', function (d) {\n    return 'select-outline select-outline-' + d + ' select-outline-' + plotinfo.id;\n  }).style(isDrawMode ? {\n    opacity: drwStyle.opacity / 2,\n    fill: isOpenMode ? undefined : drwStyle.fillcolor,\n    stroke: drwStyle.line.color,\n    'stroke-dasharray': dashStyle(drwStyle.line.dash, drwStyle.line.width),\n    'stroke-width': drwStyle.line.width + 'px'\n  } : {}).attr('fill-rule', drwStyle.fillrule).classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', transform).attr('d', 'M0,0Z');\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = []; // find the traces to search for selection points\n\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);\n\n  function ascending(a, b) {\n    return a - b;\n  } // allow subplots to override fillRangeItems routine\n\n\n  var fillRangeItems;\n\n  if (plotinfo.fillRangeItems) {\n    fillRangeItems = plotinfo.fillRangeItems;\n  } else {\n    if (isRectMode) {\n      fillRangeItems = function (eventData, poly) {\n        var ranges = eventData.range = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n\n          var axLetter = ax._id.charAt(0);\n\n          ranges[ax._id] = [p2r(ax, poly[axLetter + 'min']), p2r(ax, poly[axLetter + 'max'])].sort(ascending);\n        }\n      };\n    } else {\n      // case of isFreeMode\n      fillRangeItems = function (eventData, poly, filterPoly) {\n        var dataPts = eventData.lassoPoints = {};\n\n        for (i = 0; i < allAxes.length; i++) {\n          var ax = allAxes[i];\n          dataPts[ax._id] = filterPoly.filtered.map(axValue(ax));\n        }\n      };\n    }\n  }\n\n  dragOptions.moveFn = function (dx0, dy0) {\n    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n\n    if (isRectMode) {\n      var direction;\n      var start, end;\n\n      if (isSelectMode) {\n        var q = fullLayout.selectdirection;\n\n        if (q === 'any') {\n          if (dy < Math.min(dx * 0.6, MINSELECT)) {\n            direction = 'h';\n          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {\n            direction = 'v';\n          } else {\n            direction = 'd';\n          }\n        } else {\n          direction = q;\n        }\n\n        switch (direction) {\n          case 'h':\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'v':\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n        }\n      }\n\n      if (isDrawMode) {\n        switch (fullLayout.newshape.drawdirection) {\n          case 'vertical':\n            direction = 'h';\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'horizontal':\n            direction = 'v';\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n\n          case 'ortho':\n            if (dx < dy) {\n              direction = 'h';\n              start = y0;\n              end = y1;\n            } else {\n              direction = 'v';\n              start = x0;\n              end = x1;\n            }\n\n            break;\n\n          default:\n            // i.e. case of 'diagonal'\n            direction = 'd';\n        }\n      }\n\n      if (direction === 'h') {\n        // horizontal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(start, end);\n        currentPolygon.ymax = Math.max(start, end); // extras to guide users in keeping a straight selection\n\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n        currentPolygon.xmin = Math.min(start, end);\n        currentPolygon.xmax = Math.max(start, end);\n        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (isFreeMode) {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    } // create outline & tester\n\n\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTester = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTester = polygonTester(currentPolygon);\n    } // display polygons on the screen\n\n\n    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n    if (isSelectMode) {\n      throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n        selection = [];\n        var thisSelection;\n        var traceSelections = [];\n        var traceSelection;\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n          traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTester);\n          traceSelections.push(traceSelection);\n          thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n          if (selection.length) {\n            for (var j = 0; j < thisSelection.length; j++) {\n              selection.push(thisSelection[j]);\n            }\n          } else selection = thisSelection;\n        }\n\n        eventData = {\n          points: selection\n        };\n        updateSelectedState(gd, searchTraces, eventData);\n        fillRangeItems(eventData, currentPolygon, filterPoly);\n        dragOptions.gd.emit('plotly_selecting', eventData);\n      });\n    }\n  };\n\n  dragOptions.clickFn = function (numClicks, evt) {\n    corners.remove();\n\n    if (gd._fullLayout._activeShapeIndex >= 0) {\n      gd._fullLayout._deactivateShape(gd);\n\n      return;\n    }\n\n    if (isDrawMode) return;\n    var clickmode = fullLayout.clickmode;\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        gd.emit('plotly_deselect', null);\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n\n        if (clickmode === 'event') {\n          // TODO: remove in v3 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v3 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          gd.emit('plotly_selected', undefined);\n        }\n      }\n\n      Fx.click(gd, evt);\n    }).catch(Lib.error);\n  };\n\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n      dragOptions.gd.emit('plotly_selected', eventData);\n\n      if (currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon); // we have to keep reference to arrays container\n\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n    }).catch(Lib.error);\n\n    if (isDrawMode) {\n      clearSelectionsCache(dragOptions);\n    }\n  };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var fullLayout = gd._fullLayout;\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTester, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0; // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n\n      if (sendEvents) {\n        gd.emit('plotly_deselect', null);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTester = multiTester(allSelectionDefs);\n\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTester);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n\n      if (polygonOutlines) {\n        var polygons = dragOptions.mergedPolygons;\n        var isOpenMode = openMode(dragOptions.dragmode); // display polygons on the screen\n\n        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n      }\n\n      if (sendEvents) {\n        gd.emit('plotly_selected', eventData);\n      }\n    }\n  }\n}\n/**\n * Constructs a new point selection definition object.\n */\n\n\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: subtract\n  };\n}\n\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n/*\n * Constructs a new point number tester.\n */\n\n\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function (pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: pointSelectionDef.subtract\n  };\n}\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\n\n\nfunction multiTester(list) {\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygon.tester(list[i]);\n      tester.subtract = list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n\n\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = testers[i].subtract === false;\n      }\n    }\n\n    return contained;\n  }\n\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  gd._fullLayout._drawing = false;\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var dragmode = dragOptions.dragmode;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));\n\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  } // clear selection outline when selecting a different subplot\n\n\n  if (!selectingOnSameSubplot) {\n    clearSelect(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\n\nfunction clearSelectionsCache(dragOptions) {\n  var dragmode = dragOptions.dragmode;\n  var plotinfo = dragOptions.plotinfo;\n  var gd = dragOptions.gd;\n\n  if (gd._fullLayout._activeShapeIndex >= 0) {\n    gd._fullLayout._deactivateShape(gd);\n  }\n\n  if (drawMode(dragmode)) {\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n\n    if (outlines && gd._fullLayout._drawing) {\n      // add shape\n      var shapes = newShapes(outlines, dragOptions);\n\n      if (shapes) {\n        Registry.call('_guiRelayout', gd, {\n          shapes: shapes\n        });\n      }\n\n      gd._fullLayout._drawing = false;\n    }\n  }\n\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(function (ax) {\n    return ax._id;\n  });\n  var yAxisIds = yAxes.map(function (ax) {\n    return ax._id;\n  });\n  var cd, trace, i;\n\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n    if (subplot && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom' && // FIXME: make sure we don't have more than single axis for splom\n    trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n      var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      info.scene = gd._fullLayout._splomScenes[trace.uid];\n      searchTraces.push(info);\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n\n  return searchTraces;\n\n  function createSearchInfo(module, calcData, xaxis, yaxis) {\n    return {\n      _module: module,\n      cd: calcData,\n      xaxis: xaxis,\n      yaxis: yaxis\n    };\n  }\n}\n\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      } // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n\n\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n\n      break;\n    }\n  }\n\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0; // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum; // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n\n  return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i, searchInfo, cd, trace; // before anything else, update preGUI if necessary\n\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n\n  if (eventData) {\n    var pts = eventData.points || [];\n\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n\n    for (i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n      var data = pt.data;\n      var fullData = pt.fullData;\n\n      if (pt.pointIndices) {\n        [].push.apply(data.selectedpoints, pt.pointIndices);\n\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pt.pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pt.pointIndex);\n\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pt.pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n\n  var hasRegl = false;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    cd = searchInfo.cd;\n    trace = cd[0].trace;\n\n    if (Registry.traceIs(trace, 'regl')) {\n      hasRegl = true;\n    }\n\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n  var res;\n\n  if (subtract) {\n    res = polybool.difference({\n      regions: list,\n      inverted: false\n    }, {\n      regions: [poly],\n      inverted: false\n    });\n    return res.regions;\n  }\n\n  res = polybool.union({\n    regions: list,\n    inverted: false\n  }, {\n    regions: [poly],\n    inverted: false\n  });\n  return res.regions;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n\n  return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) {\n  // add M and L command to draft positions\n  var polygonsOut = [];\n\n  for (var i = 0; i < polygonsIn.length; i++) {\n    polygonsOut[i] = [];\n\n    for (var j = 0; j < polygonsIn[i].length; j++) {\n      polygonsOut[i][j] = [];\n      polygonsOut[i][j][0] = j ? 'L' : 'M';\n\n      for (var k = 0; k < polygonsIn[i][j].length; k++) {\n        polygonsOut[i][j].push(polygonsIn[i][j][k]);\n      }\n    }\n\n    if (!isOpenMode) {\n      polygonsOut[i].push(['Z', polygonsOut[i][0][1], // initial x\n      polygonsOut[i][0][2] // initial y\n      ]);\n    }\n  }\n\n  return polygonsOut;\n}\n\nmodule.exports = {\n  prepSelect: prepSelect,\n  clearSelect: clearSelect,\n  clearSelectionsCache: clearSelectionsCache,\n  selectOnClick: selectOnClick\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/select.js"],"names":["polybool","require","Registry","dashStyle","Color","Fx","makeEventData","dragHelpers","freeMode","rectMode","drawMode","openMode","selectMode","displayOutlines","handleEllipse","newShapes","Lib","polygon","throttle","getFromId","clearGlCanvases","redrawReglTraces","constants","MINSELECT","filteredPolygon","filter","polygonTester","tester","clearSelect","helpers","p2r","axValue","getTransform","prepSelect","e","startX","startY","dragOptions","mode","isFreeMode","isRectMode","isOpenMode","isDrawMode","isSelectMode","isLine","isEllipse","isLineOrEllipse","gd","fullLayout","_fullLayout","zoomLayer","_zoomlayer","dragBBox","element","getBoundingClientRect","plotinfo","transform","x0","left","y0","top","_calcInverseTransform","transformedCoords","apply3DTransform","_invTransform","scaleX","_invScaleX","scaleY","_invScaleY","x1","y1","path0","pw","xaxes","_length","ph","yaxes","allAxes","concat","subtract","altKey","filterPoly","selectionTester","mergedPolygons","currentPolygon","i","searchInfo","eventData","coerceSelectionsCache","BENDPX","outlines","selectAll","id","data","drwStyle","newshape","enter","append","attr","d","style","opacity","fill","undefined","fillcolor","stroke","line","color","dash","width","fillrule","classed","corners","background","defaultLine","throttleID","_uid","SELECTID","selection","searchTraces","determineSearchTraces","subplot","ascending","a","b","fillRangeItems","poly","ranges","range","length","ax","axLetter","_id","charAt","sort","dataPts","lassoPoints","filtered","map","moveFn","dx0","dy0","Math","max","min","dx","abs","dy","direction","start","end","q","selectdirection","drawdirection","xmin","xmax","ymin","ymax","addPt","selectionDefs","mergePolygons","multiTester","convertPoly","SELECTDELAY","thisSelection","traceSelections","traceSelection","_module","selectPoints","push","fillSelectionItem","j","points","updateSelectedState","emit","clickFn","numClicks","evt","remove","_activeShapeIndex","_deactivateShape","clickmode","done","then","clear","clearSelectionsCache","indexOf","selectOnClick","click","catch","error","doneFn","apply","doneFnCompleted","xAxes","yAxes","polygonOutlines","hoverData","_hoverdata","sendEvents","currentSelectionDef","thisTracesSelection","pointOrBinSelected","isHoverDataSet","clickedPtInfo","extractClickedPtInfo","isBinnedTrace","pointNumbers","isOnlyThisBinSelected","isOnlyOnePointSelected","isPointOrBinSelected","shiftKey","newPointSelectionDef","pointNumber","allSelectionDefs","polygons","dragmode","isPointSelectionDef","o","newPointNumTester","pointSelectionDef","pts","contains","pt","omitFirstEdge","idxWantedTrace","cd","trace","_expandedIndex","idxActualTrace","isRect","degenerate","list","testers","arg","contained","_drawing","selectingOnSameSubplot","_lastSelectedSubplot","hasModifierKey","shapes","call","xAxisIds","yAxisIds","calcdata","visible","geo","createSearchInfo","type","_xaxes","_yaxes","info","scene","_splomScenes","uid","sankeyInfo","xaxis","yaxis","module","calcData","Array","isArray","hoverOnBox","hoverDatum","fullData","binNumber","ptNum","ptNums","ptNumsSet","ptNumToTest","selectedpoints","tracesWithSelectedPts","isSameTrace","len","fullInputTrace","_fullInput","tracePreGUI","_tracePreGUI","_input","pointIndices","pointIndex","hasRegl","traceIs","fn","styleOnSelect","node3","nodeRangePlot3","res","difference","regions","inverted","union","polygonsIn","polygonsOut","k","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar polybool = require('polybooljs');\n\nvar Registry = require('../../registry');\nvar dashStyle = require('../../components/drawing').dashStyle;\nvar Color = require('../../components/color');\nvar Fx = require('../../components/fx');\nvar makeEventData = require('../../components/fx/helpers').makeEventData;\nvar dragHelpers = require('../../components/dragelement/helpers');\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar displayOutlines = require('../../components/shapes/draw_newshape/display_outlines');\nvar handleEllipse = require('../../components/shapes/draw_newshape/helpers').handleEllipse;\nvar newShapes = require('../../components/shapes/draw_newshape/newshapes');\n\nvar Lib = require('../../lib');\nvar polygon = require('../../lib/polygon');\nvar throttle = require('../../lib/throttle');\nvar getFromId = require('./axis_ids').getFromId;\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\nvar MINSELECT = constants.MINSELECT;\n\nvar filteredPolygon = polygon.filter;\nvar polygonTester = polygon.tester;\n\nvar clearSelect = require('./handle_outline').clearSelect;\n\nvar helpers = require('./helpers');\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction prepSelect(e, startX, startY, dragOptions, mode) {\n    var isFreeMode = freeMode(mode);\n    var isRectMode = rectMode(mode);\n    var isOpenMode = openMode(mode);\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n\n    var isLine = mode === 'drawline';\n    var isEllipse = mode === 'drawcircle';\n    var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n    var gd = dragOptions.gd;\n    var fullLayout = gd._fullLayout;\n    var zoomLayer = fullLayout._zoomlayer;\n    var dragBBox = dragOptions.element.getBoundingClientRect();\n    var plotinfo = dragOptions.plotinfo;\n    var transform = getTransform(plotinfo);\n    var x0 = startX - dragBBox.left;\n    var y0 = startY - dragBBox.top;\n\n    fullLayout._calcInverseTransform(gd);\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    var scaleX = fullLayout._invScaleX;\n    var scaleY = fullLayout._invScaleY;\n\n    var x1 = x0;\n    var y1 = y0;\n    var path0 = 'M' + x0 + ',' + y0;\n    var pw = dragOptions.xaxes[0]._length;\n    var ph = dragOptions.yaxes[0]._length;\n    var allAxes = dragOptions.xaxes.concat(dragOptions.yaxes);\n    var subtract = e.altKey &&\n        !(drawMode(mode) && isOpenMode);\n\n    var filterPoly, selectionTester, mergedPolygons, currentPolygon;\n    var i, searchInfo, eventData;\n\n    coerceSelectionsCache(e, gd, dragOptions);\n\n    if(isFreeMode) {\n        filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n    }\n\n    var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data(isDrawMode ? [0] : [1, 2]);\n    var drwStyle = fullLayout.newshape;\n\n    outlines.enter()\n        .append('path')\n        .attr('class', function(d) { return 'select-outline select-outline-' + d + ' select-outline-' + plotinfo.id; })\n        .style(isDrawMode ? {\n            opacity: drwStyle.opacity / 2,\n            fill: isOpenMode ? undefined : drwStyle.fillcolor,\n            stroke: drwStyle.line.color,\n            'stroke-dasharray': dashStyle(drwStyle.line.dash, drwStyle.line.width),\n            'stroke-width': drwStyle.line.width + 'px'\n        } : {})\n        .attr('fill-rule', drwStyle.fillrule)\n        .classed('cursor-move', isDrawMode ? true : false)\n        .attr('transform', transform)\n        .attr('d', path0 + 'Z');\n\n    var corners = zoomLayer.append('path')\n        .attr('class', 'zoombox-corners')\n        .style({\n            fill: Color.background,\n            stroke: Color.defaultLine,\n            'stroke-width': 1\n        })\n        .attr('transform', transform)\n        .attr('d', 'M0,0Z');\n\n\n    var throttleID = fullLayout._uid + constants.SELECTID;\n    var selection = [];\n\n    // find the traces to search for selection points\n    var searchTraces = determineSearchTraces(gd, dragOptions.xaxes,\n      dragOptions.yaxes, dragOptions.subplot);\n\n    function ascending(a, b) { return a - b; }\n\n    // allow subplots to override fillRangeItems routine\n    var fillRangeItems;\n\n    if(plotinfo.fillRangeItems) {\n        fillRangeItems = plotinfo.fillRangeItems;\n    } else {\n        if(isRectMode) {\n            fillRangeItems = function(eventData, poly) {\n                var ranges = eventData.range = {};\n\n                for(i = 0; i < allAxes.length; i++) {\n                    var ax = allAxes[i];\n                    var axLetter = ax._id.charAt(0);\n\n                    ranges[ax._id] = [\n                        p2r(ax, poly[axLetter + 'min']),\n                        p2r(ax, poly[axLetter + 'max'])\n                    ].sort(ascending);\n                }\n            };\n        } else { // case of isFreeMode\n            fillRangeItems = function(eventData, poly, filterPoly) {\n                var dataPts = eventData.lassoPoints = {};\n\n                for(i = 0; i < allAxes.length; i++) {\n                    var ax = allAxes[i];\n                    dataPts[ax._id] = filterPoly.filtered.map(axValue(ax));\n                }\n            };\n        }\n    }\n\n    dragOptions.moveFn = function(dx0, dy0) {\n        x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n        y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n\n        var dx = Math.abs(x1 - x0);\n        var dy = Math.abs(y1 - y0);\n\n        if(isRectMode) {\n            var direction;\n            var start, end;\n\n            if(isSelectMode) {\n                var q = fullLayout.selectdirection;\n\n                if(q === 'any') {\n                    if(dy < Math.min(dx * 0.6, MINSELECT)) {\n                        direction = 'h';\n                    } else if(dx < Math.min(dy * 0.6, MINSELECT)) {\n                        direction = 'v';\n                    } else {\n                        direction = 'd';\n                    }\n                } else {\n                    direction = q;\n                }\n\n                switch(direction) {\n                    case 'h':\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'v':\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                }\n            }\n\n            if(isDrawMode) {\n                switch(fullLayout.newshape.drawdirection) {\n                    case 'vertical':\n                        direction = 'h';\n                        start = isEllipse ? ph / 2 : 0;\n                        end = ph;\n                        break;\n                    case 'horizontal':\n                        direction = 'v';\n                        start = isEllipse ? pw / 2 : 0;\n                        end = pw;\n                        break;\n                    case 'ortho':\n                        if(dx < dy) {\n                            direction = 'h';\n                            start = y0;\n                            end = y1;\n                        } else {\n                            direction = 'v';\n                            start = x0;\n                            end = x1;\n                        }\n                        break;\n                    default: // i.e. case of 'diagonal'\n                        direction = 'd';\n                }\n            }\n\n            if(direction === 'h') {\n                // horizontal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n                    [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n                currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n                currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(start, end);\n                currentPolygon.ymax = Math.max(start, end);\n                // extras to guide users in keeping a straight selection\n                corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) +\n                    'h-4v' + (2 * MINSELECT) + 'h4Z' +\n                    'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) +\n                    'h4v' + (2 * MINSELECT) + 'h-4Z');\n            } else if(direction === 'v') {\n                // vertical motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n                    [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n                currentPolygon.xmin = Math.min(start, end);\n                currentPolygon.xmax = Math.max(start, end);\n                currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n                currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n                corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin +\n                    'v-4h' + (2 * MINSELECT) + 'v4Z' +\n                    'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) +\n                    'v4h' + (2 * MINSELECT) + 'v-4Z');\n            } else if(direction === 'd') {\n                // diagonal motion\n                currentPolygon = isLineOrEllipse ?\n                    handleEllipse(isEllipse, [x0, y0], [x1, y1]) :\n                    [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n\n                currentPolygon.xmin = Math.min(x0, x1);\n                currentPolygon.xmax = Math.max(x0, x1);\n                currentPolygon.ymin = Math.min(y0, y1);\n                currentPolygon.ymax = Math.max(y0, y1);\n                corners.attr('d', 'M0,0Z');\n            }\n        } else if(isFreeMode) {\n            filterPoly.addPt([x1, y1]);\n            currentPolygon = filterPoly.filtered;\n        }\n\n        // create outline & tester\n        if(dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n            currentPolygon.subtract = subtract;\n            selectionTester = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n        } else {\n            mergedPolygons = [currentPolygon];\n            selectionTester = polygonTester(currentPolygon);\n        }\n\n        // display polygons on the screen\n        displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n        if(isSelectMode) {\n            throttle.throttle(\n                throttleID,\n                constants.SELECTDELAY,\n                function() {\n                    selection = [];\n\n                    var thisSelection;\n                    var traceSelections = [];\n                    var traceSelection;\n                    for(i = 0; i < searchTraces.length; i++) {\n                        searchInfo = searchTraces[i];\n\n                        traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTester);\n                        traceSelections.push(traceSelection);\n\n                        thisSelection = fillSelectionItem(traceSelection, searchInfo);\n\n                        if(selection.length) {\n                            for(var j = 0; j < thisSelection.length; j++) {\n                                selection.push(thisSelection[j]);\n                            }\n                        } else selection = thisSelection;\n                    }\n\n                    eventData = {points: selection};\n                    updateSelectedState(gd, searchTraces, eventData);\n                    fillRangeItems(eventData, currentPolygon, filterPoly);\n                    dragOptions.gd.emit('plotly_selecting', eventData);\n                }\n            );\n        }\n    };\n\n    dragOptions.clickFn = function(numClicks, evt) {\n        corners.remove();\n\n        if(gd._fullLayout._activeShapeIndex >= 0) {\n            gd._fullLayout._deactivateShape(gd);\n            return;\n        }\n        if(isDrawMode) return;\n\n        var clickmode = fullLayout.clickmode;\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            if(numClicks === 2) {\n                // clear selection on doubleclick\n                outlines.remove();\n                for(i = 0; i < searchTraces.length; i++) {\n                    searchInfo = searchTraces[i];\n                    searchInfo._module.selectPoints(searchInfo, false);\n                }\n\n                updateSelectedState(gd, searchTraces);\n\n                clearSelectionsCache(dragOptions);\n\n                gd.emit('plotly_deselect', null);\n            } else {\n                if(clickmode.indexOf('select') > -1) {\n                    selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes,\n                      dragOptions.subplot, dragOptions, outlines);\n                }\n\n                if(clickmode === 'event') {\n                    // TODO: remove in v3 - this was probably never intended to work as it does,\n                    // but in case anyone depends on it we don't want to break it now.\n                    // Note that click-to-select introduced pre v3 also emitts proper\n                    // event data when clickmode is having 'select' in its flag list.\n                    gd.emit('plotly_selected', undefined);\n                }\n            }\n\n            Fx.click(gd, evt);\n        }).catch(Lib.error);\n    };\n\n    dragOptions.doneFn = function() {\n        corners.remove();\n\n        throttle.done(throttleID).then(function() {\n            throttle.clear(throttleID);\n            dragOptions.gd.emit('plotly_selected', eventData);\n\n            if(currentPolygon && dragOptions.selectionDefs) {\n                // save last polygons\n                currentPolygon.subtract = subtract;\n                dragOptions.selectionDefs.push(currentPolygon);\n\n                // we have to keep reference to arrays container\n                dragOptions.mergedPolygons.length = 0;\n                [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n            }\n\n            if(dragOptions.doneFnCompleted) {\n                dragOptions.doneFnCompleted(selection);\n            }\n        }).catch(Lib.error);\n\n        if(isDrawMode) {\n            clearSelectionsCache(dragOptions);\n        }\n    };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n    var hoverData = gd._hoverdata;\n    var fullLayout = gd._fullLayout;\n    var clickmode = fullLayout.clickmode;\n    var sendEvents = clickmode.indexOf('event') > -1;\n    var selection = [];\n    var searchTraces, searchInfo, currentSelectionDef, selectionTester, traceSelection;\n    var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n    if(isHoverDataSet(hoverData)) {\n        coerceSelectionsCache(evt, gd, dragOptions);\n        searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n        var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n        var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;\n\n\n        // Note: potentially costly operation isPointOrBinSelected is\n        // called as late as possible through the use of an assignment\n        // in an if condition.\n        if(isBinnedTrace ?\n            isOnlyThisBinSelected(searchTraces, clickedPtInfo) :\n            isOnlyOnePointSelected(searchTraces) &&\n                (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n            if(polygonOutlines) polygonOutlines.remove();\n            for(i = 0; i < searchTraces.length; i++) {\n                searchInfo = searchTraces[i];\n                searchInfo._module.selectPoints(searchInfo, false);\n            }\n\n            updateSelectedState(gd, searchTraces);\n\n            clearSelectionsCache(dragOptions);\n\n            if(sendEvents) {\n                gd.emit('plotly_deselect', null);\n            }\n        } else {\n            subtract = evt.shiftKey &&\n              (pointOrBinSelected !== undefined ?\n                pointOrBinSelected :\n                isPointOrBinSelected(clickedPtInfo));\n            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n\n            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n            selectionTester = multiTester(allSelectionDefs);\n\n            for(i = 0; i < searchTraces.length; i++) {\n                traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTester);\n                thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n                if(selection.length) {\n                    for(var j = 0; j < thisTracesSelection.length; j++) {\n                        selection.push(thisTracesSelection[j]);\n                    }\n                } else selection = thisTracesSelection;\n            }\n\n            eventData = {points: selection};\n            updateSelectedState(gd, searchTraces, eventData);\n\n            if(currentSelectionDef && dragOptions) {\n                dragOptions.selectionDefs.push(currentSelectionDef);\n            }\n\n            if(polygonOutlines) {\n                var polygons = dragOptions.mergedPolygons;\n                var isOpenMode = openMode(dragOptions.dragmode);\n\n                // display polygons on the screen\n                displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n            }\n\n            if(sendEvents) {\n                gd.emit('plotly_selected', eventData);\n            }\n        }\n    }\n}\n\n/**\n * Constructs a new point selection definition object.\n */\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n    return {\n        pointNumber: pointNumber,\n        searchInfo: searchInfo,\n        subtract: subtract\n    };\n}\n\nfunction isPointSelectionDef(o) {\n    return 'pointNumber' in o && 'searchInfo' in o;\n}\n\n/*\n * Constructs a new point number tester.\n */\nfunction newPointNumTester(pointSelectionDef) {\n    return {\n        xmin: 0,\n        xmax: 0,\n        ymin: 0,\n        ymax: 0,\n        pts: [],\n        contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {\n            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n            var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n            return idxActualTrace === idxWantedTrace &&\n              pointNumber === pointSelectionDef.pointNumber;\n        },\n        isRect: false,\n        degenerate: false,\n        subtract: pointSelectionDef.subtract\n    };\n}\n\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\nfunction multiTester(list) {\n    var testers = [];\n    var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n    var xmax = xmin;\n    var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n    var ymax = ymin;\n\n    for(var i = 0; i < list.length; i++) {\n        if(isPointSelectionDef(list[i])) {\n            testers.push(newPointNumTester(list[i]));\n        } else {\n            var tester = polygon.tester(list[i]);\n            tester.subtract = list[i].subtract;\n            testers.push(tester);\n            xmin = Math.min(xmin, tester.xmin);\n            xmax = Math.max(xmax, tester.xmax);\n            ymin = Math.min(ymin, tester.ymin);\n            ymax = Math.max(ymax, tester.ymax);\n        }\n    }\n\n    /**\n     * Tests if the given point is within this tester.\n     *\n     * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n     * @param {*} arg - An optional parameter to pass down to wrapped testers.\n     * @param {number} pointNumber - The point number of the point within the underlying data array.\n     * @param {number} searchInfo - An object identifying the trace the point is contained in.\n     *\n     * @return {boolean} true if point is considered to be selected, false otherwise.\n     */\n    function contains(pt, arg, pointNumber, searchInfo) {\n        var contained = false;\n        for(var i = 0; i < testers.length; i++) {\n            if(testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n                // if contained by subtract tester - exclude the point\n                contained = testers[i].subtract === false;\n            }\n        }\n\n        return contained;\n    }\n\n    return {\n        xmin: xmin,\n        xmax: xmax,\n        ymin: ymin,\n        ymax: ymax,\n        pts: [],\n        contains: contains,\n        isRect: false,\n        degenerate: false\n    };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n    gd._fullLayout._drawing = false;\n\n    var fullLayout = gd._fullLayout;\n    var plotinfo = dragOptions.plotinfo;\n    var dragmode = dragOptions.dragmode;\n\n    var selectingOnSameSubplot = (\n        fullLayout._lastSelectedSubplot &&\n        fullLayout._lastSelectedSubplot === plotinfo.id\n    );\n\n    var hasModifierKey = (evt.shiftKey || evt.altKey) &&\n        !(drawMode(dragmode) && openMode(dragmode));\n\n    if(selectingOnSameSubplot && hasModifierKey &&\n      (plotinfo.selection && plotinfo.selection.selectionDefs) && !dragOptions.selectionDefs) {\n        // take over selection definitions from prev mode, if any\n        dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n        dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n    } else if(!hasModifierKey || !plotinfo.selection) {\n        clearSelectionsCache(dragOptions);\n    }\n\n    // clear selection outline when selecting a different subplot\n    if(!selectingOnSameSubplot) {\n        clearSelect(gd);\n        fullLayout._lastSelectedSubplot = plotinfo.id;\n    }\n}\n\nfunction clearSelectionsCache(dragOptions) {\n    var dragmode = dragOptions.dragmode;\n    var plotinfo = dragOptions.plotinfo;\n\n    var gd = dragOptions.gd;\n    if(gd._fullLayout._activeShapeIndex >= 0) {\n        gd._fullLayout._deactivateShape(gd);\n    }\n\n    if(drawMode(dragmode)) {\n        var fullLayout = gd._fullLayout;\n        var zoomLayer = fullLayout._zoomlayer;\n\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n        if(outlines && gd._fullLayout._drawing) {\n            // add shape\n            var shapes = newShapes(outlines, dragOptions);\n            if(shapes) {\n                Registry.call('_guiRelayout', gd, {\n                    shapes: shapes\n                });\n            }\n\n            gd._fullLayout._drawing = false;\n        }\n    }\n\n    plotinfo.selection = {};\n    plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n    plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n    var searchTraces = [];\n    var xAxisIds = xAxes.map(function(ax) { return ax._id; });\n    var yAxisIds = yAxes.map(function(ax) { return ax._id; });\n    var cd, trace, i;\n\n    for(i = 0; i < gd.calcdata.length; i++) {\n        cd = gd.calcdata[i];\n        trace = cd[0].trace;\n\n        if(trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n        if(subplot && (trace.subplot === subplot || trace.geo === subplot)) {\n            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n        } else if(\n          trace.type === 'splom' &&\n          // FIXME: make sure we don't have more than single axis for splom\n          trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]\n        ) {\n            var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n            info.scene = gd._fullLayout._splomScenes[trace.uid];\n            searchTraces.push(info);\n        } else if(\n          trace.type === 'sankey'\n        ) {\n            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n            searchTraces.push(sankeyInfo);\n        } else {\n            if(xAxisIds.indexOf(trace.xaxis) === -1) continue;\n            if(yAxisIds.indexOf(trace.yaxis) === -1) continue;\n\n            searchTraces.push(createSearchInfo(trace._module, cd,\n              getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n        }\n    }\n\n    return searchTraces;\n\n    function createSearchInfo(module, calcData, xaxis, yaxis) {\n        return {\n            _module: module,\n            cd: calcData,\n            xaxis: xaxis,\n            yaxis: yaxis\n        };\n    }\n}\n\nfunction isHoverDataSet(hoverData) {\n    return hoverData &&\n      Array.isArray(hoverData) &&\n      hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n    var hoverDatum = hoverData[0];\n    var pointNumber = -1;\n    var pointNumbers = [];\n    var searchInfo, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n            // Special case for box (and violin)\n            if(hoverDatum.hoverOnBox === true) {\n                break;\n            }\n\n            // Hint: in some traces like histogram, one graphical element\n            // doesn't correspond to one particular data point, but to\n            // bins of data points. Thus, hoverDatum can have a binNumber\n            // property instead of pointNumber.\n            if(hoverDatum.pointNumber !== undefined) {\n                pointNumber = hoverDatum.pointNumber;\n            } else if(hoverDatum.binNumber !== undefined) {\n                pointNumber = hoverDatum.binNumber;\n                pointNumbers = hoverDatum.pointNumbers;\n            }\n\n            break;\n        }\n    }\n\n    return {\n        pointNumber: pointNumber,\n        pointNumbers: pointNumbers,\n        searchInfo: searchInfo\n    };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n    var trace = clickedPtInfo.searchInfo.cd[0].trace;\n    var ptNum = clickedPtInfo.pointNumber;\n    var ptNums = clickedPtInfo.pointNumbers;\n    var ptNumsSet = ptNums.length > 0;\n\n    // When pointsNumbers is set (e.g. histogram's binning),\n    // it is assumed that when the first point of\n    // a bin is selected, all others are as well\n    var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;\n\n    // TODO potential performance improvement\n    // Primarily we need this function to determine if a click adds\n    // or subtracts from a selection.\n    // In cases `trace.selectedpoints` is a huge array, indexOf\n    // might be slow. One remedy would be to introduce a hash somewhere.\n    return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n    var tracesWithSelectedPts = [];\n    var searchInfo, trace, isSameTrace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        if(searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n            tracesWithSelectedPts.push(searchInfo);\n        }\n    }\n\n    if(tracesWithSelectedPts.length === 1) {\n        isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n        if(isSameTrace) {\n            trace = clickedPtInfo.searchInfo.cd[0].trace;\n            if(trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n                for(i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n                    if(trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n    var len = 0;\n    var searchInfo, trace, i;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        trace = searchInfo.cd[0].trace;\n        if(trace.selectedpoints) {\n            if(trace.selectedpoints.length > 1) return false;\n\n            len += trace.selectedpoints.length;\n            if(len > 1) return false;\n        }\n    }\n\n    return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n    var i, searchInfo, cd, trace;\n\n    // before anything else, update preGUI if necessary\n    for(i = 0; i < searchTraces.length; i++) {\n        var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n        var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n        if(tracePreGUI.selectedpoints === undefined) {\n            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n        }\n    }\n\n    if(eventData) {\n        var pts = eventData.points || [];\n\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n            if(trace._fullInput !== trace) trace.selectedpoints = [];\n        }\n\n        for(i = 0; i < pts.length; i++) {\n            var pt = pts[i];\n            var data = pt.data;\n            var fullData = pt.fullData;\n\n            if(pt.pointIndices) {\n                [].push.apply(data.selectedpoints, pt.pointIndices);\n                if(trace._fullInput !== trace) {\n                    [].push.apply(fullData.selectedpoints, pt.pointIndices);\n                }\n            } else {\n                data.selectedpoints.push(pt.pointIndex);\n                if(trace._fullInput !== trace) {\n                    fullData.selectedpoints.push(pt.pointIndex);\n                }\n            }\n        }\n    } else {\n        for(i = 0; i < searchTraces.length; i++) {\n            trace = searchTraces[i].cd[0].trace;\n            delete trace.selectedpoints;\n            delete trace._input.selectedpoints;\n            if(trace._fullInput !== trace) {\n                delete trace._fullInput.selectedpoints;\n            }\n        }\n    }\n\n    var hasRegl = false;\n\n    for(i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n        cd = searchInfo.cd;\n        trace = cd[0].trace;\n\n        if(Registry.traceIs(trace, 'regl')) {\n            hasRegl = true;\n        }\n\n        var _module = searchInfo._module;\n        var fn = _module.styleOnSelect || _module.style;\n        if(fn) {\n            fn(gd, cd, cd[0].node3);\n            if(cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n        }\n    }\n\n    if(hasRegl) {\n        clearGlCanvases(gd);\n        redrawReglTraces(gd);\n    }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n    var res;\n\n    if(subtract) {\n        res = polybool.difference({\n            regions: list,\n            inverted: false\n        }, {\n            regions: [poly],\n            inverted: false\n        });\n\n        return res.regions;\n    }\n\n    res = polybool.union({\n        regions: list,\n        inverted: false\n    }, {\n        regions: [poly],\n        inverted: false\n    });\n\n    return res.regions;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n    if(Array.isArray(selection)) {\n        var cd = searchInfo.cd;\n        var trace = searchInfo.cd[0].trace;\n\n        for(var i = 0; i < selection.length; i++) {\n            selection[i] = makeEventData(selection[i], trace, cd);\n        }\n    }\n\n    return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) { // add M and L command to draft positions\n    var polygonsOut = [];\n    for(var i = 0; i < polygonsIn.length; i++) {\n        polygonsOut[i] = [];\n        for(var j = 0; j < polygonsIn[i].length; j++) {\n            polygonsOut[i][j] = [];\n            polygonsOut[i][j][0] = j ? 'L' : 'M';\n            for(var k = 0; k < polygonsIn[i][j].length; k++) {\n                polygonsOut[i][j].push(\n                    polygonsIn[i][j][k]\n                );\n            }\n        }\n\n        if(!isOpenMode) {\n            polygonsOut[i].push([\n                'Z',\n                polygonsOut[i][0][1], // initial x\n                polygonsOut[i][0][2]  // initial y\n            ]);\n        }\n    }\n\n    return polygonsOut;\n}\n\nmodule.exports = {\n    prepSelect: prepSelect,\n    clearSelect: clearSelect,\n    clearSelectionsCache: clearSelectionsCache,\n    selectOnClick: selectOnClick\n};\n"]},"metadata":{},"sourceType":"script"}