{"ast":null,"code":"'use strict'; // Requirements\n// ============\n\nvar wrap = require('../../lib/gup').wrap;\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nvar filterUnique = require('../../lib/filter_unique.js');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar isNumeric = require('fast-isnumeric');\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\n\n\nmodule.exports = function calc(gd, trace) {\n  var visibleDims = Lib.filterVisible(trace.dimensions);\n  if (visibleDims.length === 0) return [];\n  var uniqueInfoDims = visibleDims.map(function (dim) {\n    var categoryValues;\n\n    if (dim.categoryorder === 'trace') {\n      // Use order of first occurrence in trace\n      categoryValues = null;\n    } else if (dim.categoryorder === 'array') {\n      // Use categories specified in `categoryarray` first,\n      // then add extra to the end in trace order\n      categoryValues = dim.categoryarray;\n    } else {\n      // Get all categories up front\n      categoryValues = filterUnique(dim.values); // order them\n\n      var allNumeric = true;\n\n      for (var i = 0; i < categoryValues.length; i++) {\n        if (!isNumeric(categoryValues[i])) {\n          allNumeric = false;\n          break;\n        }\n      }\n\n      categoryValues.sort(allNumeric ? Lib.sorterAsc : undefined);\n\n      if (dim.categoryorder === 'category descending') {\n        categoryValues = categoryValues.reverse();\n      }\n    }\n\n    return getUniqueInfo(dim.values, categoryValues);\n  });\n  var counts, count, totalCount;\n\n  if (Lib.isArrayOrTypedArray(trace.counts)) {\n    counts = trace.counts;\n  } else {\n    counts = [trace.counts];\n  }\n\n  validateDimensionDisplayInds(visibleDims);\n  visibleDims.forEach(function (dim, dimInd) {\n    validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n  }); // Handle path colors\n  // ------------------\n\n  var line = trace.line;\n  var markerColorscale; // Process colorscale\n\n  if (line) {\n    if (hasColorscale(trace, 'line')) {\n      colorscaleCalc(gd, trace, {\n        vals: trace.line.color,\n        containerStr: 'line',\n        cLetter: 'c'\n      });\n    }\n\n    markerColorscale = Drawing.tryColorscale(line);\n  } else {\n    markerColorscale = Lib.identity;\n  } // Build color generation function\n\n\n  function getMarkerColorInfo(index) {\n    var value, rawColor;\n\n    if (Lib.isArrayOrTypedArray(line.color)) {\n      value = line.color[index % line.color.length];\n      rawColor = value;\n    } else {\n      value = line.color;\n    }\n\n    return {\n      color: markerColorscale(value),\n      rawColor: rawColor\n    };\n  } // Number of values and counts\n  // ---------------------------\n\n\n  var numValues = visibleDims[0].values.length; // Build path info\n  // ---------------\n  // Mapping from category inds to PathModel objects\n\n  var pathModels = {}; // Category inds array for each dimension\n\n  var categoryIndsDims = uniqueInfoDims.map(function (di) {\n    return di.inds;\n  }); // Initialize total count\n\n  totalCount = 0;\n  var valueInd;\n  var d;\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    // Category inds for this input value across dimensions\n    var categoryIndsPath = [];\n\n    for (d = 0; d < categoryIndsDims.length; d++) {\n      categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n    } // Count\n\n\n    count = counts[valueInd % counts.length]; // Update total count\n\n    totalCount += count; // Path color\n\n    var pathColorInfo = getMarkerColorInfo(valueInd); // path key\n\n    var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor; // Create / Update PathModel\n\n    if (pathModels[pathKey] === undefined) {\n      pathModels[pathKey] = createPathModel(categoryIndsPath, pathColorInfo.color, pathColorInfo.rawColor);\n    }\n\n    updatePathModel(pathModels[pathKey], valueInd, count);\n  }\n\n  var dimensionModels = visibleDims.map(function (di, i) {\n    return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n  });\n\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    count = counts[valueInd % counts.length];\n\n    for (d = 0; d < dimensionModels.length; d++) {\n      var containerInd = dimensionModels[d].containerInd;\n      var catInd = uniqueInfoDims[d].inds[valueInd];\n      var cats = dimensionModels[d].categories;\n\n      if (cats[catInd] === undefined) {\n        var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n        var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n        cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n      }\n\n      updateCategoryModel(cats[catInd], valueInd, count);\n    }\n  } // Compute unique\n\n\n  return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n}; // Models\n// ======\n// Parcats Model\n// -------------\n\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\n\n\nfunction createParcatsModel(dimensions, paths, count) {\n  var maxCats = dimensions.map(function (d) {\n    return d.categories.length;\n  }).reduce(function (v1, v2) {\n    return Math.max(v1, v2);\n  });\n  return {\n    dimensions: dimensions,\n    paths: paths,\n    trace: undefined,\n    maxCats: maxCats,\n    count: count\n  };\n} // Dimension Model\n// ---------------\n\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\n\n\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n  return {\n    dimensionInd: dimensionInd,\n    containerInd: containerInd,\n    displayInd: displayInd,\n    dimensionLabel: dimensionLabel,\n    count: count,\n    categories: [],\n    dragX: null\n  };\n} // Category Model\n// --------------\n\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\n\n\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n  return {\n    dimensionInd: dimensionInd,\n    categoryInd: categoryInd,\n    categoryValue: categoryValue,\n    displayInd: categoryInd,\n    categoryLabel: categoryLabel,\n    valueInds: [],\n    count: 0,\n    dragY: null\n  };\n}\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n  categoryModel.valueInds.push(valueInd);\n  categoryModel.count += count;\n} // Path Model\n// ----------\n\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\n\n\nfunction createPathModel(categoryInds, color, rawColor) {\n  return {\n    categoryInds: categoryInds,\n    color: color,\n    rawColor: rawColor,\n    valueInds: [],\n    count: 0\n  };\n}\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\n\n\nfunction updatePathModel(pathModel, valueInd, count) {\n  pathModel.valueInds.push(valueInd);\n  pathModel.count += count;\n} // Unique calculations\n// ===================\n\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\n\n\nfunction getUniqueInfo(values, uniqueValues) {\n  // Initialize uniqueValues if not specified\n  if (uniqueValues === undefined || uniqueValues === null) {\n    uniqueValues = [];\n  } else {\n    // Shallow copy so append below doesn't alter input array\n    uniqueValues = uniqueValues.map(function (e) {\n      return e;\n    });\n  } // Initialize Variables\n\n\n  var uniqueValueCounts = {};\n  var uniqueValueInds = {};\n  var inds = []; // Initialize uniqueValueCounts and\n\n  uniqueValues.forEach(function (uniqueVal, valInd) {\n    uniqueValueCounts[uniqueVal] = 0;\n    uniqueValueInds[uniqueVal] = valInd;\n  }); // Compute the necessary unique info in a single pass\n\n  for (var i = 0; i < values.length; i++) {\n    var item = values[i];\n    var itemInd;\n\n    if (uniqueValueCounts[item] === undefined) {\n      // This item has a previously unseen value\n      uniqueValueCounts[item] = 1;\n      itemInd = uniqueValues.push(item) - 1;\n      uniqueValueInds[item] = itemInd;\n    } else {\n      // Increment count for this item\n      uniqueValueCounts[item]++;\n      itemInd = uniqueValueInds[item];\n    }\n\n    inds.push(itemInd);\n  } // Build UniqueInfo\n\n\n  var uniqueCounts = uniqueValues.map(function (v) {\n    return uniqueValueCounts[v];\n  });\n  return {\n    uniqueValues: uniqueValues,\n    uniqueCounts: uniqueCounts,\n    inds: inds\n  };\n}\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\n\n\nfunction validateDimensionDisplayInds(visibleDims) {\n  var displayInds = visibleDims.map(function (d) {\n    return d.displayindex;\n  });\n  var i;\n\n  if (isRangePermutation(displayInds)) {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = visibleDims[i].displayindex;\n    }\n  } else {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = i;\n    }\n  }\n}\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\n\n\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n  // Update categoryarray\n  dim._categoryarray = uniqueInfoDim.uniqueValues; // Handle ticktext\n\n  if (dim.ticktext === null || dim.ticktext === undefined) {\n    dim._ticktext = [];\n  } else {\n    // Shallow copy to avoid modifying input array\n    dim._ticktext = dim.ticktext.slice();\n  } // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n\n\n  for (var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n    dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n  }\n}\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\n\n\nfunction isRangePermutation(inds) {\n  var indsSpecified = new Array(inds.length);\n\n  for (var i = 0; i < inds.length; i++) {\n    // Check for out of bounds\n    if (inds[i] < 0 || inds[i] >= inds.length) {\n      return false;\n    } // Check for collisions with already specified index\n\n\n    if (indsSpecified[inds[i]] !== undefined) {\n      return false;\n    }\n\n    indsSpecified[inds[i]] = true;\n  } // Nothing out of bounds and no collisions. We have a permutation\n\n\n  return true;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/parcats/calc.js"],"names":["wrap","require","hasColorscale","colorscaleCalc","filterUnique","Drawing","Lib","isNumeric","module","exports","calc","gd","trace","visibleDims","filterVisible","dimensions","length","uniqueInfoDims","map","dim","categoryValues","categoryorder","categoryarray","values","allNumeric","i","sort","sorterAsc","undefined","reverse","getUniqueInfo","counts","count","totalCount","isArrayOrTypedArray","validateDimensionDisplayInds","forEach","dimInd","validateCategoryProperties","line","markerColorscale","vals","color","containerStr","cLetter","tryColorscale","identity","getMarkerColorInfo","index","value","rawColor","numValues","pathModels","categoryIndsDims","di","inds","valueInd","d","categoryIndsPath","push","pathColorInfo","pathKey","createPathModel","updatePathModel","dimensionModels","createDimensionModel","_index","_displayindex","label","containerInd","catInd","cats","categories","catValue","_categoryarray","catLabel","_ticktext","createCategoryModel","updateCategoryModel","createParcatsModel","paths","maxCats","reduce","v1","v2","Math","max","dimensionInd","displayInd","dimensionLabel","dragX","categoryInd","categoryValue","categoryLabel","valueInds","dragY","categoryModel","categoryInds","pathModel","uniqueValues","e","uniqueValueCounts","uniqueValueInds","uniqueVal","valInd","item","itemInd","uniqueCounts","v","displayInds","displayindex","isRangePermutation","uniqueInfoDim","ticktext","slice","indsSpecified","Array"],"mappings":"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","sourcesContent":["'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\nvar isNumeric = require('fast-isnumeric');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n    var visibleDims = Lib.filterVisible(trace.dimensions);\n\n    if(visibleDims.length === 0) return [];\n\n    var uniqueInfoDims = visibleDims.map(function(dim) {\n        var categoryValues;\n        if(dim.categoryorder === 'trace') {\n            // Use order of first occurrence in trace\n            categoryValues = null;\n        } else if(dim.categoryorder === 'array') {\n            // Use categories specified in `categoryarray` first,\n            // then add extra to the end in trace order\n            categoryValues = dim.categoryarray;\n        } else {\n            // Get all categories up front\n            categoryValues = filterUnique(dim.values);\n\n            // order them\n            var allNumeric = true;\n            for(var i = 0; i < categoryValues.length; i++) {\n                if(!isNumeric(categoryValues[i])) {\n                    allNumeric = false;\n                    break;\n                }\n            }\n            categoryValues.sort(allNumeric ? Lib.sorterAsc : undefined);\n\n            if(dim.categoryorder === 'category descending') {\n                categoryValues = categoryValues.reverse();\n            }\n        }\n        return getUniqueInfo(dim.values, categoryValues);\n    });\n\n    var counts,\n        count,\n        totalCount;\n    if(Lib.isArrayOrTypedArray(trace.counts)) {\n        counts = trace.counts;\n    } else {\n        counts = [trace.counts];\n    }\n\n    validateDimensionDisplayInds(visibleDims);\n\n    visibleDims.forEach(function(dim, dimInd) {\n        validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n    });\n\n    // Handle path colors\n    // ------------------\n    var line = trace.line;\n    var markerColorscale;\n\n    // Process colorscale\n    if(line) {\n        if(hasColorscale(trace, 'line')) {\n            colorscaleCalc(gd, trace, {\n                vals: trace.line.color,\n                containerStr: 'line',\n                cLetter: 'c'\n            });\n        }\n        markerColorscale = Drawing.tryColorscale(line);\n    } else {\n        markerColorscale = Lib.identity;\n    }\n\n    // Build color generation function\n    function getMarkerColorInfo(index) {\n        var value, rawColor;\n        if(Lib.isArrayOrTypedArray(line.color)) {\n            value = line.color[index % line.color.length];\n            rawColor = value;\n        } else {\n            value = line.color;\n        }\n\n        return {color: markerColorscale(value), rawColor: rawColor};\n    }\n\n    // Number of values and counts\n    // ---------------------------\n    var numValues = visibleDims[0].values.length;\n\n    // Build path info\n    // ---------------\n    // Mapping from category inds to PathModel objects\n    var pathModels = {};\n\n    // Category inds array for each dimension\n    var categoryIndsDims = uniqueInfoDims.map(function(di) {return di.inds;});\n\n    // Initialize total count\n    totalCount = 0;\n    var valueInd;\n    var d;\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        // Category inds for this input value across dimensions\n        var categoryIndsPath = [];\n        for(d = 0; d < categoryIndsDims.length; d++) {\n            categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n        }\n\n        // Count\n        count = counts[valueInd % counts.length];\n\n        // Update total count\n        totalCount += count;\n\n        // Path color\n        var pathColorInfo = getMarkerColorInfo(valueInd);\n\n        // path key\n        var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n        // Create / Update PathModel\n        if(pathModels[pathKey] === undefined) {\n            pathModels[pathKey] = createPathModel(categoryIndsPath,\n                pathColorInfo.color,\n                pathColorInfo.rawColor);\n        }\n        updatePathModel(pathModels[pathKey], valueInd, count);\n    }\n\n    var dimensionModels = visibleDims.map(function(di, i) {\n        return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n    });\n\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n        count = counts[valueInd % counts.length];\n\n        for(d = 0; d < dimensionModels.length; d++) {\n            var containerInd = dimensionModels[d].containerInd;\n            var catInd = uniqueInfoDims[d].inds[valueInd];\n            var cats = dimensionModels[d].categories;\n\n            if(cats[catInd] === undefined) {\n                var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n                var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n                cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n            }\n\n            updateCategoryModel(cats[catInd], valueInd, count);\n        }\n    }\n\n    // Compute unique\n    return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n    var maxCats = dimensions\n        .map(function(d) {return d.categories.length;})\n        .reduce(function(v1, v2) {return Math.max(v1, v2);});\n    return {dimensions: dimensions, paths: paths, trace: undefined, maxCats: maxCats, count: count};\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n    return {\n        dimensionInd: dimensionInd,\n        containerInd: containerInd,\n        displayInd: displayInd,\n        dimensionLabel: dimensionLabel,\n        count: count,\n        categories: [],\n        dragX: null\n    };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n    return {\n        dimensionInd: dimensionInd,\n        categoryInd: categoryInd,\n        categoryValue: categoryValue,\n        displayInd: categoryInd,\n        categoryLabel: categoryLabel,\n        valueInds: [],\n        count: 0,\n        dragY: null\n    };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n    categoryModel.valueInds.push(valueInd);\n    categoryModel.count += count;\n}\n\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n    return {\n        categoryInds: categoryInds,\n        color: color,\n        rawColor: rawColor,\n        valueInds: [],\n        count: 0\n    };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n    pathModel.valueInds.push(valueInd);\n    pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n    // Initialize uniqueValues if not specified\n    if(uniqueValues === undefined || uniqueValues === null) {\n        uniqueValues = [];\n    } else {\n        // Shallow copy so append below doesn't alter input array\n        uniqueValues = uniqueValues.map(function(e) {return e;});\n    }\n\n    // Initialize Variables\n    var uniqueValueCounts = {};\n    var uniqueValueInds = {};\n    var inds = [];\n\n    // Initialize uniqueValueCounts and\n    uniqueValues.forEach(function(uniqueVal, valInd) {\n        uniqueValueCounts[uniqueVal] = 0;\n        uniqueValueInds[uniqueVal] = valInd;\n    });\n\n    // Compute the necessary unique info in a single pass\n    for(var i = 0; i < values.length; i++) {\n        var item = values[i];\n        var itemInd;\n\n        if(uniqueValueCounts[item] === undefined) {\n            // This item has a previously unseen value\n            uniqueValueCounts[item] = 1;\n            itemInd = uniqueValues.push(item) - 1;\n            uniqueValueInds[item] = itemInd;\n        } else {\n            // Increment count for this item\n            uniqueValueCounts[item]++;\n            itemInd = uniqueValueInds[item];\n        }\n        inds.push(itemInd);\n    }\n\n    // Build UniqueInfo\n    var uniqueCounts = uniqueValues.map(function(v) { return uniqueValueCounts[v]; });\n\n    return {\n        uniqueValues: uniqueValues,\n        uniqueCounts: uniqueCounts,\n        inds: inds\n    };\n}\n\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n    var displayInds = visibleDims.map(function(d) { return d.displayindex; });\n    var i;\n\n    if(isRangePermutation(displayInds)) {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = visibleDims[i].displayindex;\n        }\n    } else {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = i;\n        }\n    }\n}\n\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n    // Update categoryarray\n    dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n    // Handle ticktext\n    if(dim.ticktext === null || dim.ticktext === undefined) {\n        dim._ticktext = [];\n    } else {\n        // Shallow copy to avoid modifying input array\n        dim._ticktext = dim.ticktext.slice();\n    }\n\n    // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n    for(var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n        dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n    }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n    var indsSpecified = new Array(inds.length);\n\n    for(var i = 0; i < inds.length; i++) {\n        // Check for out of bounds\n        if(inds[i] < 0 || inds[i] >= inds.length) {\n            return false;\n        }\n\n        // Check for collisions with already specified index\n        if(indsSpecified[inds[i]] !== undefined) {\n            return false;\n        }\n\n        indsSpecified[inds[i]] = true;\n    }\n\n    // Nothing out of bounds and no collisions. We have a permutation\n    return true;\n}\n"]},"metadata":{},"sourceType":"script"}