{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nmodule.exports = function sceneUpdate(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var uid = trace.uid; // must place ref to 'scene' in fullLayout, so that:\n  // - it can be relinked properly on updates\n  // - it can be destroyed properly when needed\n\n  var splomScenes = fullLayout._splomScenes;\n  if (!splomScenes) splomScenes = fullLayout._splomScenes = {};\n  var reset = {\n    dirty: true,\n    selectBatch: [],\n    unselectBatch: []\n  };\n  var first = {\n    matrix: false,\n    selectBatch: [],\n    unselectBatch: []\n  };\n  var scene = splomScenes[trace.uid];\n\n  if (!scene) {\n    scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);\n\n    scene.draw = function draw() {\n      if (scene.matrix && scene.matrix.draw) {\n        if (scene.selectBatch.length || scene.unselectBatch.length) {\n          scene.matrix.draw(scene.unselectBatch, scene.selectBatch);\n        } else {\n          scene.matrix.draw();\n        }\n      }\n\n      scene.dirty = false;\n    }; // remove scene resources\n\n\n    scene.destroy = function destroy() {\n      if (scene.matrix && scene.matrix.destroy) {\n        scene.matrix.destroy();\n      }\n\n      scene.matrixOptions = null;\n      scene.selectBatch = null;\n      scene.unselectBatch = null;\n      scene = null;\n    };\n  } // In case if we have scene from the last calc - reset data\n\n\n  if (!scene.dirty) {\n    Lib.extendFlat(scene, reset);\n  }\n\n  return scene;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/traces/splom/scene_update.js"],"names":["Lib","require","module","exports","sceneUpdate","gd","trace","fullLayout","_fullLayout","uid","splomScenes","_splomScenes","reset","dirty","selectBatch","unselectBatch","first","matrix","scene","extendFlat","draw","length","destroy","matrixOptions"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,WAAT,CAAqBC,EAArB,EAAyBC,KAAzB,EAAgC;AAC7C,MAAIC,UAAU,GAAGF,EAAE,CAACG,WAApB;AACA,MAAIC,GAAG,GAAGH,KAAK,CAACG,GAAhB,CAF6C,CAI7C;AACA;AACA;;AACA,MAAIC,WAAW,GAAGH,UAAU,CAACI,YAA7B;AACA,MAAG,CAACD,WAAJ,EAAiBA,WAAW,GAAGH,UAAU,CAACI,YAAX,GAA0B,EAAxC;AAEjB,MAAIC,KAAK,GAAG;AACRC,IAAAA,KAAK,EAAE,IADC;AAERC,IAAAA,WAAW,EAAE,EAFL;AAGRC,IAAAA,aAAa,EAAE;AAHP,GAAZ;AAMA,MAAIC,KAAK,GAAG;AACRC,IAAAA,MAAM,EAAE,KADA;AAERH,IAAAA,WAAW,EAAE,EAFL;AAGRC,IAAAA,aAAa,EAAE;AAHP,GAAZ;AAMA,MAAIG,KAAK,GAAGR,WAAW,CAACJ,KAAK,CAACG,GAAP,CAAvB;;AAEA,MAAG,CAACS,KAAJ,EAAW;AACPA,IAAAA,KAAK,GAAGR,WAAW,CAACD,GAAD,CAAX,GAAmBT,GAAG,CAACmB,UAAJ,CAAe,EAAf,EAAmBP,KAAnB,EAA0BI,KAA1B,CAA3B;;AAEAE,IAAAA,KAAK,CAACE,IAAN,GAAa,SAASA,IAAT,GAAgB;AACzB,UAAGF,KAAK,CAACD,MAAN,IAAgBC,KAAK,CAACD,MAAN,CAAaG,IAAhC,EAAsC;AAClC,YAAGF,KAAK,CAACJ,WAAN,CAAkBO,MAAlB,IAA4BH,KAAK,CAACH,aAAN,CAAoBM,MAAnD,EAA2D;AACvDH,UAAAA,KAAK,CAACD,MAAN,CAAaG,IAAb,CAAkBF,KAAK,CAACH,aAAxB,EAAuCG,KAAK,CAACJ,WAA7C;AACH,SAFD,MAEO;AACHI,UAAAA,KAAK,CAACD,MAAN,CAAaG,IAAb;AACH;AACJ;;AAEDF,MAAAA,KAAK,CAACL,KAAN,GAAc,KAAd;AACH,KAVD,CAHO,CAeP;;;AACAK,IAAAA,KAAK,CAACI,OAAN,GAAgB,SAASA,OAAT,GAAmB;AAC/B,UAAGJ,KAAK,CAACD,MAAN,IAAgBC,KAAK,CAACD,MAAN,CAAaK,OAAhC,EAAyC;AACrCJ,QAAAA,KAAK,CAACD,MAAN,CAAaK,OAAb;AACH;;AACDJ,MAAAA,KAAK,CAACK,aAAN,GAAsB,IAAtB;AACAL,MAAAA,KAAK,CAACJ,WAAN,GAAoB,IAApB;AACAI,MAAAA,KAAK,CAACH,aAAN,GAAsB,IAAtB;AACAG,MAAAA,KAAK,GAAG,IAAR;AACH,KARD;AASH,GAjD4C,CAmD7C;;;AACA,MAAG,CAACA,KAAK,CAACL,KAAV,EAAiB;AACbb,IAAAA,GAAG,CAACmB,UAAJ,CAAeD,KAAf,EAAsBN,KAAtB;AACH;;AAED,SAAOM,KAAP;AACH,CAzDD","sourcesContent":["'use strict';\n\nvar Lib = require('../../lib');\n\nmodule.exports = function sceneUpdate(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var uid = trace.uid;\n\n    // must place ref to 'scene' in fullLayout, so that:\n    // - it can be relinked properly on updates\n    // - it can be destroyed properly when needed\n    var splomScenes = fullLayout._splomScenes;\n    if(!splomScenes) splomScenes = fullLayout._splomScenes = {};\n\n    var reset = {\n        dirty: true,\n        selectBatch: [],\n        unselectBatch: []\n    };\n\n    var first = {\n        matrix: false,\n        selectBatch: [],\n        unselectBatch: []\n    };\n\n    var scene = splomScenes[trace.uid];\n\n    if(!scene) {\n        scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);\n\n        scene.draw = function draw() {\n            if(scene.matrix && scene.matrix.draw) {\n                if(scene.selectBatch.length || scene.unselectBatch.length) {\n                    scene.matrix.draw(scene.unselectBatch, scene.selectBatch);\n                } else {\n                    scene.matrix.draw();\n                }\n            }\n\n            scene.dirty = false;\n        };\n\n        // remove scene resources\n        scene.destroy = function destroy() {\n            if(scene.matrix && scene.matrix.destroy) {\n                scene.matrix.destroy();\n            }\n            scene.matrixOptions = null;\n            scene.selectBatch = null;\n            scene.unselectBatch = null;\n            scene = null;\n        };\n    }\n\n    // In case if we have scene from the last calc - reset data\n    if(!scene.dirty) {\n        Lib.extendFlat(scene, reset);\n    }\n\n    return scene;\n};\n"]},"metadata":{},"sourceType":"script"}