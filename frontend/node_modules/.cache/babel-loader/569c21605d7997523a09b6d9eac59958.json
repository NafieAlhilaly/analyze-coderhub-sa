{"ast":null,"code":"'use strict';\n\nmodule.exports = Sieve;\n\nvar distinctVals = require('../../lib').distinctVals;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */\n\n\nfunction Sieve(traces, opts) {\n  this.traces = traces;\n  this.sepNegVal = opts.sepNegVal;\n  this.overlapNoMerge = opts.overlapNoMerge; // for single-bin histograms - see histogram/calc\n\n  var width1 = Infinity;\n  var positions = [];\n\n  for (var i = 0; i < traces.length; i++) {\n    var trace = traces[i];\n\n    for (var j = 0; j < trace.length; j++) {\n      var bar = trace[j];\n      if (bar.p !== BADNUM) positions.push(bar.p);\n    }\n\n    if (trace[0] && trace[0].width1) {\n      width1 = Math.min(trace[0].width1, width1);\n    }\n  }\n\n  this.positions = positions;\n  var dv = distinctVals(positions);\n  this.distinctPositions = dv.vals;\n  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);\n  var type = (opts.posAxis || {}).type;\n\n  if (type === 'category' || type === 'multicategory') {\n    this.minDiff = 1;\n  }\n\n  this.binWidth = this.minDiff;\n  this.bins = {};\n}\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\n\n\nSieve.prototype.put = function put(position, value) {\n  var label = this.getLabel(position, value);\n  var oldValue = this.bins[label] || 0;\n  this.bins[label] = oldValue + value;\n  return oldValue;\n};\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */\n\n\nSieve.prototype.get = function get(position, value) {\n  var label = this.getLabel(position, value);\n  return this.bins[label] || 0;\n};\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */\n\n\nSieve.prototype.getLabel = function getLabel(position, value) {\n  var prefix = value < 0 && this.sepNegVal ? 'v' : '^';\n  var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);\n  return prefix + label;\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/bar/sieve.js"],"names":["module","exports","Sieve","distinctVals","require","BADNUM","traces","opts","sepNegVal","overlapNoMerge","width1","Infinity","positions","i","length","trace","j","bar","p","push","Math","min","dv","distinctPositions","vals","minDiff","type","posAxis","binWidth","bins","prototype","put","position","value","label","getLabel","oldValue","get","prefix","round"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;;AAEA,IAAIC,YAAY,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBD,YAAxC;;AACA,IAAIE,MAAM,GAAGD,OAAO,CAAC,2BAAD,CAAP,CAAqCC,MAAlD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASH,KAAT,CAAeI,MAAf,EAAuBC,IAAvB,EAA6B;AACzB,OAAKD,MAAL,GAAcA,MAAd;AACA,OAAKE,SAAL,GAAiBD,IAAI,CAACC,SAAtB;AACA,OAAKC,cAAL,GAAsBF,IAAI,CAACE,cAA3B,CAHyB,CAKzB;;AACA,MAAIC,MAAM,GAAGC,QAAb;AAEA,MAAIC,SAAS,GAAG,EAAhB;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGP,MAAM,CAACQ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnC,QAAIE,KAAK,GAAGT,MAAM,CAACO,CAAD,CAAlB;;AACA,SAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,KAAK,CAACD,MAAzB,EAAiCE,CAAC,EAAlC,EAAsC;AAClC,UAAIC,GAAG,GAAGF,KAAK,CAACC,CAAD,CAAf;AACA,UAAGC,GAAG,CAACC,CAAJ,KAAUb,MAAb,EAAqBO,SAAS,CAACO,IAAV,CAAeF,GAAG,CAACC,CAAnB;AACxB;;AACD,QAAGH,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,CAASL,MAAxB,EAAgC;AAC5BA,MAAAA,MAAM,GAAGU,IAAI,CAACC,GAAL,CAASN,KAAK,CAAC,CAAD,CAAL,CAASL,MAAlB,EAA0BA,MAA1B,CAAT;AACH;AACJ;;AACD,OAAKE,SAAL,GAAiBA,SAAjB;AAEA,MAAIU,EAAE,GAAGnB,YAAY,CAACS,SAAD,CAArB;AAEA,OAAKW,iBAAL,GAAyBD,EAAE,CAACE,IAA5B;AACA,MAAGF,EAAE,CAACE,IAAH,CAAQV,MAAR,KAAmB,CAAnB,IAAwBJ,MAAM,KAAKC,QAAtC,EAAgD,KAAKc,OAAL,GAAef,MAAf,CAAhD,KACK,KAAKe,OAAL,GAAeL,IAAI,CAACC,GAAL,CAASC,EAAE,CAACG,OAAZ,EAAqBf,MAArB,CAAf;AAEL,MAAIgB,IAAI,GAAG,CAACnB,IAAI,CAACoB,OAAL,IAAgB,EAAjB,EAAqBD,IAAhC;;AACA,MAAGA,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,eAAnC,EAAoD;AAChD,SAAKD,OAAL,GAAe,CAAf;AACH;;AAED,OAAKG,QAAL,GAAgB,KAAKH,OAArB;AAEA,OAAKI,IAAL,GAAY,EAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3B,KAAK,CAAC4B,SAAN,CAAgBC,GAAhB,GAAsB,SAASA,GAAT,CAAaC,QAAb,EAAuBC,KAAvB,EAA8B;AAChD,MAAIC,KAAK,GAAG,KAAKC,QAAL,CAAcH,QAAd,EAAwBC,KAAxB,CAAZ;AACA,MAAIG,QAAQ,GAAG,KAAKP,IAAL,CAAUK,KAAV,KAAoB,CAAnC;AAEA,OAAKL,IAAL,CAAUK,KAAV,IAAmBE,QAAQ,GAAGH,KAA9B;AAEA,SAAOG,QAAP;AACH,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlC,KAAK,CAAC4B,SAAN,CAAgBO,GAAhB,GAAsB,SAASA,GAAT,CAAaL,QAAb,EAAuBC,KAAvB,EAA8B;AAChD,MAAIC,KAAK,GAAG,KAAKC,QAAL,CAAcH,QAAd,EAAwBC,KAAxB,CAAZ;AACA,SAAO,KAAKJ,IAAL,CAAUK,KAAV,KAAoB,CAA3B;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhC,KAAK,CAAC4B,SAAN,CAAgBK,QAAhB,GAA2B,SAASA,QAAT,CAAkBH,QAAlB,EAA4BC,KAA5B,EAAmC;AAC1D,MAAIK,MAAM,GAAIL,KAAK,GAAG,CAAR,IAAa,KAAKzB,SAAnB,GAAgC,GAAhC,GAAsC,GAAnD;AACA,MAAI0B,KAAK,GAAI,KAAKzB,cAAN,GACRuB,QADQ,GAERZ,IAAI,CAACmB,KAAL,CAAWP,QAAQ,GAAG,KAAKJ,QAA3B,CAFJ;AAGA,SAAOU,MAAM,GAAGJ,KAAhB;AACH,CAND","sourcesContent":["'use strict';\n\nmodule.exports = Sieve;\n\nvar distinctVals = require('../../lib').distinctVals;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n *\n * @param {Array} traces\n*   Array of calculated traces\n * @param {object} opts\n *  - @param {boolean} [sepNegVal]\n *      If true, then split data at the same position into a bar\n *      for positive values and another for negative values\n *  - @param {boolean} [overlapNoMerge]\n *     If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, opts) {\n    this.traces = traces;\n    this.sepNegVal = opts.sepNegVal;\n    this.overlapNoMerge = opts.overlapNoMerge;\n\n    // for single-bin histograms - see histogram/calc\n    var width1 = Infinity;\n\n    var positions = [];\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n            if(bar.p !== BADNUM) positions.push(bar.p);\n        }\n        if(trace[0] && trace[0].width1) {\n            width1 = Math.min(trace[0].width1, width1);\n        }\n    }\n    this.positions = positions;\n\n    var dv = distinctVals(positions);\n\n    this.distinctPositions = dv.vals;\n    if(dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;\n    else this.minDiff = Math.min(dv.minDiff, width1);\n\n    var type = (opts.posAxis || {}).type;\n    if(type === 'category' || type === 'multicategory') {\n        this.minDiff = 1;\n    }\n\n    this.binWidth = this.minDiff;\n\n    this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n    var label = this.getLabel(position, value);\n    var oldValue = this.bins[label] || 0;\n\n    this.bins[label] = oldValue + value;\n\n    return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function get(position, value) {\n    var label = this.getLabel(position, value);\n    return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.sepNegVal is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n    var prefix = (value < 0 && this.sepNegVal) ? 'v' : '^';\n    var label = (this.overlapNoMerge) ?\n        position :\n        Math.round(position / this.binWidth);\n    return prefix + label;\n};\n"]},"metadata":{},"sourceType":"script"}