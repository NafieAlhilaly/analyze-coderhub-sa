{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nexports.moduleType = 'transform';\nexports.name = 'sort';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    editType: 'calc',\n    description: ['Determines whether this sort transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    editType: 'calc',\n    description: ['Sets the target by which the sort transform is applied.', 'If a string, *target* is assumed to be a reference to a data array', 'in the parent trace object.', 'To sort about nested variables, use *.* to access them.', 'For example, set `target` to *marker.size* to sort', 'about the marker size array.', 'If an array, *target* is then the data array by which', 'the sort transform is applied.'].join(' ')\n  },\n  order: {\n    valType: 'enumerated',\n    values: ['ascending', 'descending'],\n    dflt: 'ascending',\n    editType: 'calc',\n    description: ['Sets the sort transform order.'].join(' ')\n  },\n  editType: 'calc'\n};\n\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n\n  if (enabled) {\n    coerce('target');\n    coerce('order');\n  }\n\n  return transformOut;\n};\n\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var arrayAttrs = trace._arrayAttrs;\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var indices = getIndices(opts, targetArray, d2c, len);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n  var indexToPoints = {};\n  var i, j;\n\n  for (i = 0; i < arrayAttrs.length; i++) {\n    var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n    var arrayOld = np.get();\n    var arrayNew = new Array(len);\n\n    for (j = 0; j < len; j++) {\n      arrayNew[j] = arrayOld[indices[j]];\n    }\n\n    np.set(arrayNew);\n  }\n\n  for (j = 0; j < len; j++) {\n    indexToPoints[j] = originalPointsAccessor(indices[j]);\n  }\n\n  opts._indexToPoints = indexToPoints;\n  trace._length = len;\n};\n\nfunction getIndices(opts, targetArray, d2c, len) {\n  var sortedArray = new Array(len);\n  var indices = new Array(len);\n  var i;\n\n  for (i = 0; i < len; i++) {\n    sortedArray[i] = {\n      v: targetArray[i],\n      i: i\n    };\n  }\n\n  sortedArray.sort(getSortFunc(opts, d2c));\n\n  for (i = 0; i < len; i++) {\n    indices[i] = sortedArray[i].i;\n  }\n\n  return indices;\n}\n\nfunction getSortFunc(opts, d2c) {\n  switch (opts.order) {\n    case 'ascending':\n      return function (a, b) {\n        var ac = d2c(a.v);\n        var bc = d2c(b.v);\n\n        if (ac === BADNUM) {\n          return 1;\n        }\n\n        if (bc === BADNUM) {\n          return -1;\n        }\n\n        return ac - bc;\n      };\n\n    case 'descending':\n      return function (a, b) {\n        var ac = d2c(a.v);\n        var bc = d2c(b.v);\n\n        if (ac === BADNUM) {\n          return 1;\n        }\n\n        if (bc === BADNUM) {\n          return -1;\n        }\n\n        return bc - ac;\n      };\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/plotly.js/src/transforms/sort.js"],"names":["Lib","require","Axes","pointsAccessorFunction","BADNUM","exports","moduleType","name","attributes","enabled","valType","dflt","editType","description","join","target","strict","noBlank","arrayOk","order","values","supplyDefaults","transformIn","transformOut","coerce","attr","calcTransform","gd","trace","opts","targetArray","getTargetArray","len","length","_length","Math","min","arrayAttrs","_arrayAttrs","d2c","getDataToCoordFunc","indices","getIndices","originalPointsAccessor","transforms","indexToPoints","i","j","np","nestedProperty","arrayOld","get","arrayNew","Array","set","_indexToPoints","sortedArray","v","sort","getSortFunc","a","b","ac","bc"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Lib = require('../lib');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nexports.moduleType = 'transform';\n\nexports.name = 'sort';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        editType: 'calc',\n        description: [\n            'Determines whether this sort transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        editType: 'calc',\n        description: [\n            'Sets the target by which the sort transform is applied.',\n\n            'If a string, *target* is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To sort about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.size* to sort',\n            'about the marker size array.',\n\n            'If an array, *target* is then the data array by which',\n            'the sort transform is applied.'\n        ].join(' ')\n    },\n    order: {\n        valType: 'enumerated',\n        values: ['ascending', 'descending'],\n        dflt: 'ascending',\n        editType: 'calc',\n        description: [\n            'Sets the sort transform order.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        coerce('target');\n        coerce('order');\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var arrayAttrs = trace._arrayAttrs;\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var indices = getIndices(opts, targetArray, d2c, len);\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n    var indexToPoints = {};\n    var i, j;\n\n    for(i = 0; i < arrayAttrs.length; i++) {\n        var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n        var arrayOld = np.get();\n        var arrayNew = new Array(len);\n\n        for(j = 0; j < len; j++) {\n            arrayNew[j] = arrayOld[indices[j]];\n        }\n\n        np.set(arrayNew);\n    }\n\n    for(j = 0; j < len; j++) {\n        indexToPoints[j] = originalPointsAccessor(indices[j]);\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = len;\n};\n\nfunction getIndices(opts, targetArray, d2c, len) {\n    var sortedArray = new Array(len);\n    var indices = new Array(len);\n    var i;\n\n    for(i = 0; i < len; i++) {\n        sortedArray[i] = {v: targetArray[i], i: i};\n    }\n\n    sortedArray.sort(getSortFunc(opts, d2c));\n\n    for(i = 0; i < len; i++) {\n        indices[i] = sortedArray[i].i;\n    }\n\n    return indices;\n}\n\nfunction getSortFunc(opts, d2c) {\n    switch(opts.order) {\n        case 'ascending':\n            return function(a, b) {\n                var ac = d2c(a.v);\n                var bc = d2c(b.v);\n                if(ac === BADNUM) {\n                    return 1;\n                }\n                if(bc === BADNUM) {\n                    return -1;\n                }\n                return ac - bc;\n            };\n        case 'descending':\n            return function(a, b) {\n                var ac = d2c(a.v);\n                var bc = d2c(b.v);\n                if(ac === BADNUM) {\n                    return 1;\n                }\n                if(bc === BADNUM) {\n                    return -1;\n                }\n                return bc - ac;\n            };\n    }\n}\n"]},"metadata":{},"sourceType":"script"}