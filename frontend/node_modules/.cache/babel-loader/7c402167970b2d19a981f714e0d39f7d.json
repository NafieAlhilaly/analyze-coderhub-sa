{"ast":null,"code":"'use strict';\n\nconst createScatter = require('regl-scatter2d');\n\nconst pick = require('pick-by-alias');\n\nconst getBounds = require('array-bounds');\n\nconst raf = require('raf');\n\nconst arrRange = require('array-range');\n\nconst rect = require('parse-rect');\n\nconst flatten = require('flatten-vertex-data');\n\nmodule.exports = SPLOM; // @constructor\n\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options); // render passes\n\n  this.traces = []; // passes for scatter, combined across traces\n\n  this.passes = {};\n  this.regl = regl; // main scatter drawing instance\n\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n} // update & draw passes once per frame\n\n\nSPLOM.prototype.render = function (...args) {\n  if (args.length) {\n    this.update(...args);\n  }\n\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw(); // make sure draw is not called more often than once a frame\n\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(() => {\n        this.draw();\n        this.dirty = true;\n        this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(() => {\n      this.dirty = false;\n    });\n  }\n\n  return this;\n}; // update passes\n\n\nSPLOM.prototype.update = function (...args) {\n  if (!args.length) return;\n\n  for (let i = 0; i < args.length; i++) {\n    this.updateItem(i, args[i]);\n  } // remove nulled passes\n\n\n  this.traces = this.traces.filter(Boolean); // FIXME: update passes independently\n\n  let passes = [];\n  let offset = 0;\n\n  for (let i = 0; i < this.traces.length; i++) {\n    let trace = this.traces[i];\n    let tracePasses = this.traces[i].passes;\n\n    for (let j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    } // save offset of passes\n\n\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n\n  this.scatter.update(...passes);\n  return this;\n}; // update trace by index, not supposed to be called directly\n\n\nSPLOM.prototype.updateItem = function (i, options) {\n  let {\n    regl\n  } = this; // remove pass if null\n\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n\n  if (!options) return this;\n  let o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  }); // we provide regl buffer per-trace, since trace data can be changed\n\n  let trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  }); // save styles\n\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower; // put flattened data into buffer\n\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length; // detect bounds per-column\n\n    trace.bounds = [];\n\n    for (let i = 0; i < trace.columns; i++) {\n      trace.bounds[i] = getBounds(o.data[i], 1);\n    }\n  } // add proper range updating markers\n\n\n  let multirange;\n\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n\n  let multipadding = false;\n\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    } // single padding\n    else {\n      trace.padding = getPad(o.padding);\n    }\n  } // create passes\n\n\n  let m = trace.columns;\n  let n = trace.count;\n  let w = trace.viewport.width;\n  let h = trace.viewport.height;\n  let left = trace.viewport.x;\n  let top = trace.viewport.y;\n  let iw = w / m;\n  let ih = h / m;\n  trace.passes = [];\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < m; j++) {\n      if (!trace.diagonal && j === i) continue;\n      if (!trace.upper && i > j) continue;\n      if (!trace.lower && i < j) continue;\n      let key = passId(trace.id, i, j);\n      let pass = this.passes[key] || (this.passes[key] = {});\n\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: i * n,\n              count: n\n            }\n          };\n        }\n\n        pass.bounds = getBox(trace.bounds, i, j);\n      }\n\n      if (o.domain || o.viewport || o.data) {\n        let pad = multipadding ? getBox(trace.padding, i, j) : trace.padding;\n\n        if (trace.domain) {\n          let [lox, loy, hix, hiy] = getBox(trace.domain, i, j);\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        } // consider auto-domain equipartial\n        else {\n          pass.viewport = [left + j * iw + iw * pad[0], top + i * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (i + 1) * ih - ih * pad[3]];\n        }\n      }\n\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds;\n      }\n\n      trace.passes.push(key);\n    }\n  }\n\n  return this;\n}; // draw all or passed passes\n\n\nSPLOM.prototype.draw = function (...args) {\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    let idx = [];\n\n    for (let i = 0; i < args.length; i++) {\n      // draw(0, 2, 5) - draw traces\n      if (typeof args[i] === 'number') {\n        let {\n          passes,\n          passOffset\n        } = this.traces[args[i]];\n        idx.push(...arrRange(passOffset, passOffset + passes.length));\n      } // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n      else if (args[i].length) {\n        let els = args[i];\n        let {\n          passes,\n          passOffset\n        } = this.traces[i];\n        passes = passes.map((passId, i) => {\n          idx[passOffset + i] = els;\n        });\n      }\n    }\n\n    this.scatter.draw(...idx);\n  }\n\n  return this;\n}; // dispose resources\n\n\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(trace => {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n}; // return pass corresponding to trace i- j- square\n\n\nfunction passId(trace, i, j) {\n  let id = trace.id != null ? trace.id : trace;\n  let n = i;\n  let m = j;\n  let key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n} // return bounding box corresponding to a pass\n\n\nfunction getBox(items, i, j) {\n  let ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  let iitem = items[i],\n      jitem = items[j];\n\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n\n  return [jlox, iloy, jhix, ihiy];\n}\n\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    let box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":{"version":3,"sources":["C:/Projects/reactApp/frontend/node_modules/regl-splom/index.js"],"names":["createScatter","require","pick","getBounds","raf","arrRange","rect","flatten","module","exports","SPLOM","regl","options","traces","passes","scatter","canvas","prototype","render","args","length","update","attributes","preserveDrawingBuffer","draw","dirty","planned","i","updateItem","filter","Boolean","offset","trace","tracePasses","j","push","passOffset","o","data","snap","size","color","opacity","borderSize","borderColor","marker","range","viewport","domain","padding","transpose","diagonal","upper","lower","id","buffer","usage","type","Uint8Array","_gl","drawingBufferWidth","drawingBufferHeight","columns","count","bounds","multirange","multipadding","Array","isArray","map","getPad","m","n","w","width","h","height","left","x","top","y","iw","ih","key","passId","pass","positions","stride","getBox","pad","lox","loy","hix","hiy","idx","els","destroy","forEach","items","ilox","iloy","ihix","ihiy","jlox","jloy","jhix","jhiy","iitem","jitem","arg","box"],"mappings":"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","sourcesContent":["'use strict'\n\n\nconst createScatter = require('regl-scatter2d')\nconst pick = require('pick-by-alias')\nconst getBounds = require('array-bounds')\nconst raf = require('raf')\nconst arrRange = require('array-range')\nconst rect = require('parse-rect')\nconst flatten = require('flatten-vertex-data')\n\n\nmodule.exports = SPLOM\n\n\n// @constructor\nfunction SPLOM (regl, options) {\n\tif (!(this instanceof SPLOM)) return new SPLOM(regl, options)\n\n\t// render passes\n\tthis.traces = []\n\n\t// passes for scatter, combined across traces\n\tthis.passes = {}\n\n\tthis.regl = regl\n\n\t// main scatter drawing instance\n\tthis.scatter = createScatter(regl)\n\n\tthis.canvas = this.scatter.canvas\n}\n\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tif (this.regl.attributes.preserveDrawingBuffer) return this.draw()\n\n\t// make sure draw is not called more often than once a frame\n\tif (this.dirty) {\n\t\tif (this.planned == null) {\n\t\t\tthis.planned = raf(() => {\n\t\t\t\tthis.draw()\n\t\t\t\tthis.dirty = true\n\t\t\t\tthis.planned = null\n\t\t\t})\n\t\t}\n\t}\n\telse {\n\t\tthis.draw()\n\t\tthis.dirty = true\n\t\traf(() => {\n\t\t\tthis.dirty = false\n\t\t})\n\t}\n\n\treturn this\n}\n\n\n// update passes\nSPLOM.prototype.update = function (...args) {\n\tif (!args.length) return\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tthis.updateItem(i, args[i])\n\t}\n\n\t// remove nulled passes\n\tthis.traces = this.traces.filter(Boolean)\n\n\t// FIXME: update passes independently\n\tlet passes = []\n\tlet offset = 0\n\tfor (let i = 0; i < this.traces.length; i++) {\n\t\tlet trace = this.traces[i]\n\t\tlet tracePasses = this.traces[i].passes\n\t\tfor (let j = 0; j < tracePasses.length; j++) {\n\t\t\tpasses.push(this.passes[tracePasses[j]])\n\t\t}\n\t\t// save offset of passes\n\t\ttrace.passOffset = offset\n\t\toffset += trace.passes.length\n\t}\n\n\tthis.scatter.update(...passes)\n\n\treturn this\n}\n\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n\tlet { regl } = this\n\n\t// remove pass if null\n\tif (options === null) {\n\t\tthis.traces[i] = null\n\t\treturn this\n\t}\n\n\tif (!options) return this\n\n\tlet o = pick(options, {\n\t\tdata: 'data items columns rows values dimensions samples x',\n\t\tsnap: 'snap cluster',\n\t\tsize: 'sizes size radius',\n\t\tcolor: 'colors color fill fill-color fillColor',\n\t\topacity: 'opacity alpha transparency opaque',\n\t\tborderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n\t\tborderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n\t\tmarker: 'markers marker shape',\n\t\trange: 'range ranges databox dataBox',\n\t\tviewport: 'viewport viewBox viewbox',\n\t\tdomain: 'domain domains area areas',\n\t\tpadding: 'pad padding paddings pads margin margins',\n\t\ttranspose: 'transpose transposed',\n\t\tdiagonal: 'diagonal diag showDiagonal',\n\t\tupper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n\t\tlower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n\t})\n\n\t// we provide regl buffer per-trace, since trace data can be changed\n\tlet trace = (this.traces[i] || (this.traces[i] = {\n\t\tid: i,\n\t\tbuffer: regl.buffer({\n\t\t\tusage: 'dynamic',\n\t\t\ttype: 'float',\n\t\t\tdata: new Uint8Array()\n\t\t}),\n\t\tcolor: 'black',\n\t\tmarker: null,\n\t\tsize: 12,\n\t\tborderColor: 'transparent',\n\t\tborderSize: 1,\n\t\tviewport:  rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n\t\tpadding: [0, 0, 0, 0],\n\t\topacity: 1,\n\t\tdiagonal: true,\n\t\tupper: true,\n\t\tlower: true\n\t}))\n\n\n\t// save styles\n\tif (o.color != null) {\n\t\ttrace.color = o.color\n\t}\n\tif (o.size != null) {\n\t\ttrace.size = o.size\n\t}\n\tif (o.marker != null) {\n\t\ttrace.marker = o.marker\n\t}\n\tif (o.borderColor != null) {\n\t\ttrace.borderColor = o.borderColor\n\t}\n\tif (o.borderSize != null) {\n\t\ttrace.borderSize = o.borderSize\n\t}\n\tif (o.opacity != null) {\n\t\ttrace.opacity = o.opacity\n\t}\n\tif (o.viewport) {\n\t\ttrace.viewport = rect(o.viewport)\n\t}\n\tif (o.diagonal != null) trace.diagonal = o.diagonal\n\tif (o.upper != null) trace.upper = o.upper\n\tif (o.lower != null) trace.lower = o.lower\n\n\t// put flattened data into buffer\n\tif (o.data) {\n\t\ttrace.buffer(flatten(o.data))\n\t\ttrace.columns = o.data.length\n\t\ttrace.count = o.data[0].length\n\n\t\t// detect bounds per-column\n\t\ttrace.bounds = []\n\n\t\tfor (let i = 0; i < trace.columns; i++) {\n\t\t\ttrace.bounds[i] = getBounds(o.data[i], 1)\n\t\t}\n\t}\n\n\t// add proper range updating markers\n\tlet multirange\n\tif (o.range) {\n\t\ttrace.range = o.range\n\t\tmultirange = trace.range && typeof trace.range[0] !== 'number'\n\t}\n\n\tif (o.domain) {\n\t\ttrace.domain = o.domain\n\t}\n\tlet multipadding = false\n\tif (o.padding != null) {\n\t\t// multiple paddings\n\t\tif (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n\t\t\ttrace.padding = o.padding.map(getPad)\n\t\t\tmultipadding = true\n\t\t}\n\t\t// single padding\n\t\telse {\n\t\t\ttrace.padding = getPad(o.padding)\n\t\t}\n\t}\n\n\t// create passes\n\tlet m = trace.columns\n\tlet n = trace.count\n\n\tlet w = trace.viewport.width\n\tlet h = trace.viewport.height\n\tlet left = trace.viewport.x\n\tlet top = trace.viewport.y\n\tlet iw = w / m\n\tlet ih = h / m\n\n\ttrace.passes = []\n\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\tif (!trace.diagonal && j === i) continue\n\t\t\tif (!trace.upper && i > j) continue\n\t\t\tif (!trace.lower && i < j) continue\n\n\t\t\tlet key = passId(trace.id, i, j)\n\n\t\t\tlet pass = this.passes[key] || (this.passes[key] = {})\n\n\t\t\tif (o.data) {\n\t\t\t\tif (o.transpose) {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j, count: n, stride: m},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i, count: n, stride: m}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j * n, count: n},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i * n, count: n}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpass.bounds = getBox(trace.bounds, i, j)\n\t\t\t}\n\n\t\t\tif (o.domain || o.viewport || o.data) {\n\t\t\t\tlet pad = multipadding ? getBox(trace.padding, i, j) : trace.padding\n\t\t\t\tif (trace.domain) {\n\t\t\t\t\tlet [lox, loy, hix, hiy] = getBox(trace.domain, i, j)\n\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + lox * w + pad[0],\n\t\t\t\t\t\ttop + loy * h + pad[1],\n\t\t\t\t\t\tleft + hix * w - pad[2],\n\t\t\t\t\t\ttop + hiy * h - pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t// consider auto-domain equipartial\n\t\t\t\telse {\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + j * iw + iw * pad[0],\n\t\t\t\t\t\ttop + i * ih + ih * pad[1],\n\t\t\t\t\t\tleft + (j + 1) * iw - iw * pad[2],\n\t\t\t\t\t\ttop + (i + 1) * ih - ih * pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.color) pass.color = trace.color\n\t\t\tif (o.size) pass.size = trace.size\n\t\t\tif (o.marker) pass.marker = trace.marker\n\t\t\tif (o.borderSize) pass.borderSize = trace.borderSize\n\t\t\tif (o.borderColor) pass.borderColor = trace.borderColor\n\t\t\tif (o.opacity) pass.opacity = trace.opacity\n\n\t\t\tif (o.range) {\n\t\t\t\tpass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds\n\t\t\t}\n\n\t\t\ttrace.passes.push(key)\n\t\t}\n\t}\n\n\treturn this\n}\n\n\n// draw all or passed passes\nSPLOM.prototype.draw = function (...args) {\n\tif (!args.length) {\n\t\tthis.scatter.draw()\n\t}\n\telse {\n\t\tlet idx = []\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t// draw(0, 2, 5) - draw traces\n\t\t\tif (typeof args[i] === 'number' ) {\n\t\t\t\tlet { passes, passOffset } = this.traces[args[i]]\n\t\t\t\tidx.push(...arrRange(passOffset, passOffset + passes.length))\n\t\t\t}\n\t\t\t// draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n\t\t\telse if (args[i].length) {\n\t\t\t\tlet els = args[i]\n\t\t\t\tlet { passes, passOffset } = this.traces[i]\n\t\t\t\tpasses = passes.map((passId, i) => {\n\t\t\t\t\tidx[passOffset + i] = els\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tthis.scatter.draw(...idx)\n\t}\n\n\treturn this\n}\n\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n\tthis.traces.forEach(trace => {\n\t\tif (trace.buffer && trace.buffer.destroy) trace.buffer.destroy()\n\t})\n\tthis.traces = null\n\tthis.passes = null\n\n\tthis.scatter.destroy()\n\n\treturn this\n}\n\n\n// return pass corresponding to trace i- j- square\nfunction passId (trace, i, j) {\n\tlet id = (trace.id != null ? trace.id : trace)\n\tlet n = i\n\tlet m = j\n\tlet key = id << 16 | (n & 0xff) << 8 | m & 0xff\n\n\treturn key\n}\n\n\n// return bounding box corresponding to a pass\nfunction getBox (items, i, j) {\n\tlet ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy\n\tlet iitem = items[i], jitem = items[j]\n\n\tif (iitem.length > 2) {\n\t\tilox = iitem[0]\n\t\tihix = iitem[2]\n\t\tiloy = iitem[1]\n\t\tihiy = iitem[3]\n\t}\n\telse if (iitem.length) {\n\t\tilox = iloy = iitem[0]\n\t\tihix = ihiy = iitem[1]\n\t}\n\telse {\n\t\tilox = iitem.x\n\t\tiloy = iitem.y\n\t\tihix = iitem.x + iitem.width\n\t\tihiy = iitem.y + iitem.height\n\t}\n\n\tif (jitem.length > 2) {\n\t\tjlox = jitem[0]\n\t\tjhix = jitem[2]\n\t\tjloy = jitem[1]\n\t\tjhiy = jitem[3]\n\t}\n\telse if (jitem.length) {\n\t\tjlox = jloy = jitem[0]\n\t\tjhix = jhiy = jitem[1]\n\t}\n\telse {\n\t\tjlox = jitem.x\n\t\tjloy = jitem.y\n\t\tjhix = jitem.x + jitem.width\n\t\tjhiy = jitem.y + jitem.height\n\t}\n\n\treturn [ jlox, iloy, jhix, ihiy ]\n}\n\n\nfunction getPad (arg) {\n\tif (typeof arg === 'number') return [arg, arg, arg, arg]\n\telse if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]]\n\telse {\n\t\tlet box = rect(arg)\n\t\treturn [box.x, box.y, box.x + box.width, box.y + box.height]\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}