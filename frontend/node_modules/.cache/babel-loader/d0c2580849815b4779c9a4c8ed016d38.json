{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\n\nvar Registry = require('../../registry');\n\nvar Drawing = require('../../components/drawing');\n\nvar axIds = require('./axis_ids');\n\nvar getFromId = axIds.getFromId;\nvar isLinked = axIds.isLinked;\nmodule.exports = {\n  getAutoRange: getAutoRange,\n  makePadFn: makePadFn,\n  doAutoRange: doAutoRange,\n  findExtremes: findExtremes,\n  concatExtremes: concatExtremes\n};\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\n\nfunction getAutoRange(gd, ax) {\n  var i, j;\n  var newRange = [];\n  var fullLayout = gd._fullLayout;\n  var getPadMin = makePadFn(fullLayout, ax, 0);\n  var getPadMax = makePadFn(fullLayout, ax, 1);\n  var extremes = concatExtremes(gd, ax);\n  var minArray = extremes.min;\n  var maxArray = extremes.max;\n\n  if (minArray.length === 0 || maxArray.length === 0) {\n    return Lib.simpleMap(ax.range, ax.r2l);\n  }\n\n  var minmin = minArray[0].val;\n  var maxmax = maxArray[0].val;\n\n  for (i = 1; i < minArray.length; i++) {\n    if (minmin !== maxmax) break;\n    minmin = Math.min(minmin, minArray[i].val);\n  }\n\n  for (i = 1; i < maxArray.length; i++) {\n    if (minmin !== maxmax) break;\n    maxmax = Math.max(maxmax, maxArray[i].val);\n  }\n\n  var axReverse = false;\n\n  if (ax.range) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    axReverse = rng[1] < rng[0];\n  } // one-time setting to easily reverse the axis\n  // when plotting from code\n\n\n  if (ax.autorange === 'reversed') {\n    axReverse = true;\n    ax.autorange = true;\n  }\n\n  var rangeMode = ax.rangemode;\n  var toZero = rangeMode === 'tozero';\n  var nonNegative = rangeMode === 'nonnegative';\n  var axLen = ax._length; // don't allow padding to reduce the data to < 10% of the length\n\n  var minSpan = axLen / 10;\n  var mbest = 0;\n  var minpt, maxpt, minbest, maxbest, dp, dv;\n\n  for (i = 0; i < minArray.length; i++) {\n    minpt = minArray[i];\n\n    for (j = 0; j < maxArray.length; j++) {\n      maxpt = maxArray[j];\n      dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);\n\n      if (dv > 0) {\n        dp = axLen - getPadMin(minpt) - getPadMax(maxpt);\n\n        if (dp > minSpan) {\n          if (dv / dp > mbest) {\n            minbest = minpt;\n            maxbest = maxpt;\n            mbest = dv / dp;\n          }\n        } else if (dv / axLen > mbest) {\n          // in case of padding longer than the axis\n          // at least include the unpadded data values.\n          minbest = {\n            val: minpt.val,\n            nopad: 1\n          };\n          maxbest = {\n            val: maxpt.val,\n            nopad: 1\n          };\n          mbest = dv / axLen;\n        }\n      }\n    }\n  }\n\n  function maximumPad(prev, pt) {\n    return Math.max(prev, getPadMax(pt));\n  }\n\n  if (minmin === maxmax) {\n    var lower = minmin - 1;\n    var upper = minmin + 1;\n\n    if (toZero) {\n      if (minmin === 0) {\n        // The only value we have on this axis is 0, and we want to\n        // autorange so zero is one end.\n        // In principle this could be [0, 1] or [-1, 0] but usually\n        // 'tozero' pins 0 to the low end, so follow that.\n        newRange = [0, 1];\n      } else {\n        var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0); // we're pushing a single value away from the edge due to its\n        // padding, with the other end clamped at zero\n        // 0.5 means don't push it farther than the center.\n\n        var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n        newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n      }\n    } else if (nonNegative) {\n      newRange = [Math.max(0, lower), Math.max(1, upper)];\n    } else {\n      newRange = [lower, upper];\n    }\n  } else {\n    if (toZero) {\n      if (minbest.val >= 0) {\n        minbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n    } else if (nonNegative) {\n      if (minbest.val - mbest * getPadMin(minbest) < 0) {\n        minbest = {\n          val: 0,\n          nopad: 1\n        };\n      }\n\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 1,\n          nopad: 1\n        };\n      }\n    } // in case it changed again...\n\n\n    mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));\n    newRange = [minbest.val - mbest * getPadMin(minbest), maxbest.val + mbest * getPadMax(maxbest)];\n  } // maintain reversal\n\n\n  if (axReverse) newRange.reverse();\n  return Lib.simpleMap(newRange, ax.l2r || Number);\n} // find axis rangebreaks in [v0,v1] and compute its length in value space\n\n\nfunction calcBreaksLength(ax, v0, v1) {\n  var lBreaks = 0;\n\n  if (ax.rangebreaks) {\n    var rangebreaksOut = ax.locateBreaks(v0, v1);\n\n    for (var i = 0; i < rangebreaksOut.length; i++) {\n      var brk = rangebreaksOut[i];\n      lBreaks += brk.max - brk.min;\n    }\n  }\n\n  return lBreaks;\n}\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\n\n\nfunction makePadFn(fullLayout, ax, max) {\n  // 5% padding for points that specify extrapad: true\n  var extrappad = 0.05 * ax._length;\n  var anchorAxis = ax._anchorAxis || {};\n\n  if ((ax.ticklabelposition || '').indexOf('inside') !== -1 || (anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n    var axReverse = ax.autorange === 'reversed';\n\n    if (!axReverse) {\n      var rng = Lib.simpleMap(ax.range, ax.r2l);\n      axReverse = rng[1] < rng[0];\n    }\n\n    if (axReverse) max = !max;\n  }\n\n  var zero = 0;\n\n  if (!isLinked(fullLayout, ax._id)) {\n    zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);\n  }\n\n  extrappad = Math.max(zero, extrappad); // domain-constrained axes: base extrappad on the unconstrained\n  // domain so it's consistent as the domain changes\n\n  if (ax.constrain === 'domain' && ax._inputDomain) {\n    extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);\n  }\n\n  return function getPad(pt) {\n    if (pt.nopad) return 0;\n    return pt.pad + (pt.extrapad ? extrappad : zero);\n  };\n}\n\nvar TEXTPAD = 3;\n\nfunction padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {\n  var pad = 0;\n  var isX = ax._id.charAt(0) === 'x';\n\n  for (var subplot in fullLayout._plots) {\n    var plotinfo = fullLayout._plots[subplot];\n    if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n    var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};\n\n    if ((anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n      // increase padding to make more room for inside tick labels of the counter axis\n      if (!max && (anchorAxis.side === 'left' || anchorAxis.side === 'bottom') || max && (anchorAxis.side === 'top' || anchorAxis.side === 'right')) {\n        if (anchorAxis._vals) {\n          var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + 'tick'] || 0);\n          var cosA = Math.abs(Math.cos(rad));\n          var sinA = Math.abs(Math.sin(rad)); // no stashed bounding boxes - stash bounding boxes\n\n          if (!anchorAxis._vals[0].bb) {\n            var cls = anchorAxis._id + 'tick';\n            var tickLabels = anchorAxis._selections[cls];\n            tickLabels.each(function (d) {\n              var thisLabel = d3.select(this);\n              var mathjaxGroup = thisLabel.select('.text-math-group');\n\n              if (mathjaxGroup.empty()) {\n                d.bb = Drawing.bBox(thisLabel.node());\n              }\n            });\n          } // use bounding boxes\n\n\n          for (var i = 0; i < anchorAxis._vals.length; i++) {\n            var t = anchorAxis._vals[i];\n            var bb = t.bb;\n\n            if (bb) {\n              var w = 2 * TEXTPAD + bb.width;\n              var h = 2 * TEXTPAD + bb.height;\n              pad = Math.max(pad, isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA));\n            }\n          }\n        }\n\n        if (anchorAxis.ticks === 'inside' && anchorAxis.ticklabelposition === 'inside') {\n          pad += anchorAxis.ticklen || 0;\n        }\n      }\n    }\n  }\n\n  return pad;\n}\n\nfunction concatExtremes(gd, ax, noMatch) {\n  var axId = ax._id;\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n  var minArray = [];\n  var maxArray = [];\n  var i, j, d;\n\n  function _concat(cont, indices) {\n    for (i = 0; i < indices.length; i++) {\n      var item = cont[indices[i]];\n      var extremes = (item._extremes || {})[axId];\n\n      if (item.visible === true && extremes) {\n        for (j = 0; j < extremes.min.length; j++) {\n          d = extremes.min[j];\n          collapseMinArray(minArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n\n        for (j = 0; j < extremes.max.length; j++) {\n          d = extremes.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n\n  _concat(fullData, ax._traceIndices);\n\n  _concat(fullLayout.annotations || [], ax._annIndices || []);\n\n  _concat(fullLayout.shapes || [], ax._shapeIndices || []); // Include the extremes from other matched axes with this one\n\n\n  if (ax._matchGroup && !noMatch) {\n    for (var axId2 in ax._matchGroup) {\n      if (axId2 !== ax._id) {\n        var ax2 = getFromId(gd, axId2);\n        var extremes2 = concatExtremes(gd, ax2, true); // convert padding on the second axis to the first with lenRatio\n\n        var lenRatio = ax._length / ax2._length;\n\n        for (j = 0; j < extremes2.min.length; j++) {\n          d = extremes2.min[j];\n          collapseMinArray(minArray, d.val, d.pad * lenRatio, {\n            extrapad: d.extrapad\n          });\n        }\n\n        for (j = 0; j < extremes2.max.length; j++) {\n          d = extremes2.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad * lenRatio, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    min: minArray,\n    max: maxArray\n  };\n}\n\nfunction doAutoRange(gd, ax, presetRange) {\n  ax.setScale();\n\n  if (ax.autorange) {\n    ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);\n    ax._r = ax.range.slice();\n    ax._rl = Lib.simpleMap(ax._r, ax.r2l); // doAutoRange will get called on fullLayout,\n    // but we want to report its results back to layout\n\n    var axIn = ax._input; // before we edit _input, store preGUI values\n\n    var edits = {};\n    edits[ax._attr + '.range'] = ax.range;\n    edits[ax._attr + '.autorange'] = ax.autorange;\n    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n    axIn.range = ax.range.slice();\n    axIn.autorange = ax.autorange;\n  }\n\n  var anchorAx = ax._anchorAxis;\n\n  if (anchorAx && anchorAx.rangeslider) {\n    var axeRangeOpts = anchorAx.rangeslider[ax._name];\n\n    if (axeRangeOpts) {\n      if (axeRangeOpts.rangemode === 'auto') {\n        axeRangeOpts.range = getAutoRange(gd, ax);\n      }\n    }\n\n    anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n  }\n}\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\n\n\nfunction findExtremes(ax, data, opts) {\n  if (!opts) opts = {};\n  if (!ax._m) ax.setScale();\n  var minArray = [];\n  var maxArray = [];\n  var len = data.length;\n  var extrapad = opts.padded || false;\n  var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n  var isLog = ax.type === 'log';\n  var hasArrayOption = false;\n  var vpadLinearized = opts.vpadLinearized || false;\n  var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n  function makePadAccessor(item) {\n    if (Array.isArray(item)) {\n      hasArrayOption = true;\n      return function (i) {\n        return Math.max(Number(item[i] || 0), 0);\n      };\n    } else {\n      var v = Math.max(Number(item || 0), 0);\n      return function () {\n        return v;\n      };\n    }\n  }\n\n  var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n  var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n  var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n  var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n  if (!hasArrayOption) {\n    // with no arrays other than `data` we don't need to consider\n    // every point, only the extreme data points\n    vmin = Infinity;\n    vmax = -Infinity;\n\n    if (isLog) {\n      for (i = 0; i < len; i++) {\n        v = data[i]; // data is not linearized yet so we still have to filter out negative logs\n\n        if (v < vmin && v > 0) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        if (v < vmin && v > -FP_SAFE) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    }\n\n    data = [vmin, vmax];\n    len = 2;\n  }\n\n  var collapseOpts = {\n    tozero: tozero,\n    extrapad: extrapad\n  };\n\n  function addItem(i) {\n    di = data[i];\n    if (!isNumeric(di)) return;\n    ppadiplus = ppadplus(i);\n    ppadiminus = ppadminus(i);\n\n    if (vpadLinearized) {\n      dmin = ax.c2l(di) - vpadminus(i);\n      dmax = ax.c2l(di) + vpadplus(i);\n    } else {\n      vmin = di - vpadminus(i);\n      vmax = di + vpadplus(i); // special case for log axes: if vpad makes this object span\n      // more than an order of mag, clip it to one order. This is so\n      // we don't have non-positive errors or absurdly large lower\n      // range due to rounding errors\n\n      if (isLog && vmin < vmax / 10) vmin = vmax / 10;\n      dmin = ax.c2l(vmin);\n      dmax = ax.c2l(vmax);\n    }\n\n    if (tozero) {\n      dmin = Math.min(0, dmin);\n      dmax = Math.max(0, dmax);\n    }\n\n    if (goodNumber(dmin)) {\n      collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n    }\n\n    if (goodNumber(dmax)) {\n      collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n    }\n  } // For efficiency covering monotonic or near-monotonic data,\n  // check a few points at both ends first and then sweep\n  // through the middle\n\n\n  var iMax = Math.min(6, len);\n\n  for (i = 0; i < iMax; i++) addItem(i);\n\n  for (i = len - 1; i >= iMax; i--) addItem(i);\n\n  return {\n    min: minArray,\n    max: maxArray,\n    opts: opts\n  };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\n\n\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n  var tozero = opts.tozero;\n  var extrapad = opts.extrapad;\n  var includeThis = true;\n\n  for (var j = 0; j < array.length && includeThis; j++) {\n    var v = array[j];\n\n    if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n      includeThis = false;\n      break;\n    } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n      array.splice(j, 1);\n      j--;\n    }\n  }\n\n  if (includeThis) {\n    var clipAtZero = tozero && newVal === 0;\n    array.push({\n      val: newVal,\n      pad: clipAtZero ? 0 : newPad,\n      extrapad: clipAtZero ? false : extrapad\n    });\n  }\n} // In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\n\n\nfunction goodNumber(v) {\n  return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) {\n  return v0 <= v1;\n}\n\nfunction greaterOrEqual(v0, v1) {\n  return v0 >= v1;\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/plots/cartesian/autorange.js"],"names":["d3","require","isNumeric","Lib","FP_SAFE","Registry","Drawing","axIds","getFromId","isLinked","module","exports","getAutoRange","makePadFn","doAutoRange","findExtremes","concatExtremes","gd","ax","i","j","newRange","fullLayout","_fullLayout","getPadMin","getPadMax","extremes","minArray","min","maxArray","max","length","simpleMap","range","r2l","minmin","val","maxmax","Math","axReverse","rng","autorange","rangeMode","rangemode","toZero","nonNegative","axLen","_length","minSpan","mbest","minpt","maxpt","minbest","maxbest","dp","dv","calcBreaksLength","nopad","maximumPad","prev","pt","lower","upper","maxPad","reduce","rangeEnd","reverse","l2r","Number","v0","v1","lBreaks","rangebreaks","rangebreaksOut","locateBreaks","brk","extrappad","anchorAxis","_anchorAxis","ticklabelposition","indexOf","zero","_id","padInsideLabelsOnAnchorAxis","constrain","_inputDomain","domain","getPad","pad","extrapad","TEXTPAD","isX","charAt","subplot","_plots","plotinfo","xaxis","yaxis","side","_vals","rad","deg2rad","_tickAngles","cosA","abs","cos","sinA","sin","bb","cls","tickLabels","_selections","each","d","thisLabel","select","mathjaxGroup","empty","bBox","node","t","w","width","h","height","ticks","ticklen","noMatch","axId","fullData","_fullData","_concat","cont","indices","item","_extremes","visible","collapseMinArray","collapseMaxArray","_traceIndices","annotations","_annIndices","shapes","_shapeIndices","_matchGroup","axId2","ax2","extremes2","lenRatio","presetRange","setScale","slice","_r","_rl","axIn","_input","edits","_attr","call","layout","_preGUI","anchorAx","rangeslider","axeRangeOpts","_name","extendFlat","data","opts","_m","len","padded","tozero","type","isLog","hasArrayOption","vpadLinearized","v","di","dmin","dmax","ppadiplus","ppadiminus","vmin","vmax","makePadAccessor","Array","isArray","ppadplus","ppadminus","ppad","vpadplus","vpad","vpadminus","Infinity","collapseOpts","addItem","c2l","goodNumber","iMax","array","newVal","newPad","collapseArray","lessOrEqual","greaterOrEqual","atLeastAsExtreme","includeThis","splice","clipAtZero","push"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\nvar Drawing = require('../../components/drawing');\n\nvar axIds = require('./axis_ids');\nvar getFromId = axIds.getFromId;\nvar isLinked = axIds.isLinked;\n\nmodule.exports = {\n    getAutoRange: getAutoRange,\n    makePadFn: makePadFn,\n    doAutoRange: doAutoRange,\n    findExtremes: findExtremes,\n    concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n    var i, j;\n    var newRange = [];\n\n    var fullLayout = gd._fullLayout;\n    var getPadMin = makePadFn(fullLayout, ax, 0);\n    var getPadMax = makePadFn(fullLayout, ax, 1);\n    var extremes = concatExtremes(gd, ax);\n    var minArray = extremes.min;\n    var maxArray = extremes.max;\n\n    if(minArray.length === 0 || maxArray.length === 0) {\n        return Lib.simpleMap(ax.range, ax.r2l);\n    }\n\n    var minmin = minArray[0].val;\n    var maxmax = maxArray[0].val;\n\n    for(i = 1; i < minArray.length; i++) {\n        if(minmin !== maxmax) break;\n        minmin = Math.min(minmin, minArray[i].val);\n    }\n    for(i = 1; i < maxArray.length; i++) {\n        if(minmin !== maxmax) break;\n        maxmax = Math.max(maxmax, maxArray[i].val);\n    }\n\n    var axReverse = false;\n\n    if(ax.range) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        axReverse = rng[1] < rng[0];\n    }\n    // one-time setting to easily reverse the axis\n    // when plotting from code\n    if(ax.autorange === 'reversed') {\n        axReverse = true;\n        ax.autorange = true;\n    }\n\n    var rangeMode = ax.rangemode;\n    var toZero = rangeMode === 'tozero';\n    var nonNegative = rangeMode === 'nonnegative';\n    var axLen = ax._length;\n    // don't allow padding to reduce the data to < 10% of the length\n    var minSpan = axLen / 10;\n\n    var mbest = 0;\n    var minpt, maxpt, minbest, maxbest, dp, dv;\n\n    for(i = 0; i < minArray.length; i++) {\n        minpt = minArray[i];\n        for(j = 0; j < maxArray.length; j++) {\n            maxpt = maxArray[j];\n            dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);\n            if(dv > 0) {\n                dp = axLen - getPadMin(minpt) - getPadMax(maxpt);\n                if(dp > minSpan) {\n                    if(dv / dp > mbest) {\n                        minbest = minpt;\n                        maxbest = maxpt;\n                        mbest = dv / dp;\n                    }\n                } else if(dv / axLen > mbest) {\n                    // in case of padding longer than the axis\n                    // at least include the unpadded data values.\n                    minbest = {val: minpt.val, nopad: 1};\n                    maxbest = {val: maxpt.val, nopad: 1};\n                    mbest = dv / axLen;\n                }\n            }\n        }\n    }\n\n    function maximumPad(prev, pt) {\n        return Math.max(prev, getPadMax(pt));\n    }\n\n    if(minmin === maxmax) {\n        var lower = minmin - 1;\n        var upper = minmin + 1;\n        if(toZero) {\n            if(minmin === 0) {\n                // The only value we have on this axis is 0, and we want to\n                // autorange so zero is one end.\n                // In principle this could be [0, 1] or [-1, 0] but usually\n                // 'tozero' pins 0 to the low end, so follow that.\n                newRange = [0, 1];\n            } else {\n                var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);\n                // we're pushing a single value away from the edge due to its\n                // padding, with the other end clamped at zero\n                // 0.5 means don't push it farther than the center.\n                var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n                newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n            }\n        } else if(nonNegative) {\n            newRange = [Math.max(0, lower), Math.max(1, upper)];\n        } else {\n            newRange = [lower, upper];\n        }\n    } else {\n        if(toZero) {\n            if(minbest.val >= 0) {\n                minbest = {val: 0, nopad: 1};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 0, nopad: 1};\n            }\n        } else if(nonNegative) {\n            if(minbest.val - mbest * getPadMin(minbest) < 0) {\n                minbest = {val: 0, nopad: 1};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 1, nopad: 1};\n            }\n        }\n\n        // in case it changed again...\n        mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) /\n            (axLen - getPadMin(minbest) - getPadMax(maxbest));\n\n        newRange = [\n            minbest.val - mbest * getPadMin(minbest),\n            maxbest.val + mbest * getPadMax(maxbest)\n        ];\n    }\n\n    // maintain reversal\n    if(axReverse) newRange.reverse();\n\n    return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n// find axis rangebreaks in [v0,v1] and compute its length in value space\nfunction calcBreaksLength(ax, v0, v1) {\n    var lBreaks = 0;\n    if(ax.rangebreaks) {\n        var rangebreaksOut = ax.locateBreaks(v0, v1);\n        for(var i = 0; i < rangebreaksOut.length; i++) {\n            var brk = rangebreaksOut[i];\n            lBreaks += brk.max - brk.min;\n        }\n    }\n    return lBreaks;\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(fullLayout, ax, max) {\n    // 5% padding for points that specify extrapad: true\n    var extrappad = 0.05 * ax._length;\n\n    var anchorAxis = ax._anchorAxis || {};\n\n    if(\n        (ax.ticklabelposition || '').indexOf('inside') !== -1 ||\n        (anchorAxis.ticklabelposition || '').indexOf('inside') !== -1\n    ) {\n        var axReverse = ax.autorange === 'reversed';\n        if(!axReverse) {\n            var rng = Lib.simpleMap(ax.range, ax.r2l);\n            axReverse = rng[1] < rng[0];\n        }\n        if(axReverse) max = !max;\n    }\n\n    var zero = 0;\n    if(!isLinked(fullLayout, ax._id)) {\n        zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);\n    }\n    extrappad = Math.max(zero, extrappad);\n\n    // domain-constrained axes: base extrappad on the unconstrained\n    // domain so it's consistent as the domain changes\n    if((ax.constrain === 'domain') && ax._inputDomain) {\n        extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) /\n            (ax.domain[1] - ax.domain[0]);\n    }\n\n    return function getPad(pt) {\n        if(pt.nopad) return 0;\n        return pt.pad + (pt.extrapad ? extrappad : zero);\n    };\n}\n\nvar TEXTPAD = 3;\n\nfunction padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {\n    var pad = 0;\n\n    var isX = ax._id.charAt(0) === 'x';\n\n    for(var subplot in fullLayout._plots) {\n        var plotinfo = fullLayout._plots[subplot];\n\n        if(ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n\n        var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};\n\n        if((anchorAxis.ticklabelposition || '').indexOf('inside') !== -1) {\n            // increase padding to make more room for inside tick labels of the counter axis\n            if((\n                !max && (\n                    anchorAxis.side === 'left' ||\n                    anchorAxis.side === 'bottom'\n                )\n            ) || (\n                max && (\n                    anchorAxis.side === 'top' ||\n                    anchorAxis.side === 'right'\n                )\n            )) {\n                if(anchorAxis._vals) {\n                    var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + 'tick'] || 0);\n                    var cosA = Math.abs(Math.cos(rad));\n                    var sinA = Math.abs(Math.sin(rad));\n\n                    // no stashed bounding boxes - stash bounding boxes\n                    if(!anchorAxis._vals[0].bb) {\n                        var cls = anchorAxis._id + 'tick';\n                        var tickLabels = anchorAxis._selections[cls];\n                        tickLabels.each(function(d) {\n                            var thisLabel = d3.select(this);\n                            var mathjaxGroup = thisLabel.select('.text-math-group');\n                            if(mathjaxGroup.empty()) {\n                                d.bb = Drawing.bBox(thisLabel.node());\n                            }\n                        });\n                    }\n\n                    // use bounding boxes\n                    for(var i = 0; i < anchorAxis._vals.length; i++) {\n                        var t = anchorAxis._vals[i];\n                        var bb = t.bb;\n\n                        if(bb) {\n                            var w = 2 * TEXTPAD + bb.width;\n                            var h = 2 * TEXTPAD + bb.height;\n\n                            pad = Math.max(pad, isX ?\n                                Math.max(w * cosA, h * sinA) :\n                                Math.max(h * cosA, w * sinA)\n                            );\n                        }\n                    }\n                }\n\n                if(anchorAxis.ticks === 'inside' && anchorAxis.ticklabelposition === 'inside') {\n                    pad += anchorAxis.ticklen || 0;\n                }\n            }\n        }\n    }\n\n    return pad;\n}\n\nfunction concatExtremes(gd, ax, noMatch) {\n    var axId = ax._id;\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var minArray = [];\n    var maxArray = [];\n    var i, j, d;\n\n    function _concat(cont, indices) {\n        for(i = 0; i < indices.length; i++) {\n            var item = cont[indices[i]];\n            var extremes = (item._extremes || {})[axId];\n            if(item.visible === true && extremes) {\n                for(j = 0; j < extremes.min.length; j++) {\n                    d = extremes.min[j];\n                    collapseMinArray(minArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes.max.length; j++) {\n                    d = extremes.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    _concat(fullData, ax._traceIndices);\n    _concat(fullLayout.annotations || [], ax._annIndices || []);\n    _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n    // Include the extremes from other matched axes with this one\n    if(ax._matchGroup && !noMatch) {\n        for(var axId2 in ax._matchGroup) {\n            if(axId2 !== ax._id) {\n                var ax2 = getFromId(gd, axId2);\n                var extremes2 = concatExtremes(gd, ax2, true);\n                // convert padding on the second axis to the first with lenRatio\n                var lenRatio = ax._length / ax2._length;\n                for(j = 0; j < extremes2.min.length; j++) {\n                    d = extremes2.min[j];\n                    collapseMinArray(minArray, d.val, d.pad * lenRatio, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes2.max.length; j++) {\n                    d = extremes2.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad * lenRatio, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    return {min: minArray, max: maxArray};\n}\n\nfunction doAutoRange(gd, ax, presetRange) {\n    ax.setScale();\n\n    if(ax.autorange) {\n        ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);\n\n        ax._r = ax.range.slice();\n        ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n        // doAutoRange will get called on fullLayout,\n        // but we want to report its results back to layout\n\n        var axIn = ax._input;\n\n        // before we edit _input, store preGUI values\n        var edits = {};\n        edits[ax._attr + '.range'] = ax.range;\n        edits[ax._attr + '.autorange'] = ax.autorange;\n        Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n\n        axIn.range = ax.range.slice();\n        axIn.autorange = ax.autorange;\n    }\n\n    var anchorAx = ax._anchorAxis;\n\n    if(anchorAx && anchorAx.rangeslider) {\n        var axeRangeOpts = anchorAx.rangeslider[ax._name];\n        if(axeRangeOpts) {\n            if(axeRangeOpts.rangemode === 'auto') {\n                axeRangeOpts.range = getAutoRange(gd, ax);\n            }\n        }\n        anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n    }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *      vpadLinearized: (boolean) whether or not vpad (or vpadplus/vpadminus)\n *          is linearized (for log scale axes)\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n    if(!opts) opts = {};\n    if(!ax._m) ax.setScale();\n\n    var minArray = [];\n    var maxArray = [];\n\n    var len = data.length;\n    var extrapad = opts.padded || false;\n    var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n    var isLog = ax.type === 'log';\n    var hasArrayOption = false;\n    var vpadLinearized = opts.vpadLinearized || false;\n    var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n    function makePadAccessor(item) {\n        if(Array.isArray(item)) {\n            hasArrayOption = true;\n            return function(i) { return Math.max(Number(item[i]||0), 0); };\n        } else {\n            var v = Math.max(Number(item||0), 0);\n            return function() { return v; };\n        }\n    }\n\n    var ppadplus = makePadAccessor((ax._m > 0 ?\n        opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n    var ppadminus = makePadAccessor((ax._m > 0 ?\n        opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n    var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n    var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n    if(!hasArrayOption) {\n        // with no arrays other than `data` we don't need to consider\n        // every point, only the extreme data points\n        vmin = Infinity;\n        vmax = -Infinity;\n\n        if(isLog) {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                // data is not linearized yet so we still have to filter out negative logs\n                if(v < vmin && v > 0) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        } else {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                if(v < vmin && v > -FP_SAFE) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        }\n\n        data = [vmin, vmax];\n        len = 2;\n    }\n\n    var collapseOpts = {tozero: tozero, extrapad: extrapad};\n\n    function addItem(i) {\n        di = data[i];\n        if(!isNumeric(di)) return;\n        ppadiplus = ppadplus(i);\n        ppadiminus = ppadminus(i);\n\n        if(vpadLinearized) {\n            dmin = ax.c2l(di) - vpadminus(i);\n            dmax = ax.c2l(di) + vpadplus(i);\n        } else {\n            vmin = di - vpadminus(i);\n            vmax = di + vpadplus(i);\n            // special case for log axes: if vpad makes this object span\n            // more than an order of mag, clip it to one order. This is so\n            // we don't have non-positive errors or absurdly large lower\n            // range due to rounding errors\n            if(isLog && vmin < vmax / 10) vmin = vmax / 10;\n\n            dmin = ax.c2l(vmin);\n            dmax = ax.c2l(vmax);\n        }\n\n        if(tozero) {\n            dmin = Math.min(0, dmin);\n            dmax = Math.max(0, dmax);\n        }\n        if(goodNumber(dmin)) {\n            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n        }\n        if(goodNumber(dmax)) {\n            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n        }\n    }\n\n    // For efficiency covering monotonic or near-monotonic data,\n    // check a few points at both ends first and then sweep\n    // through the middle\n    var iMax = Math.min(6, len);\n    for(i = 0; i < iMax; i++) addItem(i);\n    for(i = len - 1; i >= iMax; i--) addItem(i);\n\n    return {\n        min: minArray,\n        max: maxArray,\n        opts: opts\n    };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n    var tozero = opts.tozero;\n    var extrapad = opts.extrapad;\n    var includeThis = true;\n\n    for(var j = 0; j < array.length && includeThis; j++) {\n        var v = array[j];\n        if(atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n            includeThis = false;\n            break;\n        } else if(atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n            array.splice(j, 1);\n            j--;\n        }\n    }\n    if(includeThis) {\n        var clipAtZero = (tozero && newVal === 0);\n        array.push({\n            val: newVal,\n            pad: clipAtZero ? 0 : newPad,\n            extrapad: clipAtZero ? false : extrapad\n        });\n    }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n    return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) { return v0 <= v1; }\nfunction greaterOrEqual(v0, v1) { return v0 >= v1; }\n"]},"metadata":{},"sourceType":"script"}