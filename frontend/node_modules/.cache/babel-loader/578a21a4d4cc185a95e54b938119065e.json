{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\nvar strRotate = Lib.strRotate;\n\nvar Events = require('../../lib/events');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar overrideCursor = require('../../lib/override_cursor');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar dragElement = require('../dragelement');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar legendSupplyDefaults = require('../legend/defaults');\n\nvar legendDraw = require('../legend/draw'); // hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\n\n\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180; // expansion of projected height\n\nvar YFACTOR = 1 / Math.sin(YA_RADIANS); // to make the appropriate post-rotation x offset,\n// you need both x and y offsets\n\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS); // size and display constants for hover text\n\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\nvar multipleHoverPoints = {\n  box: true,\n  ohlc: true,\n  violin: true,\n  candlestick: true\n};\nvar cartesianScatterPoints = {\n  scatter: true,\n  scattergl: true,\n  splom: true\n}; // fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\n\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n  gd = Lib.getGraphDiv(gd);\n  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {\n    _hover(gd, evt, subplot, noHoverEvent);\n  });\n};\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\n\n\nexports.loneHover = function loneHover(hoverItems, opts) {\n  var multiHover = true;\n\n  if (!Array.isArray(hoverItems)) {\n    multiHover = false;\n    hoverItems = [hoverItems];\n  }\n\n  var gd = opts.gd;\n  var gTop = getTopOffset(gd);\n  var gLeft = getLeftOffset(gd);\n  var pointsData = hoverItems.map(function (hoverItem) {\n    var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;\n\n    var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;\n\n    var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;\n\n    var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;\n\n    var eventData = hoverItem.eventData;\n\n    if (eventData) {\n      var x0 = Math.min(_x0, _x1);\n      var x1 = Math.max(_x0, _x1);\n      var y0 = Math.min(_y0, _y1);\n      var y1 = Math.max(_y0, _y1);\n      var trace = hoverItem.trace;\n\n      if (Registry.traceIs(trace, 'gl3d')) {\n        var container = gd._fullLayout[trace.scene]._scene.container;\n        var dx = container.offsetLeft;\n        var dy = container.offsetTop;\n        x0 += dx;\n        x1 += dx;\n        y0 += dy;\n        y1 += dy;\n      } // TODO: handle heatmapgl\n\n\n      eventData.bbox = {\n        x0: x0 + gLeft,\n        x1: x1 + gLeft,\n        y0: y0 + gTop,\n        y1: y1 + gTop\n      };\n\n      if (opts.inOut_bbox) {\n        opts.inOut_bbox.push(eventData.bbox);\n      }\n    } else {\n      eventData = false;\n    }\n\n    return {\n      color: hoverItem.color || Color.defaultLine,\n      x0: hoverItem.x0 || hoverItem.x || 0,\n      x1: hoverItem.x1 || hoverItem.x || 0,\n      y0: hoverItem.y0 || hoverItem.y || 0,\n      y1: hoverItem.y1 || hoverItem.y || 0,\n      xLabel: hoverItem.xLabel,\n      yLabel: hoverItem.yLabel,\n      zLabel: hoverItem.zLabel,\n      text: hoverItem.text,\n      name: hoverItem.name,\n      idealAlign: hoverItem.idealAlign,\n      // optional extra bits of styling\n      borderColor: hoverItem.borderColor,\n      fontFamily: hoverItem.fontFamily,\n      fontSize: hoverItem.fontSize,\n      fontColor: hoverItem.fontColor,\n      nameLength: hoverItem.nameLength,\n      textAlign: hoverItem.textAlign,\n      // filler to make createHoverText happy\n      trace: hoverItem.trace || {\n        index: 0,\n        hoverinfo: ''\n      },\n      xa: {\n        _offset: 0\n      },\n      ya: {\n        _offset: 0\n      },\n      index: 0,\n      hovertemplate: hoverItem.hovertemplate || false,\n      hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n      eventData: eventData\n    };\n  });\n  var rotateLabels = false;\n  var hoverLabel = createHoverText(pointsData, {\n    gd: gd,\n    hovermode: 'closest',\n    rotateLabels: rotateLabels,\n    bgColor: opts.bgColor || Color.background,\n    container: d3.select(opts.container),\n    outerContainer: opts.outerContainer || opts.container\n  }); // Fix vertical overlap\n\n  var tooltipSpacing = 5;\n  var lastBottomY = 0;\n  var anchor = 0;\n  hoverLabel.sort(function (a, b) {\n    return a.y0 - b.y0;\n  }).each(function (d, i) {\n    var topY = d.y0 - d.by / 2;\n\n    if (topY - tooltipSpacing < lastBottomY) {\n      d.offset = lastBottomY - topY + tooltipSpacing;\n    } else {\n      d.offset = 0;\n    }\n\n    lastBottomY = topY + d.by + d.offset;\n    if (i === opts.anchorIndex || 0) anchor = d.offset;\n  }).each(function (d) {\n    d.offset -= anchor;\n  });\n  var scaleX = gd._fullLayout._invScaleX;\n  var scaleY = gd._fullLayout._invScaleY;\n  alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);\n  return multiHover ? hoverLabel : hoverLabel.node();\n}; // The actual implementation is here:\n\n\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n  if (!subplot) subplot = 'xy'; // if the user passed in an array of subplots,\n  // use those instead of finding overlayed plots\n\n  var subplots = Array.isArray(subplot) ? subplot : [subplot];\n  var fullLayout = gd._fullLayout;\n  var plots = fullLayout._plots || [];\n  var plotinfo = plots[subplot];\n\n  var hasCartesian = fullLayout._has('cartesian'); // list of all overlaid subplots to look at\n\n\n  if (plotinfo) {\n    var overlayedSubplots = plotinfo.overlays.map(function (pi) {\n      return pi.id;\n    });\n    subplots = subplots.concat(overlayedSubplots);\n  }\n\n  var len = subplots.length;\n  var xaArray = new Array(len);\n  var yaArray = new Array(len);\n  var supportsCompare = false;\n\n  for (var i = 0; i < len; i++) {\n    var spId = subplots[i];\n\n    if (plots[spId]) {\n      // 'cartesian' case\n      supportsCompare = true;\n      xaArray[i] = plots[spId].xaxis;\n      yaArray[i] = plots[spId].yaxis;\n    } else if (fullLayout[spId] && fullLayout[spId]._subplot) {\n      // other subplot types\n      var _subplot = fullLayout[spId]._subplot;\n      xaArray[i] = _subplot.xaxis;\n      yaArray[i] = _subplot.yaxis;\n    } else {\n      Lib.warn('Unrecognized subplot: ' + spId);\n      return;\n    }\n  }\n\n  var hovermode = evt.hovermode || fullLayout.hovermode;\n  if (hovermode && !supportsCompare) hovermode = 'closest';\n\n  if (['x', 'y', 'closest', 'x unified', 'y unified'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {\n    return dragElement.unhoverRaw(gd, evt);\n  }\n\n  var hoverdistance = fullLayout.hoverdistance;\n  if (hoverdistance === -1) hoverdistance = Infinity;\n  var spikedistance = fullLayout.spikedistance;\n  if (spikedistance === -1) spikedistance = Infinity; // hoverData: the set of candidate points we've found to highlight\n\n  var hoverData = []; // searchData: the data to search in. Mostly this is just a copy of\n  // gd.calcdata, filtered to the subplot and overlays we're on\n  // but if a point array is supplied it will be a mapping\n  // of indicated curves\n\n  var searchData = []; // [x|y]valArray: the axis values of the hover event\n  // mapped onto each of the currently selected overlaid subplots\n\n  var xvalArray, yvalArray;\n\n  var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength; // spikePoints: the set of candidate points we've found to draw spikes to\n\n\n  var spikePoints = {\n    hLinePoint: null,\n    vLinePoint: null\n  }; // does subplot have one (or more) horizontal traces?\n  // This is used to determine whether we rotate the labels or not\n\n  var hasOneHorizontalTrace = false; // Figure out what we're hovering on:\n  // mouse location or user-supplied data\n\n  if (Array.isArray(evt)) {\n    // user specified an array of points to highlight\n    hovermode = 'array';\n\n    for (itemnum = 0; itemnum < evt.length; itemnum++) {\n      cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n\n      if (cd) {\n        trace = cd[0].trace;\n\n        if (cd[0].trace.hoverinfo !== 'skip') {\n          searchData.push(cd);\n\n          if (trace.orientation === 'h') {\n            hasOneHorizontalTrace = true;\n          }\n        }\n      }\n    }\n  } else {\n    for (curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n      cd = gd.calcdata[curvenum];\n      trace = cd[0].trace;\n\n      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n        searchData.push(cd);\n\n        if (trace.orientation === 'h') {\n          hasOneHorizontalTrace = true;\n        }\n      }\n    } // [x|y]px: the pixels (from top left) of the mouse location\n    // on the currently selected plot area\n    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n\n\n    var hasUserCalledHover = !evt.target;\n    var xpx, ypx;\n\n    if (hasUserCalledHover) {\n      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;\n      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;\n    } else {\n      // fire the beforehover event and quit if it returns false\n      // note that we're only calling this on real mouse events, so\n      // manual calls to fx.hover will always run.\n      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n      } // Discover event target, traversing open shadow roots.\n\n\n      var target = evt.composedPath && evt.composedPath()[0];\n\n      if (!target) {\n        // Fallback for browsers not supporting composedPath\n        target = evt.target;\n      }\n\n      var dbb = target.getBoundingClientRect();\n      xpx = evt.clientX - dbb.left;\n      ypx = evt.clientY - dbb.top;\n\n      fullLayout._calcInverseTransform(gd);\n\n      var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);\n      xpx = transformedCoords[0];\n      ypx = transformedCoords[1]; // in case hover was called from mouseout into hovertext,\n      // it's possible you're not actually over the plot anymore\n\n      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n        return dragElement.unhoverRaw(gd, evt);\n      }\n    }\n\n    evt.pointerX = xpx + xaArray[0]._offset;\n    evt.pointerY = ypx + yaArray[0]._offset;\n    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);\n    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);\n\n    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n      Lib.warn('Fx.hover failed', evt, gd);\n      return dragElement.unhoverRaw(gd, evt);\n    }\n  } // the pixel distance to beat as a matching point\n  // in 'x' or 'y' mode this resets for each trace\n\n\n  var distance = Infinity; // find the closest point in each trace\n  // this is minimum dx and/or dy, depending on mode\n  // and the pixel position for the label (labelXpx, labelYpx)\n\n  function findHoverPoints(customXVal, customYVal) {\n    for (curvenum = 0; curvenum < searchData.length; curvenum++) {\n      cd = searchData[curvenum]; // filter out invisible or broken data\n\n      if (!cd || !cd[0] || !cd[0].trace) continue;\n      trace = cd[0].trace;\n      if (trace.visible !== true || trace._length === 0) continue; // Explicitly bail out for these two. I don't know how to otherwise prevent\n      // the rest of this function from running and failing\n\n      if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n      if (trace.type === 'splom') {\n        // splom traces do not generate overlay subplots,\n        // it is safe to assume here splom traces correspond to the 0th subplot\n        subploti = 0;\n        subplotId = subplots[subploti];\n      } else {\n        subplotId = helpers.getSubplot(trace);\n        subploti = subplots.indexOf(subplotId);\n      } // within one trace mode can sometimes be overridden\n\n\n      _mode = hovermode;\n\n      if (helpers.isUnifiedHover(_mode)) {\n        _mode = _mode.charAt(0);\n      } // container for new point, also used to pass info into module.hoverPoints\n\n\n      pointData = {\n        // trace properties\n        cd: cd,\n        trace: trace,\n        xa: xaArray[subploti],\n        ya: yaArray[subploti],\n        // max distances for hover and spikes - for points that want to show but do not\n        // want to override other points, set distance/spikeDistance equal to max*Distance\n        // and it will not get filtered out but it will be guaranteed to have a greater\n        // distance than any point that calculated a real distance.\n        maxHoverDistance: hoverdistance,\n        maxSpikeDistance: spikedistance,\n        // point properties - override all of these\n        index: false,\n        // point index in trace - only used by plotly.js hoverdata consumers\n        distance: Math.min(distance, hoverdistance),\n        // pixel distance or pseudo-distance\n        // distance/pseudo-distance for spikes. This distance should always be calculated\n        // as if in \"closest\" mode, and should only be set if this point should\n        // generate a spike.\n        spikeDistance: Infinity,\n        // in some cases the spikes have different positioning from the hover label\n        // they don't need x0/x1, just one position\n        xSpike: undefined,\n        ySpike: undefined,\n        // where and how to display the hover label\n        color: Color.defaultLine,\n        // trace color\n        name: trace.name,\n        x0: undefined,\n        x1: undefined,\n        y0: undefined,\n        y1: undefined,\n        xLabelVal: undefined,\n        yLabelVal: undefined,\n        zLabelVal: undefined,\n        text: undefined\n      }; // add ref to subplot object (non-cartesian case)\n\n      if (fullLayout[subplotId]) {\n        pointData.subplot = fullLayout[subplotId]._subplot;\n      } // add ref to splom scene\n\n\n      if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n        pointData.scene = fullLayout._splomScenes[trace.uid];\n      }\n\n      closedataPreviousLength = hoverData.length; // for a highlighting array, figure out what\n      // we're searching for with this element\n\n      if (_mode === 'array') {\n        var selection = evt[curvenum];\n\n        if ('pointNumber' in selection) {\n          pointData.index = selection.pointNumber;\n          _mode = 'closest';\n        } else {\n          _mode = '';\n\n          if ('xval' in selection) {\n            xval = selection.xval;\n            _mode = 'x';\n          }\n\n          if ('yval' in selection) {\n            yval = selection.yval;\n            _mode = _mode ? 'closest' : 'y';\n          }\n        }\n      } else if (customXVal !== undefined && customYVal !== undefined) {\n        xval = customXVal;\n        yval = customYVal;\n      } else {\n        xval = xvalArray[subploti];\n        yval = yvalArray[subploti];\n      } // Now if there is range to look in, find the points to hover.\n\n\n      if (hoverdistance !== 0) {\n        if (trace._module && trace._module.hoverPoints) {\n          var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {\n            finiteRange: true,\n            hoverLayer: fullLayout._hoverlayer\n          });\n\n          if (newPoints) {\n            var newPoint;\n\n            for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n              newPoint = newPoints[newPointNum];\n\n              if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                hoverData.push(cleanPoint(newPoint, hovermode));\n              }\n            }\n          }\n        } else {\n          Lib.log('Unrecognized trace type in hover:', trace);\n        }\n      } // in closest mode, remove any existing (farther) points\n      // and don't look any farther than this latest point (or points, some\n      // traces like box & violin make multiple hover labels at once)\n\n\n      if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n        hoverData.splice(0, closedataPreviousLength);\n        distance = hoverData[0].distance;\n      } // Now if there is range to look in, find the points to draw the spikelines\n      // Do it only if there is no hoverData\n\n\n      if (hasCartesian && spikedistance !== 0) {\n        if (hoverData.length === 0) {\n          pointData.distance = spikedistance;\n          pointData.index = false;\n\n          var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', {\n            hoverLayer: fullLayout._hoverlayer\n          });\n\n          if (closestPoints) {\n            closestPoints = closestPoints.filter(function (point) {\n              // some hover points, like scatter fills, do not allow spikes,\n              // so will generate a hover point but without a valid spikeDistance\n              return point.spikeDistance <= spikedistance;\n            });\n          }\n\n          if (closestPoints && closestPoints.length) {\n            var tmpPoint;\n            var closestVPoints = closestPoints.filter(function (point) {\n              return point.xa.showspikes && point.xa.spikesnap !== 'hovered data';\n            });\n\n            if (closestVPoints.length) {\n              var closestVPt = closestVPoints[0];\n\n              if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                tmpPoint = fillSpikePoint(closestVPt);\n\n                if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                  spikePoints.vLinePoint = tmpPoint;\n                }\n              }\n            }\n\n            var closestHPoints = closestPoints.filter(function (point) {\n              return point.ya.showspikes && point.ya.spikesnap !== 'hovered data';\n            });\n\n            if (closestHPoints.length) {\n              var closestHPt = closestHPoints[0];\n\n              if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                tmpPoint = fillSpikePoint(closestHPt);\n\n                if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                  spikePoints.hLinePoint = tmpPoint;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  findHoverPoints();\n\n  function selectClosestPoint(pointsData, spikedistance, spikeOnWinning) {\n    var resultPoint = null;\n    var minDistance = Infinity;\n    var thisSpikeDistance;\n\n    for (var i = 0; i < pointsData.length; i++) {\n      thisSpikeDistance = pointsData[i].spikeDistance;\n      if (spikeOnWinning && i === 0) thisSpikeDistance = -Infinity;\n\n      if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance) {\n        resultPoint = pointsData[i];\n        minDistance = thisSpikeDistance;\n      }\n    }\n\n    return resultPoint;\n  }\n\n  function fillSpikePoint(point) {\n    if (!point) return null;\n    return {\n      xa: point.xa,\n      ya: point.ya,\n      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n      distance: point.distance,\n      spikeDistance: point.spikeDistance,\n      curveNumber: point.trace.index,\n      color: point.color,\n      pointNumber: point.index\n    };\n  }\n\n  var spikelineOpts = {\n    fullLayout: fullLayout,\n    container: fullLayout._hoverlayer,\n    event: evt\n  };\n  var oldspikepoints = gd._spikepoints;\n  var newspikepoints = {\n    vLinePoint: spikePoints.vLinePoint,\n    hLinePoint: spikePoints.hLinePoint\n  };\n  gd._spikepoints = newspikepoints;\n\n  var sortHoverData = function () {\n    hoverData.sort(function (d1, d2) {\n      return d1.distance - d2.distance;\n    }); // move period positioned points and box/bar-like traces to the end of the list\n\n    hoverData = orderRangePoints(hoverData, hovermode);\n  };\n\n  sortHoverData();\n  var axLetter = hovermode.charAt(0);\n  var spikeOnWinning = (axLetter === 'x' || axLetter === 'y') && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type]; // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n\n  if (hasCartesian && spikedistance !== 0) {\n    if (hoverData.length !== 0) {\n      var tmpHPointData = hoverData.filter(function (point) {\n        return point.ya.showspikes;\n      });\n      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);\n      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n      var tmpVPointData = hoverData.filter(function (point) {\n        return point.xa.showspikes;\n      });\n      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);\n      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n    }\n  } // if hoverData is empty check for the spikes to draw and quit if there are none\n\n\n  if (hoverData.length === 0) {\n    var result = dragElement.unhoverRaw(gd, evt);\n\n    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {\n      if (spikesChanged(oldspikepoints)) {\n        createSpikelines(gd, spikePoints, spikelineOpts);\n      }\n    }\n\n    return result;\n  }\n\n  if (hasCartesian) {\n    if (spikesChanged(oldspikepoints)) {\n      createSpikelines(gd, spikePoints, spikelineOpts);\n    }\n  }\n\n  if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== 'splom' // TODO: add support for splom\n  ) {\n    // pick winning point\n    var winningPoint = hoverData[0]; // discard other points\n\n    if (multipleHoverPoints[winningPoint.trace.type]) {\n      hoverData = hoverData.filter(function (d) {\n        return d.trace.index === winningPoint.trace.index;\n      });\n    } else {\n      hoverData = [winningPoint];\n    }\n\n    var initLen = hoverData.length;\n    var winX = getCoord('x', winningPoint, fullLayout);\n    var winY = getCoord('y', winningPoint, fullLayout); // in compare mode, select every point at position\n\n    findHoverPoints(winX, winY);\n    var finalPoints = [];\n    var seen = {};\n    var id = 0;\n\n    var insert = function (newHd) {\n      var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;\n\n      if (!seen[key]) {\n        id++;\n        seen[key] = id;\n        finalPoints.push(newHd);\n      } else {\n        var oldId = seen[key] - 1;\n        var oldHd = finalPoints[oldId];\n\n        if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {\n          // replace with closest\n          finalPoints[oldId] = newHd;\n        }\n      }\n    };\n\n    var k; // insert the winnig point(s) first\n\n    for (k = 0; k < initLen; k++) {\n      insert(hoverData[k]);\n    } // override from the end\n\n\n    for (k = hoverData.length - 1; k > initLen - 1; k--) {\n      insert(hoverData[k]);\n    }\n\n    hoverData = finalPoints;\n    sortHoverData();\n  } // lastly, emit custom hover/unhover events\n\n\n  var oldhoverdata = gd._hoverdata;\n  var newhoverdata = [];\n  var gTop = getTopOffset(gd);\n  var gLeft = getLeftOffset(gd); // pull out just the data that's useful to\n  // other people and send it to the event\n\n  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {\n    var pt = hoverData[itemnum];\n    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n    if (pt.hovertemplate !== false) {\n      var ht = false;\n\n      if (pt.cd[pt.index] && pt.cd[pt.index].ht) {\n        ht = pt.cd[pt.index].ht;\n      }\n\n      pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n    }\n\n    if (pt.xa && pt.ya) {\n      var _x0 = pt.x0 + pt.xa._offset;\n\n      var _x1 = pt.x1 + pt.xa._offset;\n\n      var _y0 = pt.y0 + pt.ya._offset;\n\n      var _y1 = pt.y1 + pt.ya._offset;\n\n      var x0 = Math.min(_x0, _x1);\n      var x1 = Math.max(_x0, _x1);\n      var y0 = Math.min(_y0, _y1);\n      var y1 = Math.max(_y0, _y1);\n      eventData.bbox = {\n        x0: x0 + gLeft,\n        x1: x1 + gLeft,\n        y0: y0 + gTop,\n        y1: y1 + gTop\n      };\n    }\n\n    pt.eventData = [eventData];\n    newhoverdata.push(eventData);\n  }\n\n  gd._hoverdata = newhoverdata;\n  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;\n  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);\n  var hoverLabels = createHoverText(hoverData, {\n    gd: gd,\n    hovermode: hovermode,\n    rotateLabels: rotateLabels,\n    bgColor: bgColor,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paper.node(),\n    commonLabelOpts: fullLayout.hoverlabel,\n    hoverdistance: fullLayout.hoverdistance\n  });\n\n  if (!helpers.isUnifiedHover(hovermode)) {\n    hoverAvoidOverlaps(hoverLabels, rotateLabels ? 'xa' : 'ya', fullLayout);\n    alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);\n  } // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n  // we should improve the \"fx\" API so other plots can use it without these hack.\n\n\n  if (evt.target && evt.target.tagName) {\n    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n    overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n  } // don't emit events if called manually\n\n\n  if (!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n  if (oldhoverdata) {\n    gd.emit('plotly_unhover', {\n      event: evt,\n      points: oldhoverdata\n    });\n  }\n\n  gd.emit('plotly_hover', {\n    event: evt,\n    points: gd._hoverdata,\n    xaxes: xaArray,\n    yaxes: yaArray,\n    xvals: xvalArray,\n    yvals: yvalArray\n  });\n}\n\nfunction hoverDataKey(d) {\n  return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : '', d.ya ? d.ya._id : ''].join(',');\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts) {\n  var gd = opts.gd;\n  var fullLayout = gd._fullLayout;\n  var hovermode = opts.hovermode;\n  var rotateLabels = opts.rotateLabels;\n  var bgColor = opts.bgColor;\n  var container = opts.container;\n  var outerContainer = opts.outerContainer;\n  var commonLabelOpts = opts.commonLabelOpts || {}; // opts.fontFamily/Size are used for the common label\n  // and as defaults for each hover label, though the individual labels\n  // can override this.\n\n  var fontFamily = opts.fontFamily || constants.HOVERFONT;\n  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n  var c0 = hoverData[0];\n  var xa = c0.xa;\n  var ya = c0.ya;\n  var axLetter = hovermode.charAt(0);\n  var t0 = c0[axLetter + 'Label'];\n  var outerContainerBB = getBoundingClientRect(gd, outerContainer);\n  var outerTop = outerContainerBB.top;\n  var outerWidth = outerContainerBB.width;\n  var outerHeight = outerContainerBB.height; // show the common label, if any, on the axis\n  // never show a common label in array mode,\n  // even if sometimes there could be one\n\n  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y'); // all hover traces hoverinfo must contain the hovermode\n  // to have common labels\n\n  if (showCommonLabel) {\n    var allHaveZ = true;\n    var i, traceHoverinfo;\n\n    for (i = 0; i < hoverData.length; i++) {\n      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n\n      if (traceHoverinfo) {\n        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n\n        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {\n          showCommonLabel = false;\n          break;\n        }\n      }\n    } // xyz labels put all info in their main label, so have no need of a common label\n\n\n    if (allHaveZ) showCommonLabel = false;\n  }\n\n  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);\n  commonLabel.enter().append('g').classed('axistext', true);\n  commonLabel.exit().remove();\n  commonLabel.each(function () {\n    var label = d3.select(this);\n    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {\n      s.style({\n        'stroke-width': '1px'\n      });\n    });\n    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n    var contrastColor = Color.contrast(commonBgColor);\n    var commonLabelFont = {\n      family: commonLabelOpts.font.family || fontFamily,\n      size: commonLabelOpts.font.size || fontSize,\n      color: commonLabelOpts.font.color || contrastColor\n    };\n    lpath.style({\n      fill: commonBgColor,\n      stroke: commonStroke\n    });\n    ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    label.attr('transform', '');\n    var tbb = getBoundingClientRect(gd, ltext.node());\n    var lx, ly;\n\n    if (hovermode === 'x') {\n      var topsign = xa.side === 'top' ? '-' : '';\n      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);\n      lx = xa._offset + (c0.x0 + c0.x1) / 2;\n      ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n      var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n      if (lx < halfWidth) {\n        lx = halfWidth;\n        lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'Z');\n      } else if (lx > fullLayout.width - halfWidth) {\n        lx = fullLayout.width - halfWidth;\n        lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' + 'L' + halfWidth + ',' + topsign + HOVERARROWSIZE + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + halfWidth + 'V' + topsign + HOVERARROWSIZE + 'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');\n      } else {\n        lpath.attr('d', 'M0,0' + 'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + (HOVERTEXTPAD + tbb.width / 2) + 'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n      }\n    } else {\n      var anchor;\n      var sgn;\n      var leftsign;\n\n      if (ya.side === 'right') {\n        anchor = 'start';\n        sgn = 1;\n        leftsign = '';\n        lx = xa._offset + xa._length;\n      } else {\n        anchor = 'end';\n        sgn = -1;\n        leftsign = '-';\n        lx = xa._offset;\n      }\n\n      ly = ya._offset + (c0.y0 + c0.y1) / 2;\n      ltext.attr('text-anchor', anchor);\n      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n      var halfHeight = tbb.height / 2;\n      var lty = outerTop - tbb.top - halfHeight;\n      var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n      var clipPath;\n\n      if (lx < tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {\n        clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight + 'h-' + (tbb.width - HOVERTEXTPAD) + 'V' + halfHeight + 'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n        var ltx = tbb.width - lx + HOVERTEXTPAD;\n        svgTextUtils.positionText(ltext, ltx, lty); // shift each line (except the longest) so that start-of-line\n        // is always visible\n\n        if (anchor === 'end') {\n          ltext.selectAll('tspan').each(function () {\n            var s = d3.select(this);\n            var dummy = Drawing.tester.append('text').text(s.text()).call(Drawing.font, commonLabelFont);\n            var dummyBB = getBoundingClientRect(gd, dummy.node());\n\n            if (Math.round(dummyBB.width) < Math.round(tbb.width)) {\n              s.attr('x', ltx - dummyBB.width);\n            }\n\n            dummy.remove();\n          });\n        }\n      } else {\n        svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n        clipPath = null;\n      }\n\n      var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n\n      textClip.enter().append('clipPath').attr('id', clipId).append('path');\n      textClip.exit().remove();\n      textClip.select('path').attr('d', clipPath);\n      Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n    }\n\n    label.attr('transform', strTranslate(lx, ly));\n  }); // Show a single hover label\n\n  if (helpers.isUnifiedHover(hovermode)) {\n    // Delete leftover hover labels from other hovermodes\n    container.selectAll('g.hovertext').remove(); // Return early if nothing is hovered on\n\n    if (hoverData.length === 0) return; // mock legend\n\n    var hoverlabel = fullLayout.hoverlabel;\n    var font = hoverlabel.font;\n    var mockLayoutIn = {\n      showlegend: true,\n      legend: {\n        title: {\n          text: t0,\n          font: font\n        },\n        font: font,\n        bgcolor: hoverlabel.bgcolor,\n        bordercolor: hoverlabel.bordercolor,\n        borderwidth: 1,\n        tracegroupgap: 7,\n        traceorder: fullLayout.legend ? fullLayout.legend.traceorder : undefined,\n        orientation: 'v'\n      }\n    };\n    var mockLayoutOut = {};\n    legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);\n    var mockLegend = mockLayoutOut.legend; // prepare items for the legend\n\n    mockLegend.entries = [];\n\n    for (var j = 0; j < hoverData.length; j++) {\n      var texts = getHoverLabelText(hoverData[j], true, hovermode, fullLayout, t0);\n      var text = texts[0];\n      var name = texts[1];\n      var pt = hoverData[j];\n      pt.name = name;\n\n      if (name !== '') {\n        pt.text = name + ' : ' + text;\n      } else {\n        pt.text = text;\n      } // pass through marker's calcdata to style legend items\n\n\n      var cd = pt.cd[pt.index];\n\n      if (cd) {\n        if (cd.mc) pt.mc = cd.mc;\n        if (cd.mcc) pt.mc = cd.mcc;\n        if (cd.mlc) pt.mlc = cd.mlc;\n        if (cd.mlcc) pt.mlc = cd.mlcc;\n        if (cd.mlw) pt.mlw = cd.mlw;\n        if (cd.mrc) pt.mrc = cd.mrc;\n        if (cd.dir) pt.dir = cd.dir;\n      }\n\n      pt._distinct = true;\n      mockLegend.entries.push([pt]);\n    }\n\n    mockLegend.entries.sort(function (a, b) {\n      return a[0].trace.index - b[0].trace.index;\n    });\n    mockLegend.layer = container; // Draw unified hover label\n\n    mockLegend._inHover = true;\n    mockLegend._groupTitleFont = font;\n    legendDraw(gd, mockLegend); // Position the hover\n\n    var legendContainer = container.select('g.legend');\n    var tbb = getBoundingClientRect(gd, legendContainer.node());\n    var tWidth = tbb.width + 2 * HOVERTEXTPAD;\n    var tHeight = tbb.height + 2 * HOVERTEXTPAD;\n    var winningPoint = hoverData[0];\n    var avgX = (winningPoint.x0 + winningPoint.x1) / 2;\n    var avgY = (winningPoint.y0 + winningPoint.y1) / 2; // When a scatter (or e.g. heatmap) point wins, it's OK for the hovelabel to occlude the bar and other points.\n\n    var pointWon = !(Registry.traceIs(winningPoint.trace, 'bar-like') || Registry.traceIs(winningPoint.trace, 'box-violin'));\n    var lyBottom, lyTop;\n\n    if (axLetter === 'y') {\n      if (pointWon) {\n        lyTop = avgY - HOVERTEXTPAD;\n        lyBottom = avgY + HOVERTEXTPAD;\n      } else {\n        lyTop = Math.min.apply(null, hoverData.map(function (c) {\n          return Math.min(c.y0, c.y1);\n        }));\n        lyBottom = Math.max.apply(null, hoverData.map(function (c) {\n          return Math.max(c.y0, c.y1);\n        }));\n      }\n    } else {\n      lyTop = lyBottom = Lib.mean(hoverData.map(function (c) {\n        return (c.y0 + c.y1) / 2;\n      })) - tHeight / 2;\n    }\n\n    var lxRight, lxLeft;\n\n    if (axLetter === 'x') {\n      if (pointWon) {\n        lxRight = avgX + HOVERTEXTPAD;\n        lxLeft = avgX - HOVERTEXTPAD;\n      } else {\n        lxRight = Math.max.apply(null, hoverData.map(function (c) {\n          return Math.max(c.x0, c.x1);\n        }));\n        lxLeft = Math.min.apply(null, hoverData.map(function (c) {\n          return Math.min(c.x0, c.x1);\n        }));\n      }\n    } else {\n      lxRight = lxLeft = Lib.mean(hoverData.map(function (c) {\n        return (c.x0 + c.x1) / 2;\n      })) - tWidth / 2;\n    }\n\n    var xOffset = xa._offset;\n    var yOffset = ya._offset;\n    lyBottom += yOffset;\n    lxRight += xOffset;\n    lxLeft += xOffset - tWidth;\n    lyTop += yOffset - tHeight;\n    var lx, ly; // top and left positions of the hover box\n    // horizontal alignment to end up on screen\n\n    if (lxRight + tWidth < outerWidth && lxRight >= 0) {\n      lx = lxRight;\n    } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {\n      lx = lxLeft;\n    } else if (xOffset + tWidth < outerWidth) {\n      lx = xOffset; // subplot left corner\n    } else {\n      // closest left or right side of the paper\n      if (lxRight - avgX < avgX - lxLeft + tWidth) {\n        lx = outerWidth - tWidth;\n      } else {\n        lx = 0;\n      }\n    }\n\n    lx += HOVERTEXTPAD; // vertical alignement to end up on screen\n\n    if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {\n      ly = lyBottom;\n    } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {\n      ly = lyTop;\n    } else if (yOffset + tHeight < outerHeight) {\n      ly = yOffset; // subplot top corner\n    } else {\n      // closest top or bottom side of the paper\n      if (lyBottom - avgY < avgY - lyTop + tHeight) {\n        ly = outerHeight - tHeight;\n      } else {\n        ly = 0;\n      }\n    }\n\n    ly += HOVERTEXTPAD;\n    legendContainer.attr('transform', strTranslate(lx - 1, ly - 1));\n    return legendContainer;\n  } // show all the individual labels\n  // first create the objects\n\n\n  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {\n    // N.B. when multiple items have the same result key-function value,\n    // only the first of those items in hoverData gets rendered\n    return hoverDataKey(d);\n  });\n  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {\n    var g = d3.select(this); // trace name label (rect and text.name)\n\n    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));\n    g.append('text').classed('name', true); // trace data label (path and text.nums)\n\n    g.append('path').style('stroke-width', '1px');\n    g.append('text').classed('nums', true).call(Drawing.font, fontFamily, fontSize);\n  });\n  hoverLabels.exit().remove(); // then put the text in, position the pointer to the data,\n  // and figure out sizes\n\n  hoverLabels.each(function (d) {\n    var g = d3.select(this).attr('transform', '');\n    var dColor = d.color;\n\n    if (Array.isArray(dColor)) {\n      dColor = dColor[d.eventData[0].pointNumber];\n    } // combine possible non-opaque trace color with bgColor\n\n\n    var color0 = d.bgcolor || dColor; // color for 'nums' part of the label\n\n    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor); // color for 'name' part of the label\n\n    var nameColor = Color.combine(Color.opacity(dColor) ? dColor : Color.defaultLine, bgColor); // find a contrasting color for border and text\n\n    var contrastColor = d.borderColor || Color.contrast(numsColor);\n    var texts = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);\n    var text = texts[0];\n    var name = texts[1]; // main label\n\n    var tx = g.select('text.nums').call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, d.fontColor || contrastColor).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    var tx2 = g.select('text.name');\n    var tx2width = 0;\n    var tx2height = 0; // secondary label for non-empty 'name'\n\n    if (name && name !== text) {\n      tx2.call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, nameColor).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n      var t2bb = getBoundingClientRect(gd, tx2.node());\n      tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n      tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n    } else {\n      tx2.remove();\n      g.select('rect').remove();\n    }\n\n    g.select('path').style({\n      fill: numsColor,\n      stroke: contrastColor\n    });\n    var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n    var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n    var dx = Math.abs(d.x1 - d.x0);\n    var dy = Math.abs(d.y1 - d.y0);\n    var tbb = getBoundingClientRect(gd, tx.node());\n    var tbbWidth = tbb.width / fullLayout._invScaleX;\n    var tbbHeight = tbb.height / fullLayout._invScaleY;\n    d.ty0 = (outerTop - tbb.top) / fullLayout._invScaleY;\n    d.bx = tbbWidth + 2 * HOVERTEXTPAD;\n    d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);\n    d.anchor = 'start';\n    d.txwidth = tbbWidth;\n    d.tx2width = tx2width;\n    d.offset = 0;\n    var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;\n    var anchorStartOK, anchorEndOK;\n\n    if (rotateLabels) {\n      d.pos = htx;\n      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n        hty -= dy / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        hty += dy / 2;\n        d.anchor = 'start';\n      } else d.anchor = 'middle';\n    } else {\n      d.pos = hty;\n      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n        htx -= dx / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        htx += dx / 2;\n        d.anchor = 'start';\n      } else {\n        d.anchor = 'middle';\n        var txHalfWidth = txTotalWidth / 2;\n        var overflowR = htx + txHalfWidth - outerWidth;\n        var overflowL = htx - txHalfWidth;\n        if (overflowR > 0) htx -= overflowR;\n        if (overflowL < 0) htx += -overflowL;\n      }\n    }\n\n    tx.attr('text-anchor', d.anchor);\n    if (tx2width) tx2.attr('text-anchor', d.anchor);\n    g.attr('transform', strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ''));\n  });\n  return hoverLabels;\n}\n\nfunction getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {\n  var name = '';\n  var text = ''; // to get custom 'name' labels pass cleanPoint\n\n  if (d.nameOverride !== undefined) d.name = d.nameOverride;\n\n  if (d.name) {\n    if (d.trace._meta) {\n      d.name = Lib.templateString(d.name, d.trace._meta);\n    }\n\n    name = plainText(d.name, d.nameLength);\n  }\n\n  var h0 = hovermode.charAt(0);\n  var h1 = h0 === 'x' ? 'y' : 'x';\n\n  if (d.zLabel !== undefined) {\n    if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n    if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n\n    if (d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {\n      text += (text ? 'z: ' : '') + d.zLabel;\n    }\n  } else if (showCommonLabel && d[h0 + 'Label'] === t0) {\n    text = d[h1 + 'Label'] || '';\n  } else if (d.xLabel === undefined) {\n    if (d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n      text = d.yLabel;\n    }\n  } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n  if ((d.text || d.text === 0) && !Array.isArray(d.text)) {\n    text += (text ? '<br>' : '') + d.text;\n  } // used by other modules (initially just ternary) that\n  // manage their own hoverinfo independent of cleanPoint\n  // the rest of this will still apply, so such modules\n  // can still put things in (x|y|z)Label, text, and name\n  // and hoverinfo will still determine their visibility\n\n\n  if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText; // if 'text' is empty at this point,\n  // and hovertemplate is not defined,\n  // put 'name' in main label and don't show secondary label\n\n  if (g && text === '' && !d.hovertemplate) {\n    // if 'name' is also empty, remove entire label\n    if (name === '') g.remove();\n    text = name;\n  } // hovertemplate\n\n\n  var hovertemplate = d.hovertemplate || false;\n\n  if (hovertemplate) {\n    var labels = d.hovertemplateLabels || d;\n\n    if (d[h0 + 'Label'] !== t0) {\n      labels[h0 + 'other'] = labels[h0 + 'Val'];\n      labels[h0 + 'otherLabel'] = labels[h0 + 'Label'];\n    }\n\n    text = Lib.hovertemplateString(hovertemplate, labels, fullLayout._d3locale, d.eventData[0] || {}, d.trace._meta);\n    text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {\n      // assign name for secondary text label\n      name = plainText(extra, d.nameLength); // remove from main text label\n\n      return '';\n    });\n  }\n\n  return [text, name];\n} // Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Incidentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\n\n\nfunction hoverAvoidOverlaps(hoverLabels, axKey, fullLayout) {\n  var nummoves = 0;\n  var axSign = 1;\n  var nLabels = hoverLabels.size(); // make groups of touching points\n\n  var pointgroups = new Array(nLabels);\n  var k = 0;\n  hoverLabels.each(function (d) {\n    var ax = d[axKey];\n    var axIsX = ax._id.charAt(0) === 'x';\n    var rng = ax.range;\n\n    if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {\n      axSign = -1;\n    }\n\n    pointgroups[k++] = [{\n      datum: d,\n      traceIndex: d.trace.index,\n      dp: 0,\n      pos: d.pos,\n      posref: d.posref,\n      size: d.by * (axIsX ? YFACTOR : 1) / 2,\n      pmin: 0,\n      pmax: axIsX ? fullLayout.width : fullLayout.height\n    }];\n  });\n  pointgroups.sort(function (a, b) {\n    return a[0].posref - b[0].posref || axSign * (b[0].traceIndex - a[0].traceIndex);\n  });\n  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n  function constrainGroup(grp) {\n    var minPt = grp[0];\n    var maxPt = grp[grp.length - 1]; // overlap with the top - positive vals are overlaps\n\n    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size; // overlap with the bottom - positive vals are overlaps\n\n    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax; // check for min overlap first, so that we always\n    // see the largest labels\n    // allow for .01px overlap, so we don't get an\n    // infinite loop from rounding errors\n\n    if (topOverlap > 0.01) {\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n\n      donepositioning = false;\n    }\n\n    if (bottomOverlap < 0.01) return;\n\n    if (topOverlap < -0.01) {\n      // make sure we're not pushing back and forth\n      for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n\n      donepositioning = false;\n    }\n\n    if (!donepositioning) return; // no room to fix positioning, delete off-screen points\n    // first see how many points we need to delete\n\n    var deleteCount = 0;\n\n    for (i = 0; i < grp.length; i++) {\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n    } // start by deleting points whose data is off screen\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos > minPt.pmax - 1) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n\n    for (i = 0; i < grp.length; i++) {\n      if (deleteCount <= 0) break;\n      pti = grp[i]; // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n\n      if (pti.pos < minPt.pmin + 1) {\n        pti.del = true;\n        deleteCount--; // shift the whole group minus into this new space\n\n        bottomOverlap = pti.size * 2;\n\n        for (j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n      }\n    } // then delete points that go off the bottom\n\n\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n  } // loop through groups, combining them if they overlap,\n  // until nothing moves\n\n\n  while (!donepositioning && nummoves <= nLabels) {\n    // to avoid infinite loops, don't move more times\n    // than there are traces\n    nummoves++; // assume nothing will move in this iteration,\n    // reverse this if it does\n\n    donepositioning = true;\n    i = 0;\n\n    while (i < pointgroups.length - 1) {\n      // the higher (g0) and lower (g1) point group\n      var g0 = pointgroups[i];\n      var g1 = pointgroups[i + 1]; // the lowest point in the higher group (p0)\n      // the highest point in the lower group (p1)\n\n      var p0 = g0[g0.length - 1];\n      var p1 = g1[0];\n      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size; // Only group points that lie on the same axes\n\n      if (topOverlap > 0.01 && p0.pmin === p1.pmin && p0.pmax === p1.pmax) {\n        // push the new point(s) added to this group out of the way\n        for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap; // add them to the group\n\n\n        g0.push.apply(g0, g1);\n        pointgroups.splice(i + 1, 1); // adjust for minimum average movement\n\n        sumdp = 0;\n\n        for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n\n        bottomOverlap = sumdp / g0.length;\n\n        for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n\n        donepositioning = false;\n      } else i++;\n    } // check if we're going off the plot on either side and fix\n\n\n    pointgroups.forEach(constrainGroup);\n  } // now put these offsets into hoverData\n\n\n  for (i = pointgroups.length - 1; i >= 0; i--) {\n    var grp = pointgroups[i];\n\n    for (j = grp.length - 1; j >= 0; j--) {\n      var pt = grp[j];\n      var hoverPt = pt.datum;\n      hoverPt.offset = pt.dp;\n      hoverPt.del = pt.del;\n    }\n  }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {\n  var pX = function (x) {\n    return x * scaleX;\n  };\n\n  var pY = function (y) {\n    return y * scaleY;\n  }; // finally set the text positioning relative to the data and draw the\n  // box around it\n\n\n  hoverLabels.each(function (d) {\n    var g = d3.select(this);\n    if (d.del) return g.remove();\n    var tx = g.select('text.nums');\n    var anchor = d.anchor;\n    var horzSign = anchor === 'end' ? -1 : 1;\n    var alignShift = {\n      start: 1,\n      end: -1,\n      middle: 0\n    }[anchor];\n    var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n    var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n    var offsetX = 0;\n    var offsetY = d.offset;\n    var isMiddle = anchor === 'middle';\n\n    if (isMiddle) {\n      txx -= d.tx2width / 2;\n      tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n    }\n\n    if (rotateLabels) {\n      offsetY *= -YSHIFTY;\n      offsetX = d.offset * YSHIFTX;\n    }\n\n    g.select('path').attr('d', isMiddle ? 'M-' + pX(d.bx / 2 + d.tx2width / 2) + ',' + pY(offsetY - d.by / 2) + 'h' + pX(d.bx) + 'v' + pY(d.by) + 'h-' + pX(d.bx) + 'Z' : 'M0,0L' + pX(horzSign * HOVERARROWSIZE + offsetX) + ',' + pY(HOVERARROWSIZE + offsetY) + 'v' + pY(d.by / 2 - HOVERARROWSIZE) + 'h' + pX(horzSign * d.bx) + 'v-' + pY(d.by) + 'H' + pX(horzSign * HOVERARROWSIZE + offsetX) + 'V' + pY(offsetY - HOVERARROWSIZE) + 'Z');\n    var posX = offsetX + txx;\n    var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n    var textAlign = d.textAlign || 'auto';\n\n    if (textAlign !== 'auto') {\n      if (textAlign === 'left' && anchor !== 'start') {\n        tx.attr('text-anchor', 'start');\n        posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;\n      } else if (textAlign === 'right' && anchor !== 'end') {\n        tx.attr('text-anchor', 'end');\n        posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;\n      }\n    }\n\n    tx.call(svgTextUtils.positionText, pX(posX), pY(posY));\n\n    if (d.tx2width) {\n      g.select('text.name').call(svgTextUtils.positionText, pX(tx2x + alignShift * HOVERTEXTPAD + offsetX), pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD));\n      g.select('rect').call(Drawing.setRect, pX(tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX), pY(offsetY - d.by / 2 - 1), pX(d.tx2width), pY(d.by + 2));\n    }\n  });\n}\n\nfunction cleanPoint(d, hovermode) {\n  var index = d.index;\n  var trace = d.trace || {};\n  var cd0 = d.cd[0];\n  var cd = d.cd[index] || {};\n\n  function pass(v) {\n    return v || isNumeric(v) && v === 0;\n  }\n\n  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {\n    var v = Lib.castOption(cd0, index, calcKey);\n    return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n  } : function (calcKey, traceKey) {\n    return Lib.extractOption(cd, trace, calcKey, traceKey);\n  };\n\n  function fill(key, calcKey, traceKey) {\n    var val = getVal(calcKey, traceKey);\n    if (pass(val)) d[key] = val;\n  }\n\n  fill('hoverinfo', 'hi', 'hoverinfo');\n  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n  fill('fontFamily', 'htf', 'hoverlabel.font.family');\n  fill('fontSize', 'hts', 'hoverlabel.font.size');\n  fill('fontColor', 'htc', 'hoverlabel.font.color');\n  fill('nameLength', 'hnl', 'hoverlabel.namelength');\n  fill('textAlign', 'hta', 'hoverlabel.align');\n  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2; // then constrain all the positions to be on the plot\n\n  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n  d.y1 = Lib.constrain(d.y1, 0, d.ya._length); // and convert the x and y label values into formatted text\n\n  if (d.xLabelVal !== undefined) {\n    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);\n    d.xVal = d.xa.c2d(d.xLabelVal);\n  }\n\n  if (d.yLabelVal !== undefined) {\n    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);\n    d.yVal = d.ya.c2d(d.yLabelVal);\n  } // Traces like heatmaps generate the zLabel in their hoverPoints function\n\n\n  if (d.zLabelVal !== undefined && d.zLabel === undefined) {\n    d.zLabel = String(d.zLabelVal);\n  } // for box means and error bars, add the range to the label\n\n\n  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n\n    if (d.xerrneg !== undefined) {\n      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n    } else d.xLabel += '  ' + xeText; // small distance penalty for error bars, so that if there are\n    // traces with errors and some without, the error bar label will\n    // hoist up to the point\n\n\n    if (hovermode === 'x') d.distance += 1;\n  }\n\n  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n\n    if (d.yerrneg !== undefined) {\n      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n    } else d.yLabel += '  ' + yeText;\n\n    if (hovermode === 'y') d.distance += 1;\n  }\n\n  var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n  if (infomode && infomode !== 'all') {\n    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n    if (infomode.indexOf('x') === -1) d.xLabel = undefined;\n    if (infomode.indexOf('y') === -1) d.yLabel = undefined;\n    if (infomode.indexOf('z') === -1) d.zLabel = undefined;\n    if (infomode.indexOf('text') === -1) d.text = undefined;\n    if (infomode.indexOf('name') === -1) d.name = undefined;\n  }\n\n  return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n  var container = opts.container;\n  var fullLayout = opts.fullLayout;\n  var gs = fullLayout._size;\n  var evt = opts.event;\n  var showY = !!closestPoints.hLinePoint;\n  var showX = !!closestPoints.vLinePoint;\n  var xa, ya; // Remove old spikeline items\n\n  container.selectAll('.spikeline').remove();\n  if (!(showX || showY)) return;\n  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor); // Horizontal line (to y-axis)\n\n  if (showY) {\n    var hLinePoint = closestPoints.hLinePoint;\n    var hLinePointX, hLinePointY;\n    xa = hLinePoint && hLinePoint.xa;\n    ya = hLinePoint && hLinePoint.ya;\n    var ySnap = ya.spikesnap;\n\n    if (ySnap === 'cursor') {\n      hLinePointX = evt.pointerX;\n      hLinePointY = evt.pointerY;\n    } else {\n      hLinePointX = xa._offset + hLinePoint.x;\n      hLinePointY = ya._offset + hLinePoint.y;\n    }\n\n    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;\n    var yMode = ya.spikemode;\n    var yThickness = ya.spikethickness;\n    var yColor = ya.spikecolor || dfltHLineColor;\n    var xEdge = Axes.getPxPosition(gd, ya);\n    var xBase, xEndSpike;\n\n    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n      if (yMode.indexOf('toaxis') !== -1) {\n        xBase = xEdge;\n        xEndSpike = hLinePointX;\n      }\n\n      if (yMode.indexOf('across') !== -1) {\n        var xAcross0 = ya._counterDomainMin;\n        var xAcross1 = ya._counterDomainMax;\n\n        if (ya.anchor === 'free') {\n          xAcross0 = Math.min(xAcross0, ya.position);\n          xAcross1 = Math.max(xAcross1, ya.position);\n        }\n\n        xBase = gs.l + xAcross0 * gs.w;\n        xEndSpike = gs.l + xAcross1 * gs.w;\n      } // Foreground horizontal line (to y-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness,\n        stroke: yColor,\n        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background horizontal Line (to y-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // Y axis marker\n\n\n    if (yMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n        cy: hLinePointY,\n        r: yThickness,\n        fill: yColor\n      }).classed('spikeline', true);\n    }\n  }\n\n  if (showX) {\n    var vLinePoint = closestPoints.vLinePoint;\n    var vLinePointX, vLinePointY;\n    xa = vLinePoint && vLinePoint.xa;\n    ya = vLinePoint && vLinePoint.ya;\n    var xSnap = xa.spikesnap;\n\n    if (xSnap === 'cursor') {\n      vLinePointX = evt.pointerX;\n      vLinePointY = evt.pointerY;\n    } else {\n      vLinePointX = xa._offset + vLinePoint.x;\n      vLinePointY = ya._offset + vLinePoint.y;\n    }\n\n    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;\n    var xMode = xa.spikemode;\n    var xThickness = xa.spikethickness;\n    var xColor = xa.spikecolor || dfltVLineColor;\n    var yEdge = Axes.getPxPosition(gd, xa);\n    var yBase, yEndSpike;\n\n    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n      if (xMode.indexOf('toaxis') !== -1) {\n        yBase = yEdge;\n        yEndSpike = vLinePointY;\n      }\n\n      if (xMode.indexOf('across') !== -1) {\n        var yAcross0 = xa._counterDomainMin;\n        var yAcross1 = xa._counterDomainMax;\n\n        if (xa.anchor === 'free') {\n          yAcross0 = Math.min(yAcross0, xa.position);\n          yAcross1 = Math.max(yAcross1, xa.position);\n        }\n\n        yBase = gs.t + (1 - yAcross1) * gs.h;\n        yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n      } // Foreground vertical line (to x-axis)\n\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness,\n        stroke: xColor,\n        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n      }).classed('spikeline', true).classed('crisp', true); // Background vertical line (to x-axis)\n\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    } // X axis marker\n\n\n    if (xMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: vLinePointX,\n        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n        r: xThickness,\n        fill: xColor\n      }).classed('spikeline', true);\n    }\n  }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n  // don't emit any events if nothing changed\n  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n  for (var i = oldhoverdata.length - 1; i >= 0; i--) {\n    var oldPt = oldhoverdata[i];\n    var newPt = gd._hoverdata[i];\n\n    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n  // don't relayout the plot because of new spikelines if spikelines points didn't change\n  if (!oldspikepoints) return true;\n  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;\n  return false;\n}\n\nfunction plainText(s, len) {\n  return svgTextUtils.plainText(s || '', {\n    len: len,\n    allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n  });\n}\n\nfunction orderRangePoints(hoverData, hovermode) {\n  var axLetter = hovermode.charAt(0);\n  var first = [];\n  var second = [];\n  var last = [];\n\n  for (var i = 0; i < hoverData.length; i++) {\n    var d = hoverData[i];\n\n    if (Registry.traceIs(d.trace, 'bar-like') || Registry.traceIs(d.trace, 'box-violin')) {\n      last.push(d);\n    } else if (d.trace[axLetter + 'period']) {\n      second.push(d);\n    } else {\n      first.push(d);\n    }\n  }\n\n  return first.concat(second).concat(last);\n}\n\nfunction getCoord(axLetter, winningPoint, fullLayout) {\n  var ax = winningPoint[axLetter + 'a'];\n  var val = winningPoint[axLetter + 'Val'];\n  var cd0 = winningPoint.cd[0];\n  if (ax.type === 'category') val = ax._categoriesMap[val];else if (ax.type === 'date') {\n    var periodalignment = winningPoint.trace[axLetter + 'periodalignment'];\n\n    if (periodalignment) {\n      var d = winningPoint.cd[winningPoint.index];\n      var start = d[axLetter + 'Start'];\n      if (start === undefined) start = d[axLetter];\n      var end = d[axLetter + 'End'];\n      if (end === undefined) end = d[axLetter];\n      var diff = end - start;\n\n      if (periodalignment === 'end') {\n        val += diff;\n      } else if (periodalignment === 'middle') {\n        val += diff / 2;\n      }\n    }\n\n    val = ax.d2c(val);\n  }\n\n  if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {\n    if (fullLayout.boxmode === 'group' || fullLayout.violinmode === 'group') {\n      val += cd0.t.dPos;\n    }\n  }\n\n  return val;\n} // Top/left hover offsets relative to graph div. As long as hover content is\n// a sibling of the graph div, it will be positioned correctly relative to\n// the offset parent, whatever that may be.\n\n\nfunction getTopOffset(gd) {\n  return gd.offsetTop + gd.clientTop;\n}\n\nfunction getLeftOffset(gd) {\n  return gd.offsetLeft + gd.clientLeft;\n}\n\nfunction getBoundingClientRect(gd, node) {\n  var fullLayout = gd._fullLayout;\n  var rect = node.getBoundingClientRect();\n  var x0 = rect.x;\n  var y0 = rect.y;\n  var x1 = x0 + rect.width;\n  var y1 = y0 + rect.height;\n  var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);\n  var Ax = A[0];\n  var Ay = A[1];\n  var Bx = B[0];\n  var By = B[1];\n  return {\n    x: Ax,\n    y: Ay,\n    width: Bx - Ax,\n    height: By - Ay,\n    top: Math.min(Ay, By),\n    left: Math.min(Ax, Bx),\n    right: Math.max(Ax, Bx),\n    bottom: Math.max(Ay, By)\n  };\n}","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/components/fx/hover.js"],"names":["d3","require","isNumeric","tinycolor","Lib","strTranslate","strRotate","Events","svgTextUtils","overrideCursor","Drawing","Color","dragElement","Axes","Registry","helpers","constants","legendSupplyDefaults","legendDraw","YANGLE","YA_RADIANS","Math","PI","YFACTOR","sin","YSHIFTX","cos","YSHIFTY","HOVERARROWSIZE","HOVERTEXTPAD","multipleHoverPoints","box","ohlc","violin","candlestick","cartesianScatterPoints","scatter","scattergl","splom","exports","hover","gd","evt","subplot","noHoverEvent","getGraphDiv","throttle","_fullLayout","_uid","HOVERID","HOVERMINTIME","_hover","loneHover","hoverItems","opts","multiHover","Array","isArray","gTop","getTopOffset","gLeft","getLeftOffset","pointsData","map","hoverItem","_x0","x0","x","_x1","x1","_y0","y0","y","_y1","y1","eventData","min","max","trace","traceIs","container","scene","_scene","dx","offsetLeft","dy","offsetTop","bbox","inOut_bbox","push","color","defaultLine","xLabel","yLabel","zLabel","text","name","idealAlign","borderColor","fontFamily","fontSize","fontColor","nameLength","textAlign","index","hoverinfo","xa","_offset","ya","hovertemplate","hovertemplateLabels","rotateLabels","hoverLabel","createHoverText","hovermode","bgColor","background","select","outerContainer","tooltipSpacing","lastBottomY","anchor","sort","a","b","each","d","i","topY","by","offset","anchorIndex","scaleX","_invScaleX","scaleY","_invScaleY","alignHoverText","node","subplots","fullLayout","plots","_plots","plotinfo","hasCartesian","_has","overlayedSubplots","overlays","pi","id","concat","len","length","xaArray","yaArray","supportsCompare","spId","xaxis","yaxis","_subplot","warn","indexOf","calcdata","querySelector","_dragging","unhoverRaw","hoverdistance","Infinity","spikedistance","hoverData","searchData","xvalArray","yvalArray","itemnum","curvenum","cd","subplotId","subploti","_mode","xval","yval","pointData","closedataPreviousLength","spikePoints","hLinePoint","vLinePoint","hasOneHorizontalTrace","curveNumber","orientation","isTraceInSubplots","hasUserCalledHover","target","xpx","ypx","_length","triggerHandler","composedPath","dbb","getBoundingClientRect","clientX","left","clientY","top","_calcInverseTransform","transformedCoords","apply3DTransform","_invTransform","pointerX","pointerY","flat","p2c","distance","findHoverPoints","customXVal","customYVal","visible","_module","type","getSubplot","isUnifiedHover","charAt","maxHoverDistance","maxSpikeDistance","spikeDistance","xSpike","undefined","ySpike","xLabelVal","yLabelVal","zLabelVal","_splomScenes","uid","selection","pointNumber","hoverPoints","newPoints","finiteRange","hoverLayer","_hoverlayer","newPoint","newPointNum","cleanPoint","log","splice","closestPoints","filter","point","tmpPoint","closestVPoints","showspikes","spikesnap","closestVPt","fillSpikePoint","closestHPoints","closestHPt","selectClosestPoint","spikeOnWinning","resultPoint","minDistance","thisSpikeDistance","spikelineOpts","event","oldspikepoints","_spikepoints","newspikepoints","sortHoverData","d1","d2","orderRangePoints","axLetter","tmpHPointData","tmpHPoint","tmpVPointData","tmpVPoint","result","spikesChanged","createSpikelines","isXYhover","winningPoint","initLen","winX","getCoord","winY","finalPoints","seen","insert","newHd","key","hoverDataKey","oldId","oldHd","abs","k","oldhoverdata","_hoverdata","newhoverdata","pt","makeEventData","ht","combine","plot_bgcolor","paper_bgcolor","hoverLabels","_paper","commonLabelOpts","hoverlabel","hoverAvoidOverlaps","tagName","hasClickToShow","getComponentMethod","hoverChanged","emit","points","xaxes","yaxes","xvals","yvals","attr","_id","join","EXTRA_STRING_REGEX","HOVERFONT","HOVERFONTSIZE","c0","t0","outerContainerBB","outerTop","outerWidth","width","outerHeight","height","showCommonLabel","allHaveZ","traceHoverinfo","parts","split","commonLabel","selectAll","data","enter","append","classed","exit","remove","label","lpath","ensureSingle","s","style","ltext","commonBgColor","bgcolor","commonStroke","bordercolor","contrast","contrastColor","commonLabelFont","family","font","size","fill","stroke","call","positionText","convertToTspans","tbb","lx","ly","topsign","side","bottom","halfWidth","sgn","leftsign","halfHeight","lty","clipId","clipPath","ltx","dummy","tester","dummyBB","round","textClip","_topclips","setClipUrl","mockLayoutIn","showlegend","legend","title","borderwidth","tracegroupgap","traceorder","mockLayoutOut","_fullData","mockLegend","entries","j","texts","getHoverLabelText","mc","mcc","mlc","mlcc","mlw","mrc","dir","_distinct","layer","_inHover","_groupTitleFont","legendContainer","tWidth","tHeight","avgX","avgY","pointWon","lyBottom","lyTop","apply","c","mean","lxRight","lxLeft","xOffset","yOffset","g","addOpacity","dColor","color0","numsColor","opacity","nameColor","tx","tx2","tx2width","tx2height","t2bb","htx","hty","tbbWidth","tbbHeight","ty0","bx","txwidth","txTotalWidth","anchorStartOK","anchorEndOK","pos","txHalfWidth","overflowR","overflowL","nameOverride","_meta","templateString","plainText","h0","h1","extraText","labels","hovertemplateString","_d3locale","replace","match","extra","axKey","nummoves","axSign","nLabels","pointgroups","ax","axIsX","rng","range","datum","traceIndex","dp","posref","pmin","pmax","donepositioning","topOverlap","bottomOverlap","pti","sumdp","constrainGroup","grp","minPt","maxPt","deleteCount","del","g0","g1","p0","p1","forEach","hoverPt","pX","pY","horzSign","alignShift","start","end","middle","txx","tx2x","offsetX","offsetY","isMiddle","posX","posY","setRect","cd0","pass","v","getVal","calcKey","traceKey","castOption","extractOption","val","constrain","hoverLabelText","xhoverformat","xVal","c2d","yhoverformat","yVal","String","isNaN","xerr","xeText","tickText","c2l","xerrneg","yerr","yeText","yerrneg","infomode","gs","_size","showY","showX","hLinePointX","hLinePointY","ySnap","dfltHLineColor","readability","yMode","spikemode","yThickness","spikethickness","yColor","spikecolor","xEdge","getPxPosition","xBase","xEndSpike","xAcross0","_counterDomainMin","xAcross1","_counterDomainMax","position","l","w","x2","y2","dashStyle","spikedash","cx","cy","r","vLinePointX","vLinePointY","xSnap","dfltVLineColor","xMode","xThickness","xColor","yEdge","yBase","yEndSpike","yAcross0","yAcross1","t","h","oldPt","newPt","pointNumbers","allowedTags","first","second","last","_categoriesMap","periodalignment","diff","d2c","posLetter","boxmode","violinmode","dPos","clientTop","clientLeft","rect","A","B","Ax","Ay","Bx","By","right"],"mappings":"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","sourcesContent":["'use strict';\n\nvar d3 = require('@plotly/d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar strTranslate = Lib.strTranslate;\nvar strRotate = Lib.strRotate;\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\n\nvar legendSupplyDefaults = require('../legend/defaults');\nvar legendDraw = require('../legend/draw');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\nvar multipleHoverPoints = {\n    box: true,\n    ohlc: true,\n    violin: true,\n    candlestick: true\n};\n\nvar cartesianScatterPoints = {\n    scatter: true,\n    scattergl: true,\n    splom: true\n};\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n    gd = Lib.getGraphDiv(gd);\n\n    Lib.throttle(\n        gd._fullLayout._uid + constants.HOVERID,\n        constants.HOVERMINTIME,\n        function() { _hover(gd, evt, subplot, noHoverEvent); }\n    );\n};\n\n/*\n * Draw a single hover item or an array of hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n * opts can have optional keys:\n *    - anchorIndex:\n        the index of the hover item used as an anchor for positioning.\n        The other hover items will be pushed up or down to prevent overlap.\n */\nexports.loneHover = function loneHover(hoverItems, opts) {\n    var multiHover = true;\n    if(!Array.isArray(hoverItems)) {\n        multiHover = false;\n        hoverItems = [hoverItems];\n    }\n\n    var gd = opts.gd;\n    var gTop = getTopOffset(gd);\n    var gLeft = getLeftOffset(gd);\n\n    var pointsData = hoverItems.map(function(hoverItem) {\n        var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;\n        var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;\n        var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;\n        var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;\n\n        var eventData = hoverItem.eventData;\n        if(eventData) {\n            var x0 = Math.min(_x0, _x1);\n            var x1 = Math.max(_x0, _x1);\n            var y0 = Math.min(_y0, _y1);\n            var y1 = Math.max(_y0, _y1);\n\n            var trace = hoverItem.trace;\n            if(Registry.traceIs(trace, 'gl3d')) {\n                var container = gd._fullLayout[trace.scene]._scene.container;\n                var dx = container.offsetLeft;\n                var dy = container.offsetTop;\n                x0 += dx;\n                x1 += dx;\n                y0 += dy;\n                y1 += dy;\n            } // TODO: handle heatmapgl\n\n            eventData.bbox = {\n                x0: x0 + gLeft,\n                x1: x1 + gLeft,\n                y0: y0 + gTop,\n                y1: y1 + gTop\n            };\n\n            if(opts.inOut_bbox) {\n                opts.inOut_bbox.push(eventData.bbox);\n            }\n        } else {\n            eventData = false;\n        }\n\n        return {\n            color: hoverItem.color || Color.defaultLine,\n            x0: hoverItem.x0 || hoverItem.x || 0,\n            x1: hoverItem.x1 || hoverItem.x || 0,\n            y0: hoverItem.y0 || hoverItem.y || 0,\n            y1: hoverItem.y1 || hoverItem.y || 0,\n            xLabel: hoverItem.xLabel,\n            yLabel: hoverItem.yLabel,\n            zLabel: hoverItem.zLabel,\n            text: hoverItem.text,\n            name: hoverItem.name,\n            idealAlign: hoverItem.idealAlign,\n\n            // optional extra bits of styling\n            borderColor: hoverItem.borderColor,\n            fontFamily: hoverItem.fontFamily,\n            fontSize: hoverItem.fontSize,\n            fontColor: hoverItem.fontColor,\n            nameLength: hoverItem.nameLength,\n            textAlign: hoverItem.textAlign,\n\n            // filler to make createHoverText happy\n            trace: hoverItem.trace || {\n                index: 0,\n                hoverinfo: ''\n            },\n            xa: {_offset: 0},\n            ya: {_offset: 0},\n            index: 0,\n\n            hovertemplate: hoverItem.hovertemplate || false,\n            hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n\n            eventData: eventData\n        };\n    });\n\n    var rotateLabels = false;\n\n    var hoverLabel = createHoverText(pointsData, {\n        gd: gd,\n        hovermode: 'closest',\n        rotateLabels: rotateLabels,\n        bgColor: opts.bgColor || Color.background,\n        container: d3.select(opts.container),\n        outerContainer: opts.outerContainer || opts.container\n    });\n\n    // Fix vertical overlap\n    var tooltipSpacing = 5;\n    var lastBottomY = 0;\n    var anchor = 0;\n    hoverLabel\n        .sort(function(a, b) {return a.y0 - b.y0;})\n        .each(function(d, i) {\n            var topY = d.y0 - d.by / 2;\n\n            if((topY - tooltipSpacing) < lastBottomY) {\n                d.offset = (lastBottomY - topY) + tooltipSpacing;\n            } else {\n                d.offset = 0;\n            }\n\n            lastBottomY = topY + d.by + d.offset;\n\n            if(i === opts.anchorIndex || 0) anchor = d.offset;\n        })\n        .each(function(d) {\n            d.offset -= anchor;\n        });\n\n    var scaleX = gd._fullLayout._invScaleX;\n    var scaleY = gd._fullLayout._invScaleY;\n    alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);\n\n    return multiHover ? hoverLabel : hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n    if(!subplot) subplot = 'xy';\n\n    // if the user passed in an array of subplots,\n    // use those instead of finding overlayed plots\n    var subplots = Array.isArray(subplot) ? subplot : [subplot];\n\n    var fullLayout = gd._fullLayout;\n    var plots = fullLayout._plots || [];\n    var plotinfo = plots[subplot];\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // list of all overlaid subplots to look at\n    if(plotinfo) {\n        var overlayedSubplots = plotinfo.overlays.map(function(pi) {\n            return pi.id;\n        });\n\n        subplots = subplots.concat(overlayedSubplots);\n    }\n\n    var len = subplots.length;\n    var xaArray = new Array(len);\n    var yaArray = new Array(len);\n    var supportsCompare = false;\n\n    for(var i = 0; i < len; i++) {\n        var spId = subplots[i];\n\n        if(plots[spId]) {\n            // 'cartesian' case\n            supportsCompare = true;\n            xaArray[i] = plots[spId].xaxis;\n            yaArray[i] = plots[spId].yaxis;\n        } else if(fullLayout[spId] && fullLayout[spId]._subplot) {\n            // other subplot types\n            var _subplot = fullLayout[spId]._subplot;\n            xaArray[i] = _subplot.xaxis;\n            yaArray[i] = _subplot.yaxis;\n        } else {\n            Lib.warn('Unrecognized subplot: ' + spId);\n            return;\n        }\n    }\n\n    var hovermode = evt.hovermode || fullLayout.hovermode;\n\n    if(hovermode && !supportsCompare) hovermode = 'closest';\n\n    if(['x', 'y', 'closest', 'x unified', 'y unified'].indexOf(hovermode) === -1 || !gd.calcdata ||\n            gd.querySelector('.zoombox') || gd._dragging) {\n        return dragElement.unhoverRaw(gd, evt);\n    }\n\n    var hoverdistance = fullLayout.hoverdistance;\n    if(hoverdistance === -1) hoverdistance = Infinity;\n\n    var spikedistance = fullLayout.spikedistance;\n    if(spikedistance === -1) spikedistance = Infinity;\n\n    // hoverData: the set of candidate points we've found to highlight\n    var hoverData = [];\n\n    // searchData: the data to search in. Mostly this is just a copy of\n    // gd.calcdata, filtered to the subplot and overlays we're on\n    // but if a point array is supplied it will be a mapping\n    // of indicated curves\n    var searchData = [];\n\n    // [x|y]valArray: the axis values of the hover event\n    // mapped onto each of the currently selected overlaid subplots\n    var xvalArray, yvalArray;\n\n    var itemnum, curvenum, cd, trace, subplotId, subploti, _mode,\n        xval, yval, pointData, closedataPreviousLength;\n\n    // spikePoints: the set of candidate points we've found to draw spikes to\n    var spikePoints = {\n        hLinePoint: null,\n        vLinePoint: null\n    };\n\n    // does subplot have one (or more) horizontal traces?\n    // This is used to determine whether we rotate the labels or not\n    var hasOneHorizontalTrace = false;\n\n    // Figure out what we're hovering on:\n    // mouse location or user-supplied data\n\n    if(Array.isArray(evt)) {\n        // user specified an array of points to highlight\n        hovermode = 'array';\n        for(itemnum = 0; itemnum < evt.length; itemnum++) {\n            cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n            if(cd) {\n                trace = cd[0].trace;\n                if(cd[0].trace.hoverinfo !== 'skip') {\n                    searchData.push(cd);\n                    if(trace.orientation === 'h') {\n                        hasOneHorizontalTrace = true;\n                    }\n                }\n            }\n        }\n    } else {\n        for(curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n            cd = gd.calcdata[curvenum];\n            trace = cd[0].trace;\n            if(trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n                searchData.push(cd);\n                if(trace.orientation === 'h') {\n                    hasOneHorizontalTrace = true;\n                }\n            }\n        }\n\n        // [x|y]px: the pixels (from top left) of the mouse location\n        // on the currently selected plot area\n        // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n        var hasUserCalledHover = !evt.target;\n        var xpx, ypx;\n\n        if(hasUserCalledHover) {\n            if('xpx' in evt) xpx = evt.xpx;\n            else xpx = xaArray[0]._length / 2;\n\n            if('ypx' in evt) ypx = evt.ypx;\n            else ypx = yaArray[0]._length / 2;\n        } else {\n            // fire the beforehover event and quit if it returns false\n            // note that we're only calling this on real mouse events, so\n            // manual calls to fx.hover will always run.\n            if(Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n                return;\n            }\n\n            // Discover event target, traversing open shadow roots.\n            var target = evt.composedPath && evt.composedPath()[0];\n            if(!target) {\n                // Fallback for browsers not supporting composedPath\n                target = evt.target;\n            }\n            var dbb = target.getBoundingClientRect();\n\n            xpx = evt.clientX - dbb.left;\n            ypx = evt.clientY - dbb.top;\n\n            fullLayout._calcInverseTransform(gd);\n            var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);\n\n            xpx = transformedCoords[0];\n            ypx = transformedCoords[1];\n\n            // in case hover was called from mouseout into hovertext,\n            // it's possible you're not actually over the plot anymore\n            if(xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n                return dragElement.unhoverRaw(gd, evt);\n            }\n        }\n\n        evt.pointerX = xpx + xaArray[0]._offset;\n        evt.pointerY = ypx + yaArray[0]._offset;\n\n        if('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);\n        else xvalArray = helpers.p2c(xaArray, xpx);\n\n        if('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);\n        else yvalArray = helpers.p2c(yaArray, ypx);\n\n        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n            Lib.warn('Fx.hover failed', evt, gd);\n            return dragElement.unhoverRaw(gd, evt);\n        }\n    }\n\n    // the pixel distance to beat as a matching point\n    // in 'x' or 'y' mode this resets for each trace\n    var distance = Infinity;\n\n    // find the closest point in each trace\n    // this is minimum dx and/or dy, depending on mode\n    // and the pixel position for the label (labelXpx, labelYpx)\n    function findHoverPoints(customXVal, customYVal) {\n        for(curvenum = 0; curvenum < searchData.length; curvenum++) {\n            cd = searchData[curvenum];\n\n            // filter out invisible or broken data\n            if(!cd || !cd[0] || !cd[0].trace) continue;\n\n            trace = cd[0].trace;\n\n            if(trace.visible !== true || trace._length === 0) continue;\n\n            // Explicitly bail out for these two. I don't know how to otherwise prevent\n            // the rest of this function from running and failing\n            if(['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n            if(trace.type === 'splom') {\n                // splom traces do not generate overlay subplots,\n                // it is safe to assume here splom traces correspond to the 0th subplot\n                subploti = 0;\n                subplotId = subplots[subploti];\n            } else {\n                subplotId = helpers.getSubplot(trace);\n                subploti = subplots.indexOf(subplotId);\n            }\n\n            // within one trace mode can sometimes be overridden\n            _mode = hovermode;\n            if(helpers.isUnifiedHover(_mode)) {\n                _mode = _mode.charAt(0);\n            }\n\n            // container for new point, also used to pass info into module.hoverPoints\n            pointData = {\n                // trace properties\n                cd: cd,\n                trace: trace,\n                xa: xaArray[subploti],\n                ya: yaArray[subploti],\n\n                // max distances for hover and spikes - for points that want to show but do not\n                // want to override other points, set distance/spikeDistance equal to max*Distance\n                // and it will not get filtered out but it will be guaranteed to have a greater\n                // distance than any point that calculated a real distance.\n                maxHoverDistance: hoverdistance,\n                maxSpikeDistance: spikedistance,\n\n                // point properties - override all of these\n                index: false, // point index in trace - only used by plotly.js hoverdata consumers\n                distance: Math.min(distance, hoverdistance), // pixel distance or pseudo-distance\n\n                // distance/pseudo-distance for spikes. This distance should always be calculated\n                // as if in \"closest\" mode, and should only be set if this point should\n                // generate a spike.\n                spikeDistance: Infinity,\n\n                // in some cases the spikes have different positioning from the hover label\n                // they don't need x0/x1, just one position\n                xSpike: undefined,\n                ySpike: undefined,\n\n                // where and how to display the hover label\n                color: Color.defaultLine, // trace color\n                name: trace.name,\n                x0: undefined,\n                x1: undefined,\n                y0: undefined,\n                y1: undefined,\n                xLabelVal: undefined,\n                yLabelVal: undefined,\n                zLabelVal: undefined,\n                text: undefined\n            };\n\n            // add ref to subplot object (non-cartesian case)\n            if(fullLayout[subplotId]) {\n                pointData.subplot = fullLayout[subplotId]._subplot;\n            }\n            // add ref to splom scene\n            if(fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n                pointData.scene = fullLayout._splomScenes[trace.uid];\n            }\n\n            closedataPreviousLength = hoverData.length;\n\n            // for a highlighting array, figure out what\n            // we're searching for with this element\n            if(_mode === 'array') {\n                var selection = evt[curvenum];\n                if('pointNumber' in selection) {\n                    pointData.index = selection.pointNumber;\n                    _mode = 'closest';\n                } else {\n                    _mode = '';\n                    if('xval' in selection) {\n                        xval = selection.xval;\n                        _mode = 'x';\n                    }\n                    if('yval' in selection) {\n                        yval = selection.yval;\n                        _mode = _mode ? 'closest' : 'y';\n                    }\n                }\n            } else if(customXVal !== undefined && customYVal !== undefined) {\n                xval = customXVal;\n                yval = customYVal;\n            } else {\n                xval = xvalArray[subploti];\n                yval = yvalArray[subploti];\n            }\n\n            // Now if there is range to look in, find the points to hover.\n            if(hoverdistance !== 0) {\n                if(trace._module && trace._module.hoverPoints) {\n                    var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {\n                        finiteRange: true,\n                        hoverLayer: fullLayout._hoverlayer\n                    });\n\n                    if(newPoints) {\n                        var newPoint;\n                        for(var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n                            newPoint = newPoints[newPointNum];\n                            if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                                hoverData.push(cleanPoint(newPoint, hovermode));\n                            }\n                        }\n                    }\n                } else {\n                    Lib.log('Unrecognized trace type in hover:', trace);\n                }\n            }\n\n            // in closest mode, remove any existing (farther) points\n            // and don't look any farther than this latest point (or points, some\n            // traces like box & violin make multiple hover labels at once)\n            if(hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n                hoverData.splice(0, closedataPreviousLength);\n                distance = hoverData[0].distance;\n            }\n\n            // Now if there is range to look in, find the points to draw the spikelines\n            // Do it only if there is no hoverData\n            if(hasCartesian && (spikedistance !== 0)) {\n                if(hoverData.length === 0) {\n                    pointData.distance = spikedistance;\n                    pointData.index = false;\n                    var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', {\n                        hoverLayer: fullLayout._hoverlayer\n                    });\n                    if(closestPoints) {\n                        closestPoints = closestPoints.filter(function(point) {\n                            // some hover points, like scatter fills, do not allow spikes,\n                            // so will generate a hover point but without a valid spikeDistance\n                            return point.spikeDistance <= spikedistance;\n                        });\n                    }\n                    if(closestPoints && closestPoints.length) {\n                        var tmpPoint;\n                        var closestVPoints = closestPoints.filter(function(point) {\n                            return point.xa.showspikes && point.xa.spikesnap !== 'hovered data';\n                        });\n                        if(closestVPoints.length) {\n                            var closestVPt = closestVPoints[0];\n                            if(isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                                tmpPoint = fillSpikePoint(closestVPt);\n                                if(!spikePoints.vLinePoint || (spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                    spikePoints.vLinePoint = tmpPoint;\n                                }\n                            }\n                        }\n\n                        var closestHPoints = closestPoints.filter(function(point) {\n                            return point.ya.showspikes && point.ya.spikesnap !== 'hovered data';\n                        });\n                        if(closestHPoints.length) {\n                            var closestHPt = closestHPoints[0];\n                            if(isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                                tmpPoint = fillSpikePoint(closestHPt);\n                                if(!spikePoints.hLinePoint || (spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                    spikePoints.hLinePoint = tmpPoint;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    findHoverPoints();\n\n    function selectClosestPoint(pointsData, spikedistance, spikeOnWinning) {\n        var resultPoint = null;\n        var minDistance = Infinity;\n        var thisSpikeDistance;\n\n        for(var i = 0; i < pointsData.length; i++) {\n            thisSpikeDistance = pointsData[i].spikeDistance;\n            if(spikeOnWinning && i === 0) thisSpikeDistance = -Infinity;\n\n            if(thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance) {\n                resultPoint = pointsData[i];\n                minDistance = thisSpikeDistance;\n            }\n        }\n        return resultPoint;\n    }\n\n    function fillSpikePoint(point) {\n        if(!point) return null;\n        return {\n            xa: point.xa,\n            ya: point.ya,\n            x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n            y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n            distance: point.distance,\n            spikeDistance: point.spikeDistance,\n            curveNumber: point.trace.index,\n            color: point.color,\n            pointNumber: point.index\n        };\n    }\n\n    var spikelineOpts = {\n        fullLayout: fullLayout,\n        container: fullLayout._hoverlayer,\n        event: evt\n    };\n    var oldspikepoints = gd._spikepoints;\n    var newspikepoints = {\n        vLinePoint: spikePoints.vLinePoint,\n        hLinePoint: spikePoints.hLinePoint\n    };\n    gd._spikepoints = newspikepoints;\n\n    var sortHoverData = function() {\n        hoverData.sort(function(d1, d2) { return d1.distance - d2.distance; });\n\n        // move period positioned points and box/bar-like traces to the end of the list\n        hoverData = orderRangePoints(hoverData, hovermode);\n    };\n    sortHoverData();\n\n    var axLetter = hovermode.charAt(0);\n    var spikeOnWinning = (axLetter === 'x' || axLetter === 'y') && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];\n\n    // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n    if(hasCartesian && (spikedistance !== 0)) {\n        if(hoverData.length !== 0) {\n            var tmpHPointData = hoverData.filter(function(point) {\n                return point.ya.showspikes;\n            });\n            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);\n            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n\n            var tmpVPointData = hoverData.filter(function(point) {\n                return point.xa.showspikes;\n            });\n            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);\n            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n        }\n    }\n\n    // if hoverData is empty check for the spikes to draw and quit if there are none\n    if(hoverData.length === 0) {\n        var result = dragElement.unhoverRaw(gd, evt);\n        if(hasCartesian && ((spikePoints.hLinePoint !== null) || (spikePoints.vLinePoint !== null))) {\n            if(spikesChanged(oldspikepoints)) {\n                createSpikelines(gd, spikePoints, spikelineOpts);\n            }\n        }\n        return result;\n    }\n\n    if(hasCartesian) {\n        if(spikesChanged(oldspikepoints)) {\n            createSpikelines(gd, spikePoints, spikelineOpts);\n        }\n    }\n\n    if(\n        helpers.isXYhover(_mode) &&\n        hoverData[0].length !== 0 &&\n        hoverData[0].trace.type !== 'splom' // TODO: add support for splom\n    ) {\n        // pick winning point\n        var winningPoint = hoverData[0];\n        // discard other points\n        if(multipleHoverPoints[winningPoint.trace.type]) {\n            hoverData = hoverData.filter(function(d) {\n                return d.trace.index === winningPoint.trace.index;\n            });\n        } else {\n            hoverData = [winningPoint];\n        }\n        var initLen = hoverData.length;\n\n        var winX = getCoord('x', winningPoint, fullLayout);\n        var winY = getCoord('y', winningPoint, fullLayout);\n\n        // in compare mode, select every point at position\n        findHoverPoints(winX, winY);\n\n        var finalPoints = [];\n        var seen = {};\n        var id = 0;\n        var insert = function(newHd) {\n            var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;\n            if(!seen[key]) {\n                id++;\n                seen[key] = id;\n                finalPoints.push(newHd);\n            } else {\n                var oldId = seen[key] - 1;\n                var oldHd = finalPoints[oldId];\n                if(oldId > 0 &&\n                    Math.abs(newHd.distance) <\n                    Math.abs(oldHd.distance)\n                ) {\n                    // replace with closest\n                    finalPoints[oldId] = newHd;\n                }\n            }\n        };\n\n        var k;\n        // insert the winnig point(s) first\n        for(k = 0; k < initLen; k++) {\n            insert(hoverData[k]);\n        }\n        // override from the end\n        for(k = hoverData.length - 1; k > initLen - 1; k--) {\n            insert(hoverData[k]);\n        }\n        hoverData = finalPoints;\n        sortHoverData();\n    }\n\n    // lastly, emit custom hover/unhover events\n    var oldhoverdata = gd._hoverdata;\n    var newhoverdata = [];\n\n    var gTop = getTopOffset(gd);\n    var gLeft = getLeftOffset(gd);\n\n    // pull out just the data that's useful to\n    // other people and send it to the event\n    for(itemnum = 0; itemnum < hoverData.length; itemnum++) {\n        var pt = hoverData[itemnum];\n        var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n        if(pt.hovertemplate !== false) {\n            var ht = false;\n            if(pt.cd[pt.index] && pt.cd[pt.index].ht) {\n                ht = pt.cd[pt.index].ht;\n            }\n            pt.hovertemplate = ht || pt.trace.hovertemplate || false;\n        }\n\n        if(pt.xa && pt.ya) {\n            var _x0 = pt.x0 + pt.xa._offset;\n            var _x1 = pt.x1 + pt.xa._offset;\n            var _y0 = pt.y0 + pt.ya._offset;\n            var _y1 = pt.y1 + pt.ya._offset;\n\n            var x0 = Math.min(_x0, _x1);\n            var x1 = Math.max(_x0, _x1);\n            var y0 = Math.min(_y0, _y1);\n            var y1 = Math.max(_y0, _y1);\n\n            eventData.bbox = {\n                x0: x0 + gLeft,\n                x1: x1 + gLeft,\n                y0: y0 + gTop,\n                y1: y1 + gTop\n            };\n        }\n\n        pt.eventData = [eventData];\n        newhoverdata.push(eventData);\n    }\n\n    gd._hoverdata = newhoverdata;\n\n    var rotateLabels = (\n        (hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1)) ||\n        (hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1)\n    );\n\n    var bgColor = Color.combine(\n        fullLayout.plot_bgcolor || Color.background,\n        fullLayout.paper_bgcolor\n    );\n\n    var hoverLabels = createHoverText(hoverData, {\n        gd: gd,\n        hovermode: hovermode,\n        rotateLabels: rotateLabels,\n        bgColor: bgColor,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paper.node(),\n        commonLabelOpts: fullLayout.hoverlabel,\n        hoverdistance: fullLayout.hoverdistance\n    });\n\n    if(!helpers.isUnifiedHover(hovermode)) {\n        hoverAvoidOverlaps(hoverLabels, rotateLabels ? 'xa' : 'ya', fullLayout);\n        alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);\n    }    // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n    // we should improve the \"fx\" API so other plots can use it without these hack.\n    if(evt.target && evt.target.tagName) {\n        var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n        overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n    }\n\n    // don't emit events if called manually\n    if(!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n    if(oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n\n    gd.emit('plotly_hover', {\n        event: evt,\n        points: gd._hoverdata,\n        xaxes: xaArray,\n        yaxes: yaArray,\n        xvals: xvalArray,\n        yvals: yvalArray\n    });\n}\n\nfunction hoverDataKey(d) {\n    return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : '', d.ya ? d.ya._id : ''].join(',');\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts) {\n    var gd = opts.gd;\n    var fullLayout = gd._fullLayout;\n    var hovermode = opts.hovermode;\n    var rotateLabels = opts.rotateLabels;\n    var bgColor = opts.bgColor;\n    var container = opts.container;\n    var outerContainer = opts.outerContainer;\n    var commonLabelOpts = opts.commonLabelOpts || {};\n\n    // opts.fontFamily/Size are used for the common label\n    // and as defaults for each hover label, though the individual labels\n    // can override this.\n    var fontFamily = opts.fontFamily || constants.HOVERFONT;\n    var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n\n    var c0 = hoverData[0];\n    var xa = c0.xa;\n    var ya = c0.ya;\n    var axLetter = hovermode.charAt(0);\n    var t0 = c0[axLetter + 'Label'];\n    var outerContainerBB = getBoundingClientRect(gd, outerContainer);\n    var outerTop = outerContainerBB.top;\n    var outerWidth = outerContainerBB.width;\n    var outerHeight = outerContainerBB.height;\n\n    // show the common label, if any, on the axis\n    // never show a common label in array mode,\n    // even if sometimes there could be one\n    var showCommonLabel = (\n        (t0 !== undefined) &&\n        (c0.distance <= opts.hoverdistance) &&\n        (hovermode === 'x' || hovermode === 'y')\n    );\n\n    // all hover traces hoverinfo must contain the hovermode\n    // to have common labels\n    if(showCommonLabel) {\n        var allHaveZ = true;\n        var i, traceHoverinfo;\n        for(i = 0; i < hoverData.length; i++) {\n            if(allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n\n            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n            if(traceHoverinfo) {\n                var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n                if(parts.indexOf('all') === -1 &&\n                    parts.indexOf(hovermode) === -1) {\n                    showCommonLabel = false;\n                    break;\n                }\n            }\n        }\n\n        // xyz labels put all info in their main label, so have no need of a common label\n        if(allHaveZ) showCommonLabel = false;\n    }\n\n    var commonLabel = container.selectAll('g.axistext')\n        .data(showCommonLabel ? [0] : []);\n    commonLabel.enter().append('g')\n        .classed('axistext', true);\n    commonLabel.exit().remove();\n\n    commonLabel.each(function() {\n        var label = d3.select(this);\n        var lpath = Lib.ensureSingle(label, 'path', '', function(s) {\n            s.style({'stroke-width': '1px'});\n        });\n        var ltext = Lib.ensureSingle(label, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n        var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n        var contrastColor = Color.contrast(commonBgColor);\n        var commonLabelFont = {\n            family: commonLabelOpts.font.family || fontFamily,\n            size: commonLabelOpts.font.size || fontSize,\n            color: commonLabelOpts.font.color || contrastColor\n        };\n\n        lpath.style({\n            fill: commonBgColor,\n            stroke: commonStroke\n        });\n\n        ltext.text(t0)\n            .call(Drawing.font, commonLabelFont)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        label.attr('transform', '');\n\n        var tbb = getBoundingClientRect(gd, ltext.node());\n        var lx, ly;\n\n        if(hovermode === 'x') {\n            var topsign = xa.side === 'top' ? '-' : '';\n\n            ltext.attr('text-anchor', 'middle')\n                .call(svgTextUtils.positionText, 0, (xa.side === 'top' ?\n                    (outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD) :\n                    (outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD)));\n\n            lx = xa._offset + (c0.x0 + c0.x1) / 2;\n            ly = ya._offset + (xa.side === 'top' ? 0 : ya._length);\n\n            var halfWidth = tbb.width / 2 + HOVERTEXTPAD;\n\n            if(lx < halfWidth) {\n                lx = halfWidth;\n\n                lpath.attr('d', 'M-' + (halfWidth - HOVERARROWSIZE) + ',0' +\n                    'L-' + (halfWidth - HOVERARROWSIZE * 2) + ',' + topsign + HOVERARROWSIZE +\n                    'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + halfWidth +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'Z');\n            } else if(lx > (fullLayout.width - halfWidth)) {\n                lx = fullLayout.width - halfWidth;\n\n                lpath.attr('d', 'M' + (halfWidth - HOVERARROWSIZE) + ',0' +\n                    'L' + halfWidth + ',' + topsign + HOVERARROWSIZE +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + halfWidth +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'H' + (halfWidth - HOVERARROWSIZE * 2) + 'Z');\n            } else {\n                lpath.attr('d', 'M0,0' +\n                    'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE +\n                    'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                    'H-' + (HOVERTEXTPAD + tbb.width / 2) +\n                    'V' + topsign + HOVERARROWSIZE +\n                    'H-' + HOVERARROWSIZE + 'Z');\n            }\n        } else {\n            var anchor;\n            var sgn;\n            var leftsign;\n            if(ya.side === 'right') {\n                anchor = 'start';\n                sgn = 1;\n                leftsign = '';\n                lx = xa._offset + xa._length;\n            } else {\n                anchor = 'end';\n                sgn = -1;\n                leftsign = '-';\n                lx = xa._offset;\n            }\n\n            ly = ya._offset + (c0.y0 + c0.y1) / 2;\n\n            ltext.attr('text-anchor', anchor);\n\n            lpath.attr('d', 'M0,0' +\n                'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE +\n                'V' + (HOVERTEXTPAD + tbb.height / 2) +\n                'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) +\n                'V-' + (HOVERTEXTPAD + tbb.height / 2) +\n                'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n\n            var halfHeight = tbb.height / 2;\n            var lty = outerTop - tbb.top - halfHeight;\n            var clipId = 'clip' + fullLayout._uid + 'commonlabel' + ya._id;\n            var clipPath;\n\n            if(lx < (tbb.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE)) {\n                clipPath = 'M-' + (HOVERARROWSIZE + HOVERTEXTPAD) + '-' + halfHeight +\n                    'h-' + (tbb.width - HOVERTEXTPAD) +\n                    'V' + halfHeight +\n                    'h' + (tbb.width - HOVERTEXTPAD) + 'Z';\n\n                var ltx = tbb.width - lx + HOVERTEXTPAD;\n                svgTextUtils.positionText(ltext, ltx, lty);\n\n                // shift each line (except the longest) so that start-of-line\n                // is always visible\n                if(anchor === 'end') {\n                    ltext.selectAll('tspan').each(function() {\n                        var s = d3.select(this);\n                        var dummy = Drawing.tester.append('text')\n                            .text(s.text())\n                            .call(Drawing.font, commonLabelFont);\n                        var dummyBB = getBoundingClientRect(gd, dummy.node());\n                        if(Math.round(dummyBB.width) < Math.round(tbb.width)) {\n                            s.attr('x', ltx - dummyBB.width);\n                        }\n                        dummy.remove();\n                    });\n                }\n            } else {\n                svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);\n                clipPath = null;\n            }\n\n            var textClip = fullLayout._topclips.selectAll('#' + clipId).data(clipPath ? [0] : []);\n            textClip.enter().append('clipPath').attr('id', clipId).append('path');\n            textClip.exit().remove();\n            textClip.select('path').attr('d', clipPath);\n            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);\n        }\n\n        label.attr('transform', strTranslate(lx, ly));\n    });\n\n    // Show a single hover label\n    if(helpers.isUnifiedHover(hovermode)) {\n        // Delete leftover hover labels from other hovermodes\n        container.selectAll('g.hovertext').remove();\n\n        // Return early if nothing is hovered on\n        if(hoverData.length === 0) return;\n\n        // mock legend\n        var hoverlabel = fullLayout.hoverlabel;\n        var font = hoverlabel.font;\n        var mockLayoutIn = {\n            showlegend: true,\n            legend: {\n                title: {text: t0, font: font},\n                font: font,\n                bgcolor: hoverlabel.bgcolor,\n                bordercolor: hoverlabel.bordercolor,\n                borderwidth: 1,\n                tracegroupgap: 7,\n                traceorder: fullLayout.legend ? fullLayout.legend.traceorder : undefined,\n                orientation: 'v'\n            }\n        };\n        var mockLayoutOut = {};\n        legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);\n        var mockLegend = mockLayoutOut.legend;\n\n        // prepare items for the legend\n        mockLegend.entries = [];\n        for(var j = 0; j < hoverData.length; j++) {\n            var texts = getHoverLabelText(hoverData[j], true, hovermode, fullLayout, t0);\n            var text = texts[0];\n            var name = texts[1];\n            var pt = hoverData[j];\n            pt.name = name;\n            if(name !== '') {\n                pt.text = name + ' : ' + text;\n            } else {\n                pt.text = text;\n            }\n\n            // pass through marker's calcdata to style legend items\n            var cd = pt.cd[pt.index];\n            if(cd) {\n                if(cd.mc) pt.mc = cd.mc;\n                if(cd.mcc) pt.mc = cd.mcc;\n                if(cd.mlc) pt.mlc = cd.mlc;\n                if(cd.mlcc) pt.mlc = cd.mlcc;\n                if(cd.mlw) pt.mlw = cd.mlw;\n                if(cd.mrc) pt.mrc = cd.mrc;\n                if(cd.dir) pt.dir = cd.dir;\n            }\n            pt._distinct = true;\n\n            mockLegend.entries.push([pt]);\n        }\n        mockLegend.entries.sort(function(a, b) { return a[0].trace.index - b[0].trace.index;});\n        mockLegend.layer = container;\n\n        // Draw unified hover label\n        mockLegend._inHover = true;\n        mockLegend._groupTitleFont = font;\n        legendDraw(gd, mockLegend);\n\n        // Position the hover\n        var legendContainer = container.select('g.legend');\n        var tbb = getBoundingClientRect(gd, legendContainer.node());\n        var tWidth = tbb.width + 2 * HOVERTEXTPAD;\n        var tHeight = tbb.height + 2 * HOVERTEXTPAD;\n        var winningPoint = hoverData[0];\n        var avgX = (winningPoint.x0 + winningPoint.x1) / 2;\n        var avgY = (winningPoint.y0 + winningPoint.y1) / 2;\n        // When a scatter (or e.g. heatmap) point wins, it's OK for the hovelabel to occlude the bar and other points.\n        var pointWon = !(\n            Registry.traceIs(winningPoint.trace, 'bar-like') ||\n            Registry.traceIs(winningPoint.trace, 'box-violin')\n        );\n\n        var lyBottom, lyTop;\n        if(axLetter === 'y') {\n            if(pointWon) {\n                lyTop = avgY - HOVERTEXTPAD;\n                lyBottom = avgY + HOVERTEXTPAD;\n            } else {\n                lyTop = Math.min.apply(null, hoverData.map(function(c) { return Math.min(c.y0, c.y1); }));\n                lyBottom = Math.max.apply(null, hoverData.map(function(c) { return Math.max(c.y0, c.y1); }));\n            }\n        } else {\n            lyTop = lyBottom = Lib.mean(hoverData.map(function(c) { return (c.y0 + c.y1) / 2; })) - tHeight / 2;\n        }\n\n        var lxRight, lxLeft;\n        if(axLetter === 'x') {\n            if(pointWon) {\n                lxRight = avgX + HOVERTEXTPAD;\n                lxLeft = avgX - HOVERTEXTPAD;\n            } else {\n                lxRight = Math.max.apply(null, hoverData.map(function(c) { return Math.max(c.x0, c.x1); }));\n                lxLeft = Math.min.apply(null, hoverData.map(function(c) { return Math.min(c.x0, c.x1); }));\n            }\n        } else {\n            lxRight = lxLeft = Lib.mean(hoverData.map(function(c) { return (c.x0 + c.x1) / 2; })) - tWidth / 2;\n        }\n\n        var xOffset = xa._offset;\n        var yOffset = ya._offset;\n        lyBottom += yOffset;\n        lxRight += xOffset;\n        lxLeft += xOffset - tWidth;\n        lyTop += yOffset - tHeight;\n\n        var lx, ly; // top and left positions of the hover box\n\n        // horizontal alignment to end up on screen\n        if(lxRight + tWidth < outerWidth && lxRight >= 0) {\n            lx = lxRight;\n        } else if(lxLeft + tWidth < outerWidth && lxLeft >= 0) {\n            lx = lxLeft;\n        } else if(xOffset + tWidth < outerWidth) {\n            lx = xOffset; // subplot left corner\n        } else {\n            // closest left or right side of the paper\n            if(lxRight - avgX < avgX - lxLeft + tWidth) {\n                lx = outerWidth - tWidth;\n            } else {\n                lx = 0;\n            }\n        }\n        lx += HOVERTEXTPAD;\n\n        // vertical alignement to end up on screen\n        if(lyBottom + tHeight < outerHeight && lyBottom >= 0) {\n            ly = lyBottom;\n        } else if(lyTop + tHeight < outerHeight && lyTop >= 0) {\n            ly = lyTop;\n        } else if(yOffset + tHeight < outerHeight) {\n            ly = yOffset; // subplot top corner\n        } else {\n            // closest top or bottom side of the paper\n            if(lyBottom - avgY < avgY - lyTop + tHeight) {\n                ly = outerHeight - tHeight;\n            } else {\n                ly = 0;\n            }\n        }\n        ly += HOVERTEXTPAD;\n\n        legendContainer.attr('transform', strTranslate(lx - 1, ly - 1));\n        return legendContainer;\n    }\n\n    // show all the individual labels\n\n    // first create the objects\n    var hoverLabels = container.selectAll('g.hovertext')\n        .data(hoverData, function(d) {\n            // N.B. when multiple items have the same result key-function value,\n            // only the first of those items in hoverData gets rendered\n            return hoverDataKey(d);\n        });\n    hoverLabels.enter().append('g')\n        .classed('hovertext', true)\n        .each(function() {\n            var g = d3.select(this);\n            // trace name label (rect and text.name)\n            g.append('rect')\n                .call(Color.fill, Color.addOpacity(bgColor, 0.8));\n            g.append('text').classed('name', true);\n            // trace data label (path and text.nums)\n            g.append('path')\n                .style('stroke-width', '1px');\n            g.append('text').classed('nums', true)\n                .call(Drawing.font, fontFamily, fontSize);\n        });\n    hoverLabels.exit().remove();\n\n    // then put the text in, position the pointer to the data,\n    // and figure out sizes\n    hoverLabels.each(function(d) {\n        var g = d3.select(this).attr('transform', '');\n\n        var dColor = d.color;\n        if(Array.isArray(dColor)) {\n            dColor = dColor[d.eventData[0].pointNumber];\n        }\n\n        // combine possible non-opaque trace color with bgColor\n        var color0 = d.bgcolor || dColor;\n        // color for 'nums' part of the label\n        var numsColor = Color.combine(\n            Color.opacity(color0) ? color0 : Color.defaultLine,\n            bgColor\n        );\n        // color for 'name' part of the label\n        var nameColor = Color.combine(\n            Color.opacity(dColor) ? dColor : Color.defaultLine,\n            bgColor\n        );\n        // find a contrasting color for border and text\n        var contrastColor = d.borderColor || Color.contrast(numsColor);\n\n        var texts = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);\n        var text = texts[0];\n        var name = texts[1];\n\n        // main label\n        var tx = g.select('text.nums')\n            .call(Drawing.font,\n                d.fontFamily || fontFamily,\n                d.fontSize || fontSize,\n                d.fontColor || contrastColor)\n            .text(text)\n            .attr('data-notex', 1)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        var tx2 = g.select('text.name');\n        var tx2width = 0;\n        var tx2height = 0;\n\n        // secondary label for non-empty 'name'\n        if(name && name !== text) {\n            tx2.call(Drawing.font,\n                    d.fontFamily || fontFamily,\n                    d.fontSize || fontSize,\n                    nameColor)\n                .text(name)\n                .attr('data-notex', 1)\n                .call(svgTextUtils.positionText, 0, 0)\n                .call(svgTextUtils.convertToTspans, gd);\n\n            var t2bb = getBoundingClientRect(gd, tx2.node());\n            tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n            tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n        } else {\n            tx2.remove();\n            g.select('rect').remove();\n        }\n\n        g.select('path').style({\n            fill: numsColor,\n            stroke: contrastColor\n        });\n\n        var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n        var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n        var dx = Math.abs(d.x1 - d.x0);\n        var dy = Math.abs(d.y1 - d.y0);\n\n        var tbb = getBoundingClientRect(gd, tx.node());\n        var tbbWidth = tbb.width / fullLayout._invScaleX;\n        var tbbHeight = tbb.height / fullLayout._invScaleY;\n\n        d.ty0 = (outerTop - tbb.top) / fullLayout._invScaleY;\n        d.bx = tbbWidth + 2 * HOVERTEXTPAD;\n        d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);\n        d.anchor = 'start';\n        d.txwidth = tbbWidth;\n        d.tx2width = tx2width;\n        d.offset = 0;\n\n        var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;\n        var anchorStartOK, anchorEndOK;\n\n        if(rotateLabels) {\n            d.pos = htx;\n            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n                hty -= dy / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                hty += dy / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        } else {\n            d.pos = hty;\n            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n\n            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n                htx -= dx / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                htx += dx / 2;\n                d.anchor = 'start';\n            } else {\n                d.anchor = 'middle';\n\n                var txHalfWidth = txTotalWidth / 2;\n                var overflowR = htx + txHalfWidth - outerWidth;\n                var overflowL = htx - txHalfWidth;\n                if(overflowR > 0) htx -= overflowR;\n                if(overflowL < 0) htx += -overflowL;\n            }\n        }\n\n        tx.attr('text-anchor', d.anchor);\n        if(tx2width) tx2.attr('text-anchor', d.anchor);\n        g.attr('transform', strTranslate(htx, hty) +\n            (rotateLabels ? strRotate(YANGLE) : ''));\n    });\n\n    return hoverLabels;\n}\n\nfunction getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {\n    var name = '';\n    var text = '';\n    // to get custom 'name' labels pass cleanPoint\n    if(d.nameOverride !== undefined) d.name = d.nameOverride;\n\n    if(d.name) {\n        if(d.trace._meta) {\n            d.name = Lib.templateString(d.name, d.trace._meta);\n        }\n        name = plainText(d.name, d.nameLength);\n    }\n\n    var h0 = hovermode.charAt(0);\n    var h1 = h0 === 'x' ? 'y' : 'x';\n\n    if(d.zLabel !== undefined) {\n        if(d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n        if(d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n        if(d.trace.type !== 'choropleth' && d.trace.type !== 'choroplethmapbox') {\n            text += (text ? 'z: ' : '') + d.zLabel;\n        }\n    } else if(showCommonLabel && d[h0 + 'Label'] === t0) {\n        text = d[h1 + 'Label'] || '';\n    } else if(d.xLabel === undefined) {\n        if(d.yLabel !== undefined && d.trace.type !== 'scattercarpet') {\n            text = d.yLabel;\n        }\n    } else if(d.yLabel === undefined) text = d.xLabel;\n    else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n    if((d.text || d.text === 0) && !Array.isArray(d.text)) {\n        text += (text ? '<br>' : '') + d.text;\n    }\n\n    // used by other modules (initially just ternary) that\n    // manage their own hoverinfo independent of cleanPoint\n    // the rest of this will still apply, so such modules\n    // can still put things in (x|y|z)Label, text, and name\n    // and hoverinfo will still determine their visibility\n    if(d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n    // if 'text' is empty at this point,\n    // and hovertemplate is not defined,\n    // put 'name' in main label and don't show secondary label\n    if(g && text === '' && !d.hovertemplate) {\n        // if 'name' is also empty, remove entire label\n        if(name === '') g.remove();\n        text = name;\n    }\n\n    // hovertemplate\n    var hovertemplate = d.hovertemplate || false;\n    if(hovertemplate) {\n        var labels = d.hovertemplateLabels || d;\n\n        if(d[h0 + 'Label'] !== t0) {\n            labels[h0 + 'other'] = labels[h0 + 'Val'];\n            labels[h0 + 'otherLabel'] = labels[h0 + 'Label'];\n        }\n\n        text = Lib.hovertemplateString(\n            hovertemplate,\n            labels,\n            fullLayout._d3locale,\n            d.eventData[0] || {},\n            d.trace._meta\n        );\n\n        text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {\n            // assign name for secondary text label\n            name = plainText(extra, d.nameLength);\n            // remove from main text label\n            return '';\n        });\n    }\n    return [text, name];\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Incidentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverLabels, axKey, fullLayout) {\n    var nummoves = 0;\n    var axSign = 1;\n    var nLabels = hoverLabels.size();\n\n    // make groups of touching points\n    var pointgroups = new Array(nLabels);\n    var k = 0;\n\n    hoverLabels.each(function(d) {\n        var ax = d[axKey];\n        var axIsX = ax._id.charAt(0) === 'x';\n        var rng = ax.range;\n\n        if(k === 0 && rng && ((rng[0] > rng[1]) !== axIsX)) {\n            axSign = -1;\n        }\n        pointgroups[k++] = [{\n            datum: d,\n            traceIndex: d.trace.index,\n            dp: 0,\n            pos: d.pos,\n            posref: d.posref,\n            size: d.by * (axIsX ? YFACTOR : 1) / 2,\n            pmin: 0,\n            pmax: (axIsX ? fullLayout.width : fullLayout.height)\n        }];\n    });\n\n    pointgroups.sort(function(a, b) {\n        return (a[0].posref - b[0].posref) ||\n            // for equal positions, sort trace indices increasing or decreasing\n            // depending on whether the axis is reversed or not... so stacked\n            // traces will generally keep their order even if one trace adds\n            // nothing to the stack.\n            (axSign * (b[0].traceIndex - a[0].traceIndex));\n    });\n\n    var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n    function constrainGroup(grp) {\n        var minPt = grp[0];\n        var maxPt = grp[grp.length - 1];\n\n        // overlap with the top - positive vals are overlaps\n        topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n        // overlap with the bottom - positive vals are overlaps\n        bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n        // check for min overlap first, so that we always\n        // see the largest labels\n        // allow for .01px overlap, so we don't get an\n        // infinite loop from rounding errors\n        if(topOverlap > 0.01) {\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n            donepositioning = false;\n        }\n        if(bottomOverlap < 0.01) return;\n        if(topOverlap < -0.01) {\n            // make sure we're not pushing back and forth\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            donepositioning = false;\n        }\n        if(!donepositioning) return;\n\n        // no room to fix positioning, delete off-screen points\n\n        // first see how many points we need to delete\n        var deleteCount = 0;\n        for(i = 0; i < grp.length; i++) {\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n        }\n\n        // start by deleting points whose data is off screen\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos > minPt.pmax - 1) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n        for(i = 0; i < grp.length; i++) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos < minPt.pmin + 1) {\n                pti.del = true;\n                deleteCount--;\n\n                // shift the whole group minus into this new space\n                bottomOverlap = pti.size * 2;\n                for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            }\n        }\n        // then delete points that go off the bottom\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n    }\n\n    // loop through groups, combining them if they overlap,\n    // until nothing moves\n    while(!donepositioning && nummoves <= nLabels) {\n        // to avoid infinite loops, don't move more times\n        // than there are traces\n        nummoves++;\n\n        // assume nothing will move in this iteration,\n        // reverse this if it does\n        donepositioning = true;\n        i = 0;\n        while(i < pointgroups.length - 1) {\n            // the higher (g0) and lower (g1) point group\n            var g0 = pointgroups[i];\n            var g1 = pointgroups[i + 1];\n\n            // the lowest point in the higher group (p0)\n            // the highest point in the lower group (p1)\n            var p0 = g0[g0.length - 1];\n            var p1 = g1[0];\n            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n            // Only group points that lie on the same axes\n            if(topOverlap > 0.01 && (p0.pmin === p1.pmin) && (p0.pmax === p1.pmax)) {\n                // push the new point(s) added to this group out of the way\n                for(j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n                // add them to the group\n                g0.push.apply(g0, g1);\n                pointgroups.splice(i + 1, 1);\n\n                // adjust for minimum average movement\n                sumdp = 0;\n                for(j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n                bottomOverlap = sumdp / g0.length;\n                for(j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n                donepositioning = false;\n            } else i++;\n        }\n\n        // check if we're going off the plot on either side and fix\n        pointgroups.forEach(constrainGroup);\n    }\n\n    // now put these offsets into hoverData\n    for(i = pointgroups.length - 1; i >= 0; i--) {\n        var grp = pointgroups[i];\n        for(j = grp.length - 1; j >= 0; j--) {\n            var pt = grp[j];\n            var hoverPt = pt.datum;\n            hoverPt.offset = pt.dp;\n            hoverPt.del = pt.del;\n        }\n    }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {\n    var pX = function(x) { return x * scaleX; };\n    var pY = function(y) { return y * scaleY; };\n\n    // finally set the text positioning relative to the data and draw the\n    // box around it\n    hoverLabels.each(function(d) {\n        var g = d3.select(this);\n        if(d.del) return g.remove();\n\n        var tx = g.select('text.nums');\n        var anchor = d.anchor;\n        var horzSign = anchor === 'end' ? -1 : 1;\n        var alignShift = {start: 1, end: -1, middle: 0}[anchor];\n        var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n        var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n        var offsetX = 0;\n        var offsetY = d.offset;\n\n        var isMiddle = anchor === 'middle';\n        if(isMiddle) {\n            txx -= d.tx2width / 2;\n            tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n        }\n        if(rotateLabels) {\n            offsetY *= -YSHIFTY;\n            offsetX = d.offset * YSHIFTX;\n        }\n\n        g.select('path')\n            .attr('d', isMiddle ?\n            // middle aligned: rect centered on data\n            ('M-' + pX(d.bx / 2 + d.tx2width / 2) + ',' + pY(offsetY - d.by / 2) +\n              'h' + pX(d.bx) + 'v' + pY(d.by) + 'h-' + pX(d.bx) + 'Z') :\n            // left or right aligned: side rect with arrow to data\n            ('M0,0L' + pX(horzSign * HOVERARROWSIZE + offsetX) + ',' + pY(HOVERARROWSIZE + offsetY) +\n                'v' + pY(d.by / 2 - HOVERARROWSIZE) +\n                'h' + pX(horzSign * d.bx) +\n                'v-' + pY(d.by) +\n                'H' + pX(horzSign * HOVERARROWSIZE + offsetX) +\n                'V' + pY(offsetY - HOVERARROWSIZE) +\n                'Z'));\n\n        var posX = offsetX + txx;\n        var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;\n        var textAlign = d.textAlign || 'auto';\n\n        if(textAlign !== 'auto') {\n            if(textAlign === 'left' && anchor !== 'start') {\n                tx.attr('text-anchor', 'start');\n                posX = isMiddle ?\n                    -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD :\n                    -d.bx - HOVERTEXTPAD;\n            } else if(textAlign === 'right' && anchor !== 'end') {\n                tx.attr('text-anchor', 'end');\n                posX = isMiddle ?\n                    d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD :\n                    d.bx + HOVERTEXTPAD;\n            }\n        }\n\n        tx.call(svgTextUtils.positionText, pX(posX), pY(posY));\n\n        if(d.tx2width) {\n            g.select('text.name')\n                .call(svgTextUtils.positionText,\n                    pX(tx2x + alignShift * HOVERTEXTPAD + offsetX),\n                    pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD));\n            g.select('rect')\n                .call(Drawing.setRect,\n                    pX(tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX),\n                    pY(offsetY - d.by / 2 - 1),\n                    pX(d.tx2width), pY(d.by + 2));\n        }\n    });\n}\n\nfunction cleanPoint(d, hovermode) {\n    var index = d.index;\n    var trace = d.trace || {};\n    var cd0 = d.cd[0];\n    var cd = d.cd[index] || {};\n\n    function pass(v) {\n        return v || (isNumeric(v) && v === 0);\n    }\n\n    var getVal = Array.isArray(index) ?\n        function(calcKey, traceKey) {\n            var v = Lib.castOption(cd0, index, calcKey);\n            return pass(v) ? v : Lib.extractOption({}, trace, '', traceKey);\n        } :\n        function(calcKey, traceKey) {\n            return Lib.extractOption(cd, trace, calcKey, traceKey);\n        };\n\n    function fill(key, calcKey, traceKey) {\n        var val = getVal(calcKey, traceKey);\n        if(pass(val)) d[key] = val;\n    }\n\n    fill('hoverinfo', 'hi', 'hoverinfo');\n    fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n    fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n    fill('fontFamily', 'htf', 'hoverlabel.font.family');\n    fill('fontSize', 'hts', 'hoverlabel.font.size');\n    fill('fontColor', 'htc', 'hoverlabel.font.color');\n    fill('nameLength', 'hnl', 'hoverlabel.namelength');\n    fill('textAlign', 'hta', 'hoverlabel.align');\n\n    d.posref = (hovermode === 'y' || (hovermode === 'closest' && trace.orientation === 'h')) ?\n        (d.xa._offset + (d.x0 + d.x1) / 2) :\n        (d.ya._offset + (d.y0 + d.y1) / 2);\n\n    // then constrain all the positions to be on the plot\n    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n    // and convert the x and y label values into formatted text\n    if(d.xLabelVal !== undefined) {\n        d.xLabel = ('xLabel' in d) ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);\n        d.xVal = d.xa.c2d(d.xLabelVal);\n    }\n    if(d.yLabelVal !== undefined) {\n        d.yLabel = ('yLabel' in d) ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);\n        d.yVal = d.ya.c2d(d.yLabelVal);\n    }\n\n    // Traces like heatmaps generate the zLabel in their hoverPoints function\n    if(d.zLabelVal !== undefined && d.zLabel === undefined) {\n        d.zLabel = String(d.zLabelVal);\n    }\n\n    // for box means and error bars, add the range to the label\n    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n        if(d.xerrneg !== undefined) {\n            d.xLabel += ' +' + xeText + ' / -' +\n                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n        } else d.xLabel += '  ' + xeText;\n\n        // small distance penalty for error bars, so that if there are\n        // traces with errors and some without, the error bar label will\n        // hoist up to the point\n        if(hovermode === 'x') d.distance += 1;\n    }\n    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n        if(d.yerrneg !== undefined) {\n            d.yLabel += ' +' + yeText + ' / -' +\n                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n        } else d.yLabel += '  ' + yeText;\n\n        if(hovermode === 'y') d.distance += 1;\n    }\n\n    var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n    if(infomode && infomode !== 'all') {\n        infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n        if(infomode.indexOf('x') === -1) d.xLabel = undefined;\n        if(infomode.indexOf('y') === -1) d.yLabel = undefined;\n        if(infomode.indexOf('z') === -1) d.zLabel = undefined;\n        if(infomode.indexOf('text') === -1) d.text = undefined;\n        if(infomode.indexOf('name') === -1) d.name = undefined;\n    }\n\n    return d;\n}\n\nfunction createSpikelines(gd, closestPoints, opts) {\n    var container = opts.container;\n    var fullLayout = opts.fullLayout;\n    var gs = fullLayout._size;\n    var evt = opts.event;\n    var showY = !!closestPoints.hLinePoint;\n    var showX = !!closestPoints.vLinePoint;\n\n    var xa, ya;\n\n    // Remove old spikeline items\n    container.selectAll('.spikeline').remove();\n\n    if(!(showX || showY)) return;\n\n    var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n    // Horizontal line (to y-axis)\n    if(showY) {\n        var hLinePoint = closestPoints.hLinePoint;\n        var hLinePointX, hLinePointY;\n\n        xa = hLinePoint && hLinePoint.xa;\n        ya = hLinePoint && hLinePoint.ya;\n        var ySnap = ya.spikesnap;\n\n        if(ySnap === 'cursor') {\n            hLinePointX = evt.pointerX;\n            hLinePointY = evt.pointerY;\n        } else {\n            hLinePointX = xa._offset + hLinePoint.x;\n            hLinePointY = ya._offset + hLinePoint.y;\n        }\n        var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : hLinePoint.color;\n        var yMode = ya.spikemode;\n        var yThickness = ya.spikethickness;\n        var yColor = ya.spikecolor || dfltHLineColor;\n        var xEdge = Axes.getPxPosition(gd, ya);\n        var xBase, xEndSpike;\n\n        if(yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n            if(yMode.indexOf('toaxis') !== -1) {\n                xBase = xEdge;\n                xEndSpike = hLinePointX;\n            }\n            if(yMode.indexOf('across') !== -1) {\n                var xAcross0 = ya._counterDomainMin;\n                var xAcross1 = ya._counterDomainMax;\n                if(ya.anchor === 'free') {\n                    xAcross0 = Math.min(xAcross0, ya.position);\n                    xAcross1 = Math.max(xAcross1, ya.position);\n                }\n                xBase = gs.l + xAcross0 * gs.w;\n                xEndSpike = gs.l + xAcross1 * gs.w;\n            }\n\n            // Foreground horizontal line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness,\n                    stroke: yColor,\n                    'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background horizontal Line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n        // Y axis marker\n        if(yMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n                    cy: hLinePointY,\n                    r: yThickness,\n                    fill: yColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n\n    if(showX) {\n        var vLinePoint = closestPoints.vLinePoint;\n        var vLinePointX, vLinePointY;\n\n        xa = vLinePoint && vLinePoint.xa;\n        ya = vLinePoint && vLinePoint.ya;\n        var xSnap = xa.spikesnap;\n\n        if(xSnap === 'cursor') {\n            vLinePointX = evt.pointerX;\n            vLinePointY = evt.pointerY;\n        } else {\n            vLinePointX = xa._offset + vLinePoint.x;\n            vLinePointY = ya._offset + vLinePoint.y;\n        }\n        var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : vLinePoint.color;\n        var xMode = xa.spikemode;\n        var xThickness = xa.spikethickness;\n        var xColor = xa.spikecolor || dfltVLineColor;\n        var yEdge = Axes.getPxPosition(gd, xa);\n        var yBase, yEndSpike;\n\n        if(xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n            if(xMode.indexOf('toaxis') !== -1) {\n                yBase = yEdge;\n                yEndSpike = vLinePointY;\n            }\n            if(xMode.indexOf('across') !== -1) {\n                var yAcross0 = xa._counterDomainMin;\n                var yAcross1 = xa._counterDomainMax;\n                if(xa.anchor === 'free') {\n                    yAcross0 = Math.min(yAcross0, xa.position);\n                    yAcross1 = Math.max(yAcross1, xa.position);\n                }\n                yBase = gs.t + (1 - yAcross1) * gs.h;\n                yEndSpike = gs.t + (1 - yAcross0) * gs.h;\n            }\n\n            // Foreground vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness,\n                    stroke: xColor,\n                    'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n\n        // X axis marker\n        if(xMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: vLinePointX,\n                    cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n                    r: xThickness,\n                    fill: xColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n    // don't emit any events if nothing changed\n    if(!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n    for(var i = oldhoverdata.length - 1; i >= 0; i--) {\n        var oldPt = oldhoverdata[i];\n        var newPt = gd._hoverdata[i];\n\n        if(oldPt.curveNumber !== newPt.curveNumber ||\n            String(oldPt.pointNumber) !== String(newPt.pointNumber) ||\n            String(oldPt.pointNumbers) !== String(newPt.pointNumbers)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n    // don't relayout the plot because of new spikelines if spikelines points didn't change\n    if(!oldspikepoints) return true;\n    if(oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint ||\n        oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint\n    ) return true;\n    return false;\n}\n\nfunction plainText(s, len) {\n    return svgTextUtils.plainText(s || '', {\n        len: len,\n        allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n    });\n}\n\nfunction orderRangePoints(hoverData, hovermode) {\n    var axLetter = hovermode.charAt(0);\n\n    var first = [];\n    var second = [];\n    var last = [];\n\n    for(var i = 0; i < hoverData.length; i++) {\n        var d = hoverData[i];\n\n        if(\n            Registry.traceIs(d.trace, 'bar-like') ||\n            Registry.traceIs(d.trace, 'box-violin')\n        ) {\n            last.push(d);\n        } else if(d.trace[axLetter + 'period']) {\n            second.push(d);\n        } else {\n            first.push(d);\n        }\n    }\n\n    return first.concat(second).concat(last);\n}\n\nfunction getCoord(axLetter, winningPoint, fullLayout) {\n    var ax = winningPoint[axLetter + 'a'];\n    var val = winningPoint[axLetter + 'Val'];\n\n    var cd0 = winningPoint.cd[0];\n\n    if(ax.type === 'category') val = ax._categoriesMap[val];\n    else if(ax.type === 'date') {\n        var periodalignment = winningPoint.trace[axLetter + 'periodalignment'];\n        if(periodalignment) {\n            var d = winningPoint.cd[winningPoint.index];\n\n            var start = d[axLetter + 'Start'];\n            if(start === undefined) start = d[axLetter];\n\n            var end = d[axLetter + 'End'];\n            if(end === undefined) end = d[axLetter];\n\n            var diff = end - start;\n\n            if(periodalignment === 'end') {\n                val += diff;\n            } else if(periodalignment === 'middle') {\n                val += diff / 2;\n            }\n        }\n\n        val = ax.d2c(val);\n    }\n\n    if(cd0 && cd0.t && cd0.t.posLetter === ax._id) {\n        if(\n            fullLayout.boxmode === 'group' ||\n            fullLayout.violinmode === 'group'\n        ) {\n            val += cd0.t.dPos;\n        }\n    }\n\n    return val;\n}\n\n// Top/left hover offsets relative to graph div. As long as hover content is\n// a sibling of the graph div, it will be positioned correctly relative to\n// the offset parent, whatever that may be.\nfunction getTopOffset(gd) { return gd.offsetTop + gd.clientTop; }\nfunction getLeftOffset(gd) { return gd.offsetLeft + gd.clientLeft; }\n\nfunction getBoundingClientRect(gd, node) {\n    var fullLayout = gd._fullLayout;\n\n    var rect = node.getBoundingClientRect();\n\n    var x0 = rect.x;\n    var y0 = rect.y;\n    var x1 = x0 + rect.width;\n    var y1 = y0 + rect.height;\n\n    var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);\n\n    var Ax = A[0];\n    var Ay = A[1];\n    var Bx = B[0];\n    var By = B[1];\n\n    return {\n        x: Ax,\n        y: Ay,\n        width: Bx - Ax,\n        height: By - Ay,\n        top: Math.min(Ay, By),\n        left: Math.min(Ax, Bx),\n        right: Math.max(Ax, Bx),\n        bottom: Math.max(Ay, By),\n    };\n}\n"]},"metadata":{},"sourceType":"script"}