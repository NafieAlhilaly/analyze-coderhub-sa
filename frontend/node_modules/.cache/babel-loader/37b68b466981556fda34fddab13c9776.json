{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar Sieve = require('./sieve.js');\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else {\n        calcTracesVert.push(calcTraces[i]);\n      }\n\n      if (fullTrace._computePh) {\n        var cd = gd.calcdata[i];\n\n        for (var j = 0; j < cd.length; j++) {\n          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n        }\n      }\n    }\n  }\n\n  var opts = {\n    xCat: xa.type === 'category' || xa.type === 'multicategory',\n    yCat: ya.type === 'category' || ya.type === 'multicategory',\n    mode: fullLayout.barmode,\n    norm: fullLayout.barnorm,\n    gap: fullLayout.bargap,\n    groupgap: fullLayout.bargroupgap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n  if (!calcTraces.length) return;\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(sa, calcTraces);\n\n  switch (opts.mode) {\n    case 'overlay':\n      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n      break;\n\n    case 'group':\n      // exclude from the group those traces for which the user set an offset\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n\n    case 'stack':\n    case 'relative':\n      // exclude from the stack those traces for which the user set a base\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n  }\n\n  collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.type === 'funnel' ? trace._base : trace.base;\n    var b; // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar; // 'base' on categorical axes makes no sense\n\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], {\n      posAxis: pa,\n      sepNegVal: false,\n      overlapNoMerge: !opts.norm\n    }); // set bar offsets and widths, and update position axis\n\n    setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n\n    if (opts.norm) {\n      sieveBars(sieve);\n      normalizeBars(sa, sieve, opts);\n    } else {\n      setBaseAndTop(sa, sieve);\n    }\n  }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: false,\n    overlapNoMerge: !opts.norm\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts); // relative-stack bars within the same trace that would otherwise\n  // be hidden\n\n  unhideBarsWithinTrace(sieve, pa); // set bar bases and sizes, and update size axis\n\n  if (opts.norm) {\n    sieveBars(sieve);\n    normalizeBars(sa, sieve, opts);\n  } else {\n    setBaseAndTop(sa, sieve);\n  }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: opts.mode === 'relative',\n    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n\n  stackBars(sa, sieve, opts); // flag the outmost bar (for text display purposes)\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  } // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n\n\n  if (opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces; // set bar offsets and widths\n\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0)); // computer bar group center and bar offset\n\n  var offsetFromCenter = -barWidth / 2;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t; // store bar width and offset for this trace\n\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace offset and width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n  var fullLayout = gd._fullLayout;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n  var nTraces = calcTraces.length; // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n\n  var overlap = positions.length !== distinctPositions.length;\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var trace = calcTrace[0].trace;\n    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n    var barWidthPlusGap;\n\n    if (nOffsetGroups) {\n      barWidthPlusGap = barGroupWidth / nOffsetGroups;\n    } else {\n      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n    }\n\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n    var offsetFromCenter;\n\n    if (nOffsetGroups) {\n      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n    } else {\n      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n    }\n\n    var t = calcTrace[0].t;\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n\n\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n\n\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n\n      t.barwidth = newBarwidth; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        newPoffset = [];\n\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = Array.isArray(barwidth);\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j]; // store the actual bar width and position, for use by hover\n\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n    }\n  }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = Array.isArray(poffset);\n      var barwidthIsArray = Array.isArray(barwidth);\n\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n} // store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\n\n\nfunction setBaseAndTop(sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var base = bar.b;\n      var top = base + bar.s;\n      bar[sLetter] = top;\n      pts.push(top);\n      if (bar.hasB) pts.push(base);\n\n      if (!bar.hasB || !bar.b) {\n        tozero = true;\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: true\n    });\n  }\n}\n\nfunction stackBars(sa, sieve, opts) {\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  var calcTrace;\n  var fullTrace;\n  var isFunnel;\n  var i, j;\n  var bar;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.type === 'funnel') {\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n\n        if (bar.s !== BADNUM) {\n          // create base of funnels\n          sieve.put(bar.p, -0.5 * bar.s);\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    isFunnel = fullTrace.type === 'funnel';\n    var pts = [];\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var value;\n\n        if (isFunnel) {\n          value = bar.s;\n        } else {\n          value = bar.s + bar.b;\n        }\n\n        var base = sieve.put(bar.p, value);\n        var top = base + value; // store the bar base and top in each calcdata item\n\n        bar.b = base;\n        bar[sLetter] = top;\n\n        if (!opts.norm) {\n          pts.push(top);\n\n          if (bar.hasB) {\n            pts.push(base);\n          }\n        }\n      }\n    } // if barnorm is set, let normalizeBars update the axis range\n\n\n    if (!opts.norm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\n\nfunction sieveBars(sieve) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        sieve.put(bar.p, bar.b + bar.s);\n      }\n    }\n  }\n}\n\nfunction unhideBarsWithinTrace(sieve, pa) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.base === undefined) {\n      var inTraceSieve = new Sieve([calcTrace], {\n        posAxis: pa,\n        sepNegVal: true,\n        overlapNoMerge: true\n      });\n\n      for (var j = 0; j < calcTrace.length; j++) {\n        var bar = calcTrace[j];\n\n        if (bar.p !== BADNUM) {\n          // stack current bar and get previous sum\n          var base = inTraceSieve.put(bar.p, bar.b + bar.s); // if previous sum if non-zero, this means:\n          // multiple bars have same starting point are potentially hidden,\n          // shift them vertically so that all bars are visible by default\n\n          if (base) bar.b = base;\n        }\n      }\n    }\n  }\n} // Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\n\n\nfunction normalizeBars(sa, sieve, opts) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = opts.norm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n    var padded = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var base = bar.b;\n        var top = base + bar.s;\n        bar[sLetter] = top;\n        pts.push(top);\n        padded = padded || needsPadding(top);\n\n        if (bar.hasB) {\n          pts.push(base);\n          padded = padded || needsPadding(base);\n        }\n\n        if (!bar.hasB || !bar.b) {\n          tozero = true;\n        }\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: padded\n    });\n  }\n} // find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\n\n\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  } // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n\n\n  var roundFactor = 10000 / (pMax - pMin);\n\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n    }\n  }\n}\n\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\n\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":{"version":3,"sources":["C:/Projects/reactApp/analyse_coderhub/node_modules/plotly.js/src/traces/bar/cross_trace_calc.js"],"names":["isNumeric","require","isArrayOrTypedArray","BADNUM","Registry","Axes","getAxisGroup","Sieve","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorz","calcTracesVert","i","length","fullTrace","visible","traceIs","_id","orientation","push","_computePh","cd","j","ph0","ph1","opts","xCat","type","yCat","mode","barmode","norm","barnorm","gap","bargap","groupgap","bargroupgap","setGroupPositions","pa","sa","excluded","included","calcTrace","initBase","setGroupPositionsInOverlayMode","trace","offset","undefined","setGroupPositionsInGroupMode","base","setGroupPositionsInStackOrRelativeMode","collectExtents","_base","b","scalendar","xcalendar","ycalendar","d2c","Math","min","hasB","hasBase","sieve","posAxis","sepNegVal","overlapNoMerge","setOffsetAndWidth","sieveBars","normalizeBars","setBaseAndTop","setOffsetAndWidthInGroupMode","unhideBarsWithinTrace","stackBars","bar","s","isOutmostBar","get","p","_outmost","minDiff","traces","barGroupWidth","barWidthPlusGap","barWidth","offsetFromCenter","t","barwidth","poffset","bargroupwidth","bardelta","binWidth","applyAttributes","setBarCenterAndWidth","updatePositionAxis","positions","distinctPositions","nTraces","overlap","groupId","alignmentGroups","_alignmentOpts","alignmentGroupOpts","alignmentgroup","nOffsetGroups","Object","keys","offsetGroups","_offsetIndex","calcTrace0","_offset","initialPoffset","newPoffset","Array","prototype","slice","call","width","_width","initialBarwidth","newBarwidth","pLetter","getAxisLetter","poffsetIsArray","isArray","barwidthIsArray","calcBar","w","allowMinDtick","vpad","minDtick","pts","l","r","calcBarOffset","calcBarWidth","_extremes","findExtremes","padded","sLetter","tozero","top","isFunnel","put","value","inTraceSieve","sTop","sTiny","sMin","l2c","c2l","sMax","needsPadding","v","scale","abs","extents","pMin","Infinity","pMax","max","roundFactor","round","String","di","p0","p1","pVal","s0","s1","ax","charAt","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullLayout = gd._fullLayout;\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorz = [];\n    var calcTracesVert = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorz.push(calcTraces[i]);\n            } else {\n                calcTracesVert.push(calcTraces[i]);\n            }\n\n            if(fullTrace._computePh) {\n                var cd = gd.calcdata[i];\n                for(var j = 0; j < cd.length; j++) {\n                    if(typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n                    if(typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n                }\n            }\n        }\n    }\n\n    var opts = {\n        xCat: xa.type === 'category' || xa.type === 'multicategory',\n        yCat: ya.type === 'category' || ya.type === 'multicategory',\n\n        mode: fullLayout.barmode,\n        norm: fullLayout.barnorm,\n        gap: fullLayout.bargap,\n        groupgap: fullLayout.bargroupgap\n    };\n\n    setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n    setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n    if(!calcTraces.length) return;\n\n    var excluded;\n    var included;\n    var i, calcTrace, fullTrace;\n\n    initBase(sa, calcTraces);\n\n    switch(opts.mode) {\n        case 'overlay':\n            setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n            break;\n\n        case 'group':\n            // exclude from the group those traces for which the user set an offset\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.offset === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n\n        case 'stack':\n        case 'relative':\n            // exclude from the stack those traces for which the user set a base\n            excluded = [];\n            included = [];\n            for(i = 0; i < calcTraces.length; i++) {\n                calcTrace = calcTraces[i];\n                fullTrace = calcTrace[0].trace;\n\n                if(fullTrace.base === undefined) included.push(calcTrace);\n                else excluded.push(calcTrace);\n            }\n\n            if(included.length) {\n                setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n            }\n            if(excluded.length) {\n                setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n            }\n            break;\n    }\n\n    collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var cd = calcTraces[i];\n        var trace = cd[0].trace;\n        var base = (trace.type === 'funnel') ? trace._base : trace.base;\n        var b;\n\n        // not sure if it really makes sense to have dates for bar size data...\n        // ideally if we want to make gantt charts or something we'd treat\n        // the actual size (trace.x or y) as time delta but base as absolute\n        // time. But included here for completeness.\n        var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n        // 'base' on categorical axes makes no sense\n        var d2c = sa.type === 'category' || sa.type === 'multicategory' ?\n            function() { return null; } :\n            sa.d2c;\n\n        if(isArrayOrTypedArray(base)) {\n            for(j = 0; j < Math.min(base.length, cd.length); j++) {\n                b = d2c(base[j], 0, scalendar);\n                if(isNumeric(b)) {\n                    cd[j].b = +b;\n                    cd[j].hasB = 1;\n                } else cd[j].b = 0;\n            }\n            for(; j < cd.length; j++) {\n                cd[j].b = 0;\n            }\n        } else {\n            b = d2c(base, 0, scalendar);\n            var hasBase = isNumeric(b);\n            b = hasBase ? b : 0;\n            for(j = 0; j < cd.length; j++) {\n                cd[j].b = b;\n                if(hasBase) cd[j].hasB = 1;\n            }\n        }\n    }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        var sieve = new Sieve([calcTrace], {\n            posAxis: pa,\n            sepNegVal: false,\n            overlapNoMerge: !opts.norm\n        });\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(pa, sieve, opts);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(opts.norm) {\n            sieveBars(sieve);\n            normalizeBars(sa, sieve, opts);\n        } else {\n            setBaseAndTop(sa, sieve);\n        }\n    }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: false,\n        overlapNoMerge: !opts.norm\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve, opts);\n\n    // relative-stack bars within the same trace that would otherwise\n    // be hidden\n    unhideBarsWithinTrace(sieve, pa);\n\n    // set bar bases and sizes, and update size axis\n    if(opts.norm) {\n        sieveBars(sieve);\n        normalizeBars(sa, sieve, opts);\n    } else {\n        setBaseAndTop(sa, sieve);\n    }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n    var sieve = new Sieve(calcTraces, {\n        posAxis: pa,\n        sepNegVal: opts.mode === 'relative',\n        overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n    });\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(pa, sieve, opts);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(sa, sieve, opts);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n                if(isOutmostBar) bar._outmost = true;\n            }\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - opts.gap);\n    var barWidthPlusGap = barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n    var fullLayout = gd._fullLayout;\n    var positions = sieve.positions;\n    var distinctPositions = sieve.distinctPositions;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n    var nTraces = calcTraces.length;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n    var barGroupWidth = minDiff * (1 - opts.gap);\n\n    var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n    var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n    for(var i = 0; i < nTraces; i++) {\n        var calcTrace = calcTraces[i];\n        var trace = calcTrace[0].trace;\n\n        var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n        var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n\n        var barWidthPlusGap;\n        if(nOffsetGroups) {\n            barWidthPlusGap = barGroupWidth / nOffsetGroups;\n        } else {\n            barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n        }\n\n        var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n\n        var offsetFromCenter;\n        if(nOffsetGroups) {\n            offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n        } else {\n            offsetFromCenter = overlap ?\n                ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n                -barWidth / 2;\n        }\n\n        var t = calcTrace[0].t;\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(pa, sieve);\n\n    // update position axes\n    updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces;\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var t = calcTrace0.t;\n        var offset = fullTrace._offset || fullTrace.offset;\n        var initialPoffset = t.poffset;\n        var newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        } else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace._width || fullTrace.width;\n        var initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        } else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n    var calcTraces = sieve.traces;\n    var pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n        var poffset = t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n        var barwidth = t.barwidth;\n        var barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n            calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n        }\n    }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces;\n    var minDiff = sieve.minDiff;\n    var vpad = minDiff / 2;\n\n    Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var pts = [];\n        var bar, l, r, j;\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n            l = bar.p - vpad;\n            r = bar.p + vpad;\n            pts.push(l, r);\n        }\n\n        if(fullTrace.width || fullTrace.offset) {\n            var t = calcTrace0.t;\n            var poffset = t.poffset;\n            var barwidth = t.barwidth;\n            var poffsetIsArray = Array.isArray(poffset);\n            var barwidthIsArray = Array.isArray(barwidth);\n\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n                var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n                var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n                l = bar.p + calcBarOffset;\n                r = l + calcBarWidth;\n                pts.push(l, r);\n            }\n        }\n\n        fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {padded: false});\n    }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(sa, sieve) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var base = bar.b;\n            var top = base + bar.s;\n\n            bar[sLetter] = top;\n            pts.push(top);\n            if(bar.hasB) pts.push(base);\n\n            if(!bar.hasB || !bar.b) {\n                tozero = true;\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: true\n        });\n    }\n}\n\nfunction stackBars(sa, sieve, opts) {\n    var sLetter = getAxisLetter(sa);\n    var calcTraces = sieve.traces;\n    var calcTrace;\n    var fullTrace;\n    var isFunnel;\n    var i, j;\n    var bar;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.type === 'funnel') {\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n\n                if(bar.s !== BADNUM) {\n                    // create base of funnels\n                    sieve.put(bar.p, -0.5 * bar.s);\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n\n        isFunnel = (fullTrace.type === 'funnel');\n\n        var pts = [];\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                // stack current bar and get previous sum\n                var value;\n                if(isFunnel) {\n                    value = bar.s;\n                } else {\n                    value = bar.s + bar.b;\n                }\n\n                var base = sieve.put(bar.p, value);\n\n                var top = base + value;\n\n                // store the bar base and top in each calcdata item\n                bar.b = base;\n                bar[sLetter] = top;\n\n                if(!opts.norm) {\n                    pts.push(top);\n                    if(bar.hasB) {\n                        pts.push(base);\n                    }\n                }\n            }\n        }\n\n        // if barnorm is set, let normalizeBars update the axis range\n        if(!opts.norm) {\n            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n                // N.B. we don't stack base with 'base',\n                // so set tozero:true always!\n                tozero: true,\n                padded: true\n            });\n        }\n    }\n}\n\nfunction sieveBars(sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                sieve.put(bar.p, bar.b + bar.s);\n            }\n        }\n    }\n}\n\nfunction unhideBarsWithinTrace(sieve, pa) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n\n        if(fullTrace.base === undefined) {\n            var inTraceSieve = new Sieve([calcTrace], {\n                posAxis: pa,\n                sepNegVal: true,\n                overlapNoMerge: true\n            });\n\n            for(var j = 0; j < calcTrace.length; j++) {\n                var bar = calcTrace[j];\n\n                if(bar.p !== BADNUM) {\n                    // stack current bar and get previous sum\n                    var base = inTraceSieve.put(bar.p, bar.b + bar.s);\n\n                    // if previous sum if non-zero, this means:\n                    // multiple bars have same starting point are potentially hidden,\n                    // shift them vertically so that all bars are visible by default\n                    if(base) bar.b = base;\n                }\n            }\n        }\n    }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(sa, sieve, opts) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n    var sTop = opts.norm === 'fraction' ? 1 : 100;\n    var sTiny = sTop / 1e9; // in case of rounding error in sum\n    var sMin = sa.l2c(sa.c2l(0));\n    var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n    function needsPadding(v) {\n        return (\n            isNumeric(sa.c2l(v)) &&\n            ((v < sMin - sTiny) || (v > sMax + sTiny) || !isNumeric(sMin))\n        );\n    }\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var tozero = false;\n        var padded = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n                bar.b *= scale;\n                bar.s *= scale;\n\n                var base = bar.b;\n                var top = base + bar.s;\n\n                bar[sLetter] = top;\n                pts.push(top);\n                padded = padded || needsPadding(top);\n\n                if(bar.hasB) {\n                    pts.push(base);\n                    padded = padded || needsPadding(base);\n                }\n\n                if(!bar.hasB || !bar.b) {\n                    tozero = true;\n                }\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: tozero,\n            padded: padded\n        });\n    }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var pLetter = getAxisLetter(pa);\n    var extents = {};\n    var i, j, cd;\n\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n\n        var poffset = cd[0].t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[pLetter] - di.w / 2;\n\n            if(isNumeric(p0)) {\n                var p1 = di[pLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                } else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n\n            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n            di.p1 = di.p0 + di.w;\n            di.s0 = di.b;\n            di.s1 = di.s0 + di.s;\n        }\n    }\n}\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setGroupPositions: setGroupPositions\n};\n"]},"metadata":{},"sourceType":"script"}